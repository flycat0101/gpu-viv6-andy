/****************************************************************************
*
*    Copyright (c) 2005 - 2015 by Vivante Corp.  All rights reserved.
*
*    The material in this file is confidential and contains trade secrets
*    of Vivante Corporation. This is proprietary information owned by
*    Vivante Corporation. No part of this work may be disclosed,
*    reproduced, copied, transmitted, or used in any way for any purpose,
*    without the express written permission of Vivante Corporation.
*
*****************************************************************************/


#include "gc_glsl_gen_code.h"
#include "gc_glsl_emit_code.h"

#define SUPPORT_STRUCT_ELEMENT_IN_VARIABLE    1
#define _GetDataTypeComponentByteSize(DataType) 4

static gctBOOL
_IsUseAttrCodeForVariable(
    IN sloCOMPILER Compiler,
    IN sleSTORAGE_QUALIFIER Storage
    )
{
    gctBOOL useAttrCode = gcvFALSE;
    sleSHADER_TYPE    shaderType;
    gcmVERIFY_OK(sloCOMPILER_GetShaderType(Compiler, &shaderType));

    if (shaderType == slvSHADER_TYPE_VERTEX || shaderType == slvSHADER_TYPE_FRAGMENT ||
        shaderType == slvSHADER_TYPE_COMPUTE)
    {
        return useAttrCode;
    }

    if (Storage == slvSTORAGE_QUALIFIER_IN_IO_BLOCK ||
        Storage == slvSTORAGE_QUALIFIER_IN_IO_BLOCK_MEMBER ||
        Storage == slvSTORAGE_QUALIFIER_VARYING_IN)
    {
        useAttrCode = gcvTRUE;
    }
    else if (Storage == slvSTORAGE_QUALIFIER_OUT_IO_BLOCK ||
             Storage == slvSTORAGE_QUALIFIER_OUT_IO_BLOCK_MEMBER ||
             Storage == slvSTORAGE_QUALIFIER_VARYING_OUT)
    {
        if (shaderType == slvSHADER_TYPE_TCS)
        {
            useAttrCode = gcvTRUE;
        }
    }

    return useAttrCode;
}

static gceSTATUS
_IsExprPerVertexPatchArray(
    IN sloCOMPILER Compiler,
    IN sloIR_EXPR BaseExpr,
    OUT gctBOOL * IsPerVertexArray
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctBOOL isPerVertexArray = gcvFALSE;

    /*
    ** We only need to check these cases:
    ** 1) ioBlockA[index].elementA
    ** 2) ioBlockA.elementA[index]
    ** 3) elementA[index]
    ** 4) structA[index].elementA
    ** 5) structA.elementA[index]
    */
    if (sloIR_OBJECT_GetType(&BaseExpr->base) == slvIR_VARIABLE)
    {
        sloIR_VARIABLE variableExpr = (sloIR_VARIABLE)(&BaseExpr->base);

        isPerVertexArray = variableExpr->name->isPerVertexArray;
    }
    else if (sloIR_OBJECT_GetType(&BaseExpr->base) == slvIR_UNARY_EXPR)
    {
        sloIR_UNARY_EXPR unaryExpr = (sloIR_UNARY_EXPR)(&BaseExpr->base);

        if (unaryExpr->type == slvUNARY_FIELD_SELECTION)
        {
            isPerVertexArray = unaryExpr->u.fieldName->isPerVertexArray;
        }
    }

    if (isPerVertexArray)
    {
        *IsPerVertexArray = isPerVertexArray;
    }
    return status;
}
static gcSL_INDEXED
_ConvertIndexModeToIndexed(
    IN sleINDEX_MODE Index_Mode
    )
{
    switch (Index_Mode)
    {
    case slvINDEX_NONE:
    case slvINDEX_CONSTANT:
        return gcSL_NOT_INDEXED;
    case slvINDEX_REG:
        return gcSL_INDEXED_X;
    case slvINDEX_REG_Y:
        return gcSL_INDEXED_Y;
    case slvINDEX_REG_Z:
        return gcSL_INDEXED_Z;
    case slvINDEX_REG_W:
        return gcSL_INDEXED_W;
    default:
        return gcSL_NOT_INDEXED;
    }
}

static gceSTATUS
_FillArrayListInfo(
    IN sloCOMPILER Compiler,
    IN gcsSHADER_VAR_INFO * VariableInfo,
    IN gctINT ArrayCount,
    IN gctINT * ArrayLengthList
    )
{
    gceSTATUS status = gcvSTATUS_OK;

    VariableInfo->arrayCount = ArrayCount;
    VariableInfo->arraySizeList = gcvNULL;

    if (ArrayCount > 0)
    {
        gctINT i;
        gctPOINTER pointer = gcvNULL;

       status = sloCOMPILER_Allocate(
                                    Compiler,
                                    (gctSIZE_T)(ArrayCount * sizeof(gctINT)),
                                    &pointer);
        if (gcmIS_ERROR(status)) return status;

        gcoOS_ZeroMemory(pointer, ArrayCount * sizeof(gctINT));
        VariableInfo->arraySizeList = pointer;

        for (i = 0; i < ArrayCount; i++)
        {
            VariableInfo->arraySizeList[i] = ArrayLengthList[i];
        }

        VariableInfo->isArray = gcvTRUE;
        VariableInfo->arraySize = VariableInfo->arraySizeList[0];
    }
    else
    {
        VariableInfo->isArray = gcvFALSE;
        VariableInfo->arraySize = 1;
    }

    return status;
}

static gceSTATUS
_FreeArrayListInfo(
    IN sloCOMPILER Compiler,
    IN gcsSHADER_VAR_INFO * VariableInfo
    )
{
    gceSTATUS status = gcvSTATUS_OK;

    if (VariableInfo->arraySizeList != gcvNULL)
    {
        status = sloCOMPILER_Free(Compiler, VariableInfo->arraySizeList);
        if (gcmIS_ERROR(status)) return status;
    }

    return status;
}

#define slmNewUniform(Compiler, LineNo, StringNo, Symbol, DataType, Precision, Location, Binding, Offset,\
          ArrayCount, ArrayLengthList, VarCategory, NumStructElement, Parent, PrevSibling, ImageFormat, \
          ThisVarIndex, Uniform, Status)  \
  do { \
   gcsSHADER_VAR_INFO uniformInfo[1]; \
   uniformInfo->varCategory = (VarCategory); \
   uniformInfo->type = (DataType); \
   uniformInfo->format = slConvDataTypeToFormat(Compiler, (DataType)); \
   uniformInfo->precision = (Precision); \
   uniformInfo->location = (Location); \
   uniformInfo->binding = (Binding); \
   uniformInfo->offset = (Offset); \
   _FillArrayListInfo(Compiler, &uniformInfo[0], ArrayCount, ArrayLengthList); \
   uniformInfo->u.numStructureElement = (NumStructElement); \
   uniformInfo->parent= (Parent); \
   uniformInfo->prevSibling= (PrevSibling); \
   uniformInfo->imageFormat = (ImageFormat); \
   (status) = slNewUniform(Compiler, \
                           (LineNo), \
                           (StringNo), \
                           (Symbol), \
                           uniformInfo, \
                           (ThisVarIndex), \
                           (Uniform)); \
    _FreeArrayListInfo(Compiler, &uniformInfo[0]); \
  } while (gcvFALSE)

#define slmNewVariable(Compiler, LineNo, StringNo, Symbol, DataType, Precision, \
          ArrayCount, ArrayLengthList, IsLocal, IsOutput, IsPrecise, IsPerVertex, \
          TempRegIndex, VarCategory, NumStructElement, Parent, PrevSibling, \
          ThisVarIndex, Status)  \
  do { \
   gcsSHADER_VAR_INFO varInfo[1]; \
   varInfo->varCategory = (VarCategory); \
   varInfo->type        = (DataType); \
   varInfo->format      = slConvDataTypeToFormat(Compiler, (DataType)); \
   varInfo->precision   = (Precision); \
   _FillArrayListInfo(Compiler, &varInfo[0], ArrayCount, ArrayLengthList); \
   varInfo->u.numStructureElement = (NumStructElement); \
   varInfo->parent      = (Parent); \
   varInfo->isLocal     = (IsLocal); \
   varInfo->isOutput    = (IsOutput); \
   varInfo->isPrecise   = (IsPrecise); \
   varInfo->isPerVertex = (IsPerVertex); \
   varInfo->prevSibling = (PrevSibling); \
   (Status) = slNewVariable(Compiler, \
                            (LineNo), \
                            (StringNo), \
                            (Symbol), \
                            (TempRegIndex), \
                            varInfo, \
                            (ThisVarIndex)); \
    _FreeArrayListInfo(Compiler, &varInfo[0]); \
  } while (gcvFALSE)

static gceSTATUS
_GetShaderVariableByIndex(
    IN sloCOMPILER Compiler,
    IN gctINT16 VariableIdx,
    OUT gcVARIABLE *Variable
    )
{
    gcSHADER binary;
    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));

    return gcSHADER_GetVariable(binary, VariableIdx, Variable);
}

static gctREG_INDEX
_ConvComponentToVectorIndex(
    IN gctUINT8 Component
    );

void
slsOPERAND_CONSTANT_ChangeFloatFamilyDataType(
    IN gcSHADER_TYPE NewDataType,
    IN OUT slsOPERAND_CONSTANT * OperandConstant
    )
{
    gctUINT     i;

    gcmASSERT(OperandConstant);

    switch (gcGetComponentDataType(NewDataType))
    {
    case gcSHADER_FLOAT_X1:
        break;

    case gcSHADER_BOOLEAN_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].boolValue = slmF2B(OperandConstant->values[i].floatValue);
        }
        break;

    case gcSHADER_INTEGER_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].intValue = slmF2I(OperandConstant->values[i].floatValue);
        }
        break;

    case gcSHADER_UINT_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].uintValue = slmF2U(OperandConstant->values[i].floatValue);
        }
        break;

    default:
        gcmASSERT(0);
    }

    OperandConstant->dataType   = NewDataType;
}

void
slsOPERAND_CONSTANT_ChangeIntegerFamilyDataType(
    IN gcSHADER_TYPE NewDataType,
    IN OUT slsOPERAND_CONSTANT * OperandConstant
    )
{
    gctUINT     i;

    gcmASSERT(OperandConstant);

    switch (gcGetComponentDataType(NewDataType))
    {
    case gcSHADER_FLOAT_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].floatValue = slmI2F(OperandConstant->values[i].intValue);
        }
        break;

    case gcSHADER_BOOLEAN_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].boolValue = slmI2B(OperandConstant->values[i].intValue);
        }
        break;

    case gcSHADER_INTEGER_X1:
        break;

    case gcSHADER_UINT_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].uintValue = slmI2U(OperandConstant->values[i].intValue);
        }
        break;

    default:
        gcmASSERT(0);
    }

    OperandConstant->dataType   = NewDataType;
}

void
slsOPERAND_CONSTANT_ChangeUintFamilyDataType(
    IN gcSHADER_TYPE NewDataType,
    IN OUT slsOPERAND_CONSTANT * OperandConstant
    )
{
    gctUINT     i;

    gcmASSERT(OperandConstant);

    switch (gcGetComponentDataType(NewDataType))
    {
    case gcSHADER_FLOAT_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].floatValue = slmU2F(OperandConstant->values[i].uintValue);
        }
        break;

    case gcSHADER_BOOLEAN_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].boolValue = slmU2B(OperandConstant->values[i].uintValue);
        }
        break;

    case gcSHADER_UINT_X1:
        break;

    case gcSHADER_INTEGER_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].intValue = slmU2I(OperandConstant->values[i].uintValue);
        }
        break;

    default:
        gcmASSERT(0);
    }

    OperandConstant->dataType   = NewDataType;
}

void
slsOPERAND_CONSTANT_ChangeBooleanFamilyDataType(
    IN gcSHADER_TYPE NewDataType,
    IN OUT slsOPERAND_CONSTANT * OperandConstant
    )
{
    gctUINT     i;

    gcmASSERT(OperandConstant);

    switch (gcGetComponentDataType(NewDataType))
    {
    case gcSHADER_FLOAT_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].floatValue = slmB2F(OperandConstant->values[i].boolValue);
        }
        break;

    case gcSHADER_BOOLEAN_X1:
        break;

    case gcSHADER_INTEGER_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].intValue = slmB2I(OperandConstant->values[i].boolValue);
        }
        break;

    case gcSHADER_UINT_X1:
        for (i = 0; i < OperandConstant->valueCount; i++)
        {
            OperandConstant->values[i].uintValue = slmB2U(OperandConstant->values[i].boolValue);
        }
        break;

    default:
        gcmASSERT(0);
    }

    OperandConstant->dataType   = NewDataType;
}

gceSTATUS
slsROPERAND_ChangeDataTypeFamily(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN gctBOOL TreatFloatAsInt,
    IN gcSHADER_TYPE NewDataType,
    IN OUT slsROPERAND * ROperand
    )
{
    gceSTATUS       status;
    sleOPCODE       opcode;
    slsIOPERAND     intermIOperand;

    gcmHEADER();

    gcmASSERT(ROperand);
    gcmASSERT(gcGetDataTypeComponentCount(ROperand->dataType)
                == gcGetDataTypeComponentCount(NewDataType));

    if (ROperand->isReg)
    {
        opcode = slvOPCODE_INVALID;

        switch (gcGetComponentDataType(NewDataType))
        {
        case gcSHADER_BOOLEAN_X1:
            switch (gcGetComponentDataType(ROperand->dataType))
            {
            case gcSHADER_FLOAT_X1:     opcode = slvOPCODE_FLOAT_TO_BOOL;   break;
            case gcSHADER_INTEGER_X1:   opcode = slvOPCODE_INT_TO_BOOL;     break;
            case gcSHADER_UINT_X1:   opcode = slvOPCODE_UINT_TO_BOOL;     break;
            default: break;
            }
            break;

        case gcSHADER_INTEGER_X1:
            switch (gcGetComponentDataType(ROperand->dataType))
            {
            case gcSHADER_FLOAT_X1:
                if (!TreatFloatAsInt) opcode = slvOPCODE_FLOAT_TO_INT;
                break;
            case gcSHADER_UINT_X1:
                opcode = slvOPCODE_UINT_TO_INT;
                break;
            default: break;
            }
            break;

        case gcSHADER_UINT_X1:
            switch (gcGetComponentDataType(ROperand->dataType))
            {
            case gcSHADER_FLOAT_X1:
                if (!TreatFloatAsInt) opcode = slvOPCODE_FLOAT_TO_UINT;
                break;
            case gcSHADER_INTEGER_X1:
                opcode = slvOPCODE_INT_TO_UINT;
                break;
            default: break;
            }
            break;

        case gcSHADER_FLOAT_X1:
            if (sloCOMPILER_IsHaltiVersion(Compiler)) {
              switch (gcGetComponentDataType(ROperand->dataType)) {
              case gcSHADER_INTEGER_X1:
                opcode = slvOPCODE_INT_TO_FLOAT;
                break;

              case gcSHADER_UINT_X1:
                opcode = slvOPCODE_UINT_TO_FLOAT;
                break;

              case gcSHADER_BOOLEAN_X1:
                opcode = slvOPCODE_BOOL_TO_FLOAT;
                break;

              default:
                break;
              }
            }
            break;

        default: break;
        }

        if (opcode == slvOPCODE_INVALID)
        {
            ROperand->dataType  = NewDataType;
        }
        else
        {
            slsIOPERAND_New(Compiler, &intermIOperand, NewDataType, ROperand->u.reg.precision);

            status = slGenGenericCode1(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    opcode,
                                    &intermIOperand,
                                    ROperand);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slsROPERAND_InitializeUsingIOperand(ROperand, &intermIOperand);
        }
    }
    else
    {
        switch (gcGetComponentDataType(ROperand->dataType))
        {
        case gcSHADER_FLOAT_X1:
            slsOPERAND_CONSTANT_ChangeFloatFamilyDataType(NewDataType, &ROperand->u.constant);
            break;

        case gcSHADER_BOOLEAN_X1:
            slsOPERAND_CONSTANT_ChangeBooleanFamilyDataType(NewDataType, &ROperand->u.constant);
            break;

        case gcSHADER_INTEGER_X1:
            slsOPERAND_CONSTANT_ChangeIntegerFamilyDataType(NewDataType, &ROperand->u.constant);
            break;

        case gcSHADER_UINT_X1:
            slsOPERAND_CONSTANT_ChangeUintFamilyDataType(NewDataType, &ROperand->u.constant);
            break;

        default:
            gcmASSERT(0);
        }

        ROperand->dataType  = NewDataType;
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

void
slsROPERAND_CONSTANT_ConvScalarToVector(
    IN sloCOMPILER Compiler,
    IN gcSHADER_TYPE NewDataType,
    IN OUT slsROPERAND * ROperand
    )
{
    gctUINT     i;
    gctUINT8 vectorComponentCount;
    gceSTATUS status;

    gcmHEADER_ARG("Compiler=0x%x NewDataType=%d ROperand=0x%x",
                  Compiler, NewDataType, ROperand);

    gcmASSERT(ROperand);
    gcmASSERT(gcIsScalarDataType(ROperand->dataType));
    gcmASSERT(!ROperand->isReg);

    vectorComponentCount = gcGetDataTypeComponentCount(NewDataType);

    switch (ROperand->dataType)
    {
    case gcSHADER_FLOAT_X1:
        for (i = 1; i < vectorComponentCount; i++)
        {
            ROperand->u.constant.values[i].floatValue = ROperand->u.constant.values[0].floatValue;
        }
        break;

    case gcSHADER_BOOLEAN_X1:
        for (i = 1; i < vectorComponentCount; i++)
        {
            ROperand->u.constant.values[i].boolValue = ROperand->u.constant.values[0].boolValue;
        }
        break;

    case gcSHADER_INTEGER_X1:
        for (i = 1; i < vectorComponentCount; i++)
        {
            ROperand->u.constant.values[i].intValue = ROperand->u.constant.values[0].intValue;
        }
        break;

    case gcSHADER_UINT_X1:
        if (sloCOMPILER_IsHaltiVersion(Compiler)) {
          for (i = 1; i < vectorComponentCount; i++)
          {
            ROperand->u.constant.values[i].uintValue = ROperand->u.constant.values[0].uintValue;
          }
          break;
        }
        /*fall through */

    default:
        gcmASSERT(0);
    }

    ROperand->u.constant.valueCount = vectorComponentCount;

    ROperand->dataType = gcConvScalarToVectorDataType(ROperand->dataType, vectorComponentCount);

    status = slsROPERAND_ChangeDataTypeFamily(
                                             Compiler,
                                             0,
                                             0,
                                             gcvFALSE,
                                             NewDataType,
                                             ROperand);
    if (gcmIS_ERROR(status))
    {
        gcmFOOTER();
        return;
    }

    gcmFOOTER_NO();
}

gctBOOL
slsROPERAND_CONSTANT_IsAllVectorComponentsEqual(
    IN slsROPERAND * ROperand
    )
{
    gctUINT     i;

    gcmASSERT(ROperand);
    gcmASSERT(!ROperand->isReg);

    switch (gcGetVectorComponentDataType(ROperand->dataType))
    {
    case gcSHADER_FLOAT_X1:
        for (i = 1; i < ROperand->u.constant.valueCount; i++)
        {
            if (ROperand->u.constant.values[i].floatValue
                != ROperand->u.constant.values[0].floatValue)
            {
                return gcvFALSE;
            }
        }
        break;

    case gcSHADER_BOOLEAN_X1:
        for (i = 1; i < ROperand->u.constant.valueCount; i++)
        {
            if (ROperand->u.constant.values[i].boolValue
                != ROperand->u.constant.values[0].boolValue)
            {
                return gcvFALSE;
            }
        }
        break;

    case gcSHADER_INTEGER_X1:
        for (i = 1; i < ROperand->u.constant.valueCount; i++)
        {
            if (ROperand->u.constant.values[i].intValue
                != ROperand->u.constant.values[0].intValue)
            {
                return gcvFALSE;
            }
        }
        break;

    case gcSHADER_UINT_X1:
        for (i = 1; i < ROperand->u.constant.valueCount; i++)
        {
            if (ROperand->u.constant.values[i].uintValue
                != ROperand->u.constant.values[0].uintValue)
            {
                return gcvFALSE;
            }
        }
        break;

    default:
        gcmASSERT(0);
    }

    return gcvTRUE;
}

gctCONST_STRING
slGetOpcodeName(
    IN sleOPCODE Opcode
    )
{
    switch (Opcode)
    {
    case slvOPCODE_ASSIGN:              return "assign";

    case slvOPCODE_ADD:                 return "add";
    case slvOPCODE_SUB:                 return "sub";
    case slvOPCODE_MUL:                 return "mul";
    case slvOPCODE_MULHI:               return "mulhi";
    case slvOPCODE_MOD:                 return "mod";
    case slvOPCODE_DIV:                 return "div";
    case slvOPCODE_IDIV:                return "div";

    case slvOPCODE_TEXTURE_LOAD:        return "texture_load";
    case slvOPCODE_TEXTURE_LOAD_U:      return "texture_load_u";
    case slvOPCODE_TEXTURE_LOAD_PCF:    return "texture_load_pcf";
    case slvOPCODE_TEXTURE_LOAD_PROJ:   return "texture_load_proj";
    case slvOPCODE_TEXTURE_LOAD_PCFPROJ:return "texture_load_pcfproj";
    case slvOPCODE_TEXTURE_BIAS:        return "texture_bias";
    case slvOPCODE_TEXTURE_LOD:         return "texture_lod";
    case slvOPCODE_TEXTURE_GRAD:        return "texture_grad";
    case slvOPCODE_TEXTURE_GATHER:      return "texture_gather";
    case slvOPCODE_TEXTURE_FETCH_MS:    return "texture_fetch_ms";
    case slvOPCODE_TEXTURE_U:           return "texture_u";
    case slvOPCODE_TEXTURE_U_LOD:       return "texture_u_lod";

    case slvOPCODE_FLOAT_TO_INT:    return "float_to_int";
    case slvOPCODE_FLOAT_TO_BOOL:    return "float_to_bool";
    case slvOPCODE_FLOAT_TO_UINT:    return "float_to_uint";
    case slvOPCODE_FLOAT_TO_HALF:    return "float_to_half";
    case slvOPCODE_HALF_TO_FLOAT:    return "half_to_float";
    case slvOPCODE_INT_TO_BOOL:        return "int_to_bool";
    case slvOPCODE_INT_TO_FLOAT:    return "int_to_float";
    case slvOPCODE_INT_TO_UINT:        return "int_to_uint";
    case slvOPCODE_BOOL_TO_INT:        return "bool_to_int";
    case slvOPCODE_BOOL_TO_FLOAT:    return "bool_to_float";
    case slvOPCODE_BOOL_TO_UINT:    return "bool_to_uint";
    case slvOPCODE_UINT_TO_INT:        return "uint_to_int";
    case slvOPCODE_UINT_TO_BOOL:    return "uint_to_bool";
    case slvOPCODE_UINT_TO_FLOAT:    return "uint_to_float";

    case slvOPCODE_INVERSE:             return "inverse";
    case slvOPCODE_LESS_THAN:           return "less_than";
    case slvOPCODE_LESS_THAN_EQUAL:     return "less_than_equal";
    case slvOPCODE_GREATER_THAN:        return "greater_than";
    case slvOPCODE_GREATER_THAN_EQUAL:  return "greater_than_equal";
    case slvOPCODE_EQUAL:               return "equal";
    case slvOPCODE_NOT_EQUAL:           return "not_equal";

    case slvOPCODE_BITWISE_AND:         return "bitwise_and";
    case slvOPCODE_BITWISE_OR:          return "bitwise_or";
    case slvOPCODE_BITWISE_XOR:         return "bitwise_xor";
    case slvOPCODE_BITWISE_NOT:         return "bitwise_not";

    case slvOPCODE_LSHIFT:              return "lshift";
    case slvOPCODE_RSHIFT:              return "rshift";

    case slvOPCODE_ANY:                 return "any";
    case slvOPCODE_ALL:                 return "all";
    case slvOPCODE_NOT:                 return "not";

    case slvOPCODE_SIN:                 return "sin";
    case slvOPCODE_COS:                 return "cos";
    case slvOPCODE_TAN:                 return "tan";

    case slvOPCODE_ASIN:                return "asin";
    case slvOPCODE_ACOS:                return "acos";
    case slvOPCODE_ATAN:                return "atan";
    case slvOPCODE_ATAN2:               return "atan2";

    case slvOPCODE_POW:                 return "pow";
    case slvOPCODE_EXP2:                return "exp2";
    case slvOPCODE_LOG2:                return "log2";
    case slvOPCODE_SQRT:                return "sqrt";
    case slvOPCODE_INVERSE_SQRT:        return "inverse_sqrt";

    case slvOPCODE_ABS:                 return "abs";
    case slvOPCODE_SIGN:                return "sign";
    case slvOPCODE_FLOOR:               return "floor";
    case slvOPCODE_CEIL:                return "ceil";
    case slvOPCODE_FRACT:               return "fract";
    case slvOPCODE_MIN:                 return "min";
    case slvOPCODE_MAX:                 return "max";
    case slvOPCODE_SATURATE:            return "saturate";
    case slvOPCODE_STEP:                return "step";
    case slvOPCODE_DOT:                 return "dot";
    case slvOPCODE_CROSS:               return "cross";
    case slvOPCODE_NORMALIZE:           return "normalize";

    case slvOPCODE_JUMP:                return "jump";
    case slvOPCODE_CALL:                return "call";
    case slvOPCODE_RETURN:              return "return";
    case slvOPCODE_DISCARD:             return "discard";

    case slvOPCODE_DFDX:                return "dFdx";
    case slvOPCODE_DFDY:                return "dFdy";
    case slvOPCODE_FWIDTH:              return "fwidth";

    case slvOPCODE_LOAD:                return "load";
    case slvOPCODE_STORE1:              return "store1";

    case slvOPCODE_ATTR_LD:             return "attr_ld";
    case slvOPCODE_ATTR_ST:             return "attr_st";

    case slvOPCODE_SAMPLER_ASSIGN:      return "sampler_assign";

    case slvOPCODE_POPCOUNT:            return "popcount";
    case slvOPCODE_FINDLSB:             return "findlsb";
    case slvOPCODE_FINDMSB:             return "findmsb";
    case slvOPCODE_BIT_REVERSAL:        return "bit_reversal";
    case slvOPCODE_BIT_EXTRACT:         return "bit_extract";
    case slvOPCODE_BIT_RANGE:           return "bit_range";
    case slvOPCODE_BIT_RANGE1:          return "bit_range1";
    case slvOPCODE_BIT_INSERT:          return "bit_insert";

    case slvOPCODE_UCARRY:              return "ucarry";
    case slvOPCODE_ATOMADD:             return "atom_add";
    case slvOPCODE_ATOMSUB:             return "atom_sub";
    case slvOPCODE_ATOMMIN:             return "atom_min";
    case slvOPCODE_ATOMMAX:             return "atom_max";
    case slvOPCODE_ATOMOR:              return "atom_or";
    case slvOPCODE_ATOMAND:             return "atom_and";
    case slvOPCODE_ATOMXOR:             return "atom_xor";
    case slvOPCODE_ATOMXCHG:            return "atom_xchg";
    case slvOPCODE_ATOMCMPXCHG:         return "atom_cmpxchg";

    case slvOPCODE_SET:                 return "set";
    case slvOPCODE_CMP:                 return "cmp";

    case slvOPCODE_BARRIER:             return "barrier";
    case slvOPCODE_MEMORY_BARRIER:      return "memoryBarrier";

    case slvOPCODE_IMAGE_READ:          return "imageLoad";
    case slvOPCODE_IMAGE_WRITE:         return "imageStore";
    case slvOPCODE_IMAGE_ADDRESS:       return "imageAddress";
    case slvOPCODE_IMAGE_ADDRESS_3D:    return "imageAddress3D";
    case slvOPCODE_GET_SAMPLER_IDX:     return "get_sampler_idx";
    case slvOPCODE_GET_SAMPLER_LMM:     return "get_sampler_lmm";
    case slvOPCODE_GET_SAMPLER_LBS:     return "get_sampler_lbs";
    case slvOPCODE_IMAGE_READ_3D:       return "imageLoad_3D";
    case slvOPCODE_IMAGE_WRITE_3D:      return "imageStore_3D";
    case slvOPCODE_CLAMP0MAX:           return "clamp0max";
    case slvOPCODE_EMIT_VERTEX:         return "emitVertex";
    case slvOPCODE_END_PRIMITIVE:       return "endPrimitive";
    default:
        gcmASSERT(0);
        return "Invalid";
    }
}

gctCONST_STRING
slGetConditionName(
    IN sleCONDITION Condition
    )
{
    switch (Condition)
    {
    case slvCONDITION_EQUAL:                return "equal";
    case slvCONDITION_NOT_EQUAL:            return "not_equal";
    case slvCONDITION_LESS_THAN:            return "less_than";
    case slvCONDITION_LESS_THAN_EQUAL:      return "less_than_equal";
    case slvCONDITION_GREATER_THAN:         return "greater_than";
    case slvCONDITION_GREATER_THAN_EQUAL:   return "greater_than_equal";
    case slvCONDITION_XOR:                  return "xor";
    case slvCONDITION_AND:                  return "and";
    case slvCONDITION_OR:                   return "or";
    case slvCONDITION_ZERO:                 return "zero";
    case slvCONDITION_NOT_ZERO:             return "not_zero";

    default:
        gcmASSERT(0);
        return "Invalid";
    }
}

sleCONDITION
slGetNotCondition(
    IN sleCONDITION Condition
    )
{
    switch (Condition)
    {
    case slvCONDITION_EQUAL:                return slvCONDITION_NOT_EQUAL;
    case slvCONDITION_NOT_EQUAL:
    case slvCONDITION_XOR:                  return slvCONDITION_EQUAL;
    case slvCONDITION_LESS_THAN:            return slvCONDITION_GREATER_THAN_EQUAL;
    case slvCONDITION_LESS_THAN_EQUAL:      return slvCONDITION_GREATER_THAN;
    case slvCONDITION_GREATER_THAN:         return slvCONDITION_LESS_THAN_EQUAL;
    case slvCONDITION_GREATER_THAN_EQUAL:   return slvCONDITION_LESS_THAN;
    case slvCONDITION_ZERO:            return slvCONDITION_NOT_ZERO;
    case slvCONDITION_NOT_ZERO:            return slvCONDITION_ZERO;

    default:
        gcmASSERT(0);
        return slvCONDITION_NOT_EQUAL;
    }
}

gctBOOL
slsROPERAND_IsFloatOrVecConstant(
    IN slsROPERAND * ROperand,
    IN gctFLOAT FloatValue
    )
{
    gcmASSERT(ROperand);

    if (ROperand->isReg) return gcvFALSE;

    switch (ROperand->dataType)
    {
    case gcSHADER_FLOAT_X1:
        return (ROperand->u.constant.values[0].floatValue == FloatValue);

    case gcSHADER_FLOAT_X2:
        return (ROperand->u.constant.values[0].floatValue == FloatValue
                && ROperand->u.constant.values[1].floatValue == FloatValue);

    case gcSHADER_FLOAT_X3:
        return (ROperand->u.constant.values[0].floatValue == FloatValue
                && ROperand->u.constant.values[1].floatValue == FloatValue
                && ROperand->u.constant.values[2].floatValue == FloatValue);

    case gcSHADER_FLOAT_X4:
        return (ROperand->u.constant.values[0].floatValue == FloatValue
                && ROperand->u.constant.values[1].floatValue == FloatValue
                && ROperand->u.constant.values[2].floatValue == FloatValue
                && ROperand->u.constant.values[3].floatValue == FloatValue);

    default: return gcvFALSE;
    }
}

static gcSHADER_TYPE
_ConvElementDataType(
    IN slsDATA_TYPE * DataType
    )
{
    gcmASSERT(DataType);

    switch (DataType->elementType)
    {
    case slvTYPE_BOOL:
        switch (slmDATA_TYPE_vectorSize_GET(DataType))
        {
        case 0: return gcSHADER_BOOLEAN_X1;
        case 2: return gcSHADER_BOOLEAN_X2;
        case 3: return gcSHADER_BOOLEAN_X3;
        case 4: return gcSHADER_BOOLEAN_X4;

        default:
            gcmASSERT(0);
            return gcSHADER_BOOLEAN_X4;
        }

    case slvTYPE_INT:
        switch (slmDATA_TYPE_vectorSize_GET(DataType))
        {
        case 0: return gcSHADER_INTEGER_X1;
        case 2: return gcSHADER_INTEGER_X2;
        case 3: return gcSHADER_INTEGER_X3;
        case 4: return gcSHADER_INTEGER_X4;

        default:
            gcmASSERT(0);
            return gcSHADER_INTEGER_X4;
        }

    case slvTYPE_FLOAT:
        switch (slmDATA_TYPE_matrixColumnCount_GET(DataType))
        {
        case 0:
            switch (slmDATA_TYPE_vectorSize_GET(DataType))
            {
            case 0: return gcSHADER_FLOAT_X1;
            case 2: return gcSHADER_FLOAT_X2;
            case 3: return gcSHADER_FLOAT_X3;
            case 4: return gcSHADER_FLOAT_X4;

            default:
                gcmASSERT(0);
                return gcSHADER_FLOAT_X4;
            }

        case 2:
            switch (slmDATA_TYPE_matrixRowCount_GET(DataType)) {
            case 2:
                return gcSHADER_FLOAT_2X2;

            case 3:
                return gcSHADER_FLOAT_2X3;

            case 4:
                return gcSHADER_FLOAT_2X4;

            default:
                gcmASSERT(0);
                return gcSHADER_FLOAT_2X2;
            }

        case 3:
            switch (slmDATA_TYPE_matrixRowCount_GET(DataType)) {
            case 2:
                return gcSHADER_FLOAT_3X2;

            case 3:
                return gcSHADER_FLOAT_3X3;

            case 4:
                return gcSHADER_FLOAT_3X4;

            default:
                gcmASSERT(0);
                return gcSHADER_FLOAT_3X3;
            }

        case 4:
            switch (slmDATA_TYPE_matrixRowCount_GET(DataType)) {
            case 2:
                return gcSHADER_FLOAT_4X2;

            case 3:
                return gcSHADER_FLOAT_4X3;

            case 4:
                return gcSHADER_FLOAT_4X4;

            default:
                gcmASSERT(0);
                return gcSHADER_FLOAT_4X4;
            }

        default:
            gcmASSERT(0);
            return gcSHADER_FLOAT_4X4;
        }

    case slvTYPE_SAMPLER2D:
        return gcSHADER_SAMPLER_2D;

    case slvTYPE_SAMPLERCUBE:
        return gcSHADER_SAMPLER_CUBIC;

    case slvTYPE_SAMPLERCUBEARRAY:
        return gcSHADER_SAMPLER_CUBEMAP_ARRAY;

    case slvTYPE_SAMPLER1DARRAY:
        return gcSHADER_SAMPLER_1D_ARRAY;

    case slvTYPE_SAMPLER1DARRAYSHADOW:
        return gcSHADER_SAMPLER_1D_ARRAY_SHADOW;

    case slvTYPE_SAMPLER2DSHADOW:
        return gcSHADER_SAMPLER_2D_SHADOW;

    case slvTYPE_SAMPLER3D:
        return gcSHADER_SAMPLER_3D;

    case slvTYPE_SAMPLERBUFFER:
        return gcSHADER_SAMPLER_BUFFER;

    case slvTYPE_SAMPLER2DARRAY:
        return gcSHADER_SAMPLER_2D_ARRAY;

    case slvTYPE_SAMPLER2DARRAYSHADOW:
        return gcSHADER_SAMPLER_2D_ARRAY_SHADOW;

    case slvTYPE_SAMPLERCUBESHADOW:
        return gcSHADER_SAMPLER_CUBE_SHADOW;

    case slvTYPE_SAMPLERCUBEARRAYSHADOW:
        return gcSHADER_SAMPLER_CUBEMAP_ARRAY_SHADOW;

    case slvTYPE_ISAMPLERCUBE:
        return gcSHADER_ISAMPLER_CUBIC;

    case slvTYPE_ISAMPLERCUBEARRAY:
        return gcSHADER_ISAMPLER_CUBEMAP_ARRAY;

    case slvTYPE_ISAMPLER2D:
        return gcSHADER_ISAMPLER_2D;

    case slvTYPE_ISAMPLER3D:
        return gcSHADER_ISAMPLER_3D;

    case slvTYPE_ISAMPLERBUFFER:
        return gcSHADER_ISAMPLER_BUFFER;

    case slvTYPE_ISAMPLER2DARRAY:
        return gcSHADER_ISAMPLER_2D_ARRAY;

    case slvTYPE_USAMPLERCUBE:
        return gcSHADER_USAMPLER_CUBIC;

    case slvTYPE_USAMPLERCUBEARRAY:
        return gcSHADER_USAMPLER_CUBEMAP_ARRAY;

    case slvTYPE_USAMPLER2D:
        return gcSHADER_USAMPLER_2D;

    case slvTYPE_USAMPLER3D:
        return gcSHADER_USAMPLER_3D;

    case slvTYPE_USAMPLERBUFFER:
        return gcSHADER_USAMPLER_BUFFER;

    case slvTYPE_USAMPLER2DARRAY:
        return gcSHADER_USAMPLER_2D_ARRAY;

    case slvTYPE_SAMPLEREXTERNALOES:
        return gcSHADER_SAMPLER_EXTERNAL_OES;

    case slvTYPE_SAMPLER2DMS:
        return gcSHADER_SAMPLER_2D_MS;

    case slvTYPE_ISAMPLER2DMS:
        return gcSHADER_ISAMPLER_2D_MS;

    case slvTYPE_USAMPLER2DMS:
        return gcSHADER_USAMPLER_2D_MS;

    case slvTYPE_SAMPLER2DMSARRAY:
        return gcSHADER_SAMPLER_2D_MS_ARRAY;

    case slvTYPE_ISAMPLER2DMSARRAY:
        return gcSHADER_ISAMPLER_2D_MS_ARRAY;

    case slvTYPE_USAMPLER2DMSARRAY:
        return gcSHADER_USAMPLER_2D_MS_ARRAY;

    case slvTYPE_IMAGE2D:
        return gcSHADER_IMAGE_2D;

    case slvTYPE_IIMAGE2D:
        return gcSHADER_IIMAGE_2D;

    case slvTYPE_UIMAGE2D:
        return gcSHADER_UIMAGE_2D;

    case slvTYPE_IMAGE2DARRAY:
        return gcSHADER_IMAGE_2D_ARRAY;

    case slvTYPE_IIMAGE2DARRAY:
        return gcSHADER_IIMAGE_2D_ARRAY;

    case slvTYPE_UIMAGE2DARRAY:
        return gcSHADER_UIMAGE_2D_ARRAY;

    case slvTYPE_IMAGE3D:
        return gcSHADER_IMAGE_3D;

    case slvTYPE_IIMAGE3D:
        return gcSHADER_IIMAGE_3D;

    case slvTYPE_UIMAGE3D:
        return gcSHADER_UIMAGE_3D;

    case slvTYPE_IMAGECUBE:
        return gcSHADER_IMAGE_CUBE;

    case slvTYPE_IMAGECUBEARRAY:
        return gcSHADER_IMAGE_CUBEMAP_ARRAY;

    case slvTYPE_IIMAGECUBE:
        return gcSHADER_IIMAGE_CUBE;

    case slvTYPE_IIMAGECUBEARRAY:
        return gcSHADER_IIMAGE_CUBEMAP_ARRAY;

    case slvTYPE_UIMAGECUBE:
        return gcSHADER_UIMAGE_CUBE;

    case slvTYPE_UIMAGECUBEARRAY:
        return gcSHADER_UIMAGE_CUBEMAP_ARRAY;

    case slvTYPE_IMAGEBUFFER:
        return gcSHADER_IMAGE_BUFFER;

    case slvTYPE_IIMAGEBUFFER:
        return gcSHADER_IIMAGE_BUFFER;

    case slvTYPE_UIMAGEBUFFER:
        return gcSHADER_UIMAGE_BUFFER;

    case slvTYPE_UINT:
        switch (slmDATA_TYPE_vectorSize_GET(DataType))
        {
        case 0: return gcSHADER_UINT_X1;
        case 2: return gcSHADER_UINT_X2;
        case 3: return gcSHADER_UINT_X3;
        case 4: return gcSHADER_UINT_X4;

        default:
           gcmASSERT(0);
           return gcSHADER_UINT_X4;
        }
    case slvTYPE_ATOMIC_UINT:
        return gcSHADER_ATOMIC_UINT;
    default:
        gcmASSERT(0);
        return gcSHADER_FLOAT_X4;
    }
}

gctINT
_GetLogicalCountForAnArray(
    IN slsDATA_TYPE * DataType
    )
{
    gctINT count = 1;
    gctINT i;

    if (slsDATA_TYPE_IsInheritFromUnsizedDataType(DataType))
    {
        count = 1;
    }
    else
    {
        for (i = 0; i < DataType->arrayLengthCount; i++)
        {
            if (DataType->arrayLengthList[i] > 0)
            {
                count *= DataType->arrayLengthList[i];
            }
            else
            {
                count = 1;
                break;
            }
        }
    }

    if (slsDATA_TYPE_IsPerVertexArray(DataType) &&
        DataType->arrayLength != -1 && DataType->arrayLength != 0)
    {
        count /= DataType->arrayLength;
    }

    return count;
}

gctUINT
_GetLogicalOperandCount(
    IN slsDATA_TYPE * DataType,
    IN gctBOOL bCalcTypeSize
    )
{
    gctUINT     count = 0;
    slsNAME *   fieldName;

    gcmASSERT(DataType);

    if (DataType->elementType == slvTYPE_STRUCT ||
        slsDATA_TYPE_IsUnderlyingInterfaceBlock(DataType))
    {
        gcmASSERT(DataType->fieldSpace);

        FOR_EACH_DLINK_NODE(&DataType->fieldSpace->names, slsNAME, fieldName)
        {
            gcmASSERT(fieldName->dataType);
            count += _GetLogicalOperandCount(fieldName->dataType, bCalcTypeSize);
        }
    }
    else
    {
        if (bCalcTypeSize)
            count = gcGetDataTypeSize(_ConvElementDataType(DataType));
        else
            count = 1;
    }

    count *= _GetLogicalCountForAnArray(DataType);

    return count;
}

static gceSTATUS
_IsOutputColorAddBefore(
    IN sloCOMPILER Compiler
    )
{
    gcSHADER    binary;
    gctUINT32 i, count;
    gcOUTPUT output;

    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));

    gcSHADER_GetOutputCount(binary, &count);

    for (i = 0; i < count; i++)
    {
        gcSHADER_GetOutput(binary, i, &output);
        if (output->nameLength == gcSL_COLOR)
        {
            return gcvSTATUS_TRUE;
        }
    }

    return gcvSTATUS_FALSE;
}

static gctUINT32
_GetLogicalOperandFieldOffset(
    IN slsDATA_TYPE * DataType,
    IN slsNAME * FieldName,
    IN gctBOOL bCalcTypeSize
    )
{
    gctUINT32   offset = 0;
    slsNAME *   fieldName;

    gcmASSERT(DataType);
    gcmASSERT(slsDATA_TYPE_IsStruct(DataType) ||
              slsDATA_TYPE_IsInterfaceBlock(DataType));
    gcmASSERT(FieldName);

    gcmASSERT(DataType->fieldSpace);

    FOR_EACH_DLINK_NODE(&DataType->fieldSpace->names, slsNAME, fieldName)
    {
        if (fieldName == FieldName) break;

        gcmASSERT(fieldName->dataType);
        offset += _GetLogicalOperandCount(fieldName->dataType, bCalcTypeSize);
    }

    gcmASSERT(fieldName == FieldName);

    return offset;
}


#define _slmDefaultComponentSelectionByComponents(Components)  \
    ((Components) == 1 ? ComponentSelection_X \
                       : ((Components) == 2 ? ComponentSelection_XY \
                                            : ((Components) == 3 ? ComponentSelection_XYZ \
                                                                 : ComponentSelection_XYZW)))

slsCOMPONENT_SELECTION
slGetDefaultComponentSelection(
    IN gcSHADER_TYPE DataType
    )
{
    switch (DataType)
    {
    case gcSHADER_FLOAT_X1:
    case gcSHADER_BOOLEAN_X1:
    case gcSHADER_INTEGER_X1:
    case gcSHADER_UINT_X1:
        return ComponentSelection_X;

    case gcSHADER_FLOAT_X2:
    case gcSHADER_FLOAT_2X2:
    case gcSHADER_FLOAT_3X2:
    case gcSHADER_FLOAT_4X2:
    case gcSHADER_BOOLEAN_X2:
    case gcSHADER_INTEGER_X2:
    case gcSHADER_UINT_X2:
        return ComponentSelection_XY;

    case gcSHADER_FLOAT_X3:
    case gcSHADER_FLOAT_2X3:
    case gcSHADER_FLOAT_3X3:
    case gcSHADER_FLOAT_4X3:
    case gcSHADER_BOOLEAN_X3:
    case gcSHADER_INTEGER_X3:
    case gcSHADER_UINT_X3:
        return ComponentSelection_XYZ;

    case gcSHADER_FLOAT_X4:
    case gcSHADER_FLOAT_2X4:
    case gcSHADER_FLOAT_3X4:
    case gcSHADER_FLOAT_4X4:
    case gcSHADER_BOOLEAN_X4:
    case gcSHADER_INTEGER_X4:
    case gcSHADER_UINT_X4:
    case gcSHADER_SAMPLER_1D:
    case gcSHADER_SAMPLER_2D:
    case gcSHADER_SAMPLER_3D:
    case gcSHADER_SAMPLER_BUFFER:
    case gcSHADER_SAMPLER_CUBIC:
    case gcSHADER_SAMPLER_CUBEMAP_ARRAY:
    case gcSHADER_SAMPLER_EXTERNAL_OES:
    case gcSHADER_SAMPLER_2D_SHADOW:
    case gcSHADER_SAMPLER_CUBE_SHADOW:
    case gcSHADER_SAMPLER_CUBEMAP_ARRAY_SHADOW:

    case gcSHADER_SAMPLER_1D_ARRAY:
    case gcSHADER_SAMPLER_1D_ARRAY_SHADOW:
    case gcSHADER_SAMPLER_2D_ARRAY:
    case gcSHADER_SAMPLER_2D_ARRAY_SHADOW:

    case gcSHADER_ISAMPLER_2D:
    case gcSHADER_ISAMPLER_3D:
    case gcSHADER_ISAMPLER_BUFFER:
    case gcSHADER_ISAMPLER_CUBIC:
    case gcSHADER_ISAMPLER_CUBEMAP_ARRAY:
    case gcSHADER_ISAMPLER_2D_ARRAY:

    case gcSHADER_USAMPLER_2D:
    case gcSHADER_USAMPLER_3D:
    case gcSHADER_USAMPLER_BUFFER:
    case gcSHADER_USAMPLER_CUBIC:
    case gcSHADER_USAMPLER_CUBEMAP_ARRAY:
    case gcSHADER_USAMPLER_2D_ARRAY:

    case gcSHADER_SAMPLER_2D_MS:
    case gcSHADER_ISAMPLER_2D_MS:
    case gcSHADER_USAMPLER_2D_MS:
    case gcSHADER_SAMPLER_2D_MS_ARRAY:
    case gcSHADER_ISAMPLER_2D_MS_ARRAY:
    case gcSHADER_USAMPLER_2D_MS_ARRAY:

    case gcSHADER_IMAGE_2D:
    case gcSHADER_IIMAGE_2D:
    case gcSHADER_UIMAGE_2D:
    case gcSHADER_IMAGE_2D_ARRAY:
    case gcSHADER_IIMAGE_2D_ARRAY:
    case gcSHADER_UIMAGE_2D_ARRAY:
    case gcSHADER_IMAGE_3D:
    case gcSHADER_IIMAGE_3D:
    case gcSHADER_UIMAGE_3D:
    case gcSHADER_IMAGE_CUBE:
    case gcSHADER_IMAGE_CUBEMAP_ARRAY:
    case gcSHADER_IIMAGE_CUBE:
    case gcSHADER_IIMAGE_CUBEMAP_ARRAY:
    case gcSHADER_UIMAGE_CUBE:
    case gcSHADER_UIMAGE_CUBEMAP_ARRAY:
    case gcSHADER_IMAGE_BUFFER:
    case gcSHADER_IIMAGE_BUFFER:
    case gcSHADER_UIMAGE_BUFFER:
        return ComponentSelection_XYZW;

    case gcSHADER_ATOMIC_UINT:
        return ComponentSelection_X;

    default:
        gcmASSERT(0);
        return ComponentSelection_XYZW;
    }
}

static gcSHADER_PRECISION
_ConvElementDataPrecision(
    IN slsDATA_TYPE * DataType
    )
{
    gcmASSERT(DataType);

    switch (DataType->qualifiers.precision)
    {
    case slvPRECISION_QUALIFIER_DEFAULT:
        return gcSHADER_PRECISION_DEFAULT;
    case slvPRECISION_QUALIFIER_HIGH:
        return gcSHADER_PRECISION_HIGH;
    case slvPRECISION_QUALIFIER_MEDIUM:
        return gcSHADER_PRECISION_MEDIUM;
    case slvPRECISION_QUALIFIER_LOW:
        return gcSHADER_PRECISION_LOW;
    case slvPRECISION_QUALIFIER_ANY:
        return gcSHADER_PRECISION_ANY;

    default:
        gcmASSERT(0);
        return gcSHADER_PRECISION_DEFAULT;
    }
}

static gceSTATUS
_ConvDataType(
    IN slsDATA_TYPE * DataType,
    OUT gcSHADER_TYPE * TargetDataTypes,
    IN OUT gctUINT * Start
    )
{
    gceSTATUS   status;
    gctUINT     count, i;
    slsNAME *   fieldName;

    gcmHEADER();

    gcmASSERT(DataType);
    gcmASSERT(TargetDataTypes);
    gcmASSERT(Start);

    count = _GetLogicalCountForAnArray(DataType);

    for (i = 0; i < count; i++)
    {
        if (DataType->elementType == slvTYPE_STRUCT ||
            slsDATA_TYPE_IsUnderlyingInterfaceBlock(DataType))
        {
            gcmASSERT(DataType->fieldSpace);

            FOR_EACH_DLINK_NODE(&DataType->fieldSpace->names, slsNAME, fieldName)
            {
                gcmASSERT(fieldName->dataType);

                status = _ConvDataType(
                                    fieldName->dataType,
                                    TargetDataTypes,
                                    Start);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
        }
        else
        {
            TargetDataTypes[*Start] = _ConvElementDataType(DataType);
            (*Start)++;
        }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gctBOOL
_IsTempRegQualifier(
    IN sltSTORAGE_QUALIFIER Qualifier
    )
{
    switch (Qualifier)
    {
    case slvSTORAGE_QUALIFIER_NONE:
    case slvSTORAGE_QUALIFIER_CONST_IN:
    case slvSTORAGE_QUALIFIER_IN:
    case slvSTORAGE_QUALIFIER_OUT:
    case slvSTORAGE_QUALIFIER_INOUT:

    case slvSTORAGE_QUALIFIER_VARYING_OUT:
    case slvSTORAGE_QUALIFIER_FRAGMENT_OUT:
        return gcvTRUE;

    default:
        return gcvFALSE;
    }
}

static gceLAYOUT_QUALIFIER
_ConvOutputBlendSupport(
     IN gctUINT LayoutId
     )
{
    gceLAYOUT_QUALIFIER blendSupport = gcvLAYOUT_QUALIFIER_NONE;

    if(LayoutId) {
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_MULTIPLY) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_MULTIPLY;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_SCREEN) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SCREEN;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_OVERLAY) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_OVERLAY;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_DARKEN) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DARKEN;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_LIGHTEN) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_LIGHTEN;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_COLORDODGE) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_COLORBURN) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_HARDLIGHT) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HARDLIGHT;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_SOFTLIGHT) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_DIFFERENCE) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DIFFERENCE;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_EXCLUSION) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_EXCLUSION;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_HSL_HUE) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_HSL_SATURATION) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_HSL_COLOR) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR;
        }
        if(LayoutId & slvLAYOUT_BLEND_SUPPORT_HSL_LUMINOSITY) {
            blendSupport |= gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY;
        }
    }
    return blendSupport;
}

static gceSTATUS
_AllocLogicalRegOrArray(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN gctINT16 parent,
    IN gctINT16 prevSibling,
    gctBOOL CreateVariable,
    OUT gctINT16* ThisVarIndex,
    OUT gctREG_INDEX* FirstRegIndex,
    OUT slsLOGICAL_REG * LogicalRegs,
    IN OUT gctUINT * Start,
    IN OUT gctINT * FieldIndex
    )
{
    gceSTATUS               status = gcvSTATUS_OK;
    sltSTORAGE_QUALIFIER    storageQualifier;
    gcSHADER_TYPE           binaryDataType;
    gctUINT32               binaryDataTypeSize;
    gctUINT                 logicalRegCount, i;
    gctINT16                varIndex = 0;
    gctREG_INDEX            tempRegIndex = 0;
    gcUNIFORM               uniform = gcvNULL;
    gcATTRIBUTE             attribute = gcvNULL;
    gcOUTPUT                output = gcvNULL;
    gcSHADER_PRECISION      binaryPrecision;
    gcSHADER_SHADERMODE     shaderMode;
    gctBOOL                 isInvariant = gcvFALSE;
    gctBOOL                 isPrecise = gcvFALSE;
    sleSHADER_TYPE          shaderType;
    gcSHADER                binary = gcvNULL;

    gcmHEADER_ARG("Compiler=0x%x CodeGenerator=0x%x Name=0x%x Symbol=%s "
                  "DataType=0x%x",
                  Compiler, CodeGenerator, Name, gcmOPT_STRING(Symbol),
                  DataType);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmVERIFY_ARGUMENT(Name);
    gcmASSERT(DataType);
    gcmASSERT(!slsDATA_TYPE_IsStruct(DataType));
    gcmASSERT(LogicalRegs);
    gcmASSERT(Start);

    storageQualifier           = Name->dataType->qualifiers.storage;
    gcmVERIFY_OK(sloCOMPILER_GetShaderType(Compiler, &shaderType));
    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));

    if (Name->isBuiltIn &&
        !(Name->type == slvFUNC_NAME && Name->u.funcInfo.isIntrinsicCall))
    {
        status = slGetBuiltInVariableImplSymbol(Compiler,
                                                Symbol,
                                                &Symbol,
                                                &storageQualifier);
        if (gcmIS_ERROR(status)) {
           gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                           Name->lineNo,
                                           Name->stringNo,
                                           slvREPORT_ERROR,
                                           "invalid builtin variable '%s'", Symbol));

           gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);

           return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }
    }

    binaryDataType      = _ConvElementDataType(DataType);
    binaryDataTypeSize  = gcGetDataTypeSize(binaryDataType);
    binaryPrecision = _ConvElementDataPrecision(DataType);

    logicalRegCount = (gctUINT)_GetLogicalCountForAnArray(DataType);

    if ((Name->dataType->qualifiers.interpolation & slvINTERPOLATION_QUALIFIER_FLAT) ||
        gcmIS_SUCCESS(gcoOS_StrCmp(Symbol, "#Layer")) ||
        gcmIS_SUCCESS(gcoOS_StrCmp(Symbol, "#PrimitiveID")))
    {
        shaderMode = gcSHADER_SHADER_FLAT;
    }
    else if (Name->dataType->qualifiers.interpolation & slvINTERPOLATION_QUALIFIER_SMOOTH)
    {
        shaderMode = gcSHADER_SHADER_SMOOTH;
    }
    else
    {
        shaderMode = gcSHADER_SHADER_DEFAULT;
    }

    switch (storageQualifier)
    {
    case slvSTORAGE_QUALIFIER_NONE:
    case slvSTORAGE_QUALIFIER_CONST_IN:
    case slvSTORAGE_QUALIFIER_IN:
    case slvSTORAGE_QUALIFIER_OUT:
    case slvSTORAGE_QUALIFIER_INOUT:
    case slvSTORAGE_QUALIFIER_VERTEX_ID:
    case slvSTORAGE_QUALIFIER_INSTANCE_ID:
    case slvSTORAGE_QUALIFIER_SHARED:
        if (slsQUALIFIERS_HAS_FLAG(&DataType->qualifiers, slvQUALIFIERS_FLAG_PRECISE))
        {
            isPrecise = gcvTRUE;
        }
        tempRegIndex = slNewTempRegs(Compiler, logicalRegCount * binaryDataTypeSize);

        for (i = 0; i < logicalRegCount; i++)
        {
            slsLOGICAL_REG_InitializeTemp(
                                        LogicalRegs + *Start + i,
                                        storageQualifier,
                                        binaryDataType,
                                        binaryPrecision,
                                        tempRegIndex + (gctREG_INDEX)(i * binaryDataTypeSize));
        }

        if (Name->type == slvFUNC_NAME || Name->type == slvPARAMETER_NAME)
        {
            gctUINT8 argumentQualifier = gcvFUNCTION_INPUT;
            gcSHADER_VAR_CATEGORY var_category = gcSHADER_VAR_CATEGORY_FUNCTION_INPUT_ARGUMENT;

            gcmASSERT(Name->context.function);

            switch (storageQualifier)
            {
            case slvSTORAGE_QUALIFIER_NONE:
            case slvSTORAGE_QUALIFIER_CONST_IN:
            case slvSTORAGE_QUALIFIER_IN:
                argumentQualifier = gcvFUNCTION_INPUT;
                var_category = gcSHADER_VAR_CATEGORY_FUNCTION_INPUT_ARGUMENT;
                break;
            case slvSTORAGE_QUALIFIER_OUT:
                argumentQualifier = gcvFUNCTION_OUTPUT;
                var_category = gcSHADER_VAR_CATEGORY_FUNCTION_OUTPUT_ARGUMENT;
                break;
            case slvSTORAGE_QUALIFIER_INOUT:
                argumentQualifier = gcvFUNCTION_INOUT;
                var_category = gcSHADER_VAR_CATEGORY_FUNCTION_INOUT_ARGUMENT;
                break;
            }

            if (Name->type == slvPARAMETER_NAME)
            {
                gctSIZE_T length, functionLength, totalLength;
                gctUINT offset = 0;
                gctPOINTER pointer = gcvNULL;
                gctSTRING symbol = gcvNULL;
                gcoOS_StrLen(Symbol, &length);
                gcoOS_StrLen(Name->context.function->name, &functionLength);

                /*
                ** This function is built-in, so we don't have a explicit parameter name,
                ** so we allocate a temp parameter name for it.
                */
                if (length == 0)
                {
                    totalLength = 10 + functionLength;
                }
                else
                {
                    totalLength = length + functionLength + 10;
                }
                status = sloCOMPILER_Allocate(Compiler,
                                                totalLength,
                                                &pointer);

                if (gcmIS_ERROR(status))
                {
                    gcmFOOTER();
                    return status;
                }

                symbol = pointer;

                if (length == 0)
                {
                    gcmVERIFY_OK(gcoOS_PrintStrSafe(symbol, totalLength,
                                                    &offset,
                                                    (argumentQualifier == gcvFUNCTION_INPUT) ? ("%s_input") :
                                                    (argumentQualifier == gcvFUNCTION_OUTPUT ? ("%s_output") : ("%s_inout")),
                                                    Name->context.function->name));
                }
                else
                {
                    gcmVERIFY_OK(gcoOS_PrintStrSafe(symbol, totalLength,
                                                    &offset,
                                                    (argumentQualifier == gcvFUNCTION_INPUT) ? ("%s_input_%s") :
                                                    (argumentQualifier == gcvFUNCTION_OUTPUT ? ("%s_output_%s") : ("%s_inout_%s")),
                                                    Name->context.function->name,
                                                    Symbol));
                }

                slmNewVariable(Compiler,
                                Name->lineNo,
                                Name->stringNo,
                                symbol,
                                binaryDataType,
                                binaryPrecision,
                                DataType->arrayLengthCount,
                                DataType->arrayLengthList,
                                gcvTRUE,
                                gcvFALSE, /* not output */
                                isPrecise, /* not precise */
                                DataType->isPerVertexArray,
                                tempRegIndex,
                                var_category,
                                0,
                                -1,
                                -1,
                                ThisVarIndex,
                                status);

                if (gcmIS_ERROR(status))
                {
                    gcmFOOTER();
                    return status;
                }

                if (symbol != gcvNULL)
                {
                    gcmVERIFY_OK(sloCOMPILER_Free(Compiler, symbol));
                }
            }
            else
            {
                *ThisVarIndex = 0xffff;
            }

            status = slNewFunctionArgument(Compiler,
                                           Name->context.function,
                                           *ThisVarIndex,
                                           binaryDataType,
                                           logicalRegCount,
                                           tempRegIndex,
                                           argumentQualifier,
                                           binaryPrecision,
                                           isPrecise);

            if (gcmIS_ERROR(status))
            {
                gcmFOOTER();
                return status;
            }
        }
        else
        {
            slmNewVariable(Compiler,
                           Name->lineNo,
                           Name->stringNo,
                           Symbol,
                           binaryDataType,
                           binaryPrecision,
                           DataType->arrayLengthCount,
                           DataType->arrayLengthList,
                           (Name->type == slvVARIABLE_NAME) ? Name->u.variableInfo.isLocal : gcvTRUE,
                           gcvFALSE, /* not output */
                           isPrecise,
                           DataType->isPerVertexArray,
                           tempRegIndex,
                           gcSHADER_VAR_CATEGORY_NORMAL,
                           0,
                           parent,
                           prevSibling,
                           ThisVarIndex,
                           status);

            if (gcmIS_ERROR(status))
            {
                gcmFOOTER();
                return status;
            }
        }

        break;

    case slvSTORAGE_QUALIFIER_UNIFORM:
        if(!sloCOMPILER_IsES31VersionOrAbove(Compiler))
        {
            slmNewUniform(Compiler,
                              Name->lineNo,
                              Name->stringNo,
                              Symbol,
                              binaryDataType,
                              binaryPrecision,
                              -1,
                              -1,
                              -1,
                              DataType->arrayLengthCount,
                              DataType->arrayLengthList,
                              gcSHADER_VAR_CATEGORY_NORMAL,
                              0,
                              parent,
                              prevSibling,
                              gcIMAGE_FORMAT_DEFAULT,
                              ThisVarIndex,
                              &uniform,
                              status);
        }
        else if(sloCOMPILER_IsES31VersionOrAbove(Compiler))
        {
            gctUINT layoutId;
            gctINT  layoutLocation = -1;
            gctINT  layoutOffset   = -1;
            gctINT  layoutBinding  = 0;
            gctINT  imageFormat = gcIMAGE_FORMAT_DEFAULT;

            layoutId = slmDATA_TYPE_layoutId_GET(Name->dataType);
            if(layoutId & slvLAYOUT_LOCATION) {
                layoutLocation = slmDATA_TYPE_layoutLocation_GET(Name->dataType);
            }
            if(layoutId & slvLAYOUT_OFFSET) {
                layoutOffset = slmDATA_TYPE_layoutOffset_GET(Name->dataType);
            }
            if(layoutId & slvLAYOUT_BINDING) {
                layoutBinding = slmDATA_TYPE_layoutBinding_GET(Name->dataType);
            }
            if(layoutId & slvLAYOUT_IMAGE_FORMAT) {
                imageFormat = slmDATA_TYPE_imageFormat_GET(Name->dataType);
            }

            slmNewUniform(Compiler,
                          Name->lineNo,
                          Name->stringNo,
                          Symbol,
                          binaryDataType,
                          binaryPrecision,
                          layoutLocation,
                          layoutBinding,
                          layoutOffset,
                          DataType->arrayLengthCount,
                          DataType->arrayLengthList,
                          gcSHADER_VAR_CATEGORY_NORMAL,
                          0,
                          parent,
                          prevSibling,
                          imageFormat,
                          ThisVarIndex,
                          &uniform,
                          status);

            /* Update the uniform location. */
            if (slsDATA_TYPE_IsUnderlyingStruct(Name->dataType) &&
                layoutId & slvLAYOUT_LOCATION)
            {
                slmDATA_TYPE_layoutLocation_SET(Name->dataType,
                    layoutLocation + _GetLogicalCountForAnArray(DataType));
            }

            if (shaderType == slvSHADER_TYPE_TCS &&
                gcmIS_SUCCESS(gcoOS_StrCmp(Symbol, "#TcsPatchVerticesIn")))
            {
                slsLAYOUT_QUALIFIER layout;

                gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &layout, slvSTORAGE_QUALIFIER_IN));
                layout.tcsInputVerticesUniform = uniform;
                gcmVERIFY_OK(sloCOMPILER_UpdateDefaultLayout(Compiler, layout, slvSTORAGE_QUALIFIER_IN));
            }

            if (shaderType == slvSHADER_TYPE_TES &&
                gcmIS_SUCCESS(gcoOS_StrCmp(Symbol, "#TesPatchVerticesIn")))
            {
                slsLAYOUT_QUALIFIER layout;

                gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &layout, slvSTORAGE_QUALIFIER_IN));
                layout.tcsInputVerticesUniform = uniform;
                gcmVERIFY_OK(sloCOMPILER_UpdateDefaultLayout(Compiler, layout, slvSTORAGE_QUALIFIER_IN));
            }
        }

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }

        if(Name->isBuiltIn)
        {
            SetUniformFlag(uniform, gcvUNIFORM_FLAG_BUILTIN);
        }
        if(Name->dataType->type == T_ATOMIC_UINT)
        {
            SetUniformFlag(uniform, gcvUNIFORM_FLAG_ATOMIC_COUNTER);
        }

        for (i = 0; i < logicalRegCount; i++)
        {
            slsLOGICAL_REG_InitializeUniform(LogicalRegs + *Start + i,
                                             storageQualifier,
                                             binaryDataType,
                                             binaryPrecision,
                                             uniform,
                                             (gctREG_INDEX)(i * binaryDataTypeSize));
        }

        break;

    case slvSTORAGE_QUALIFIER_ATTRIBUTE:
    case slvSTORAGE_QUALIFIER_VARYING_IN:
    case slvSTORAGE_QUALIFIER_IN_IO_BLOCK_MEMBER:

        if (slsQUALIFIERS_HAS_FLAG(&DataType->qualifiers, slvQUALIFIERS_FLAG_INVARIANT))
        {
            isInvariant = gcvTRUE;
        }
        if (slsQUALIFIERS_HAS_FLAG(&DataType->qualifiers, slvQUALIFIERS_FLAG_PRECISE))
        {
            isPrecise = gcvTRUE;
        }

        if (sloCOMPILER_IsHaltiVersion(Compiler))
        {
           gctUINT layoutId;
           gctINT layoutLocation = -1;
           gctUINT arraySize = logicalRegCount;
           gctUINT arrayCount = DataType->arrayLengthCount;

           if (slsDATA_TYPE_IsPerVertexArray(DataType))
           {
               gcmASSERT(arrayCount > 0);
               arrayCount--;
           }

           layoutId = slmDATA_TYPE_layoutId_GET(Name->dataType);
           if (layoutId & slvLAYOUT_LOCATION)
           {
               layoutLocation = slmDATA_TYPE_layoutLocation_GET(Name->dataType);
           }
           if (CreateVariable)
           {
               status = slNewAttributeWithLocation(Compiler,
                                                   Name->lineNo,
                                                   Name->stringNo,
                                                   Symbol,
                                                   binaryDataType,
                                                   binaryPrecision,
                                                   arraySize,
                                                   arrayCount,
                                                   Name->context.useAsTextureCoord,
                                                   shaderMode,
                                                   layoutLocation,
                                                   FieldIndex ? *FieldIndex : -1,
                                                   isInvariant,
                                                   isPrecise,
                                                   &attribute);

               if (slsQUALIFIERS_GET_AUXILIARY(&DataType->qualifiers) == slvAUXILIARY_QUALIFIER_CENTROID)
               {
                   gcmATTRIBUTE_SetIsCentroid(attribute, gcvTRUE);
               }
               else if (slsQUALIFIERS_GET_AUXILIARY(&DataType->qualifiers) == slvAUXILIARY_QUALIFIER_SAMPLE)
               {
                   gcmATTRIBUTE_SetIsSample(attribute, gcvTRUE);
               }

               if (slsQUALIFIERS_HAS_FLAG(&DataType->qualifiers, slvQUALIFIERS_FLAG_USE_AS_INTERPOLATE_FUNCTION))
               {
                   gcmATTRIBUTE_SetIsUseAsInterpolate(attribute, gcvTRUE);
               }

               if (shaderType == slvSHADER_TYPE_TCS ||
                   shaderType == slvSHADER_TYPE_TES ||
                   shaderType == slvSHADER_TYPE_GS)
               {
                   /* TCS, GS input, arrayed
                    * TES input, it is arrayed unless it is specifed as patch
                    * VS, FS input, not arrayed
                    */
                   if (slsQUALIFIERS_HAS_FLAG(&DataType->qualifiers, slvQUALIFIERS_FLAG_PATCH) ||
                       slsQUALIFIERS_HAS_FLAG(&Name->dataType->qualifiers, slvQUALIFIERS_FLAG_PATCH))
                   {
                       gcmATTRIBUTE_SetIsPerPatch(attribute, gcvTRUE);
                   }
                   else
                   {
                       if (Name->isBuiltIn)
                       {
                           if (slsDATA_TYPE_IsUnderlyingIOBlockMember(Name->dataType) ||
                               slsDATA_TYPE_IsUnderlyingIOBlock(Name->dataType))
                           {
                               gcmATTRIBUTE_SetIsPerVertexArray(attribute, gcvTRUE);
                           }
                       }
                       else if (Name->isPerVertexNotAnArray)
                       {
                           gcmATTRIBUTE_SetIsPerVertexNotArray(attribute, gcvTRUE);
                       }
                       else
                       {
                           gcmATTRIBUTE_SetIsPerVertexArray(attribute, gcvTRUE);
                       }
                   }
               }
           }
           else
           {
               status = gcSHADER_GetAttributeByName(binary,
                                                    (gctSTRING)Symbol,
                                                    (gctUINT32)gcoOS_StrLen(Symbol, gcvNULL),
                                                    &attribute);
           }
        }
        else
        {
            status = slNewAttributeWithLocation(Compiler,
                                                 Name->lineNo,
                                                 Name->stringNo,
                                                 Symbol,
                                                 binaryDataType,
                                                 binaryPrecision,
                                                 logicalRegCount,
                                                 DataType->arrayLengthCount,
                                                 Name->context.useAsTextureCoord,
                                                 shaderMode,
                                                 -1,
                                                 FieldIndex ? *FieldIndex : -1,
                                                 isInvariant,
                                                 isPrecise,
                                                 &attribute);
        }

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }

        if (ThisVarIndex)
        {
            *ThisVarIndex = attribute->index;
        }

        for (i = 0; i < logicalRegCount; i++)
        {
            slsLOGICAL_REG_InitializeAttribute(LogicalRegs + *Start + i,
                                               storageQualifier,
                                               binaryDataType,
                                               binaryPrecision,
                                               attribute,
                                               (gctREG_INDEX)(i * binaryDataTypeSize));
        }
        break;

    case slvSTORAGE_QUALIFIER_VARYING_OUT:
    case slvSTORAGE_QUALIFIER_FRAGMENT_OUT:
    case slvSTORAGE_QUALIFIER_OUT_IO_BLOCK_MEMBER:
        if (slsQUALIFIERS_HAS_FLAG(&DataType->qualifiers, slvQUALIFIERS_FLAG_INVARIANT))
        {
            isInvariant = gcvTRUE;
        }
        if (slsQUALIFIERS_HAS_FLAG(&DataType->qualifiers, slvQUALIFIERS_FLAG_PRECISE))
        {
            isPrecise = gcvTRUE;
        }

        tempRegIndex = slNewTempRegs(Compiler, logicalRegCount * binaryDataTypeSize);

        if (sloCOMPILER_IsHaltiVersion(Compiler)) {
           gctUINT layoutId;
           gctINT layoutLocation = CodeGenerator->layoutLocation;
           gctUINT arraySize = logicalRegCount;
           gctUINT arrayCount = DataType->arrayLengthCount;

           if (slsDATA_TYPE_IsPerVertexArray(DataType))
           {
               gcmASSERT(arrayCount > 0);
               arrayCount--;
           }

           layoutId = slmDATA_TYPE_layoutId_GET(Name->dataType);
           if (layoutId & slvLAYOUT_LOCATION)
           {
               layoutLocation = slmDATA_TYPE_layoutLocation_GET(Name->dataType);
           }
           else
           {
               CodeGenerator->layoutLocation += (CodeGenerator->layoutLocation == -1 ? 0 : logicalRegCount);
           }

           if (CreateVariable)
           {
               status = slNewOutputWithLocation(Compiler,
                                                Name->lineNo,
                                                Name->stringNo,
                                                Symbol,
                                                binaryDataType,
                                                binaryPrecision,
                                                arrayCount != 0,
                                                arraySize,
                                                tempRegIndex,
                                                layoutLocation,
                                                FieldIndex ? *FieldIndex : -1,
                                                isInvariant,
                                                isPrecise,
                                                shaderMode,
                                                _ConvOutputBlendSupport(slmDATA_TYPE_layoutId_GET(Name->dataType)),
                                                &output);

               gcSHADER_GetOutputIndexByOutput(binary, output, &varIndex);
               {
                   gcOUTPUT output = gcvNULL;
                   gctUINT i;

                   for (i = 0; i < arraySize; i++)
                   {
                       gcSHADER_GetOutput(binary, (gctUINT)(varIndex + i ), &output);

                       if ((shaderType == slvSHADER_TYPE_TCS || shaderType == slvSHADER_TYPE_TES) &&
                           (slsQUALIFIERS_HAS_FLAG(&DataType->qualifiers, slvQUALIFIERS_FLAG_PATCH) ||
                            slsQUALIFIERS_HAS_FLAG(&Name->dataType->qualifiers, slvQUALIFIERS_FLAG_PATCH)))
                       {
                           gcmOUTPUT_SetIsPerPatch(output, gcvTRUE);
                       }
                       else if (shaderType == slvSHADER_TYPE_TCS)
                       {
                           if (Name->isBuiltIn)
                           {
                               if (slsDATA_TYPE_IsUnderlyingIOBlockMember(Name->dataType) ||
                                   slsDATA_TYPE_IsUnderlyingIOBlock(Name->dataType))
                               {
                                   gcmOUTPUT_SetIsPerVertexArray(output, gcvTRUE);
                               }
                           }
                           else if (Name->isPerVertexNotAnArray)
                           {
                               gcmOUTPUT_SetIsPerVertexNotArray(output, gcvTRUE);
                           }
                           else
                           {
                               gcmOUTPUT_SetIsPerVertexArray(output, gcvTRUE);
                           }
                       }

                       if (slsQUALIFIERS_GET_AUXILIARY(&DataType->qualifiers) == slvAUXILIARY_QUALIFIER_CENTROID)
                       {
                           gcmOUTPUT_SetIsCentroid(output, gcvTRUE);
                       }
                       else if (slsQUALIFIERS_GET_AUXILIARY(&DataType->qualifiers) == slvAUXILIARY_QUALIFIER_SAMPLE)
                       {
                           gcmOUTPUT_SetIsSample(output, gcvTRUE);
                       }
                   }
               }
           }
           else
           {
               status = gcSHADER_GetOutputByName(binary,
                                                 (gctSTRING)Symbol,
                                                 (gctUINT32)gcoOS_StrLen(Symbol, gcvNULL),
                                                 &output);
               gcSHADER_GetOutputIndexByOutput(binary, output, &varIndex);
           }

            for (i = 0; i < logicalRegCount; i++)
            {
                slsLOGICAL_REG_InitializeOutput(LogicalRegs + *Start + i,
                                                storageQualifier,
                                                binaryDataType,
                                                binaryPrecision,
                                                output,
                                                tempRegIndex + (gctREG_INDEX)(i * binaryDataTypeSize));
            }

            if (ThisVarIndex)
            {
                *ThisVarIndex = varIndex;
            }
        }
        else {
            if (Name->isBuiltIn &&  gcmIS_SUCCESS(gcoOS_StrCmp(Symbol, "#Color")))
            {
                if (_IsOutputColorAddBefore(Compiler))
                {
                    gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                   Name->lineNo,
                                                   Name->stringNo,
                                                   slvREPORT_ERROR,
                                                   "Can not assgin values to both gl_FragColor and gl_FragData"));

                    gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);

                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
            }
            status = slNewOutput(Compiler,
                                 Name->lineNo,
                                 Name->stringNo,
                                 Symbol,
                                 binaryDataType,
                                 binaryPrecision,
                                 Name->dataType->arrayLength != 0,
                                 logicalRegCount,
                                 tempRegIndex,
                                 FieldIndex ? *FieldIndex : -1,
                                 isInvariant,
                                 isPrecise,
                                 shaderMode,
                                 _ConvOutputBlendSupport(slmDATA_TYPE_layoutId_GET(Name->dataType)),
                                 &output);

            for (i = 0; i < logicalRegCount; i++)
            {
                slsLOGICAL_REG_InitializeOutput(LogicalRegs + *Start + i,
                                                storageQualifier,
                                                binaryDataType,
                                                binaryPrecision,
                                                output,
                                                tempRegIndex + (gctREG_INDEX)(i * binaryDataTypeSize));
            }
        }

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }

        if (storageQualifier == slvSTORAGE_QUALIFIER_VARYING_OUT)
        {
            slmNewVariable(Compiler,
                           Name->lineNo,
                           Name->stringNo,
                           Symbol,
                           binaryDataType,
                           binaryPrecision,
                           DataType->arrayLengthCount,
                           DataType->arrayLengthList,
                           (Name->type == slvVARIABLE_NAME) ? Name->u.variableInfo.isLocal : gcvTRUE,
                           gcvTRUE, /* is output */
                           isPrecise, /* is precise */
                           DataType->isPerVertexArray,
                           tempRegIndex,
                           gcSHADER_VAR_CATEGORY_NORMAL,
                           0,
                           parent,
                           prevSibling,
                           ThisVarIndex,
                           status);

            if (gcmIS_ERROR(status))
            {
                gcmFOOTER();
                return status;
            }
        }

        break;
    case slvSTORAGE_QUALIFIER_BUFFER:
        gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                Name->lineNo,
                                Name->stringNo,
                                slvREPORT_ERROR,
                                "invalid buffer variable '%s'", Symbol));

        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    (*Start) += logicalRegCount;

    if (FirstRegIndex)
        *FirstRegIndex = tempRegIndex;

    gcmFOOTER_ARG("*LogicalRegs=0x%x *Start=%u", *LogicalRegs, *Start);
    return gcvSTATUS_OK;
}

gceSTATUS
slAllocSamplerLevelBaseSize(
    IN sloCOMPILER Compiler,
    IN slsNAME * Sampler,
    IN gcSHADER_TYPE BinaryDataType
    )
{
    gceSTATUS          status;
    gcUNIFORM          levelBaseSizeUniform;
    gcUNIFORM          samplerUniform;
    gctINT16           thisVarIndex[1];
    gctSIZE_T          len;
    gctSTRING          symbol;
    gctUINT            offset;
    gctPOINTER         pointer;
    gctUINT16          lastChildIndex;
    gcSHADER           binary;

    gcmHEADER_ARG("Compiler=0x%x Sampler=0x%x",
                  Compiler, Sampler);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmVERIFY_ARGUMENT(Sampler);

    len = gcoOS_StrLen(Sampler->symbol, gcvNULL) + 16;

    status = sloCOMPILER_Allocate(Compiler,
                                  len,
                                  &pointer);
    if (gcmIS_ERROR(status)) {
        gcmFOOTER();
        return status;
    }

    symbol = pointer;

    gcmASSERT(Sampler->context.logicalRegCount != 0);

    gcmASSERT(Sampler->context.logicalRegs->qualifier == slvSTORAGE_QUALIFIER_UNIFORM);

    samplerUniform = Sampler->context.logicalRegs->u.uniform;

    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));
    lastChildIndex = samplerUniform->firstChild;
    while ((gctINT16)lastChildIndex != -1)
    {
        gcUNIFORM temp= gcvNULL;
        gcmVERIFY_OK(gcSHADER_GetUniform(binary, (gctUINT)lastChildIndex, &temp));
        lastChildIndex = temp->index;
        if (temp->nextSibling != -1)
        {
            lastChildIndex = temp->nextSibling;
        }
        else
        {
            break;
        }
    }

    offset = 0;
    gcmVERIFY_OK(gcoOS_PrintStrSafe(symbol,
                                    len,
                                    &offset,
                                    "#%s$LevelBaseSize",
                                    Sampler->symbol));

    slmNewUniform(Compiler,
                  Sampler->lineNo,
                  Sampler->stringNo,
                  symbol,
                  BinaryDataType,
                  gcSHADER_PRECISION_MEDIUM,
                  -1,
                  -1,
                  -1,
                  0,
                  gcvNULL,
                  gcSHADER_VAR_CATEGORY_LEVEL_BASE_SIZE,
                  0,
                  samplerUniform->index,
                  lastChildIndex,
                  gcIMAGE_FORMAT_DEFAULT,
                  thisVarIndex,
                  &levelBaseSizeUniform,
                  status);

    if (gcmIS_ERROR(status))
    {
        sloCOMPILER_Free(Compiler, symbol);
        gcmFOOTER();
        return status;
    }
    Sampler->u.variableInfo.levelBaseSize = levelBaseSizeUniform;

    sloCOMPILER_Free(Compiler, symbol);
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slAllocImageSizeUniform(
    IN sloCOMPILER Compiler,
    IN slsNAME * Image,
    IN gcSHADER_TYPE BinaryDataType
    )
{
    gceSTATUS          status;
    gcUNIFORM          imageSizeUniform;
    gcUNIFORM          imageUniform;
    gctINT16           thisVarIndex[1];
    gctSIZE_T          len;
    gctSTRING          symbol;
    gctUINT            offset;
    gctPOINTER         pointer;

    gcmHEADER_ARG("Compiler=0x%x Image=0x%x",
                  Compiler, Image);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmVERIFY_ARGUMENT(Image);

    len = gcoOS_StrLen(Image->symbol, gcvNULL) + 16;

    status = sloCOMPILER_Allocate(Compiler,
                                  len,
                                  &pointer);
    if (gcmIS_ERROR(status)) {
        gcmFOOTER();
        return status;
    }

    symbol = pointer;

    gcmASSERT(Image->context.logicalRegCount != 0);

    gcmASSERT(Image->context.logicalRegs->qualifier == slvSTORAGE_QUALIFIER_UNIFORM);

    imageUniform = Image->context.logicalRegs->u.uniform;
    offset = 0;
    gcmVERIFY_OK(gcoOS_PrintStrSafe(symbol,
                                    len,
                                    &offset,
                                    "#sh_imageSize$%s",
                                    Image->symbol));

    slmNewUniform(Compiler,
                  Image->lineNo,
                  Image->stringNo,
                  symbol,
                  BinaryDataType,
                  gcSHADER_PRECISION_MEDIUM,
                  -1,
                  -1,
                  -1,
                  0,
                  gcvFALSE,
                  gcSHADER_VAR_CATEGORY_NORMAL,
                  0,
                  -1,
                  -1,
                  gcIMAGE_FORMAT_DEFAULT,
                  thisVarIndex,
                  &imageSizeUniform,
                  status);

    if (gcmIS_ERROR(status))
    {
        gcmFOOTER();
        return status;
    }
    Image->u.variableInfo.levelBaseSize = imageSizeUniform;
    SetUniformFlag(imageSizeUniform, gcvUNIFORM_FLAG_COMPILER_GEN);

    imageSizeUniform->parent = (gctINT16)imageUniform->index;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slAllocSamplerLodMinMax(
    IN sloCOMPILER Compiler,
    IN slsNAME * Sampler
    )
{
    gceSTATUS          status;
    gcUNIFORM          lodMinMaxUniform;
    gcUNIFORM          samplerUniform;
    gctINT16           thisVarIndex[1];
    gctSIZE_T          len;
    gctSTRING          symbol;
    gctUINT            offset;
    gctPOINTER         pointer;
    gctUINT16          lastChildIndex;
    gcSHADER           binary;

    gcmHEADER_ARG("Compiler=0x%x Sampler=0x%x",
                  Compiler, Sampler);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmVERIFY_ARGUMENT(Sampler);

    len = gcoOS_StrLen(Sampler->symbol, gcvNULL) + 12;

    status = sloCOMPILER_Allocate(Compiler,
                                  len,
                                  &pointer);
    if (gcmIS_ERROR(status)) {
        gcmFOOTER();
        return status;
    }

    symbol = pointer;

    gcmASSERT(Sampler->context.logicalRegCount != 0);

    gcmASSERT(Sampler->context.logicalRegs->qualifier == slvSTORAGE_QUALIFIER_UNIFORM);

    samplerUniform = Sampler->context.logicalRegs->u.uniform;

    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));
    lastChildIndex = samplerUniform->firstChild;
    while ((gctINT16)lastChildIndex != -1)
    {
        gcUNIFORM temp= gcvNULL;
        gcmVERIFY_OK(gcSHADER_GetUniform(binary, (gctUINT)lastChildIndex, &temp));
        lastChildIndex = temp->index;
        if (temp->nextSibling != -1)
        {
            lastChildIndex = temp->nextSibling;
        }
        else
        {
            break;
        }
    }

    offset = 0;
    gcmVERIFY_OK(gcoOS_PrintStrSafe(symbol,
                                    len,
                                    &offset,
                                    "#%s$LodMinMax",
                                    Sampler->symbol));

    /* the uniform will contain the LOD_MIN, LOD_MAX and IS_MIPMAPPED */
    slmNewUniform(Compiler,
                  Sampler->lineNo,
                  Sampler->stringNo,
                  symbol,
                  gcSHADER_FLOAT_X3,
                  gcSHADER_PRECISION_MEDIUM,
                  -1,
                  -1,
                  -1,
                  0,
                  gcvNULL,
                  gcSHADER_VAR_CATEGORY_LOD_MIN_MAX,
                  0,
                  samplerUniform->index,
                  lastChildIndex,
                  gcIMAGE_FORMAT_DEFAULT,
                  thisVarIndex,
                  &lodMinMaxUniform,
                  status);

    if (gcmIS_ERROR(status))
    {
        sloCOMPILER_Free(Compiler, symbol);
        gcmFOOTER();
        return status;
    }
    Sampler->u.variableInfo.lodMinMax = lodMinMaxUniform;

    sloCOMPILER_Free(Compiler, symbol);
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS _AllocStructElementAggregatedSymbol(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsDATA_TYPE * structDataType,
    IN gctUINT arrayIdx,
    IN gctCONST_STRING structSymbol,
    IN gctCONST_STRING fieldSymbol, /* this can be NULL */
    OUT gctSTRING *Symbol
    )
{
    gceSTATUS       status;
    gctSIZE_T       symbolLength = 0, fieldLength = 0, len;
    gctSTRING       symbol = gcvNULL;
    gctUINT         offset;
    gctPOINTER      pointer = gcvNULL;
    gctBOOL         skipArrayIndex = (gctINT)arrayIdx == -1 ? gcvTRUE : gcvFALSE;

    gcmHEADER_ARG("Compiler=0x%x codeGenerator=0x%x structDataType=0x%x arrayIdx=%d"
                  "structSymbol=%s fieldSymbol=%s Symbol=0x%x",
                  Compiler, CodeGenerator, structDataType, arrayIdx, structSymbol, fieldSymbol, Symbol);

    symbolLength = gcoOS_StrLen(structSymbol, gcvNULL);

    if (fieldSymbol)
    {
        fieldLength = gcoOS_StrLen(fieldSymbol, gcvNULL);
    }

    len = symbolLength + fieldLength + 20;

    status = sloCOMPILER_Allocate(Compiler,
                                  len,
                                  &pointer);

    if (gcmIS_ERROR(status))
    {
        if (Symbol) *Symbol = gcvNULL;

        gcmFOOTER();
        return status;
    }

    symbol = pointer;

    if (structDataType->arrayLength == 0 || skipArrayIndex)
    {
        offset = 0;
        if (fieldSymbol)
            gcmVERIFY_OK(gcoOS_PrintStrSafe(symbol, len,
                                            &offset,
                                            "%s.%s",
                                            structSymbol,
                                            fieldSymbol));
        else
            gcmVERIFY_OK(gcoOS_PrintStrSafe(symbol, len,
                                            &offset,
                                            "%s",
                                            structSymbol));

    }
    else
    {
        offset = 0;
        if (fieldSymbol)
            gcmVERIFY_OK(gcoOS_PrintStrSafe(symbol, len,
                                            &offset,
                                            "%s[%d].%s",
                                            structSymbol,
                                            arrayIdx,
                                            fieldSymbol));
        else
            gcmVERIFY_OK(gcoOS_PrintStrSafe(symbol, len,
                                            &offset,
                                            "%s[%d]",
                                            structSymbol,
                                            arrayIdx));
    }

    if (Symbol)
        *Symbol = symbol;

    gcmFOOTER_ARG("*Symbol=%s", *Symbol);
    return gcvSTATUS_OK;
}

static gceSTATUS _FreeStructElementAggregatedSymbol(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN gctSTRING symbol
    )
{
    gceSTATUS       status = gcvSTATUS_OK;
    gcmHEADER_ARG("Compiler=0x%x codeGenerator=0x%x symbol=%s",
                  Compiler, CodeGenerator, symbol);

    gcmVERIFY_OK(sloCOMPILER_Free(Compiler, symbol));

    gcmFOOTER();
    return status;
}

#if SUPPORT_STRUCT_ELEMENT_IN_VARIABLE
static gceSTATUS
_NewStructIntermediateElementSymbol(
    IN sloCOMPILER Compiler,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN gcSHADER_TYPE DataType,
    IN gctINT    ArrayLengthCount,
    IN gctINT *  ArrayLengthList,
    IN gctREG_INDEX TempRegIndex,
    IN gcSHADER_VAR_CATEGORY varCategory,
    IN gctUINT16 numStructureElement,
    IN gctINT16 parent,
    IN gctINT16 prevSibling,
    OUT gctINT16* ThisVarIndex
    )
{
    gceSTATUS status = gcvSTATUS_OK;

    gcmHEADER();

    if (Name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_UNIFORM)
    {
        gcUNIFORM uniform;

        slmNewUniform(Compiler,
                              Name->lineNo,
                              Name->stringNo,
                              Symbol,
                              DataType,
                              _ConvElementDataPrecision(Name->dataType),
                              -1,
                              -1,
                              -1,
                              ArrayLengthCount,
                              ArrayLengthList,
                              varCategory,
                              numStructureElement,
                              parent,
                              prevSibling,
                              gcIMAGE_FORMAT_DEFAULT,
                              ThisVarIndex,
                              &uniform,
                              status);
    }
    else
    {
        gcSHADER shader = gcvNULL;
        gcVARIABLE var = gcvNULL;

        gcmONERROR(sloCOMPILER_GetBinary(Compiler, &shader));

        slmNewVariable(Compiler,
                       Name->lineNo,
                       Name->stringNo,
                       Symbol,
                       DataType,
                       _ConvElementDataPrecision(Name->dataType),
                       ArrayLengthCount,
                       ArrayLengthList,
                       (Name->type == slvVARIABLE_NAME) ? Name->u.variableInfo.isLocal : gcvTRUE,
                       gcvFALSE, /* not output */
                       gcvFALSE, /* not precise */
                       gcvFALSE,
                       TempRegIndex,
                       varCategory,
                       numStructureElement,
                       parent,
                       prevSibling,
                       ThisVarIndex,
                       status);

        gcmONERROR(gcSHADER_GetVariable(shader, *ThisVarIndex, &var));
        gcmASSERT(var != gcvNULL);

        if (Name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_VARYING_OUT)
        {
            SetVariableIsOutput(var);
        }
    }

OnError:
    gcmFOOTER_NO();
    return status;
}

static gceSTATUS
_UpdateVariableTempReg(
    IN sloCOMPILER Compiler,
    IN slsNAME * Name,
    IN gctUINT varIndex,
    IN gctREG_INDEX newTempRegIndex
    )
{
    gceSTATUS status = gcvSTATUS_OK;

    gcmHEADER();

    if (Name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_UNIFORM)
    {
    }
    else
    {
        status = slUpdateVariableTempReg(Compiler,
                                         Name->lineNo,
                                         Name->stringNo,
                                         varIndex,
                                         newTempRegIndex);
    }

    gcmFOOTER_NO();
    return status;
}
#endif

static gceSTATUS
_AllocMemoryOffsets(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN slsNAME *BlockName,
    IN gctBOOL IsBlockMemberActive,
    IN gctPOINTER StructParent,
    IN OUT gctBOOL *NeedAllocateRegs,
    IN OUT gctINT16 *PrevSibling,
    IN OUT slsLOGICAL_REG **LogicalRegs,
    IN OUT gctINT32 *Offset
    );

static gceSTATUS
_AllocLogicalRegs(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN gctINT16 parent,
    IN gctINT16 prevSibling,
    OUT gctINT16* ThisVarIndex,
    OUT gctREG_INDEX* FirstRegIndex,
    IN OUT slsLOGICAL_REG * LogicalRegs,
    IN OUT gctUINT * Start
    );

static gceSTATUS
_AllocLogicalRegsForStruct(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN gctINT16 parent,
    IN gctINT16 prevSibling,
    IN gctBOOL IsTopeLevel,
    OUT gctINT16* ThisVarIndex,
    OUT gctREG_INDEX* FirstRegIndex,
    IN OUT slsLOGICAL_REG * LogicalRegs,
    IN OUT gctUINT * Start,
    IN OUT gctINT * FieldIndex
    );

static gceSTATUS
_AllocLogicalRegsForStruct1(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN gctINT16 parent,
    IN gctINT16 prevSibling,
    IN gctBOOL IsTopLevel,
    OUT gctINT16* ThisVarIndex,
    OUT gctREG_INDEX* FirstRegIndex,
    IN OUT slsLOGICAL_REG * LogicalRegs,
    IN OUT gctUINT * Start,
    IN OUT gctINT * FieldIndex
    )
{
    gceSTATUS       status  = gcvSTATUS_OK;
    gctUINT         count, i;
    slsNAME *       fieldName;
    gctSTRING       symbol = gcvNULL;
    gctINT16        mainIdx = -1, structEleParent;
#if SUPPORT_STRUCT_ELEMENT_IN_VARIABLE
    gctINT16        arrayElePrevSibling;
#endif
    gctINT16        structElePrevSibling;
    gctINT          regOfFirstArrayEle, regOfFirststructEle;
    gctREG_INDEX    regOfFirstMain, firstReg;
    gctUINT16       structEleCount;
    gctBOOL         isPerVertexStruct = gcvFALSE;

    gcmHEADER_ARG("Compiler=0x%x codeGenerator=0x%x Name=0x%x Symbol=%s "
                  "DataType=0x%x",
                  Compiler, CodeGenerator, Name, Symbol, DataType);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmVERIFY_ARGUMENT(Name);
    gcmASSERT(DataType);
    gcmASSERT(LogicalRegs);
    gcmASSERT(Start);

    gcmASSERT(Name->dataType->fieldSpace);

    count = _GetLogicalCountForAnArray(DataType);
    slsDLINK_NODE_COUNT(&DataType->fieldSpace->names, structEleCount);

#if SUPPORT_STRUCT_ELEMENT_IN_VARIABLE
    /* Allocate the parent variable for all struct members, including arrays and elements. */
    status = _NewStructIntermediateElementSymbol(Compiler,
                                                 Name,
                                                 Symbol,
                                                 gcSHADER_FLOAT_X1, /* It is dummy for struct */
                                                 DataType->arrayLengthCount,
                                                 DataType->arrayLengthList,
                                                 (gctREG_INDEX)-1, /* Will resolve it when trasersing back */
                                                 gcSHADER_VAR_CATEGORY_STRUCT,
                                                 (count > 1) ? 0 : structEleCount,
                                                 parent,
                                                 prevSibling,
                                                 &mainIdx);

    if (gcmIS_ERROR(status))
    {
        gcmFOOTER();
        return status;
    }

    arrayElePrevSibling = -1;
#endif

    isPerVertexStruct = slsNAME_IsPerVertexArray(Name);

    regOfFirstArrayEle = -1;
    for (i = 0; i < count; i++)
    {
        structEleParent = mainIdx;

#if SUPPORT_STRUCT_ELEMENT_IN_VARIABLE
        if (count > 1 && !isPerVertexStruct)
        {
            gcmVERIFY_OK(_AllocStructElementAggregatedSymbol(Compiler,
                                                       CodeGenerator,
                                                       DataType,
                                                       i,
                                                       Symbol,
                                                       gcvNULL,
                                                       &symbol));

            status = _NewStructIntermediateElementSymbol(Compiler,
                                                         Name,
                                                         symbol,
                                                         gcSHADER_FLOAT_X1, /* It is dummy for struct */
                                                         0,
                                                         gcvNULL,
                                                         (gctREG_INDEX)-1, /* Will resolve it when trasersing back */
                                                         gcSHADER_VAR_CATEGORY_STRUCT,
                                                         structEleCount,
                                                         mainIdx,
                                                         arrayElePrevSibling,
                                                         &arrayElePrevSibling);

            if (gcmIS_ERROR(status))
            {
                gcmFOOTER();
                return status;
            }

            structEleParent = arrayElePrevSibling;

            gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, symbol));
        }
#endif

        structElePrevSibling = -1;
        regOfFirststructEle = -1;
        FOR_EACH_DLINK_NODE(&DataType->fieldSpace->names, slsNAME, fieldName)
        {
            gcmASSERT(fieldName->dataType);
            gcmVERIFY_OK(_AllocStructElementAggregatedSymbol(Compiler,
                                                       CodeGenerator,
                                                       DataType,
                                                       isPerVertexStruct ? (gctUINT)-1 : i,
                                                       Symbol,
                                                       fieldName->symbol,
                                                       &symbol));

            /* Past the struct auxiliary qualifiers to its elements. */
            slsQUALIFIERS_SET_AUXILIARY(&fieldName->dataType->qualifiers, slsQUALIFIERS_GET_AUXILIARY(&DataType->qualifiers));

            if (fieldName->dataType->elementType == slvTYPE_STRUCT)
            {
                status = _AllocLogicalRegsForStruct(Compiler,
                                           CodeGenerator,
                                           Name,
                                           symbol,
                                           fieldName->dataType,
                                           structEleParent,
                                           structElePrevSibling,
                                           gcvFALSE,
                                           &structElePrevSibling,
                                           &firstReg,
                                           LogicalRegs,
                                           Start,
                                           FieldIndex);
            }
            else
            {
                status = _AllocLogicalRegOrArray(Compiler,
                                           CodeGenerator,
                                           Name,
                                           symbol,
                                           fieldName->dataType,
                                           structEleParent,
                                           structElePrevSibling,
                                           !isPerVertexStruct ? gcvTRUE :
                                            (i == 0) ? gcvTRUE : gcvFALSE,
                                           &structElePrevSibling,
                                           &firstReg,
                                           LogicalRegs,
                                           Start,
                                           FieldIndex);
            }

            (*FieldIndex)++;

            if (gcmIS_ERROR(status))
            {
                gcmFOOTER();
                return status;
            }

            gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, symbol));

            if (regOfFirststructEle == -1)
                regOfFirststructEle = firstReg;
        }

#if SUPPORT_STRUCT_ELEMENT_IN_VARIABLE
        gcmASSERT(regOfFirststructEle != -1);

        status = _UpdateVariableTempReg(Compiler,
                                        Name,
                                        structEleParent,
                                        (gctREG_INDEX)regOfFirststructEle);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }
#endif

        if (regOfFirstArrayEle == -1)
            regOfFirstArrayEle = regOfFirststructEle;
    }

    regOfFirstMain = (gctUINT16)regOfFirstArrayEle;

#if SUPPORT_STRUCT_ELEMENT_IN_VARIABLE
    if (count > 1)
    {
        gcmASSERT(regOfFirstArrayEle != -1);

        status = _UpdateVariableTempReg(Compiler,
                                        Name,
                                        mainIdx,
                                        (gctREG_INDEX)regOfFirstArrayEle);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }
    }
#endif

    if (ThisVarIndex)
        *ThisVarIndex = mainIdx;

    if (FirstRegIndex)
        *FirstRegIndex = regOfFirstMain;

    gcmFOOTER_ARG("*LogicalRegs=0x%x *Start=%u", *LogicalRegs, *Start);
    return gcvSTATUS_OK;
}

static gceSTATUS
_AllocLogicalRegsForStruct(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN gctINT16 Parent,
    IN gctINT16 PrevSibling,
    IN gctBOOL IsTopeLevel,
    OUT gctINT16* ThisVarIndex,
    OUT gctREG_INDEX* FirstRegIndex,
    IN OUT slsLOGICAL_REG * LogicalRegs,
    IN OUT gctUINT * Start,
    IN OUT gctINT * FieldIndex
    )
{
    gceSTATUS       status  = gcvSTATUS_OK;
    gctINT firstRegIndexOfStruct = -1;
    gctREG_INDEX firstRegIndex;
    gctINT16 mainIndex = -1;

    gcmHEADER();

    /* If this struct is not an arrays of arrays, */
    if (DataType->arrayLengthCount < 2)
    {
        status = _AllocLogicalRegsForStruct1(Compiler,
                                         CodeGenerator,
                                         Name,
                                         Symbol,
                                         DataType,
                                         Parent,
                                         PrevSibling,
                                         IsTopeLevel,
                                         &mainIndex,
                                         &firstRegIndex,
                                         LogicalRegs,
                                         Start,
                                         FieldIndex);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }

        firstRegIndexOfStruct = (gctINT)firstRegIndex;
    }
    else
    {
        slsDATA_TYPE * elementDataType = gcvNULL;
        gctINT i;
        gctSTRING symbol = gcvNULL;
        gctINT16 parent = 0;
        gctINT16 prevSibling = PrevSibling;
        gctINT16 subStructMain = -1;

#if SUPPORT_STRUCT_ELEMENT_IN_VARIABLE
        status = _NewStructIntermediateElementSymbol(Compiler,
                                                     Name,
                                                     Symbol,
                                                     gcSHADER_FLOAT_X1, /* It is dummy for struct */
                                                     DataType->arrayLengthCount,
                                                     DataType->arrayLengthList,
                                                     (gctREG_INDEX)-1, /* Will resolve it when trasersing back */
                                                     gcSHADER_VAR_CATEGORY_STRUCT,
                                                     0,
                                                     Parent,
                                                     PrevSibling,
                                                     &parent);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }
#endif

        mainIndex = parent;

        for (i = 0; i < DataType->arrayLength; i++)
        {
            gcmVERIFY_OK(_AllocStructElementAggregatedSymbol(Compiler,
                                                       CodeGenerator,
                                                       DataType,
                                                       i,
                                                       Symbol,
                                                       gcvNULL,
                                                       &symbol));

            status = slsDATA_TYPE_ConstructElement(Compiler, DataType, &elementDataType);

            if (gcmIS_ERROR(status))
            {
                gcmFOOTER();
                return status;
            }

            /* Past the struct auxiliary qualifiers to its elements. */
            slsQUALIFIERS_SET_AUXILIARY(&elementDataType->qualifiers, slsQUALIFIERS_GET_AUXILIARY(&DataType->qualifiers));

            status = _AllocLogicalRegsForStruct(Compiler,
                                             CodeGenerator,
                                             Name,
                                             symbol,
                                             elementDataType,
                                             parent,
                                             prevSibling,
                                             gcvFALSE,
                                             &subStructMain,
                                             &firstRegIndex,
                                             LogicalRegs,
                                             Start,
                                             FieldIndex);

            if (gcmIS_ERROR(status))
            {
                gcmFOOTER();
                return status;
            }

            gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, symbol));

            if (firstRegIndexOfStruct == -1)
            {
                firstRegIndexOfStruct = (gctINT)firstRegIndex;
            }

            prevSibling = subStructMain;
        }

        status = _UpdateVariableTempReg(Compiler,
                                        Name,
                                        mainIndex,
                                        (gctREG_INDEX)firstRegIndexOfStruct);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }
    }

    if (ThisVarIndex)
    {
        *ThisVarIndex = mainIndex;
    }

    if (FirstRegIndex)
    {
        *FirstRegIndex = firstRegIndexOfStruct;
    }

    return status;
}

static gceSTATUS
_AllocLogicalRegs(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN gctINT16 Parent,
    IN gctINT16 PrevSibling,
    OUT gctINT16* ThisVarIndex,
    OUT gctREG_INDEX* FirstRegIndex,
    IN OUT slsLOGICAL_REG * LogicalRegs,
    IN OUT gctUINT * Start
    )
{
    gceSTATUS       status;
    gctINT16        mainIdx = -1;
    gctREG_INDEX    regOfFirstMain;

    gcmHEADER_ARG("Compiler=0x%x codeGenerator=0x%x Name=0x%x Symbol=%s "
                  "DataType=0x%x",
                  Compiler, CodeGenerator, Name, Symbol, DataType);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmVERIFY_ARGUMENT(Name);
    gcmASSERT(DataType);
    gcmASSERT(LogicalRegs);
    gcmASSERT(Start);

    if (DataType->elementType == slvTYPE_STRUCT)
    {
        gctINT fieldIndex = 0;
        status = _AllocLogicalRegsForStruct(Compiler,
                                            CodeGenerator,
                                            Name,
                                            Symbol,
                                            DataType,
                                            Parent,
                                            PrevSibling,
                                            gcvTRUE,
                                            &mainIdx,
                                            &regOfFirstMain,
                                            LogicalRegs,
                                            Start,
                                            &fieldIndex);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }
    }
    else
    {
        status = _AllocLogicalRegOrArray(Compiler,
                                         CodeGenerator,
                                         Name,
                                         Symbol,
                                         DataType,
                                         Parent,
                                         PrevSibling,
                                         gcvTRUE,
                                         &mainIdx,
                                         &regOfFirstMain,
                                         LogicalRegs,
                                         Start,
                                         gcvNULL);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }
    }

    if (ThisVarIndex)
        *ThisVarIndex = mainIdx;

    if (FirstRegIndex)
        *FirstRegIndex = regOfFirstMain;

    gcmFOOTER_ARG("*LogicalRegs=0x%x *Start=%u", *LogicalRegs, *Start);
    return gcvSTATUS_OK;
}

gceSTATUS
slsNAME_CloneContext(
    IN sloCOMPILER Compiler,
    IN slsNAME * ActualParamName,
    IN slsNAME * FormalParamName
    )
{
    gceSTATUS   status;
    gctUINT     i;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Compiler=0x%x ActualParamName=0x%x FormalParamName=0x%x",
                  Compiler, ActualParamName, FormalParamName);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmVERIFY_ARGUMENT(ActualParamName);
    gcmVERIFY_ARGUMENT(FormalParamName);

    ActualParamName->context    = FormalParamName->context;

    status = sloCOMPILER_Allocate(
                                Compiler,
                                (gctSIZE_T)sizeof(slsLOGICAL_REG)
                                    * FormalParamName->context.logicalRegCount,
                                &pointer);

    if (gcmIS_ERROR(status))
    {
        gcmFOOTER();
        return status;
    }

    gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG)
                                    * FormalParamName->context.logicalRegCount);

    ActualParamName->context.logicalRegs = pointer;

    for (i = 0; i < FormalParamName->context.logicalRegCount; i++)
    {
        ActualParamName->context.logicalRegs[i] = FormalParamName->context.logicalRegs[i];
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_NewBlockIntermediateElementSymbol(
    IN sloCOMPILER Compiler,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN gcSHADER_TYPE DataType,
    IN gctINT ArrayLengthCount,
    IN gctINT * ArrayLengthList,
    IN gcsINTERFACE_BLOCK_INFO  *InterfaceBlock,
    IN gcSHADER_VAR_CATEGORY VarCategory,
    IN gctUINT16 NumStructureElement,
    IN gctINT16 Parent,
    IN gctINT16 PrevSibling,
    OUT gctINT16* ThisVarIndex
    )
{
    gceSTATUS status = gcvSTATUS_OK;

    gcmHEADER();
    if(isIBIUniformBlock(InterfaceBlock))
    {
        gcUNIFORM uniform;
        slmNewUniform(Compiler,
                      Name->lineNo,
                      Name->stringNo,
                      Symbol,
                      DataType,
                      _ConvElementDataPrecision(Name->dataType),
                      -1,
                      -1,
                      -1,
                      ArrayLengthCount,
                      ArrayLengthList,
                      VarCategory,
                      NumStructureElement,
                      Parent,
                      PrevSibling,
                      gcIMAGE_FORMAT_DEFAULT,
                      ThisVarIndex,
                      &uniform,
                      status);
        if (gcmIS_ERROR(status))
        {
           gcmFOOTER();
           return status;
        }
        uniform->blockIndex = GetIBIBlockIndex(InterfaceBlock);
    }
    else
    {
        gcVARIABLE variable;

        gcmASSERT(isIBIStorageBlock(InterfaceBlock));
        slmNewVariable(Compiler,
                       Name->lineNo,
                       Name->stringNo,
                       Symbol,
                       DataType,
                       _ConvElementDataPrecision(Name->dataType),
                       ArrayLengthCount,
                       ArrayLengthList,
                       gcvFALSE,
                       gcvFALSE, /* not output */
                       gcvFALSE, /* not precise */
                       gcvFALSE,
                       0,
                       VarCategory,
                       NumStructureElement,
                       Parent,
                       PrevSibling,
                       ThisVarIndex,
                       status);

        if (gcmIS_ERROR(status))
        {
           gcmFOOTER();
           return status;
        }

        status = _GetShaderVariableByIndex(Compiler, *ThisVarIndex, &variable);
        variable->blockIndex = GetIBIBlockIndex(InterfaceBlock);
    }

    gcmFOOTER_NO();
    return status;
}

#define slmInterfaceBlockMemoryLayout(Layout) \
    ((Layout.id & slvLAYOUT_SHARED) ? gcvINTERFACE_BLOCK_SHARED : \
     (Layout.id & slvLAYOUT_STD140) ? gcvINTERFACE_BLOCK_STD140 : \
     (Layout.id & slvLAYOUT_STD430) ? gcvINTERFACE_BLOCK_STD430 : \
     (Layout.id & slvLAYOUT_PACKED) ? gcvINTERFACE_BLOCK_PACKED : gcvINTERFACE_BLOCK_SHARED)

#define _slmALIGN(N, Alignment, Packed) \
   ((Packed) ? (N) : gcmALIGN(N, Alignment))

static gctINT32
_GetDataTypeByteOffset(
    IN gctINT32 BaseOffset,
    IN gcSHADER_TYPE  DataType,
    IN gctBOOL IsRowMajor,
    IN gceINTERFACE_BLOCK_LAYOUT_ID MemoryLayout,
    IN gctBOOL IsArray,
    OUT gctINT16 *MatrixStride,
    OUT gctINT32 *ArrayStride,
    OUT gctINT16 *Alignment
)
{
    gctINT32    size = 0;
    gctINT16 matrixStride = 0;
    gctINT16 alignment = 1;
    gctBOOL packed;

    packed = (MemoryLayout & gcvINTERFACE_BLOCK_PACKED) != 0;
    switch (DataType)
    {
    case gcSHADER_BOOLEAN_X1:
    case gcSHADER_FLOAT_X1:
    case gcSHADER_INTEGER_X1:
    case gcSHADER_UINT_X1:
    case gcSHADER_ATOMIC_UINT:
       if(IsArray &&  (MemoryLayout & gcvINTERFACE_BLOCK_STD140)) {
          alignment = 16;
          size = 16;
       }
       else {
          alignment = 4;
          size = 4;
       }
       break;

    case gcSHADER_BOOLEAN_X2:
    case gcSHADER_FLOAT_X2:
    case gcSHADER_INTEGER_X2:
    case gcSHADER_UINT_X2:
       if(IsArray &&  (MemoryLayout & gcvINTERFACE_BLOCK_STD140)) {
          alignment = 16;
          size = 16;
       }
       else {
          alignment = 8;
          size = 8;
       }
       break;

    case gcSHADER_BOOLEAN_X3:
    case gcSHADER_FLOAT_X3:
    case gcSHADER_INTEGER_X3:
    case gcSHADER_UINT_X3:
       alignment = 16;
       if (IsArray)
           size = 16;
       else
           size = 12;
       break;

    case gcSHADER_BOOLEAN_X4:
    case gcSHADER_FLOAT_X4:
    case gcSHADER_INTEGER_X4:
    case gcSHADER_UINT_X4:
       alignment = 16;
       size = 16;
       break;

   case gcSHADER_FLOAT_2X2:
       if(MemoryLayout & gcvINTERFACE_BLOCK_STD140) {
          alignment = 16;
          size = 16 * 2;
       }
       else {
          alignment = 8;
          size = 8 * 2;
       }
       matrixStride = alignment;
       break;

   case gcSHADER_FLOAT_2X3:
       if(MemoryLayout & gcvINTERFACE_BLOCK_STD140) {
          alignment = 16;
          if(IsRowMajor) {
              size = 16 * 3;
          }
          else {
              size = 16 * 2;
          }
       }
       else { /* for gcvINTERFACE_BLOCK_SHARED, gcvINTERFACE_BLOCK_PACKED
                 and gcINTERFACE_BLOCK_STD430
               */
          if(IsRowMajor) {
             alignment = 8;
             size = 8 * 3;
          }
          else {
             if(packed) {
                alignment = 12;
                size = 12 * 2;
             }
             else {
                alignment = 16;
                size = 16 * 2;
             }
          }
       }
       matrixStride = alignment;
       break;

   case gcSHADER_FLOAT_2X4:
       if(MemoryLayout & gcvINTERFACE_BLOCK_STD140) {
          alignment = 16;
          if(IsRowMajor) {
              size = 16 * 4;
          }
          else {
              size = 16 * 2;
          }
       }
       else { /* for gcvINTERFACE_BLOCK_SHARED, gcvINTERFACE_BLOCK_PACKED
                 and gcINTERFACE_BLOCK_STD430
               */
          if(IsRowMajor) {
             alignment = 8;
             size = 8 * 4;
          }
          else {
             alignment = 16;
             size = 16 * 2;
          }
       }
       matrixStride = alignment;
       break;

   case gcSHADER_FLOAT_3X2:
       if(MemoryLayout & gcvINTERFACE_BLOCK_STD140) {
          alignment = 16;
          if(IsRowMajor) {
              size = 16 * 2;
          }
          else {
              size = 16 * 3;
          }
       }
       else { /* for gcvINTERFACE_BLOCK_SHARED, gcvINTERFACE_BLOCK_PACKED
                 and gcINTERFACE_BLOCK_STD430
               */
          if(IsRowMajor) {
             if(packed) {
                alignment = 12;
                size = 12 * 2;
             }
             else {
                alignment = 16;
                size = 16 * 2;
             }
          }
          else {
             alignment = 8;
             size = 8 * 3;
          }
       }
       matrixStride = alignment;
       break;

   case gcSHADER_FLOAT_3X3:
       if(MemoryLayout & gcvINTERFACE_BLOCK_STD140) {
          alignment = 16;
          size = 16 * 3;
       }
       else {
          if(packed) {
             alignment = 12;
             size = 12 * 3;
          }
          else {
             alignment = 16;
             size = 16 * 3;
          }
       }
       matrixStride = alignment;
       break;

   case gcSHADER_FLOAT_3X4:
       if(MemoryLayout & gcvINTERFACE_BLOCK_STD140) {
          alignment = 16;
          if(IsRowMajor) {
              size = 16 * 4;
          }
          else {
              size = 16 * 3;
          }
       }
       else { /* for gcvINTERFACE_BLOCK_SHARED, gcvINTERFACE_BLOCK_PACKED
                 and gcINTERFACE_BLOCK_STD430
               */
          if(IsRowMajor) {
             if(packed) {
                alignment = 12;
                size = 12 * 4;
             }
             else {
                alignment = 16;
                size = 16 * 4;
             }
          }
          else {
             alignment = 16;
             size = 16 * 3;
          }
       }
       matrixStride = alignment;
       break;

   case gcSHADER_FLOAT_4X2:
       if(MemoryLayout & gcvINTERFACE_BLOCK_STD140) {
          alignment = 16;
          if(IsRowMajor) {
              size = 16 * 2;
          }
          else {
              size = 16 * 4;
          }
       }
       else { /* for gcvINTERFACE_BLOCK_SHARED, gcvINTERFACE_BLOCK_PACKED
                 and gcINTERFACE_BLOCK_STD430
               */
          if(IsRowMajor) {
             alignment = 16;
             size = 16 * 2;
          }
          else {
             alignment = 8;
             size = 8 * 4;
          }
       }
       matrixStride = alignment;
       break;

   case gcSHADER_FLOAT_4X3:
       if(MemoryLayout & gcvINTERFACE_BLOCK_STD140) {
          alignment = 16;
          if(IsRowMajor) {
              size = 16 * 3;
          }
          else {
              size = 16 * 4;
          }
       }
       else { /* for gcvINTERFACE_BLOCK_SHARED, gcvINTERFACE_BLOCK_PACKED
                 and gcINTERFACE_BLOCK_STD430
               */
          if(IsRowMajor) {
             alignment = 16;
             size = 16 * 3;
          }
          else {
             if(packed) {
                alignment = 12;
                size = 12 * 4;
             }
             else {
                alignment = 16;
                size = 16 * 4;
             }
          }
       }
       matrixStride = alignment;
       break;

   case gcSHADER_FLOAT_4X4:
       alignment = 16;
       size = 16 * 4;
       matrixStride = alignment;
       break;

   default:
       gcmASSERT(0);
       return 0;
   }

   if(MatrixStride) *MatrixStride = matrixStride;
   if(ArrayStride) *ArrayStride = size;
   if(Alignment) *Alignment = alignment;
   return  _slmALIGN(BaseOffset, alignment, packed);
}

union _sluObjPtrs {
    gcUNIFORM    uniform;
    gcVARIABLE   variable;
    gcsUNIFORM_BLOCK uniformBlock;
    gcsSTORAGE_BLOCK storageBlock;
    gcsINTERFACE_BLOCK_INFO *interfaceBlock;
    gctPOINTER   pointer;
};

static gceSTATUS
_AllocMemoryOffsetOrArray(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * MemberName,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN slsNAME * BlockName,
    IN gctBOOL IsBlockMemberActive,
    IN gctPOINTER StructParent,
    IN gctBOOL NeedAllocateRegs,
    IN OUT gctINT16 *PrevSibling,
    IN OUT slsLOGICAL_REG **LogicalRegs,
    IN OUT gctINT32 *Offset
    )
{
    gceSTATUS          status;
    sltSTORAGE_QUALIFIER       qualifier;
    gcSHADER_TYPE      binaryDataType;
    gctUINT            logicalRegCount, i;
    gctINT             isArray = (DataType->arrayLength != 0);
    union _sluObjPtrs  member;
    union _sluObjPtrs  structParent;
    gcSHADER_PRECISION binaryPrecision;
    gctINT16 thisVarIndex = -1;
    slsLOGICAL_REG *logicalRegs;
    gctINT32 offset, arrayOffset;
    gcsINTERFACE_BLOCK_INFO *interfaceBlock = gcvNULL;
    gctBOOL isSharedOrStd140 = gcvFALSE;

    gcmHEADER_ARG("Compiler=0x%x codeGenerator=0x%x MemberName=0x%x Symbol=%s "
                  "DataType=0x%x BlockName=0x%x StructParent=0x%x",
                  Compiler, CodeGenerator, MemberName, Symbol, DataType, BlockName, StructParent);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmVERIFY_ARGUMENT(MemberName);
    gcmASSERT(DataType);
    gcmASSERT(!slsDATA_TYPE_IsStruct(DataType));
    gcmASSERT(LogicalRegs);
    gcmASSERT(Offset);

    qualifier = MemberName->dataType->qualifiers.storage;

    if (MemberName->isBuiltIn)
    {
        status = slGetBuiltInVariableImplSymbol(Compiler,
                                                Symbol,
                                                &Symbol,
                                                &qualifier);
        if (gcmIS_ERROR(status)) {
           gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                           MemberName->lineNo,
                                           MemberName->stringNo,
                                           slvREPORT_ERROR,
                                           "invalid builtin variable '%s'", Symbol));

           gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);

           return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }
    }

    binaryDataType      = _ConvElementDataType(DataType);
    binaryPrecision = _ConvElementDataPrecision(DataType);

    logicalRegCount = (gctUINT)_GetLogicalCountForAnArray(DataType);

    member.pointer = gcvNULL;
    switch(BlockName->dataType->elementType) {
    case slvTYPE_UNIFORM_BLOCK:
        slmNewUniform(Compiler,
                      MemberName->lineNo,
                      MemberName->stringNo,
                      Symbol,
                      binaryDataType,
                      binaryPrecision,
                      -1,
                      -1,
                      -1,
                      DataType->arrayLengthCount,
                      DataType->arrayLengthList,
                      gcSHADER_VAR_CATEGORY_BLOCK_MEMBER,
                      0,
                      StructParent ? ((gcUNIFORM)StructParent)->index : -1,
                      *PrevSibling,
                      gcIMAGE_FORMAT_DEFAULT,
                      &thisVarIndex,
                      &member.uniform,
                      status);
        break;

    case slvTYPE_STORAGE_BLOCK:
        slmNewVariable(Compiler,
                       MemberName->lineNo,
                       MemberName->stringNo,
                       Symbol,
                       binaryDataType,
                       binaryPrecision,
                       DataType->arrayLengthCount,
                       DataType->arrayLengthList,
                       gcvFALSE,
                       gcvFALSE, /* not output */
                       gcvFALSE, /* not precise */
                       DataType->isPerVertexArray,
                       0,
                       gcSHADER_VAR_CATEGORY_BLOCK_MEMBER,
                       0,
                       StructParent ? ((gcVARIABLE)StructParent)->index : -1,
                       *PrevSibling,
                       &thisVarIndex,
                       status);
        if (gcmIS_ERROR(status))
        {
           gcmFOOTER();
           return status;
        }

        status = _GetShaderVariableByIndex(Compiler, thisVarIndex, &member.variable);
        break;

    default:
        status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        break;
    }

    if (gcmIS_ERROR(status))
    {
        gcmFOOTER();
        return status;
    }

    interfaceBlock = BlockName->u.interfaceBlockContent.u.interfaceBlockInfo;
    structParent.pointer = StructParent;

    *PrevSibling = thisVarIndex;
    logicalRegs = *LogicalRegs;

    if(slsDATA_TYPE_IsUnderlyingUniformBlock(BlockName->dataType)) {
        member.uniform->blockIndex = GetIBIBlockIndex(interfaceBlock);
        member.uniform->isRowMajor =
            ((DataType->qualifiers.layout.id & slvLAYOUT_ROW_MAJOR) != 0);

        if ((DataType->qualifiers.layout.id & slvLAYOUT_SHARED) ||
            (DataType->qualifiers.layout.id & slvLAYOUT_STD140))
        {
            isSharedOrStd140 = gcvTRUE;
        }

        if(!IsBlockMemberActive && !isSharedOrStd140)
        {
            SetUniformFlag(member.uniform, gcvUNIFORM_FLAG_IS_INACTIVE);
        }

        /* If this uniform is following a structure, we need to update the offset.*/
        if (member.uniform->prevSibling != -1 && (GetIBIMemoryLayout(interfaceBlock) & gcvINTERFACE_BLOCK_STD140))
        {
            gcUNIFORM prevUniform;
            gcSHADER binary;

            gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));
                gcmVERIFY_OK(gcSHADER_GetUniform(binary, member.uniform->prevSibling, &prevUniform));

            /* Following a struct. */
            if (isUniformStruct(prevUniform))
            {
                *Offset = gcmALIGN(*Offset, 16);
            }
        }

        offset = _GetDataTypeByteOffset(*Offset,
                                        binaryDataType,
                                        DataType->qualifiers.layout.id & slvLAYOUT_ROW_MAJOR,
                                        GetIBIMemoryLayout(interfaceBlock),
                                        isArray,
                                        &member.uniform->matrixStride,
                                        &member.uniform->arrayStride,
                                        gcvNULL);
        member.uniform->offset = offset;

        if(structParent.uniform &&
           isUniformStruct(structParent.uniform) &&
           structParent.uniform->offset == -1) {
           structParent.uniform->offset = offset;
        }

        arrayOffset = 0;
        for (i = 0; i < logicalRegCount; i++)
        {
            offset += member.uniform->arrayStride;
            if (NeedAllocateRegs)
            {
                if(isArray) {
                    slsLOGICAL_REG_InitializeUniform(logicalRegs,
                                                     qualifier,
                                                     binaryDataType,
                                                     binaryPrecision,
                                                     member.uniform,
                                                     arrayOffset);
                    arrayOffset += member.uniform->arrayStride;
                }
                else {
                    slsLOGICAL_REG_InitializeUniform(logicalRegs,
                                                     qualifier,
                                                     binaryDataType,
                                                     binaryPrecision,
                                                     member.uniform,
                                                     0);
                }
                logicalRegs++;
            }
        }

        if(!isArray) { /* reset arrayStride to 0 to conform to openGL es3.0 spec */
           member.uniform->arrayStride = 0;
        }
    }
    else {
        member.variable->blockIndex = GetIBIBlockIndex(interfaceBlock);
        if ((DataType->qualifiers.layout.id & slvLAYOUT_ROW_MAJOR))
        {
            SetVariableIsRowMajor(member.variable);
        }

        /* If this variable is following a structure, we need to update the offset.*/
        if (member.variable->prevSibling != -1 && (GetIBIMemoryLayout(interfaceBlock) & gcvINTERFACE_BLOCK_STD140))
        {
            gcVARIABLE prevVariable;
            gcSHADER binary;

            gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));
            gcmVERIFY_OK(gcSHADER_GetVariable(binary, member.variable->prevSibling, &prevVariable));

            /* Following a struct. */
            if (isVariableStruct(prevVariable) &&
                GetIBIMemoryLayout(BlockName->u.interfaceBlockContent.u.interfaceBlockInfo) & gcvINTERFACE_BLOCK_STD140)
            {
                *Offset = gcmALIGN(*Offset, 16);
            }
        }

        offset = _GetDataTypeByteOffset(*Offset,
                                        binaryDataType,
                                        DataType->qualifiers.layout.id & slvLAYOUT_ROW_MAJOR,
                                        GetIBIMemoryLayout(interfaceBlock),
                                        isArray,
                                        &member.variable->matrixStride,
                                        &member.variable->arrayStride,
                                        gcvNULL);
        member.variable->offset = offset;

        if(structParent.variable &&
           isVariableStruct(structParent.variable) &&
           structParent.variable->offset == -1) {
           structParent.variable->offset = offset;
        }

        arrayOffset = 0;
        for (i = 0; i < logicalRegCount; i++)
        {
            offset += member.variable->arrayStride;
            if (NeedAllocateRegs)
            {
                if(isArray) {
                    slsLOGICAL_REG_InitializeVariable(logicalRegs,
                                                      qualifier,
                                                      binaryDataType,
                                                      binaryPrecision,
                                                      member.variable,
                                                      arrayOffset);
                    arrayOffset += member.variable->arrayStride;
                }
                else {
                    slsLOGICAL_REG_InitializeVariable(logicalRegs,
                                                      qualifier,
                                                      binaryDataType,
                                                      binaryPrecision,
                                                      member.variable,
                                                      0);
                }
                logicalRegs++;
            }
        }

        if(!isArray) { /* reset arrayStride to 0 to conform to openGL es3.0 spec */
            member.variable->arrayStride = 0;
        }
    }
    /* since logicalRegs has been increasing, *LogicalRegs does not point to the array head anymore,
       and it will be used for verification only in the future */
    *LogicalRegs = logicalRegs;
    *Offset = offset;

    if(GetIBIFirstChild(interfaceBlock) == -1) {
        gcmASSERT(thisVarIndex != -1);
        SetIBIFirstChild(interfaceBlock, thisVarIndex);
    }

    gcmFOOTER_ARG("*PrevSibling=%d *LogicalRegs=0x%x *Offset=%u", *PrevSibling, *LogicalRegs, *Offset);
    return gcvSTATUS_OK;
}

static gceSTATUS
_GetMemoryAndMatrixQualifier(
    IN sleLAYOUT_ID LayoutQualifier,
    IN OUT sleLAYOUT_ID * MemoryQualifier,
    IN OUT sleLAYOUT_ID * MatrixQualifier)
{
    if (MemoryQualifier != gcvNULL)
    {
        if (LayoutQualifier & slvLAYOUT_PACKED)
            *MemoryQualifier = slvLAYOUT_PACKED;
        else if (LayoutQualifier & slvLAYOUT_SHARED)
            *MemoryQualifier = slvLAYOUT_SHARED;
        else if (LayoutQualifier & slvLAYOUT_STD140)
            *MemoryQualifier = slvLAYOUT_STD140;
        else
            *MemoryQualifier = slvLAYOUT_NONE;
    }

    if (MatrixQualifier != gcvNULL)
    {
        if (LayoutQualifier & slvLAYOUT_ROW_MAJOR)
            *MatrixQualifier = slvLAYOUT_ROW_MAJOR;
        else if (LayoutQualifier & slvLAYOUT_COLUMN_MAJOR)
            *MatrixQualifier = slvLAYOUT_COLUMN_MAJOR;
        else
            *MatrixQualifier = slvLAYOUT_NONE;
    }
    return gcvSTATUS_OK;
}

static gceSTATUS
_InheritInterfaceBlockLayoutQualifier(
    IN slsDATA_TYPE * structDataType,
    IN OUT slsDATA_TYPE * elementDataType
    )
{
    sleLAYOUT_ID elementMemoryQualifier, elementMatrixQualifier, elementLocationQualifier;
    sleLAYOUT_ID structMemoryQualifier, structMatrixQualifier;

    /* Get the memory and matrix qualifier. */
    _GetMemoryAndMatrixQualifier(elementDataType->qualifiers.layout.id, &elementMemoryQualifier, &elementMatrixQualifier);
    _GetMemoryAndMatrixQualifier(structDataType->qualifiers.layout.id, &structMemoryQualifier, &structMatrixQualifier);

    /* If the qualifier is none, inherit from uniform block. */
    if (elementMemoryQualifier == slvLAYOUT_NONE)
        elementMemoryQualifier = structMemoryQualifier;

    if (elementMatrixQualifier == slvLAYOUT_NONE)
        elementMatrixQualifier = structMatrixQualifier;

    if (elementDataType->qualifiers.layout.id & slvLAYOUT_LOCATION)
        elementLocationQualifier = slvLAYOUT_LOCATION;
    else
        elementLocationQualifier = slvLAYOUT_NONE;

    /* Reset the layout qualifier. */
    elementDataType->qualifiers.layout.id = elementMemoryQualifier | elementMatrixQualifier | elementLocationQualifier;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GetBaseAlignmentForStruct(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN gcsINTERFACE_BLOCK_INFO * InterfaceBlock,
    IN slsDATA_TYPE * DataType,
    OUT gctINT16 * StructAlignment
    )
{
    slsNAME* fieldName;
    gcSHADER_TYPE binaryDataType;
    gctINT16 alignment = 0;

    FOR_EACH_DLINK_NODE(&DataType->fieldSpace->names, slsNAME, fieldName)
    {
        gctINT16 childAlignment = 0;

        gcmASSERT(fieldName->dataType);

        if (fieldName->dataType->elementType == slvTYPE_STRUCT)
        {
            _GetBaseAlignmentForStruct(Compiler,
                                       CodeGenerator,
                                       InterfaceBlock,
                                       fieldName->dataType,
                                       &childAlignment);
        }
        else
        {
            binaryDataType      = _ConvElementDataType(fieldName->dataType);
            _GetDataTypeByteOffset(0,
                                   binaryDataType,
                                   fieldName->dataType->qualifiers.layout.id & slvLAYOUT_ROW_MAJOR,
                                   GetIBIMemoryLayout(InterfaceBlock),
                                   (fieldName->dataType->arrayLength != 0),
                                   gcvNULL,
                                   gcvNULL,
                                   &childAlignment);
        }

        if (childAlignment > alignment)
            alignment = childAlignment;
    }
    if (StructAlignment)
        *StructAlignment = alignment;
    return gcvSTATUS_OK;
}

static gceSTATUS
_AllocMemoryOffsetsForNormalStruct(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN slsNAME *BlockName,
    IN gctBOOL IsBlockMemberActive,
    IN gctINT16 ParentIndex,
    IN gctBOOL IsTopLevel,
    IN OUT gctBOOL *NeedAllocateRegs,
    IN OUT gctINT16 *PrevSibling,
    IN OUT slsLOGICAL_REG **LogicalRegs,
    IN OUT gctINT32 *Offset
    )
{
    gceSTATUS       status;
    gctUINT         count, i;
    slsNAME *       fieldName;
    gctSTRING       symbol = gcvNULL;
    gctINT16        mainIdx = -1, structEleParent;
    gctINT16        arrayElePrevSibling;
    gctINT16        structElePrevSibling;
    gctUINT16       structEleCount;
    gcsINTERFACE_BLOCK_INFO  *interfaceBlock = gcvNULL;
    union _sluObjPtrs structParent;
    gcSHADER binary;
    gctINT16 alignment = 1;
    union _sluObjPtrs mainParent;

    interfaceBlock = BlockName->u.interfaceBlockContent.u.interfaceBlockInfo;

    gcmASSERT(Name->dataType->fieldSpace);
    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));

    mainParent.pointer = gcvNULL;

    count = (DataType->arrayLength == -1 || DataType->arrayLength == 0) ? 1 : DataType->arrayLength;

    slsDLINK_NODE_COUNT(&DataType->fieldSpace->names, structEleCount)

    status = _NewBlockIntermediateElementSymbol(Compiler,
                                                Name,
                                                Symbol,
                                                gcSHADER_FLOAT_X1, /* It is dummy for struct */
                                                DataType->arrayLengthCount,
                                                DataType->arrayLengthList,
                                                interfaceBlock,
                                                IsTopLevel ? gcSHADER_VAR_CATEGORY_TOP_LEVEL_STRUCT : gcSHADER_VAR_CATEGORY_STRUCT,
                                                (count > 1 || DataType->arrayLength == -1) ? 0 : structEleCount,
                                                ParentIndex,
                                                *PrevSibling,
                                                &mainIdx);

    if(GetIBIFirstChild(interfaceBlock) == -1) {
        SetIBIFirstChild(interfaceBlock, mainIdx);
    }
    if (gcmIS_ERROR(status))
    {
        return status;
    }

    arrayElePrevSibling = -1;

    FOR_EACH_DLINK_NODE(&DataType->fieldSpace->names, slsNAME, fieldName)
    {
        gcmASSERT(fieldName->dataType);
        /* Inherit the layout from interface block. */
        status = _InheritInterfaceBlockLayoutQualifier(DataType, fieldName->dataType);
    }

    /* According to GLSL ES specs:
    ** If the member is a structure, the base alignment of the structure is N, where
    ** N is the largest base alignment value of any of its members, and rounded
    ** up to the base alignment of a vec4.
    */
    gcmVERIFY_OK(_GetBaseAlignmentForStruct(Compiler, CodeGenerator, interfaceBlock, DataType, &alignment));

    if (GetIBIMemoryLayout(interfaceBlock) & gcvINTERFACE_BLOCK_STD140) {
        alignment = (alignment > 16) ? alignment : 16;
    }

    for (i = 0; i < count; i++)
    {
        union _sluObjPtrs structChild;
        structEleParent = mainIdx;

        if (i != 0 && slsDATA_TYPE_IsInheritFromUnsizedDataType(DataType))
        {
            if (NeedAllocateRegs)
            {
                *NeedAllocateRegs = gcvFALSE;
            }
        }

        /* If this interface block member is a structure, we need to update the offset. */
        *Offset = gcmALIGN(*Offset, alignment);

        if (count > 1 || DataType->isInheritFromUnsizedDataType)
        {
            gcmVERIFY_OK(_AllocStructElementAggregatedSymbol(Compiler,
                                                             CodeGenerator,
                                                             DataType,
                                                             i,
                                                             Symbol,
                                                             gcvNULL,
                                                             &symbol));

            status = _NewBlockIntermediateElementSymbol(Compiler,
                                                        Name,
                                                        symbol,
                                                        gcSHADER_FLOAT_X1, /* It is dummy for struct */
                                                        0,
                                                        gcvNULL,
                                                        interfaceBlock,
                                                        gcSHADER_VAR_CATEGORY_STRUCT,
                                                        structEleCount,
                                                        mainIdx,
                                                        arrayElePrevSibling,
                                                        &arrayElePrevSibling);

            if (gcmIS_ERROR(status))
            {
                return status;
            }

            structEleParent = arrayElePrevSibling;

            gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, symbol));

            if(slsDATA_TYPE_IsUnderlyingUniformBlock(BlockName->dataType)) {
                status = gcSHADER_GetUniform(binary,
                                             mainIdx,
                                             &mainParent.uniform);
            }
            else { /* assume to be storage block */
                status = gcSHADER_GetVariable(binary,
                                              mainIdx,
                                              &mainParent.variable);
            }

            if (gcmIS_ERROR(status))
            {
                return status;
            }
        }

        if(slsDATA_TYPE_IsUnderlyingUniformBlock(BlockName->dataType))
        {
            status = gcSHADER_GetUniform(binary,
                                         structEleParent,
                                         &structParent.uniform);
            if (gcmIS_ERROR(status))
            {
                return status;
            }
            structParent.uniform->offset = -1;
        }
        else
        {   /* assume to be storage block */
            status = gcSHADER_GetVariable(binary,
                                          structEleParent,
                                          &structParent.variable);
            if (gcmIS_ERROR(status))
            {
                return status;
            }
            structParent.variable->offset = -1;
        }

        structElePrevSibling = -1;

        FOR_EACH_DLINK_NODE(&DataType->fieldSpace->names, slsNAME, fieldName)
        {
            gcmASSERT(fieldName->dataType);
            gcmVERIFY_OK(_AllocStructElementAggregatedSymbol(Compiler,
                                                             CodeGenerator,
                                                             DataType,
                                                             i,
                                                             Symbol,
                                                             fieldName->symbol,
                                                             &symbol));

            status = _AllocMemoryOffsets(Compiler,
                                         CodeGenerator,
                                         Name,
                                         symbol,
                                         fieldName->dataType,
                                         BlockName,
                                         IsBlockMemberActive,
                                         structParent.pointer,
                                         NeedAllocateRegs,
                                         &structElePrevSibling,
                                         LogicalRegs,
                                         Offset);
            if (gcmIS_ERROR(status))
            {
                return status;
            }

            gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, symbol));

            /* The offset of a struct is equal to the offset of its first member. */
            if(slsDATA_TYPE_IsUnderlyingUniformBlock(BlockName->dataType)) {
                if(structParent.uniform->offset == -1 )
                {
                    status = gcSHADER_GetUniform(binary,
                                                 structElePrevSibling,
                                                 &structChild.uniform);
                    if (gcmIS_ERROR(status))
                    {
                        return status;
                    }

                    if (isUniformArray(structChild.uniform) && structChild.uniform->arraySize > 1)
                    {
                            gcmASSERT(structChild.uniform->firstChild != -1);
                            gcmVERIFY_OK(gcSHADER_GetUniform(binary, structChild.uniform->firstChild, &structChild.uniform));
                    }

                    structParent.uniform->offset = structChild.uniform->offset;
                }

                if(mainParent.uniform && i == 0)
                {
                    mainParent.uniform->offset = structParent.uniform->offset;
                }
            }
            else {
                if(structParent.variable->offset == -1 )
                {
                    status = gcSHADER_GetVariable(binary,
                                                  structElePrevSibling,
                                                  &structChild.variable);
                    if (gcmIS_ERROR(status))
                    {
                        return status;
                    }

                    if (structChild.variable->arraySize > 1)
                    {
                        gcmASSERT(structChild.variable->firstChild != -1);
                        gcmVERIFY_OK(gcSHADER_GetVariable(binary, structChild.variable->firstChild, &structChild.variable));
                    }

                    structParent.variable->offset = structChild.variable->offset;
                }

                if(mainParent.variable && i == 0)
                {
                    mainParent.variable->offset = structParent.variable->offset;
                }
            }
        }
        if(i == 0)
        {
            if(slsDATA_TYPE_IsUnderlyingUniformBlock(BlockName->dataType))
            {
                if(mainParent.uniform && isUniformArray(mainParent.uniform))
                {
                    mainParent.uniform->arrayStride = gcmALIGN(*Offset, alignment) - mainParent.uniform->offset;
                }
            }
            else
            {
                if(mainParent.variable && isVariableArray(mainParent.variable))
                {
                    mainParent.variable->arrayStride = gcmALIGN(*Offset, alignment) - mainParent.variable->offset;
                }

                if (DataType->isInheritFromUnsizedDataType)
                {
                    structParent.variable->arrayStride = mainParent.variable->arrayStride;
                }
            }
        }

        /* add struct padding part */
        *Offset = gcmALIGN(*Offset, alignment);
    }
    *PrevSibling = mainIdx;

    return status;
}

static gceSTATUS
_AllocMemoryOffsetsForStruct(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN slsNAME *BlockName,
    IN gctBOOL IsBlockMemberActive,
    IN gctINT16 ParentIndex,
    IN gctBOOL IsTopLevel,
    IN OUT gctBOOL *NeedAllocateRegs,
    IN OUT gctINT16 *PrevSibling,
    IN OUT slsLOGICAL_REG **LogicalRegs,
    IN OUT gctINT32 *Offset
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcSHADER binary = gcvNULL;

    if (DataType->arrayLengthCount < 2)
    {
        status = _AllocMemoryOffsetsForNormalStruct(Compiler,
                                                    CodeGenerator,
                                                    Name,
                                                    Symbol,
                                                    DataType,
                                                    BlockName,
                                                    IsBlockMemberActive,
                                                    ParentIndex,
                                                    IsTopLevel,
                                                    NeedAllocateRegs,
                                                    PrevSibling,
                                                    LogicalRegs,
                                                    Offset);
        if (gcmIS_ERROR(status))
        {
            return status;
        }
    }
    else
    {
        slsDATA_TYPE * elementDataType = gcvNULL;
        gctINT i, arrayLength;
        gctSTRING symbol = gcvNULL;
        gctINT16 parent = 0;
        gctINT16 prevSibling = -1;
        gcVARIABLE parentVar = gcvNULL, childVar = gcvNULL;
        gcUNIFORM parentUniform = gcvNULL, childUniform = gcvNULL;
        gcsINTERFACE_BLOCK_INFO  *interfaceBlock = gcvNULL;

        interfaceBlock = BlockName->u.interfaceBlockContent.u.interfaceBlockInfo;

        status = _NewBlockIntermediateElementSymbol(Compiler,
                                                    Name,
                                                    Symbol,
                                                    gcSHADER_FLOAT_X1, /* It is dummy for struct */
                                                    DataType->arrayLengthCount,
                                                    DataType->arrayLengthList,
                                                    interfaceBlock,
                                                    IsTopLevel ? gcSHADER_VAR_CATEGORY_TOP_LEVEL_STRUCT : gcSHADER_VAR_CATEGORY_STRUCT,
                                                    0,
                                                    ParentIndex,
                                                    *PrevSibling,
                                                    &parent);

        if(GetIBIFirstChild(interfaceBlock) == -1) {
            SetIBIFirstChild(interfaceBlock, parent);
        }

        if (gcmIS_ERROR(status))
        {
            return status;
        }

        arrayLength = (DataType->arrayLength == -1) ? 1 : DataType->arrayLength;

        for (i = 0; i < arrayLength; i++)
        {
            gcmVERIFY_OK(_AllocStructElementAggregatedSymbol(Compiler,
                                                       CodeGenerator,
                                                       DataType,
                                                       i,
                                                       Symbol,
                                                       gcvNULL,
                                                       &symbol));

            status = slsDATA_TYPE_ConstructElement(Compiler, DataType, &elementDataType);

            if (gcmIS_ERROR(status))
            {
                return status;
            }

            gcmVERIFY_OK(_AllocMemoryOffsetsForStruct(Compiler,
                                                      CodeGenerator,
                                                      Name,
                                                      symbol,
                                                      elementDataType,
                                                      BlockName,
                                                      IsBlockMemberActive,
                                                      parent,
                                                      gcvFALSE,
                                                      NeedAllocateRegs,
                                                      &prevSibling,
                                                      LogicalRegs,
                                                      Offset));

            gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, symbol));
        }

        gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));

        if (isIBIUniformBlock(interfaceBlock))
        {
            gcmVERIFY_OK(gcSHADER_GetUniform(binary, parent, &parentUniform));
            gcmVERIFY_OK(gcSHADER_GetUniform(binary, parentUniform->firstChild, &childUniform));
            SetUniformArrayStride(parentUniform, DataType->arrayLengthList[1] * childUniform->arrayStride);
            SetUniformOffset(parentUniform, childUniform->offset);
        }
        else
        {
            gcmVERIFY_OK(gcSHADER_GetVariable(binary, parent, &parentVar));
            gcmVERIFY_OK(gcSHADER_GetVariable(binary, parentVar->firstChild, &childVar));
            /*
            ** If this struct is a unsized array, we need to set the arraystride.
            ** And for a unsized struct array, the array stride is the size of this struct.
            */
            if (slsDATA_TYPE_IsInheritFromUnsizedDataType(DataType))
            {
                gcmASSERT((DataType->arrayLength == -1 && DataType->arrayLevel == 0) ||
                          (DataType->arrayLength != -1 && DataType->arrayLevel != 0));

                SetVariableArrayStride(parentVar, childVar->arrayStride);
            }
            else
            {
                SetVariableArrayStride(parentVar, DataType->arrayLengthList[1] * childVar->arrayStride);
            }
            SetVariableOffset(parentVar, childVar->offset);
        }

        if (PrevSibling)
        {
            *PrevSibling = parent;
        }
    }

    return status;
}

static gceSTATUS
_AllocMemoryOffsets(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    IN gctCONST_STRING Symbol,
    IN slsDATA_TYPE * DataType,
    IN slsNAME *BlockName,
    IN gctBOOL IsBlockMemberActive,
    IN gctPOINTER StructParent,
    IN OUT gctBOOL *NeedAllocateRegs,
    IN OUT gctINT16 *PrevSibling,
    IN OUT slsLOGICAL_REG **LogicalRegs,
    IN OUT gctINT32 *Offset
    )
{
    gceSTATUS       status;
    gcsINTERFACE_BLOCK_INFO  *interfaceBlock = gcvNULL;
    gctINT16        structParentIndex = -1;

    gcmHEADER_ARG("Compiler=0x%x codeGenerator=0x%x Name=0x%x Symbol=%s "
                  "DataType=0x%x BlockName=0x%x StructParent=0x%x",
                  Compiler, CodeGenerator, Name, Symbol, DataType, BlockName, StructParent);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmVERIFY_ARGUMENT(Name);
    gcmASSERT(DataType);

    gcmASSERT(BlockName->u.interfaceBlockContent.u.interfaceBlockInfo);
    interfaceBlock = BlockName->u.interfaceBlockContent.u.interfaceBlockInfo;
    if(!interfaceBlock) {
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    if(slsDATA_TYPE_IsUnderlyingUniformBlock(BlockName->dataType)) {
        structParentIndex = StructParent ? ((gcUNIFORM)StructParent)->index : -1;
    }
    else {
        structParentIndex = StructParent ? ((gcVARIABLE)StructParent)->index : -1;
    }

    if (DataType->elementType == slvTYPE_STRUCT)
    {
        status = _AllocMemoryOffsetsForStruct(Compiler,
                                              CodeGenerator,
                                              Name,
                                              Symbol,
                                              DataType,
                                              BlockName,
                                              IsBlockMemberActive,
                                              structParentIndex,
                                              slsDATA_TYPE_IsUnderlyingStorageBlock(BlockName->dataType) ? gcvTRUE : gcvFALSE,
                                              NeedAllocateRegs,
                                              PrevSibling,
                                              LogicalRegs,
                                              Offset);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }
    }
    else
    {
        status = _AllocMemoryOffsetOrArray(Compiler,
                                           CodeGenerator,
                                           Name,
                                           Symbol,
                                           DataType,
                                           BlockName,
                                           IsBlockMemberActive,
                                           StructParent,
                                           *NeedAllocateRegs,
                                           PrevSibling,
                                           LogicalRegs,
                                           Offset);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }
    }

    gcmFOOTER_ARG("*PrevSibling=%d *LogicalRegs=0x%x *Offset=%u", *PrevSibling, *LogicalRegs, *Offset);
    return gcvSTATUS_OK;
}

static gctBOOL
_StorageBlockHasUnsizedArray(
     IN gcSHADER  Shader,
     IN gcsSTORAGE_BLOCK StorageBlock
     )
{
     gcVARIABLE variable;
     gctINT i;
     gctBOOL unSized = gcvFALSE;

     variable = gcGetSBLastVariable(Shader, StorageBlock);

     for (i = 0; i < variable->arrayLengthCount; i++)
     {
         if (variable->arrayLengthList[i] == -1)
         {
             unSized = gcvTRUE;
             break;
         }
     }

     return unSized;
}

static gceSTATUS
_AllocLogicalRegForNormalIOBlockMember(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * BlockName,
    IN slsNAME * VarName,
    IN slsNAME * BlockMemberName,
    IN gctSTRING Symbol,
    IN gctINT    IOBlockArrayIndex,
    IN gctBOOL   IsInstance,
    IN gctINT *  FieldIndex,
    IN OUT slsLOGICAL_REG ** LogicalRegs,
    IN OUT gctINT * Location
    )
{
    gceSTATUS                   status = gcvSTATUS_OK;
    gcSHADER                    binary;
    gctINT16                    variableIndex = 0;
    gctINT                      location = *Location;
    gctPOINTER                  pointer = gcvNULL;
    gctUINT                     i, logicalRegCount = 0, start = 0;
    slsLOGICAL_REG *            logicalRegs = gcvNULL;
    gctSTRING                   symbol = gcvNULL;

    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));
    start = 0;
    logicalRegCount = _GetLogicalOperandCount(BlockMemberName->dataType, gcvFALSE);
    symbol = Symbol;

    /* Allocate register for member. */
    if (BlockMemberName->context.logicalRegs == gcvNULL)
    {
        gcmONERROR(sloCOMPILER_Allocate(Compiler,
                                        (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount,
                                        &pointer));
        gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount);
        logicalRegs = (slsLOGICAL_REG *)pointer;
        BlockMemberName->context.logicalRegs = logicalRegs;
        BlockMemberName->context.logicalRegCount   = logicalRegCount;
    }
    else
    {
        gctUINT newLogicalRegCount = logicalRegCount + BlockMemberName->context.logicalRegCount;

        gcmONERROR(sloCOMPILER_Allocate(Compiler,
                                        (gctSIZE_T)sizeof(slsLOGICAL_REG) * newLogicalRegCount,
                                        &pointer));
        gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG) * newLogicalRegCount);
        logicalRegs = (slsLOGICAL_REG *)pointer;

        for (i = 0; i < BlockMemberName->context.logicalRegCount; i++)
        {
            logicalRegs[i] = BlockMemberName->context.logicalRegs[i];
        }
        gcmONERROR(sloCOMPILER_Free(Compiler, BlockMemberName->context.logicalRegs));
        BlockMemberName->context.logicalRegs = logicalRegs;
        BlockMemberName->context.logicalRegCount = newLogicalRegCount;
        logicalRegs += (newLogicalRegCount - logicalRegCount);
    }
    /* Update the qualifier. */
    for (i = 0; i < logicalRegCount; i++)
    {
        logicalRegs[i].qualifier = BlockMemberName->dataType->qualifiers.storage;
    }

    /* If this member has its own location, then update the location. */
    if (slmDATA_TYPE_layoutId_GET(BlockMemberName->dataType) & slvLAYOUT_LOCATION)
    {
        location = slmDATA_TYPE_layoutLocation_GET(BlockMemberName->dataType);
    }
    else if (location != -1)
    {
        slmDATA_TYPE_layoutLocation_SET(BlockMemberName->dataType, location);
    }
    /* Get the qualifier from instance name. */
    if (IsInstance)
    {
        if (VarName->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_IN_IO_BLOCK)
            BlockMemberName->dataType->qualifiers.storage = slvSTORAGE_QUALIFIER_IN_IO_BLOCK_MEMBER;
        else
            BlockMemberName->dataType->qualifiers.storage = slvSTORAGE_QUALIFIER_OUT_IO_BLOCK_MEMBER;
    }

    gcmONERROR(_AllocLogicalRegs(Compiler,
                                 CodeGenerator,
                                 BlockMemberName,
                                 symbol,
                                 BlockMemberName->dataType,
                                 -1,/* Assume it is not structure */
                                 -1,/* Assume it is not structure */
                                 &variableIndex,/* Do not need var index on the most top level */
                                 gcvNULL,
                                 logicalRegs,
                                 &start));

    /* Update the logical regs. */
    if (*LogicalRegs)
    {
        for (i = 0; i < start; i++)
        {
            (*(*LogicalRegs + i)) = *(logicalRegs + i);
        }
    }

    if (BlockMemberName->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_IN_IO_BLOCK_MEMBER)
    {
        gcATTRIBUTE attribute = gcvNULL;
        gcATTRIBUTE prevAttribute = gcvNULL;
        gctINT16 prevElement = GetIBIFirstChild(GetSBInterfaceBlockInfo(BlockName->u.interfaceBlockContent.u.ioBlock));

        gcmONERROR(gcSHADER_GetAttribute(binary, (gctUINT)variableIndex, &attribute));

        SetATTRIOBlockIndex(attribute, GetSBBlockIndex(BlockName->u.interfaceBlockContent.u.ioBlock));
        SetATTRIOBlockArrayIndex(attribute, IOBlockArrayIndex);

        if (FieldIndex)
        {
            GetATTRFieldIndex(attribute) = *FieldIndex;
        }
        gcmATTRIBUTE_SetIsIOBlockMember(attribute, gcvTRUE);
        gcmATTRIBUTE_SetIsInstanceMember(attribute, IsInstance);

        if (prevElement == -1)
        {
            SetIBIFirstChild(GetSBInterfaceBlockInfo(BlockName->u.interfaceBlockContent.u.ioBlock),
                             GetATTRIndex(attribute));
        }
        else
        {
            /* Find the last element. */
            gcmONERROR(gcSHADER_GetAttribute(binary, (gctUINT)prevElement, &prevAttribute));
            prevElement = GetATTRNextSibling(prevAttribute);
            while (prevElement != -1)
            {
                gcmONERROR(gcSHADER_GetAttribute(binary, (gctUINT)prevElement, &prevAttribute));
                prevElement = GetATTRNextSibling(prevAttribute);
            }
            SetATTRNextSibling(prevAttribute, variableIndex);
            SetATTRPrevSibling(attribute, GetATTRIndex(prevAttribute));
        }
    }
    else
    {
        gcOUTPUT output = gcvNULL;
        gcOUTPUT prevOutput = gcvNULL;
        gctINT length = _GetLogicalCountForAnArray(BlockMemberName->dataType), i;
        gctINT16 prevElement = GetIBIFirstChild(GetSBInterfaceBlockInfo(BlockName->u.interfaceBlockContent.u.ioBlock));

        for (i = 0; i < length; i++)
        {
            gcmONERROR(gcSHADER_GetOutput(binary, (gctUINT)(variableIndex + i), &output));

            SetOutputIOBlockIndex(output, GetSBBlockIndex(BlockName->u.interfaceBlockContent.u.ioBlock));
            SetOutputIOBlockArrayIndex(output, IOBlockArrayIndex);

            if (FieldIndex)
            {
                GetOutputFieldIndex(output) = *FieldIndex;
            }
            gcmOUTPUT_SetIsIOBlockMember(output, gcvTRUE);
            gcmOUTPUT_SetIsInstanceMember(output, IsInstance);
        }

        gcmONERROR(gcSHADER_GetOutput(binary, (gctUINT)(variableIndex), &output));
        if (prevElement == -1)
        {
            SetIBIFirstChild(GetSBInterfaceBlockInfo(BlockName->u.interfaceBlockContent.u.ioBlock),
                             GetOutputIndex(output));
        }
        else
        {
            /* Find the last element. */
            gcmONERROR(gcSHADER_GetOutput(binary, (gctUINT)prevElement, &prevOutput));
            prevElement = GetOutputNextSibling(prevOutput);
            while (prevElement != -1)
            {
                gcmONERROR(gcSHADER_GetOutput(binary, (gctUINT)prevElement, &prevOutput));
                prevElement = GetOutputNextSibling(prevOutput);
            }
            SetOutputNextSibling(prevOutput, variableIndex);
            SetOutputPrevSibling(output, GetOutputIndex(prevOutput));
        }
    }

    gcmASSERT(start == logicalRegCount);

    /* Update the logical regs. */
    if (*LogicalRegs)
    {
        *LogicalRegs += logicalRegCount;
    }

    /* Update the location. */
    if (location != -1)
    {
        location += _GetLogicalOperandCount(BlockMemberName->dataType, gcvTRUE);
        *Location = location;
    }

    if (FieldIndex)
    {
        *FieldIndex += 1;
    }

OnError:
    return status;
}

static gceSTATUS
_AllocLogicalRegForIOBlockMember(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * BlockName,
    IN slsNAME * VarName,
    IN slsNAME * BlockMemberName,
    IN gctSTRING BlockNameSymbol,
    IN gctINT    IOBlockArrayIndex,
    IN gctBOOL   IsInstance,
    IN gctINT *  FieldIndex,
    IN OUT slsLOGICAL_REG ** LogicalRegs,
    IN OUT gctINT * Location
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctSTRING structNameSymbol = gcvNULL, elementSymbol = gcvNULL;
    gctUINT i, j, arrayCount = 0;
    slsNAME * fieldName = gcvNULL;
    gctPOINTER pointer = gcvNULL;
    gctUINT logicalRegCount = 0, fieldRegCount = 0;
    slsLOGICAL_REG * logicalRegs = gcvNULL;

    if (BlockMemberName->dataType->elementType == slvTYPE_STRUCT)
    {
        logicalRegCount = _GetLogicalOperandCount(BlockMemberName->dataType, gcvFALSE);

        /* Allocate register for member. */
        if (BlockMemberName->context.logicalRegs == gcvNULL)
        {
            gcmONERROR(sloCOMPILER_Allocate(Compiler,
                                            (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount,
                                            &pointer));
            gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount);
            logicalRegs = (slsLOGICAL_REG *)pointer;
            BlockMemberName->context.logicalRegs = logicalRegs;
            BlockMemberName->context.logicalRegCount   = logicalRegCount;
        }
        else
        {
            gctUINT newLogicalRegCount = logicalRegCount + BlockMemberName->context.logicalRegCount;

            gcmONERROR(sloCOMPILER_Allocate(Compiler,
                                            (gctSIZE_T)sizeof(slsLOGICAL_REG) * newLogicalRegCount,
                                            &pointer));
            gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG) * newLogicalRegCount);
            logicalRegs = (slsLOGICAL_REG *)pointer;

            for (i = 0; i < BlockMemberName->context.logicalRegCount; i++)
            {
                logicalRegs[i] = BlockMemberName->context.logicalRegs[i];
            }
            gcmONERROR(sloCOMPILER_Free(Compiler, BlockMemberName->context.logicalRegs));
            BlockMemberName->context.logicalRegs = logicalRegs;
            BlockMemberName->context.logicalRegCount = newLogicalRegCount;
            logicalRegs += (newLogicalRegCount - logicalRegCount);
        }
        /* Update the qualifier. */
        for (i = 0; i < logicalRegCount; i++)
        {
            logicalRegs[i].qualifier = BlockMemberName->dataType->qualifiers.storage;
        }
        /* Update location. */
        if (slmDATA_TYPE_layoutId_GET(BlockMemberName->dataType) & slvLAYOUT_LOCATION)
        {
            *Location = slmDATA_TYPE_layoutLocation_GET(BlockMemberName->dataType);
        }
        /* Get the struct symbol. */
        if (IsInstance)
        {
            gcmONERROR(_AllocStructElementAggregatedSymbol(Compiler,
                                                           CodeGenerator,
                                                           VarName->dataType,
                                                           (gctUINT)-1,
                                                           BlockNameSymbol,
                                                           BlockMemberName->symbol,
                                                           &structNameSymbol));
        }
        else
        {
            structNameSymbol = BlockMemberName->symbol;
        }

        arrayCount = _GetLogicalCountForAnArray(BlockMemberName->dataType);

        for (i = 0; i < arrayCount; i++)
        {
            FOR_EACH_DLINK_NODE(&BlockMemberName->dataType->fieldSpace->names, slsNAME, fieldName)
            {
                /* Update storage. */
                fieldName->dataType->qualifiers.storage =
                    BlockMemberName->dataType->qualifiers.storage;
                /* Update qualifier. */
                if (slsQUALIFIERS_HAS_FLAG(&BlockMemberName->dataType->qualifiers, slvQUALIFIERS_FLAG_PATCH))
                {
                    slsQUALIFIERS_SET_FLAG(&(fieldName->dataType->qualifiers), slvQUALIFIERS_FLAG_PATCH);
                }
                fieldRegCount = _GetLogicalOperandCount(fieldName->dataType, gcvFALSE);
                /* Get the element symbol. */
                gcmVERIFY_OK(_AllocStructElementAggregatedSymbol(Compiler,
                                                                 CodeGenerator,
                                                                 BlockMemberName->dataType,
                                                                 i,
                                                                 structNameSymbol,
                                                                 fieldName->symbol,
                                                                 &elementSymbol));

                gcmONERROR(_AllocLogicalRegForNormalIOBlockMember(Compiler,
                                                                  CodeGenerator,
                                                                  BlockName,
                                                                  VarName,
                                                                  fieldName,
                                                                  elementSymbol,
                                                                  IOBlockArrayIndex,
                                                                  IsInstance,
                                                                  FieldIndex,
                                                                  *LogicalRegs ? LogicalRegs : &logicalRegs,
                                                                  Location));

                gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, elementSymbol));

                /* Update the logical regs. */
                if (*LogicalRegs)
                {
                    for (j = 0; j < fieldRegCount; j++)
                    {
                        *(logicalRegs + i) = (*(*LogicalRegs - fieldRegCount + i));
                    }
                    logicalRegs += fieldRegCount;
                }
            }
        }

        if (IsInstance)
        {
            gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, structNameSymbol));
        }
    }
    else
    {
        if (IsInstance)
        {
            gcmVERIFY_OK(_AllocStructElementAggregatedSymbol(Compiler,
                                                             CodeGenerator,
                                                             BlockMemberName->dataType,
                                                             (gctUINT)-1,
                                                             BlockNameSymbol,
                                                             BlockMemberName->symbol,
                                                             &elementSymbol));
        }
        else
        {
            elementSymbol = BlockMemberName->symbol;
        }

        gcmONERROR(_AllocLogicalRegForNormalIOBlockMember(Compiler,
                                                          CodeGenerator,
                                                          BlockName,
                                                          VarName,
                                                          BlockMemberName,
                                                          elementSymbol,
                                                          IOBlockArrayIndex,
                                                          IsInstance,
                                                          FieldIndex,
                                                          LogicalRegs,
                                                          Location));

        if (IsInstance)
        {
            gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, elementSymbol));
        }
    }

OnError:
    return status;
}

static gceSTATUS
_AllocLogicalRegForIOBlock(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * BlockName,
    IN slsNAME * VarName
    )
{
    gceSTATUS                   status = gcvSTATUS_OK;
    gcSHADER                    binary;
    gcsSHADER_VAR_INFO          blockInfo[1];
    gctUINT16                   blockElemCount;
    gctINT                      location = 0;
    gctPOINTER                  pointer = gcvNULL;
    slsINTERFACE_BLOCK_MEMBER * blockMember;
    slsNAME *                   blockMemberName;
    gctUINT                     i, logicalRegCount = 0, count = 1;
    slsLOGICAL_REG *            logicalRegs = gcvNULL;
    gctBOOL                     isInstance = gcvFALSE;
    gctINT                      fieldIndex = 0;

    gcmHEADER_ARG("Compiler=0x%x CodeGenerator=0x%x BlockName=0x%x VarName=0x%x",
                  Compiler, CodeGenerator, BlockName, VarName);

    if (VarName->context.logicalRegCount != 0)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));

    slsDLINK_NODE_COUNT(&BlockName->u.interfaceBlockContent.members, blockElemCount);

    gcmASSERT(blockElemCount);

    isInstance = slsDATA_TYPE_IsUnderlyingIOBlock(VarName->dataType);

    gcoOS_ZeroMemory(blockInfo, gcmSIZEOF(gcsSHADER_VAR_INFO));

    /* Create a IO block. */
    blockInfo->varCategory = gcSHADER_VAR_CATEGORY_BLOCK;
    blockInfo->format = gcSL_FLOAT;
    if (isInstance)
    {
        blockInfo->precision = VarName->dataType->qualifiers.precision;
        blockInfo->arraySize = VarName->dataType->arrayLength;
        blockInfo->arrayCount = VarName->dataType->arrayLengthCount;
        count = (blockInfo->arraySize == 0) ? 1 : (gctUINT)blockInfo->arraySize;

        if (slsNAME_IsPerVertexArray(VarName))
        {
            if (VarName->dataType->arrayLengthCount > 1)
            {
                blockInfo->arraySize = VarName->dataType->arrayLengthList[1];
                blockInfo->arrayCount--;
                count = (blockInfo->arraySize == 0) ? 1 : (gctUINT)blockInfo->arraySize;
            }
            else
            {
                blockInfo->arraySize = 0;
                blockInfo->arrayCount = 0;
                count = 1;
            }
        }
        else
        {
            blockInfo->arraySize = VarName->dataType->arrayLength;
            blockInfo->arrayCount = VarName->dataType->arrayLengthCount;
            count = (blockInfo->arraySize == 0) ? 1 : (gctUINT)blockInfo->arraySize;
        }
    }
    else
    {
        blockInfo->precision = VarName->dataType->qualifiers.precision;
        blockInfo->arraySize = 0;
        blockInfo->arrayCount = 0;
        count = 1;
    }
    if (blockInfo->arrayCount > 0)
    {
        gcmONERROR(gcoOS_Allocate(gcvNULL, gcmSIZEOF(gctINT32), &pointer));
        blockInfo->arraySizeList = (gctINT *)pointer;
        blockInfo->arraySizeList[0] = blockInfo->arraySize;
    }
    blockInfo->u.numBlockElement = blockElemCount;
    blockInfo->firstChild = -1;
    blockInfo->nextSibling = -1;
    blockInfo->prevSibling = -1;
    blockInfo->parent= -1;

    if (slmDATA_TYPE_layoutId_GET(VarName->dataType) & slvLAYOUT_LOCATION)
    {
        blockInfo->location = slmDATA_TYPE_layoutLocation_GET(VarName->dataType);
    }
    else
    {
        blockInfo->location = -1;
    }
    /* This block is a input or an output. */
    if (VarName->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_OUT_IO_BLOCK ||
        VarName->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_OUT_IO_BLOCK_MEMBER)
    {
        blockInfo->isOutput = gcvTRUE;
    }

    gcmONERROR(gcSHADER_AddIoBlock(binary,
                                   BlockName->symbol,
                                   isInstance ? VarName->symbol : gcvNULL,
                                   blockInfo,
                                   slmInterfaceBlockMemoryLayout(BlockName->dataType->qualifiers.layout),
                                   &BlockName->u.interfaceBlockContent.u.ioBlock));

    if (isInstance)
    {
        SetSBFlag(BlockName->u.interfaceBlockContent.u.ioBlock, gceIB_FLAG_WITH_INSTANCE_NAME);
    }

    /* If this is a instance name, allocate register for instance. */
    location = blockInfo->location;
    if (isInstance)
    {
        logicalRegCount = _GetLogicalOperandCount(VarName->dataType, gcvFALSE);
        gcmONERROR(sloCOMPILER_Allocate(Compiler,
                                        (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount,
                                        &pointer));
        gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount);
        logicalRegs = (slsLOGICAL_REG *)pointer;
        for (i = 0; i < logicalRegCount; i++)
        {
            logicalRegs[i].qualifier = VarName->dataType->qualifiers.storage;
        }
        VarName->context.logicalRegs = logicalRegs;
        VarName->context.logicalRegCount = logicalRegCount;
    }

    for (i = 0; i < count; i++)
    {
        /* If this IO block has instance name, then we must get the members from the instance name. */
        if (isInstance)
        {
            gctSTRING blockNameSymbol = gcvNULL;

            if (!slsNAME_IsPerVertexArray(VarName))
            {
                gcmONERROR(_AllocStructElementAggregatedSymbol(Compiler,
                                                               CodeGenerator,
                                                               VarName->dataType,
                                                               i,
                                                               VarName->symbol,
                                                               gcvNULL,
                                                               &blockNameSymbol));
            }
            else
            {
                blockNameSymbol = VarName->symbol;
            }

            FOR_EACH_DLINK_NODE(&(VarName->dataType->fieldSpace->names), slsNAME, blockMemberName)
            {
                gcmONERROR(_AllocLogicalRegForIOBlockMember(Compiler,
                                                            CodeGenerator,
                                                            BlockName,
                                                            VarName,
                                                            blockMemberName,
                                                            blockNameSymbol,
                                                            (gctINT)i,
                                                            isInstance,
                                                            &fieldIndex,
                                                            &logicalRegs,
                                                            &location));
            }
            if (!slsNAME_IsPerVertexArray(VarName))
            {
                gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, blockNameSymbol));
            }
        }
        else
        {
            FOR_EACH_DLINK_NODE(&BlockName->u.interfaceBlockContent.members,
                                slsINTERFACE_BLOCK_MEMBER, blockMember)
            {
                gcmONERROR(_AllocLogicalRegForIOBlockMember(Compiler,
                                                            CodeGenerator,
                                                            BlockName,
                                                            VarName,
                                                            blockMember->name,
                                                            gcvNULL,
                                                            (gctINT)i,
                                                            isInstance,
                                                            &fieldIndex,
                                                            &logicalRegs,
                                                            &location));
            }
        }
    }

    gcmFOOTER();
    return status;

OnError:
    gcmFOOTER();
    return status;
}

static gceSTATUS
_AllocLogicalRegForInterfaceBlock(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * VarName
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    slsNAME * blockName;
    gcsSHADER_VAR_INFO blockInfo[1];
    gctUINT count, i;
    gctUINT16 blockElemCount;
    gctINT16 arrayPrevSibling, blockPrevSibling;
    gctINT32 offset = 0;
    gctSTRING symbol = gcvNULL;
    slsINTERFACE_BLOCK_MEMBER *blockMember;
    gcSHADER binary;
    gctPOINTER pointer = gcvNULL;
    gctUINT             logicalRegCount = 0;
    slsLOGICAL_REG *    logicalRegs = gcvNULL;
    gctINT    atLeastOneActiveMember;
    gctBOOL isSharedOrStd140OrStd430 = gcvFALSE, needAllocateRegs = gcvTRUE;
    gctBOOL hasInstanceName = gcvFALSE;
    gctINT isArray = (VarName->dataType->arrayLength != 0);
    gcsINTERFACE_BLOCK_INFO *interfaceBlock;
    gctINT32 binding = 0;

    gcmHEADER_ARG("Compiler=0x%x CodeGenerator=0x%x VarName=0x%x",
                  Compiler, CodeGenerator, VarName);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmVERIFY_ARGUMENT(VarName);

    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));
    /* GLSL 3.1 doesn't support arrays of arrays for both uniform block and storage block. */
    if(slsDATA_TYPE_IsUnderlyingInterfaceBlock(VarName->dataType))
    {
       count = (VarName->dataType->arrayLength > 0) ? VarName->dataType->arrayLength : 1;
       hasInstanceName = gcvTRUE;
    }
    else
    {
       count = 1;
    }

    blockName = VarName->u.variableInfo.interfaceBlock;
    gcmASSERT(blockName);
    binding = slmDATA_TYPE_layoutBinding_GET(blockName->dataType);

    if (slsDATA_TYPE_IsUnderlyingIOBlock(blockName->dataType))
    {
        status = _AllocLogicalRegForIOBlock(Compiler,
                                            CodeGenerator,
                                            blockName,
                                            VarName);
        gcmFOOTER();
        return status;
    }

    slsDLINK_NODE_COUNT(&blockName->u.interfaceBlockContent.members, blockElemCount);

    gcmASSERT(blockElemCount);

    gcoOS_ZeroMemory(blockInfo, gcmSIZEOF(gcsSHADER_VAR_INFO));

    symbol = blockName->symbol;
    blockInfo->varCategory = gcSHADER_VAR_CATEGORY_BLOCK;
    blockInfo->format = gcSL_FLOAT;
    blockInfo->precision = gcSHADER_PRECISION_HIGH;
    blockInfo->arraySize = 1;
    blockInfo->u.numBlockElement = blockElemCount;
    blockInfo->parent= -1;

    arrayPrevSibling = -1;
    for (i = 0; i < count; i++)
    {
       blockName->u.interfaceBlockContent.u.interfaceBlockInfo = gcvNULL;
       if (isArray && slsDATA_TYPE_IsUnderlyingInterfaceBlock(VarName->dataType))
       {
          gcmVERIFY_OK(_AllocStructElementAggregatedSymbol(Compiler,
                                                           CodeGenerator,
                                                           VarName->dataType,
                                                           i,
                                                           VarName->u.variableInfo.interfaceBlock->symbol,
                                                           gcvNULL,
                                                           &symbol));
       }

       blockInfo->prevSibling = arrayPrevSibling;
       switch(blockName->dataType->elementType)
       {
       case slvTYPE_UNIFORM_BLOCK:
           status = gcSHADER_AddUniformBlock(binary,
                                             symbol,
                                             blockInfo,
                                             slmInterfaceBlockMemoryLayout(VarName->u.variableInfo.interfaceBlock->dataType->qualifiers.layout),
                                             isArray ? (gctINT16)i : -1,
                                             isArray ? (gctUINT16)count : 0,
                                             &blockName->u.interfaceBlockContent.u.uniformBlock);

           if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

           if (hasInstanceName)
           {
               SetUBFlag(blockName->u.interfaceBlockContent.u.uniformBlock, gceIB_FLAG_WITH_INSTANCE_NAME);
           }
           break;

       case slvTYPE_STORAGE_BLOCK:
           status = gcSHADER_AddStorageBlock(binary,
                                             symbol,
                                             blockInfo,
                                             slmInterfaceBlockMemoryLayout(VarName->u.variableInfo.interfaceBlock->dataType->qualifiers.layout),
                                             &blockName->u.interfaceBlockContent.u.storageBlock);

           if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

           if (hasInstanceName)
           {
               SetSBFlag(blockName->u.interfaceBlockContent.u.storageBlock, gceIB_FLAG_WITH_INSTANCE_NAME);
           }
           break;

       default:
           status = gcvSTATUS_OK;
           break;
       }

       interfaceBlock = blockName->u.interfaceBlockContent.u.interfaceBlockInfo;
       gcmASSERT(interfaceBlock);

       SetIBIBinding(interfaceBlock, binding++);
       if (isArray && slsDATA_TYPE_IsUnderlyingInterfaceBlock(VarName->dataType))
       {
          gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, symbol));
       }

       arrayPrevSibling = GetIBIBlockIndex(interfaceBlock);

       blockPrevSibling = -1;

       if (slsDATA_TYPE_IsUnderlyingInterfaceBlock(VarName->dataType) && i == 0)
       {
           logicalRegCount = _GetLogicalOperandCount(VarName->dataType, gcvFALSE);
           status = sloCOMPILER_Allocate(Compiler,
                                         (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount,
                                         &pointer);
           if (gcmIS_ERROR(status)) break;
           gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount);
           logicalRegs = pointer;
           VarName->context.logicalRegs = logicalRegs;
       }

       offset = 0;
       atLeastOneActiveMember = 0;
       FOR_EACH_DLINK_NODE(&blockName->u.interfaceBlockContent.members, slsINTERFACE_BLOCK_MEMBER, blockMember)
       {
           needAllocateRegs = gcvTRUE;
           gcmASSERT(blockMember->name->dataType);

           if (slsDATA_TYPE_IsUnderlyingInterfaceBlock(VarName->dataType))
           {
              gcmVERIFY_OK(_AllocStructElementAggregatedSymbol(Compiler,
                                                               CodeGenerator,
                                                               blockName->dataType,
                                                               0,
                                                               blockName->symbol,
                                                               blockMember->name->symbol,
                                                               &symbol));
           }
           else
           {
              symbol = blockMember->name->symbol;
              logicalRegCount = _GetLogicalOperandCount(blockMember->name->dataType, gcvFALSE);
              status = sloCOMPILER_Allocate(Compiler,
                                            (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount,
                                            &pointer);
              if (gcmIS_ERROR(status)) break;
              gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount);
              logicalRegs = pointer;

              blockMember->name->context.logicalRegs = logicalRegs;
           }

           atLeastOneActiveMember += blockMember->isActive ? 1 : 0;
           status = _AllocMemoryOffsets(Compiler,
                                        CodeGenerator,
                                        blockMember->name,
                                        symbol,
                                        blockMember->name->dataType,
                                        blockName,
                                        blockMember->isActive,
                                        gcvNULL,
                                        &needAllocateRegs,
                                        &blockPrevSibling,
                                        &logicalRegs,
                                        &offset);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            if (slsDATA_TYPE_IsUnderlyingInterfaceBlock(VarName->dataType)) {
               gcmVERIFY_OK(_FreeStructElementAggregatedSymbol(Compiler, CodeGenerator, symbol));
            }
            else
            {
               gcmASSERT(logicalRegs == (blockMember->name->context.logicalRegs + logicalRegCount));
               blockMember->name->context.logicalRegCount   = logicalRegCount;
            }
        }

        SetIBIBlockSize(interfaceBlock, offset);

        if (blockName->dataType->elementType == slvTYPE_STORAGE_BLOCK)
        {
            status = gcSHADER_SetStorageBlockTopLevelMemberArrayInfo(binary,
                                                                     GetSBFirstChild(blockName->u.interfaceBlockContent.u.storageBlock),
                                                                     gcvTRUE,
                                                                     1,
                                                                     0);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            if(_StorageBlockHasUnsizedArray(binary, blockName->u.interfaceBlockContent.u.storageBlock))
            {
                SetSBFlag(blockName->u.interfaceBlockContent.u.storageBlock, gceIB_FLAG_UNSIZED);
            }
        }

        if ((blockName->dataType->qualifiers.layout.id & slvLAYOUT_SHARED) ||
            (blockName->dataType->qualifiers.layout.id & slvLAYOUT_STD140) ||
            (blockName->dataType->qualifiers.layout.id & slvLAYOUT_STD430))
        {
            isSharedOrStd140OrStd430 = gcvTRUE;
        }

        if (!atLeastOneActiveMember && !isSharedOrStd140OrStd430)
        {
            gcUNIFORM interfaceBlockAddress;

            status = gcSHADER_GetUniform(binary,
                                         GetIBIIndex(interfaceBlock),
                                         &interfaceBlockAddress);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            SetUniformFlag(interfaceBlockAddress, gcvUNIFORM_FLAG_IS_INACTIVE);
        }
    }
    if (slsDATA_TYPE_IsUnderlyingInterfaceBlock(VarName->dataType))
    {
        gcmASSERT(logicalRegs == (VarName->context.logicalRegs + logicalRegCount));
        VarName->context.logicalRegCount   = logicalRegCount;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
slsNAME_AllocLogicalRegs(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name
    )
{
    gceSTATUS           status;
    gctUINT             logicalRegCount;
    slsLOGICAL_REG *    logicalRegs = gcvNULL;
    gctUINT             start = 0;

    gcmHEADER_ARG("Compiler=0x%x CodeGenerator=0x%x Name=0x%x",
                  Compiler, CodeGenerator, Name);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmVERIFY_ARGUMENT(Name);
    gcmASSERT(Name->dataType);
    gcmASSERT(Name->type == slvVARIABLE_NAME
                || Name->type == slvPARAMETER_NAME
                || Name->type == slvFUNC_NAME);

    if (Name->context.logicalRegCount != 0)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    if (Name->type == slvVARIABLE_NAME && Name->u.variableInfo.interfaceBlock) {
        status = _AllocLogicalRegForInterfaceBlock(Compiler,
                                                   CodeGenerator,
                                                   Name);
        if (gcmIS_ERROR(status)) {
           gcmFOOTER();
           return status;
        }
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    if (Name->type == slvPARAMETER_NAME && Name->u.parameterInfo.aliasName != gcvNULL)
    {
        status = slsNAME_CloneContext(Compiler,
                                      Name,
                                      Name->u.parameterInfo.aliasName);

        gcmFOOTER();
        return status;
    }

    logicalRegCount = _GetLogicalOperandCount(Name->dataType, gcvFALSE);
    gcmASSERT(logicalRegCount > 0);

    do
    {
        gctPOINTER pointer = gcvNULL;
        gctINT location = 0;

        status = sloCOMPILER_Allocate(
                                    Compiler,
                                    (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount,
                                    &pointer);

        if (gcmIS_ERROR(status)) break;

        gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG) * logicalRegCount);

        logicalRegs = pointer;

        if (slsDATA_TYPE_IsUnderlyingStruct(Name->dataType) &&
            slmDATA_TYPE_layoutId_GET(Name->dataType) & slvLAYOUT_LOCATION)
        {
            location = slmDATA_TYPE_layoutLocation_GET(Name->dataType);
        }

        status = _AllocLogicalRegs(
                                Compiler,
                                CodeGenerator,
                                Name,
                                Name->symbol,
                                Name->dataType,
                                -1,/* Assume it is not structure */
                                -1,/* Assume it is not structure */
                                gcvNULL,/* Do not need var index on the most top level */
                                gcvNULL,
                                logicalRegs,
                                &start);

        if (gcmIS_ERROR(status)) break;

        if (slsDATA_TYPE_IsUnderlyingStruct(Name->dataType) &&
            slmDATA_TYPE_layoutId_GET(Name->dataType) & slvLAYOUT_LOCATION)
        {
            slmDATA_TYPE_layoutLocation_SET(Name->dataType, location);
        }

        gcmASSERT(start == logicalRegCount);

        Name->context.logicalRegCount   = logicalRegCount;
        Name->context.logicalRegs       = logicalRegs;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    if (logicalRegs != gcvNULL)
    {
        gcmVERIFY_OK(sloCOMPILER_Free(Compiler, logicalRegs));
    }

    gcmFOOTER();
    return status;
}

gctUINT
_getTheRootIdIndex(
    IN gctSTRING Id,
    IN gctINT   IdLength
)
{
    gctINT i = 0;
    for (i=0; i < IdLength; ++i)
    {
        if (Id[i] == '[' ||
            Id[i] == '.')
        {
            break;
        }
    }

    return i;
}

gceSTATUS
slsNAME_SetStaticallyUsed(
    IN sloCOMPILER Compiler,
    IN OUT slsNAME * Name,
    IN slsLOGICAL_REG * LogicalRegs,
    IN gctUINT LogicalRegsCount
    )
{
    gctUINT i;
    slsLOGICAL_REG * logicalReg = LogicalRegs;

    if (Name->dataType->elementType == slvTYPE_IO_BLOCK)
    {
        return gcvSTATUS_OK;
    }

    if (LogicalRegs == gcvNULL || LogicalRegsCount == 0)
    {
        return gcvSTATUS_OK;
    }

    if (Name->dataType->elementType == slvTYPE_STRUCT)
    {
        slsNAME * fieldName;
        gctUINT logicalRegCount;
        gctINT leftLogicalRegCount = (gctINT)LogicalRegsCount;

        FOR_EACH_DLINK_NODE(&Name->dataType->fieldSpace->names, slsNAME, fieldName)
        {
            logicalRegCount = _GetLogicalOperandCount(fieldName->dataType, gcvFALSE);
            leftLogicalRegCount -= (gctINT)logicalRegCount;

            if (leftLogicalRegCount < 0)
            {
                gcmASSERT(0);
                return gcvSTATUS_OK;
            }

            if (fieldName->u.variableInfo.isReferenced)
            {
                slsNAME_SetStaticallyUsed(Compiler, fieldName, logicalReg, logicalRegCount);
            }
            logicalReg += logicalRegCount;
        }

        return gcvSTATUS_OK;
    }

    for(i = 0; i < LogicalRegsCount; i++)
    {
        logicalReg = &LogicalRegs[i];
        switch(logicalReg->qualifier)
        {
            case slvSTORAGE_QUALIFIER_NONE:
            case slvSTORAGE_QUALIFIER_INSTANCE_ID:
            case slvSTORAGE_QUALIFIER_VERTEX_ID:
            case slvSTORAGE_QUALIFIER_IN_IO_BLOCK:
            case slvSTORAGE_QUALIFIER_OUT_IO_BLOCK:
            {
                break;
            }
            case slvSTORAGE_QUALIFIER_CONST_IN:
            case slvSTORAGE_QUALIFIER_IN:
            case slvSTORAGE_QUALIFIER_OUT:
            case slvSTORAGE_QUALIFIER_INOUT:
            {
                break;
            }
            case slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER:
            {
                gcSHADER shader = gcvNULL;
                gcUNIFORM uniform = logicalReg->u.uniform;
                gcsUNIFORM_BLOCK ubo = gcvNULL;

                sloCOMPILER_GetBinary(Compiler, &shader);
                SetUniformFlag(uniform, gcvUNIFORM_FLAG_STATICALLY_USED);
                gcSHADER_GetUniformBlock(shader, uniform->blockIndex, &ubo);
                SetIBIFlag(&ubo->interfaceBlockInfo, gceIB_FLAG_STATICALLY_USED);
                break;
            }
            case slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER:
            {
                gcSHADER shader = gcvNULL;
                gcVARIABLE variable = logicalReg->u.variable;
                gcsSTORAGE_BLOCK ssbo = gcvNULL;
                gctBOOL    markAll = gcvFALSE;
                gctINT     i       = 0;

                sloCOMPILER_GetBinary(Compiler, &shader);

                for (i = 0; i < variable->nameLength; ++i)
                {
                    if (variable->name[i] == '[')
                    {
                        markAll = gcvTRUE;
                        break;
                    }
                }

                if (markAll)
                {
                    gctINT variableCount = 0;
                    gcVARIABLE variablei = gcvNULL;
                    gctUINT    idx0 = _getTheRootIdIndex(variable->name, variable->nameLength);
                    gcSHADER_GetVariableCount(shader, (gctUINT *)&variableCount);

                    if (!IsVariableStaticallyUsed(variable))
                    {
                        for (i = 0; i < variableCount; ++i)
                        {
                            gctUINT idx1 = 0;
                            gctUINT j    = 0;
                            gctBOOL sameRootId = gcvTRUE;

                            gcSHADER_GetVariable(shader, i, &variablei);

                            idx1 = _getTheRootIdIndex(variablei->name, variablei->nameLength);

                            if (idx0 != idx1)
                            {
                                continue;
                            }

                            for (j = 0; j < idx0; ++j)
                            {
                                if (variable->name[j] != variablei->name[j])
                                {
                                    sameRootId = gcvFALSE;
                                }
                            }

                            if (sameRootId)
                            {
                                SetVariableIsStaticallyUsed(variablei);
                                gcSHADER_GetStorageBlock(shader, variablei->blockIndex, &ssbo);
                                SetIBIFlag(&ssbo->interfaceBlockInfo, gceIB_FLAG_STATICALLY_USED);
                            }
                        }
                    }
                }
                else
                {
                    SetVariableIsStaticallyUsed(variable);
                    gcSHADER_GetStorageBlock(shader, variable->blockIndex, &ssbo);
                    SetIBIFlag(&ssbo->interfaceBlockInfo, gceIB_FLAG_STATICALLY_USED);
                }
                break;
            }
            case slvSTORAGE_QUALIFIER_UNIFORM:
            {
                gcUNIFORM uniform = logicalReg->u.uniform;
                SetUniformFlag(uniform, gcvUNIFORM_FLAG_STATICALLY_USED);
                break;
            }
            case slvSTORAGE_QUALIFIER_ATTRIBUTE:
            case slvSTORAGE_QUALIFIER_VARYING_IN:
            case slvSTORAGE_QUALIFIER_IN_IO_BLOCK_MEMBER:
            {
                gcATTRIBUTE attribute = logicalReg->u.attribute;
                gcmATTRIBUTE_SetIsStaticallyUsed(attribute, gcvTRUE);
                break;
            }
            case slvSTORAGE_QUALIFIER_VARYING_OUT:
            case slvSTORAGE_QUALIFIER_FRAGMENT_OUT:
            case slvSTORAGE_QUALIFIER_OUT_IO_BLOCK_MEMBER:
            {
                gcOUTPUT output = logicalReg->u.output;
                gcmOUTPUT_SetIsStaticallyUsed(output, gcvTRUE);
                break;
            }
            default:
                gcmASSERT(0);
        }
    }

    return gcvSTATUS_OK;
}

gceSTATUS
slsNAME_FreeLogicalRegs(
    IN sloCOMPILER Compiler,
    IN slsNAME * Name
    )
{
    gcmHEADER_ARG("Compiler=0x%x Name=0x%x", Compiler, Name);

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmVERIFY_ARGUMENT(Name);

    if (Name->context.logicalRegs != gcvNULL)
    {
        gcmVERIFY_OK(sloCOMPILER_Free(Compiler, Name->context.logicalRegs));
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gctUINT
_GetLogicalArgCount(
    IN slsDATA_TYPE *DataType
    )
{
    gctUINT     count = 0;
    slsNAME *fieldName;

    gcmASSERT(DataType);

    if (DataType->elementType == slvTYPE_STRUCT) {
        gcmASSERT(DataType->fieldSpace);

        FOR_EACH_DLINK_NODE(&DataType->fieldSpace->names, slsNAME, fieldName) {
            gcmASSERT(fieldName->dataType);
            count += _GetLogicalArgCount(fieldName->dataType);
        }
    }
    else {
        count = slmDATA_TYPE_matrixSize_GET(DataType) ? slmDATA_TYPE_matrixSize_GET(DataType) : 1;
    }

    if (DataType->arrayLength > 0) {
        count *= DataType->arrayLength;
    }

    return count;
}

static gceSTATUS
_AllocateFuncResources(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * FuncName,
    IN gctBOOL  intrinsicCall
    )
{
    gceSTATUS   status = gcvSTATUS_OK;
    slsNAME *paramName;
    gctUINT argCount;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(FuncName);

    if (FuncName->context.function != gcvNULL) { gcmFOOTER_NO(); return gcvSTATUS_OK; }

    if (intrinsicCall)
    {
        status = slNewFunction(Compiler,
                               FuncName->lineNo,
                               FuncName->stringNo,
                               FuncName->u.funcInfo.mangled_symbol,
                               &FuncName->context.function);
    }
    else
    {
        status = slNewFunction(Compiler,
                               FuncName->lineNo,
                               FuncName->stringNo,
                               FuncName->symbol,
                               &FuncName->context.function);
    }

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    argCount = 0;

    /* count arguments for all parameters */
    FOR_EACH_DLINK_NODE(&FuncName->u.funcInfo.localSpace->names, slsNAME, paramName)
    {
        if (paramName->type != slvPARAMETER_NAME) break;
        argCount += _GetLogicalArgCount(paramName->dataType);
    }

    /* Count arguments for return value */
    if (!slsDATA_TYPE_IsVoid(FuncName->dataType))
    {
        argCount += _GetLogicalArgCount(FuncName->dataType);
    }

    gcmVERIFY_OK(sloCOMPILER_Dump(Compiler,
                                  slvDUMP_CODE_GENERATOR,
                                  "<FUNCTION ARGUMENT COUNT: function name = \"%s\" "
                                  "argument count = \"%d\" />",
                                  FuncName->symbol,
                                  argCount));

    status = gcFUNCTION_ReallocateArguments(FuncName->context.function, argCount);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Allocate registers for all parameters */
    FOR_EACH_DLINK_NODE(&FuncName->u.funcInfo.localSpace->names, slsNAME, paramName)
    {
        if (paramName->type != slvPARAMETER_NAME) break;

        paramName->context.function = FuncName->context.function;

        status = slsNAME_AllocLogicalRegs(Compiler,
                                          CodeGenerator,
                                          paramName);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    /* Allocate registers for return value */
    if (!slsDATA_TYPE_IsVoid(FuncName->dataType))
    {
        /* Return registers are output */
        FuncName->dataType->qualifiers.storage = slvSTORAGE_QUALIFIER_OUT;

        status = slsNAME_AllocLogicalRegs(Compiler,
                                          CodeGenerator,
                                          FuncName);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_DefineFuncBegin(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_SET FuncBody
    )
{
    gceSTATUS       status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(FuncBody, slvIR_SET);
    gcmASSERT(FuncBody->funcName);

    gcmVERIFY_OK(sloCOMPILER_Dump(Compiler,
                                  slvDUMP_CODE_GENERATOR,
                                  "<FUNC_DEF line=\"%d\" string=\"%d\" name=\"%s\">",
                                  FuncBody->base.lineNo,
                                  FuncBody->base.stringNo,
                                  FuncBody->funcName->symbol));

    if (gcmIS_SUCCESS(gcoOS_StrCmp(FuncBody->funcName->symbol, "main")))
    {
        if (gcmIS_ERROR(sloCOMPILER_MainDefined(Compiler)))
        {
            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                            FuncBody->funcName->lineNo,
                                            FuncBody->funcName->stringNo,
                                            slvREPORT_ERROR,
                                            "'main' function redefined"));

            gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }

        CodeGenerator->currentFuncDefContext.isMain         = gcvTRUE;
        CodeGenerator->currentFuncDefContext.u.mainEndLabel = slNewLabel(Compiler);

        status = slBeginMainFunction(Compiler,
                                     FuncBody->base.lineNo,
                                     FuncBody->base.stringNo);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        CodeGenerator->currentFuncDefContext.isMain         = gcvFALSE;
        CodeGenerator->currentFuncDefContext.u.funcBody     = FuncBody;

        status = _AllocateFuncResources(Compiler,
                                        CodeGenerator,
                                        FuncBody->funcName,
                                        gcvFALSE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        status = slBeginFunction(Compiler,
                                 FuncBody->base.lineNo,
                                 FuncBody->base.stringNo,
                                 FuncBody->funcName->context.function);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_DefineFuncEnd(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_SET FuncBody,
    IN gctBOOL HasReturn
    )
{
    gceSTATUS           status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(FuncBody, slvIR_SET);
    gcmASSERT(FuncBody->funcName);

    if (CodeGenerator->currentFuncDefContext.isMain)
    {
        status = slSetLabel(
                            Compiler,
                            0,
                            0,
                            CodeGenerator->currentFuncDefContext.u.mainEndLabel);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        status = slEndMainFunction(Compiler);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        gcmASSERT(CodeGenerator->currentFuncDefContext.u.funcBody == FuncBody);

        if (!HasReturn)
        {
            if (!slsDATA_TYPE_IsVoid(FuncBody->funcName->dataType))
            {
                /*
                ** If the return type is not void,
                ** any return statements within the function definition must include a return-expression and the type of the
                ** expression must match the return type
                **
                ** spec says The function returns an undefined value and should not be an error
                */
                gcmVERIFY_OK(sloCOMPILER_Report(
                                                Compiler,
                                                FuncBody->base.lineNo,
                                                FuncBody->base.stringNo,
                                                slvREPORT_WARN,
                                                "non-void function: '%s' should return a value",
                                                FuncBody->funcName->symbol));
            }

            status = slEmitAlwaysBranchCode(
                                            Compiler,
                                            FuncBody->base.lineNo,
                                            FuncBody->base.stringNo,
                                            slvOPCODE_RETURN,
                                            0);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }

        status = slEndFunction(Compiler, FuncBody->funcName->context.function);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                                Compiler,
                                slvDUMP_CODE_GENERATOR,
                                "</FUNC_DEF>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
slsLOGICAL_REG_Dump(
    IN sloCOMPILER Compiler,
    IN slsLOGICAL_REG * LogicalReg
    )
{
    gctCONST_STRING     name;
    gctUINT8            i, component;
    const gctCHAR       componentNames[4] = {'x', 'y', 'z', 'w'};
    gcSHADER            binary = gcvNULL;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LogicalReg);

    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));

    switch (LogicalReg->qualifier)
    {
    case slvSTORAGE_QUALIFIER_UNIFORM:
        name = gcGetUniformName(LogicalReg->u.uniform);
        break;

    case slvSTORAGE_QUALIFIER_ATTRIBUTE:
        name = gcGetAttributeName(binary, LogicalReg->u.attribute);
        break;

    default:
        name = "";
    }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                                Compiler,
                                slvDUMP_CODE_GENERATOR,
                                "<LOGICAL_REG qualifier=\"%s\" dataType=\"%s\""
                                " name=\"%s\" regIndex=\"%d\" componentSelection=\"",
                                slGetStorageQualifierName(Compiler, LogicalReg->qualifier),
                                gcGetDataTypeName(LogicalReg->dataType),
                                name,
                                LogicalReg->regIndex));

    for (i = 0; i < LogicalReg->componentSelection.components; i++)
    {
        switch (i)
        {
        case 0: component = LogicalReg->componentSelection.x; break;
        case 1: component = LogicalReg->componentSelection.y; break;
        case 2: component = LogicalReg->componentSelection.z; break;
        case 3: component = LogicalReg->componentSelection.w; break;

        default:
            gcmASSERT(0);
            gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }

        gcmVERIFY_OK(sloCOMPILER_Dump(
                                    Compiler,
                                    slvDUMP_CODE_GENERATOR,
                                    "%c",
                                    componentNames[component]));
    }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                                Compiler,
                                slvDUMP_CODE_GENERATOR,
                                "\" />"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_DumpIndex(
    IN sloCOMPILER Compiler,
    IN gctCONST_STRING Name,
    IN slsINDEX * Index
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(Name);
    gcmASSERT(Index);

    switch (Index->mode)
    {
    case slvINDEX_NONE:
        gcmFOOTER_NO();
        return gcvSTATUS_OK;

    case slvINDEX_REG:
    case slvINDEX_REG_Y:
    case slvINDEX_REG_Z:
    case slvINDEX_REG_W:
        gcmVERIFY_OK(sloCOMPILER_Dump(
                                    Compiler,
                                    slvDUMP_CODE_GENERATOR,
                                    "<%s_REG_INDEX indexRegIndex=\"%d\" />",
                                    Name,
                                    Index->u.indexRegIndex));

        break;

    case slvINDEX_CONSTANT:
        gcmVERIFY_OK(sloCOMPILER_Dump(
                                    Compiler,
                                    slvDUMP_CODE_GENERATOR,
                                    "<%s_CONSTANT_INDEX index=\"%d\" />",
                                    Name,
                                    Index->u.constant));
        break;
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
slsLOPERAND_Dump(
    IN sloCOMPILER Compiler,
    IN slsLOPERAND * LOperand
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LOperand);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                                Compiler,
                                slvDUMP_CODE_GENERATOR,
                                "<LOPERAND dataType=\"%s\">",
                                gcGetDataTypeName(LOperand->dataType)));

    gcmVERIFY_OK(slsLOGICAL_REG_Dump(Compiler, &LOperand->reg));

    gcmVERIFY_OK(_DumpIndex(Compiler, "ARRAY", &LOperand->arrayIndex));

    gcmVERIFY_OK(_DumpIndex(Compiler, "MATRIX", &LOperand->matrixIndex));

    gcmVERIFY_OK(_DumpIndex(Compiler, "VECTOR", &LOperand->vectorIndex));

    gcmVERIFY_OK(sloCOMPILER_Dump(
                                Compiler,
                                slvDUMP_CODE_GENERATOR,
                                "</LOPERAND>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
slsROPERAND_Dump(
    IN sloCOMPILER Compiler,
    IN slsROPERAND * ROperand
    )
{
    gctUINT     i;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                                Compiler,
                                slvDUMP_CODE_GENERATOR,
                                "<ROPERAND dataType=\"%s\">",
                                gcGetDataTypeName(ROperand->dataType)));

    if (ROperand->isReg)
    {
        gcmVERIFY_OK(slsLOGICAL_REG_Dump(Compiler, &ROperand->u.reg));
    }
    else
    {
        gcmVERIFY_OK(sloCOMPILER_Dump(
                                    Compiler,
                                    slvDUMP_CODE_GENERATOR,
                                    "<CONSTANT dataType=\"%s\" valueCount=\"%d\">",
                                    gcGetDataTypeName(ROperand->u.constant.dataType),
                                    ROperand->u.constant.valueCount));

        for (i = 0; i < ROperand->u.constant.valueCount; i++)
        {
            gcmVERIFY_OK(sloCOMPILER_Dump(
                                        Compiler,
                                        slvDUMP_CODE_GENERATOR,
                                        "<VALUE bool=\"%s\" int=\"%d\" float=\"%f\" />",
                                        (ROperand->u.constant.values[i].boolValue) ?
                                            "true" : "false",
                                        ROperand->u.constant.values[i].intValue,
                                        ROperand->u.constant.values[i].floatValue));
        }

        gcmVERIFY_OK(sloCOMPILER_Dump(
                                    Compiler,
                                    slvDUMP_IR,
                                    "</CONSTANT>"));

    }

    gcmVERIFY_OK(_DumpIndex(Compiler, "ARRAY", &ROperand->arrayIndex));

    gcmVERIFY_OK(_DumpIndex(Compiler, "MATRIX", &ROperand->matrixIndex));

    gcmVERIFY_OK(_DumpIndex(Compiler, "VECTOR", &ROperand->vectorIndex));

    gcmVERIFY_OK(sloCOMPILER_Dump(
                                Compiler,
                                slvDUMP_CODE_GENERATOR,
                                "</ROPERAND>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
slsIOPERAND_Dump(
    IN sloCOMPILER Compiler,
    IN slsIOPERAND * IOperand
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                                Compiler,
                                slvDUMP_CODE_GENERATOR,
                                "<IOPERAND dataType=\"%s\" tempRegIndex=\"%d\" />",
                                gcGetDataTypeName(IOperand->dataType),
                                IOperand->tempRegIndex));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static slsCOMPONENT_SELECTION
_ReverseComponentSelection(
    IN slsCOMPONENT_SELECTION Source
    )
{
    slsCOMPONENT_SELECTION  result;

    result = ComponentSelection_XYZW;

    switch (Source.x)
    {
    case slvCOMPONENT_X: result.x = slvCOMPONENT_X; break;
    case slvCOMPONENT_Y: result.y = slvCOMPONENT_X; break;
    case slvCOMPONENT_Z: result.z = slvCOMPONENT_X; break;
    case slvCOMPONENT_W: result.w = slvCOMPONENT_X; break;

    default: gcmASSERT(0);
    }

    if (Source.components >= 2)
    {
        switch (Source.y)
        {
        case slvCOMPONENT_X: result.x = slvCOMPONENT_Y; break;
        case slvCOMPONENT_Y: result.y = slvCOMPONENT_Y; break;
        case slvCOMPONENT_Z: result.z = slvCOMPONENT_Y; break;
        case slvCOMPONENT_W: result.w = slvCOMPONENT_Y; break;

        default: gcmASSERT(0);
        }
    }

    if (Source.components >= 3)
    {
        switch (Source.z)
        {
        case slvCOMPONENT_X: result.x = slvCOMPONENT_Z; break;
        case slvCOMPONENT_Y: result.y = slvCOMPONENT_Z; break;
        case slvCOMPONENT_Z: result.z = slvCOMPONENT_Z; break;
        case slvCOMPONENT_W: result.w = slvCOMPONENT_Z; break;

        default: gcmASSERT(0);
        }
    }

    if (Source.components == 4)
    {
        switch (Source.w)
        {
        case slvCOMPONENT_X: result.x = slvCOMPONENT_W; break;
        case slvCOMPONENT_Y: result.y = slvCOMPONENT_W; break;
        case slvCOMPONENT_Z: result.z = slvCOMPONENT_W; break;
        case slvCOMPONENT_W: result.w = slvCOMPONENT_W; break;

        default: gcmASSERT(0);
        }
    }

    return result;
}

static slsCOMPONENT_SELECTION
_SwizzleComponentSelection(
    IN slsCOMPONENT_SELECTION Source1,
    IN slsCOMPONENT_SELECTION Source2
    )
{
    slsCOMPONENT_SELECTION  result = { 0 };

    result.components = Source1.components;

    switch (Source2.components)
    {
    case 1: Source2.w = Source2.z = Source2.y = Source2.x; break;
    case 2: Source2.w = Source2.z = Source2.y; break;
    case 3: Source2.w = Source2.z; break;
    case 4: break;

    default: gcmASSERT(0);
    }

    switch (Source1.x)
    {
    case slvCOMPONENT_X: result.x = Source2.x; break;
    case slvCOMPONENT_Y: result.x = Source2.y; break;
    case slvCOMPONENT_Z: result.x = Source2.z; break;
    case slvCOMPONENT_W: result.x = Source2.w; break;

    default: gcmASSERT(0);
    }

    if (Source1.components >= 2)
    {
        switch (Source1.y)
        {
        case slvCOMPONENT_X: result.y = Source2.x; break;
        case slvCOMPONENT_Y: result.y = Source2.y; break;
        case slvCOMPONENT_Z: result.y = Source2.z; break;
        case slvCOMPONENT_W: result.y = Source2.w; break;

        default: gcmASSERT(0);
        }
    }

    if (Source1.components >= 3)
    {
        switch (Source1.z)
        {
        case slvCOMPONENT_X: result.z = Source2.x; break;
        case slvCOMPONENT_Y: result.z = Source2.y; break;
        case slvCOMPONENT_Z: result.z = Source2.z; break;
        case slvCOMPONENT_W: result.z = Source2.w; break;

        default: gcmASSERT(0);
        }
    }

    if (Source1.components == 4)
    {
        switch (Source1.w)
        {
        case slvCOMPONENT_X: result.w = Source2.x; break;
        case slvCOMPONENT_Y: result.w = Source2.y; break;
        case slvCOMPONENT_Z: result.w = Source2.z; break;
        case slvCOMPONENT_W: result.w = Source2.w; break;

        default: gcmASSERT(0);
        }
    }

    return result;
}

static void
_CopySelectionToArray(
    IN slsCOMPONENT_SELECTION CompSel,
    OUT gctUINT8 *SelArr
    )
{
    SelArr[slvCOMPONENT_X] = CompSel.x;
    SelArr[slvCOMPONENT_Y] = CompSel.y;
    SelArr[slvCOMPONENT_Z] = CompSel.z;
    SelArr[slvCOMPONENT_W] = CompSel.w;
    return;
}

static gceSTATUS
_SwizzleOperandConstant(
    IN slsOPERAND_CONSTANT * OperandConstant,
    IN slsCOMPONENT_SELECTION CompSel,
    OUT slsOPERAND_CONSTANT * Res
    )
{
    gctUINT i;
    gctUINT8 selection[sldMAX_VECTOR_COMPONENT];

    slsCOMPONENT_SELECTION  resSel;

    resSel = _SwizzleComponentSelection(CompSel,
                                        slGetDefaultComponentSelection(OperandConstant->dataType));

    _CopySelectionToArray(resSel, selection);
    Res->valueCount = resSel.components;
    for(i = 0; i < resSel.components; i++) {
        Res->values[i] = OperandConstant->values[selection[i]];
    }

    Res->dataType = gcConvScalarToVectorDataType(gcGetComponentDataType(OperandConstant->dataType),
                                                 resSel.components);

    return gcvSTATUS_OK;
}

static slsCOMPONENT_SELECTION
_ConvVectorIndexToComponentSelection(
    IN gctUINT VectorIndex
    )
{
    switch (VectorIndex)
    {
    case 0: return ComponentSelection_X;
    case 1: return ComponentSelection_Y;
    case 2: return ComponentSelection_Z;
    case 3: return ComponentSelection_W;

    default:
        gcmASSERT(0);
        return ComponentSelection_X;
    }
}

static sleINDEX_MODE
_ConvVectorIndexToIndexMode(
    IN gctUINT VectorIndex
    )
{
    switch (VectorIndex)
    {
    case 0: return slvINDEX_REG;
    case 1: return slvINDEX_REG_Y;
    case 2: return slvINDEX_REG_Z;
    case 3: return slvINDEX_REG_W;

    default:
        gcmASSERT(0);
        return slvINDEX_REG;
    }
}

static gctUINT8
_ConvComponentToEnable(
    IN gctUINT8 Component
    )
{
    switch (Component)
    {
    case slvCOMPONENT_X: return gcSL_ENABLE_X;
    case slvCOMPONENT_Y: return gcSL_ENABLE_Y;
    case slvCOMPONENT_Z: return gcSL_ENABLE_Z;
    case slvCOMPONENT_W: return gcSL_ENABLE_W;

    default:
        gcmASSERT(0);
        return gcSL_ENABLE_X;
    }
}


static gctUINT8
_ConvComponentSelectionToEnable(
    IN slsCOMPONENT_SELECTION ComponentSelection
    )
{
    gctUINT8    enable;

    enable = _ConvComponentToEnable(ComponentSelection.x);

    if (ComponentSelection.components >= 2)
    {
        enable |= _ConvComponentToEnable(ComponentSelection.y);
    }

    if (ComponentSelection.components >= 3)
    {
        enable |= _ConvComponentToEnable(ComponentSelection.z);
    }

    if (ComponentSelection.components == 4)
    {
        enable |= _ConvComponentToEnable(ComponentSelection.w);
    }

    return enable;
}

static gceSTATUS
_ConvLOperandToTarget(
    IN sloCOMPILER Compiler,
    IN slsLOPERAND * LOperand,
    OUT gcsTARGET * Target,
    OUT slsCOMPONENT_SELECTION * ReversedComponentSelection
    )
{
    gctREG_INDEX            tempRegIndex;
    gctUINT8                enable = 0;
    gcSL_INDEXED            indexMode;
    gctREG_INDEX            indexRegIndex;
    slsCOMPONENT_SELECTION  reversedComponentSelection = { 0 };

    gcmHEADER();

    reversedComponentSelection.components = 0;

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LOperand);
    gcmASSERT(!gcIsMatrixDataType(LOperand->dataType));
    gcmASSERT(Target);
    gcmASSERT(ReversedComponentSelection);

    tempRegIndex    = LOperand->reg.regIndex;

    switch (LOperand->arrayIndex.mode)
    {
    case slvINDEX_NONE:
        indexMode       = gcSL_NOT_INDEXED;
        indexRegIndex   = 0;
        break;

    case slvINDEX_REG:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_X;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Y:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_Y;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Z:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_Z;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_W:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_W;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    if (gcIsSamplerDataType(LOperand->dataType))
    {
        gcmASSERT(gcIsSamplerDataType(LOperand->reg.dataType));

        enable                      = gcGetDefaultEnable(LOperand->dataType);
        reversedComponentSelection  = slGetDefaultComponentSelection(LOperand->dataType);
    }
    else if (gcIsImageDataType(LOperand->dataType))
    {
        gcmASSERT(gcIsImageDataType(LOperand->reg.dataType));

        enable                      = gcGetDefaultEnable(LOperand->dataType);
        reversedComponentSelection  = slGetDefaultComponentSelection(LOperand->dataType);
    }
    else if (gcIsScalarDataType(LOperand->dataType))
    {
        if (gcIsScalarDataType(LOperand->reg.dataType))
        {
            enable                      = gcGetDefaultEnable(LOperand->dataType);
            reversedComponentSelection  = slGetDefaultComponentSelection(LOperand->dataType);
        }
        else
        {
            gcmASSERT(gcIsVectorDataType(LOperand->reg.dataType)
                        || gcIsMatrixDataType(LOperand->reg.dataType));

            switch (LOperand->vectorIndex.mode)
            {
            case slvINDEX_CONSTANT:
                reversedComponentSelection = _ConvVectorIndexToComponentSelection(
                                                        LOperand->vectorIndex.u.indexRegIndex);

                reversedComponentSelection = _SwizzleComponentSelection(
                                                        reversedComponentSelection,
                                                        LOperand->reg.componentSelection);

                enable = _ConvComponentSelectionToEnable(reversedComponentSelection);

                reversedComponentSelection = _ReverseComponentSelection(reversedComponentSelection);
                break;

            default:
                gcmASSERT(0);
                gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }

            if (gcIsMatrixDataType(LOperand->reg.dataType))
            {
                switch (LOperand->matrixIndex.mode)
                {
                case slvINDEX_CONSTANT:
                    tempRegIndex += LOperand->matrixIndex.u.constant;
                    break;

                case slvINDEX_REG:
                    gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

                    indexMode       = gcSL_INDEXED_X;
                    indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
                    break;

                case slvINDEX_REG_Y:
                    gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

                    indexMode       = gcSL_INDEXED_Y;
                    indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
                    break;

                case slvINDEX_REG_Z:
                    gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

                    indexMode       = gcSL_INDEXED_Z;
                    indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
                    break;

                case slvINDEX_REG_W:
                    gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

                    indexMode       = gcSL_INDEXED_W;
                    indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
                    break;

                default:
                    gcmASSERT(0);
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
            }
        }
    }
    else if (gcIsVectorDataType(LOperand->dataType))
    {
        gcmASSERT(gcIsVectorDataType(LOperand->reg.dataType)
                    || gcIsMatrixDataType(LOperand->reg.dataType));

        enable = _ConvComponentSelectionToEnable(LOperand->reg.componentSelection);

        reversedComponentSelection = _ReverseComponentSelection(LOperand->reg.componentSelection);

        if (gcIsMatrixDataType(LOperand->reg.dataType))
        {
            switch (LOperand->matrixIndex.mode)
            {
            case slvINDEX_CONSTANT:
                tempRegIndex += LOperand->matrixIndex.u.constant;
                break;

            case slvINDEX_REG:
                gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

                indexMode       = gcSL_INDEXED_X;
                indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
                break;

            case slvINDEX_REG_Y:
                gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

                indexMode       = gcSL_INDEXED_Y;
                indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
                break;

            case slvINDEX_REG_Z:
                gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

                indexMode       = gcSL_INDEXED_Z;
                indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
                break;

            case slvINDEX_REG_W:
                gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

                indexMode       = gcSL_INDEXED_W;
                indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
                break;

            default:
                gcmASSERT(0);
                gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }
        }
    }
    else
    {
        gcmASSERT(0);
    }

    gcsTARGET_Initialize(Target,
                         LOperand->dataType,
                         LOperand->reg.precision,
                         tempRegIndex,
                         enable,
                         indexMode,
                         indexRegIndex);

    *ReversedComponentSelection = reversedComponentSelection;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvLOperandToVectorComponentTarget(
    IN sloCOMPILER Compiler,
    IN slsLOPERAND * LOperand,
    IN gctUINT VectorIndex,
    OUT gcsTARGET * Target
    )
{
    gctREG_INDEX            tempRegIndex;
    gctUINT8                enable;
    gcSL_INDEXED            indexMode;
    gctREG_INDEX            indexRegIndex;
    slsCOMPONENT_SELECTION  componentSelection;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LOperand);
    gcmASSERT(gcIsVectorDataType(LOperand->dataType));
    gcmASSERT(Target);

    tempRegIndex    = LOperand->reg.regIndex;

    switch (LOperand->arrayIndex.mode)
    {
    case slvINDEX_NONE:
        indexMode       = gcSL_NOT_INDEXED;
        indexRegIndex   = 0;
        break;

    case slvINDEX_REG:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_X;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Y:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_Y;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Z:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_Z;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_W:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_W;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    gcmASSERT(gcIsVectorDataType(LOperand->reg.dataType)
                || gcIsMatrixDataType(LOperand->reg.dataType));

    componentSelection = _ConvVectorIndexToComponentSelection(VectorIndex);

    componentSelection = _SwizzleComponentSelection(
                                            componentSelection,
                                            LOperand->reg.componentSelection);

    enable = _ConvComponentSelectionToEnable(componentSelection);

    if (gcIsMatrixDataType(LOperand->reg.dataType))
    {
        switch (LOperand->matrixIndex.mode)
        {
        case slvINDEX_CONSTANT:
            tempRegIndex += LOperand->matrixIndex.u.constant;
            break;

        case slvINDEX_REG:
            gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

            indexMode       = gcSL_INDEXED_X;
            indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
            break;

        case slvINDEX_REG_Y:
            gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

            indexMode       = gcSL_INDEXED_Y;
            indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
            break;

        case slvINDEX_REG_Z:
            gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

            indexMode       = gcSL_INDEXED_Z;
            indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
            break;

        case slvINDEX_REG_W:
            gcmASSERT(LOperand->arrayIndex.mode != slvINDEX_REG);

            indexMode       = gcSL_INDEXED_W;
            indexRegIndex   = LOperand->matrixIndex.u.indexRegIndex;
            break;

        default:
            gcmASSERT(0);
            gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }
    }

    gcsTARGET_Initialize(Target,
                         gcGetVectorComponentDataType(LOperand->dataType),
                         LOperand->reg.precision,
                         tempRegIndex,
                         enable,
                         indexMode,
                         indexRegIndex);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvLOperandToMatrixColumnTarget(
    IN sloCOMPILER Compiler,
    IN slsLOPERAND * LOperand,
    IN gctUINT MatrixIndex,
    OUT gcsTARGET * Target
    )
{
    gcSHADER_TYPE           dataType;
    gctREG_INDEX            tempRegIndex;
    gctUINT8                enable;
    gcSL_INDEXED            indexMode;
    gctREG_INDEX            indexRegIndex;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LOperand);
    gcmASSERT(gcIsMatrixDataType(LOperand->dataType));
    gcmASSERT(gcIsMatrixDataType(LOperand->reg.dataType));
    gcmASSERT(Target);

    dataType        = gcGetMatrixColumnDataType(LOperand->dataType);
    tempRegIndex    = (gctREG_INDEX) (LOperand->reg.regIndex + MatrixIndex);
    enable          = gcGetDefaultEnable(dataType);

    switch (LOperand->arrayIndex.mode)
    {
    case slvINDEX_NONE:
        indexMode       = gcSL_NOT_INDEXED;
        indexRegIndex   = 0;
        break;

    case slvINDEX_REG:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_X;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Y:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_Y;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Z:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_Z;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_W:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_W;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    gcsTARGET_Initialize(Target,
                         dataType,
                         LOperand->reg.precision,
                         tempRegIndex,
                         enable,
                         indexMode,
                         indexRegIndex);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvLOperandToMatrixComponentTarget(
    IN sloCOMPILER Compiler,
    IN slsLOPERAND * LOperand,
    IN gctUINT MatrixIndex,
    IN gctUINT VectorIndex,
    OUT gcsTARGET * Target
    )
{
    gcSHADER_TYPE           dataType;
    gctREG_INDEX            tempRegIndex;
    gctUINT8                enable;
    gcSL_INDEXED            indexMode;
    gctREG_INDEX            indexRegIndex;
    const gctUINT8          enableTable[4] =
                                {gcSL_ENABLE_X, gcSL_ENABLE_Y, gcSL_ENABLE_Z, gcSL_ENABLE_W};

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LOperand);
    gcmASSERT(gcIsMatrixDataType(LOperand->dataType));
    gcmASSERT(gcIsMatrixDataType(LOperand->reg.dataType));
    gcmASSERT(Target);

    dataType        = gcGetVectorComponentDataType(gcGetMatrixColumnDataType(LOperand->dataType));
    tempRegIndex    = (gctREG_INDEX) (LOperand->reg.regIndex + MatrixIndex);
    enable          = enableTable[VectorIndex];

    switch (LOperand->arrayIndex.mode)
    {
    case slvINDEX_NONE:
        indexMode       = gcSL_NOT_INDEXED;
        indexRegIndex   = 0;
        break;

    case slvINDEX_REG:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_X;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Y:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_Y;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Z:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_Z;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_W:
        gcmASSERT(LOperand->matrixIndex.mode != slvINDEX_REG);

        indexMode       = gcSL_INDEXED_W;
        indexRegIndex   = LOperand->arrayIndex.u.indexRegIndex;
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    gcsTARGET_Initialize(Target,
                         dataType,
                         LOperand->reg.precision,
                         tempRegIndex,
                         enable,
                         indexMode,
                         indexRegIndex);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gctUINT8
_ConvComponentToSwizzle(
    IN gctUINT8 Component
    )
{
    switch (Component)
    {
    case slvCOMPONENT_X: return gcSL_SWIZZLE_X;
    case slvCOMPONENT_Y: return gcSL_SWIZZLE_Y;
    case slvCOMPONENT_Z: return gcSL_SWIZZLE_Z;
    case slvCOMPONENT_W: return gcSL_SWIZZLE_W;

    default:
        gcmASSERT(0);
        return gcSL_SWIZZLE_X;
    }
}

static gctUINT8
_ConvComponentSelectionToSwizzle(
    IN slsCOMPONENT_SELECTION ComponentSelection
    )
{
    gctUINT8 swizzle = _ConvComponentToSwizzle(ComponentSelection.x);

    swizzle |= (ComponentSelection.components >= 2)
            ?  ( _ConvComponentToSwizzle(ComponentSelection.y) << 2)
            :  ((swizzle & 0x03) << 2);

    swizzle |= (ComponentSelection.components >= 3)
            ?  (_ConvComponentToSwizzle(ComponentSelection.z) << 4)
            :  ((swizzle & 0x0C) << 2);

    swizzle |= (ComponentSelection.components >= 4)
            ?  (_ConvComponentToSwizzle(ComponentSelection.w) << 6)
            :  ((swizzle & 0x30) << 2);

    return swizzle;
}

static gceSOURCE_TYPE
_ConvQualifierToSourceType(
    IN sltSTORAGE_QUALIFIER Qualifier
    )
{
    switch (Qualifier)
    {
    case slvSTORAGE_QUALIFIER_NONE:
    case slvSTORAGE_QUALIFIER_CONST_IN:
    case slvSTORAGE_QUALIFIER_IN:
    case slvSTORAGE_QUALIFIER_OUT:
    case slvSTORAGE_QUALIFIER_INOUT:
    case slvSTORAGE_QUALIFIER_VARYING_OUT:
    case slvSTORAGE_QUALIFIER_FRAGMENT_OUT:
    case slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER:
    case slvSTORAGE_QUALIFIER_SHARED:
    case slvSTORAGE_QUALIFIER_OUT_IO_BLOCK_MEMBER:
        return gcvSOURCE_TEMP;

    case slvSTORAGE_QUALIFIER_UNIFORM:
    case slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER:
        return gcvSOURCE_UNIFORM;

    case slvSTORAGE_QUALIFIER_ATTRIBUTE:
    case slvSTORAGE_QUALIFIER_VARYING_IN:
    case slvSTORAGE_QUALIFIER_IN_IO_BLOCK_MEMBER:
        return gcvSOURCE_ATTRIBUTE;

    case slvSTORAGE_QUALIFIER_VERTEX_ID:
        return gcvSOURCE_VERTEX_ID;

    case slvSTORAGE_QUALIFIER_INSTANCE_ID:
        return gcvSOURCE_INSTANCE_ID;

    default:
        gcmASSERT(0);
        return gcvSOURCE_TEMP;
    }
}

static gceSTATUS
_ConvIOperandToTarget(
    IN sloCOMPILER Compiler,
    IN slsIOPERAND * IOperand,
    OUT gcsTARGET * Target
    )
{
    slsLOPERAND             lOperand;
    slsCOMPONENT_SELECTION  reversedComponentSelection;
    gceSTATUS               status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(!gcIsMatrixDataType(IOperand->dataType));
    gcmASSERT(Target);

    slsLOPERAND_InitializeUsingIOperand(&lOperand, IOperand);

    status = _ConvLOperandToTarget(
                                Compiler,
                                &lOperand,
                                Target,
                                &reversedComponentSelection);
    gcmFOOTER();
    return status;
}

#define _IsROperandUniformBlockMember(Compiler, ROperand) \
    (sloCOMPILER_IsHaltiVersion(Compiler) && \
     (ROperand)->isReg && \
     (ROperand)->u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER)

#define _IsROperandStorageBlockMember(Compiler, ROperand) \
    (sloCOMPILER_IsHaltiVersion(Compiler) && \
     (ROperand)->isReg && \
     (ROperand)->u.reg.qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER)

#define _IsLOperandStorageBlockMember(Compiler, LOperand) \
    (sloCOMPILER_IsHaltiVersion(Compiler) && \
     (LOperand)->reg.qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER)

#define _IsROperandInterfaceBlockMember(Compiler, ROperand) \
    (sloCOMPILER_IsHaltiVersion(Compiler) && \
     (ROperand)->isReg && \
     ((ROperand)->u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER || \
      (ROperand)->u.reg.qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER))

#define _IsLOperandInterfaceBlockMember(Compiler, LOperand) \
    (sloCOMPILER_IsHaltiVersion(Compiler) && \
     ((LOperand)->reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER || \
      (LOperand)->reg.qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER))

#define _IsLOperandIOBlock(Compiler, LOperand) \
    (sloCOMPILER_IsHaltiVersion(Compiler) && \
     (LOperand)->reg.qualifier == slvSTORAGE_QUALIFIER_OUT_IO_BLOCK)

#define _IsLOperandIOBlockMember(Compiler, LOperand) \
    (sloCOMPILER_IsHaltiVersion(Compiler) && \
     (LOperand)->reg.qualifier == slvSTORAGE_QUALIFIER_OUT_IO_BLOCK_MEMBER)

#define _IsROperandIOBlock(Compiler, ROperand) \
    (sloCOMPILER_IsHaltiVersion(Compiler) && \
     (ROperand)->isReg && \
     ((ROperand)->u.reg.qualifier == slvSTORAGE_QUALIFIER_IN_IO_BLOCK || \
      (ROperand)->u.reg.qualifier == slvSTORAGE_QUALIFIER_OUT_IO_BLOCK))

#define _IsROperandIOBlockMember(Compiler, ROperand) \
    (sloCOMPILER_IsHaltiVersion(Compiler) && \
     (ROperand)->isReg && \
     ((ROperand)->u.reg.qualifier == slvSTORAGE_QUALIFIER_IN_IO_BLOCK_MEMBER || \
      (ROperand)->u.reg.qualifier == slvSTORAGE_QUALIFIER_OUT_IO_BLOCK_MEMBER))

static gctBOOL
_IsResultSwizzled(
    IN slsIOPERAND *IOperand,
    IN slsCOMPONENT_SELECTION *ComponentSelection
    )
{
    gctUINT8 componentCount;
    gctBOOL isSwizzled = gcvTRUE;

    componentCount  = gcGetDataTypeComponentCount(IOperand->dataType);
    if(ComponentSelection->components == componentCount) {
        switch(ComponentSelection->components) {
        case 1:
            if(ComponentSelection->x == slvCOMPONENT_X) {
                isSwizzled = gcvFALSE;
            }
            break;

        case 2:
            if(ComponentSelection->x == slvCOMPONENT_X &&
               ComponentSelection->y == slvCOMPONENT_Y) {
                 isSwizzled = gcvFALSE;
            }
            break;

        case 3:
            if(ComponentSelection->x == slvCOMPONENT_X  &&
               ComponentSelection->y == slvCOMPONENT_Y  &&
               ComponentSelection->z == slvCOMPONENT_Z) {
                 isSwizzled = gcvFALSE;
            }
            break;

        case 4:
            if(ComponentSelection->x == slvCOMPONENT_X &&
               ComponentSelection->y == slvCOMPONENT_Y &&
               ComponentSelection->z == slvCOMPONENT_Z &&
               ComponentSelection->w == slvCOMPONENT_W) {
                isSwizzled = gcvFALSE;
            }
            break;

        default:
            gcmASSERT(0);
            isSwizzled = gcvFALSE;
            break;
        }
    }
    return isSwizzled;
}

#define _slmComputeIntConstantPrecision(intConstant) \
    ((((intConstant) >= -32768) && ((intConstant) <= 32767)) ? gcSHADER_PRECISION_MEDIUM \
                                                             : gcSHADER_PRECISION_HIGH)

#define _slmComputeUintConstantPrecision(uintConstant) \
    (((uintConstant) <= 0xFFFF) ? gcSHADER_PRECISION_MEDIUM \
                                : gcSHADER_PRECISION_HIGH)

static gctINT
_GetUnderlyingVariableArrayStride(
    IN sloCOMPILER Compiler,
    IN slsDATA_TYPE *DataType,
    IN slsLOGICAL_REG *Reg
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcSHADER shader;
    gctINT arrayStride = -1;

    gcmASSERT(Reg->qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER ||
              Reg->qualifier == slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER);

    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &shader));
    if(Reg->qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER)
    {
        gcVARIABLE variable;
        gcVARIABLE parentVariable;
        gctINT i;

        variable = Reg->u.variable;
        if(slsDATA_TYPE_IsUnderlyingStruct(DataType)) {
            gcmASSERT(variable->parent != -1);

            gcmONERROR(gcSHADER_GetVariable(shader,
                                            variable->parent,
                                            &parentVariable));

            while (parentVariable->parent != -1 &&
                   isVariableStruct(parentVariable))
            {
                gcmONERROR(gcSHADER_GetVariable(shader,
                                                parentVariable->parent,
                                                &parentVariable));
            }
            variable = parentVariable;
        }

        gcmASSERT(isVariableArray(variable) &&
                  variable->arrayStride > 0);
        arrayStride = GetVariableArrayStride(variable);

        for (i = DataType->arrayLevel + 1; i < variable->arrayLengthCount; i++)
        {
            arrayStride *= variable->arrayLengthList[i];
        }
    }
    else if(Reg->qualifier == slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER)
    {
        gcUNIFORM uniform;
        gcUNIFORM parentUniform;

        uniform = Reg->u.uniform;
        if(slsDATA_TYPE_IsUnderlyingStruct(DataType)) {
            gcmASSERT(uniform->parent != -1);

            gcmONERROR(gcSHADER_GetUniform(shader,
                                           uniform->parent,
                                           &parentUniform));

            while (isUniformStruct(parentUniform) &&
                   parentUniform->parent != -1)
            {
                gcmONERROR(gcSHADER_GetUniform(shader,
                                               parentUniform->parent,
                                               &parentUniform));
            }
            uniform = parentUniform;
        }
        gcmASSERT(isUniformArray(uniform) &&
                  uniform->arrayStride > 0);
        arrayStride = GetUniformArrayStride(uniform);
    }

OnError:
    return arrayStride;
}

static gceSTATUS
_LoadInterfaceBlockMember(
    IN sloCOMPILER Compiler,
    IN slsROPERAND * ROperand,
    IN slsCOMPONENT_SELECTION ReversedComponentSelection,
    IN gctUINT MatrixIndex,
    IN OUT slsROPERAND *ResOperand
    )
{
    gceSTATUS status;
    union _sluObjPtrs ptr;
    gcUNIFORM blockAddressUniform;
    gcSHADER binary;
    slsIOPERAND iOperand[1];
    slsROPERAND rOperand[1];
    slsLOPERAND lOperand[1];
    gcsSOURCE_REG  sourceReg = { {0} };
    gcsSOURCE address[1];
    gcsSOURCE offsetSource[1];
    gcsTARGET target[1];
    gcSHADER_TYPE targetDataType;
    slsROPERAND offset[1];
    gctINT addressOffset;
    gctBOOL constantOffset = gcvTRUE;
    slsCOMPONENT_SELECTION componentSelection = { 0 };
    gctBOOL hasComponentSelection = gcvFALSE;
    slsROPERAND constantROperand[1];
    sluCONSTANT_VALUE constantValue[1];
    slsROPERAND intermROperand[1], intermROperand1[1];
    slsIOPERAND intermIOperand[1];
    slsLOPERAND intermLOperand[1];
    slsIOPERAND offsetIOperand[1];
    gctINT rowMajorStride = 0;
    gctBOOL isRowMajor = gcvFALSE;
    gctINT arrayStride = 0;
    gctINT matrixStride = 0;
    gctINT arraySize = 1;
    gcSHADER_PRECISION precision;
    gctBOOL isIndexedMatrix = gcvFALSE;
    gctUINT8 componentCount = 0;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand &&
              (ROperand->u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER ||
               ROperand->u.reg.qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER));

    gcmASSERT(ResOperand);

    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));
    switch(ROperand->u.reg.qualifier) {
    case slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER:
        addressOffset = ROperand->u.reg.u.uniform->offset + ROperand->u.reg.regIndex;
        isRowMajor = ROperand->u.reg.u.uniform->isRowMajor;
        arrayStride = ROperand->u.reg.u.uniform->arrayStride;
        matrixStride = ROperand->u.reg.u.uniform->matrixStride;
        arraySize = ROperand->u.reg.u.uniform->arraySize;
        status = gcSHADER_GetUniformBlock(binary,
                                          ROperand->u.reg.u.uniform->blockIndex,
                                          &ptr.uniformBlock);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        break;

    case slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER:
        addressOffset = ROperand->u.reg.u.variable->offset + ROperand->u.reg.regIndex;
        isRowMajor = GetVariableIsRowMajor(ROperand->u.reg.u.variable);
        matrixStride = ROperand->u.reg.u.variable->matrixStride;
        arraySize = ROperand->u.reg.u.variable->arraySize;
        arrayStride = ROperand->u.reg.u.variable->arrayStride;
        status = gcSHADER_GetStorageBlock(binary,
                                          ROperand->u.reg.u.variable->blockIndex,
                                          &ptr.storageBlock);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
         break;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    sourceReg.indexMode = gcSL_NOT_INDEXED;
    sourceReg.indexRegIndex = 0;
    sourceReg.swizzle = gcSL_SWIZZLE_X;
    if(GetIBIFlag(ptr.interfaceBlock) & gceIB_FLAG_FOR_SHARED_VARIABLE) {
        sourceReg.u.uniform   = gcvNULL;
        gcmASSERT(GetIBISharedVariableBaseAddress(ptr.interfaceBlock) != -1);
        sourceReg.regIndex = GetIBISharedVariableBaseAddress(ptr.interfaceBlock);
        gcsSOURCE_InitializeReg(address,
                                _ConvQualifierToSourceType(slvSTORAGE_QUALIFIER_NONE),
                                gcSHADER_UINT_X1,
                                ROperand->u.reg.precision,
                                sourceReg);
    }
    else {
        status = gcSHADER_GetUniform(binary,
                                     GetIBIIndex(ptr.interfaceBlock),
                                     &blockAddressUniform);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        sourceReg.u.uniform   = blockAddressUniform;
        sourceReg.regIndex = 0;
        /* set index */
        if(ROperand->vertexIndex.mode != slvINDEX_NONE)
        {
            sourceReg.indexMode = gcSL_INDEXED_X;
            sourceReg.indexRegIndex = ROperand->vertexIndex.u.indexRegIndex;
        }
        else if(GetIBIArrayIndex(ptr.interfaceBlock) >= 0)
        {
            sourceReg.regIndex = GetIBIArrayIndex(ptr.interfaceBlock);
        }
        gcsSOURCE_InitializeReg(address,
                                _ConvQualifierToSourceType(slvSTORAGE_QUALIFIER_UNIFORM),
                                gcSHADER_UINT_X1,
                                gcSHADER_PRECISION_HIGH,        /* address uniform must be highp */
                                sourceReg);
    }
    if(gcIsMatrixDataType(ROperand->u.reg.dataType)) {
        targetDataType = gcGetMatrixColumnDataType(ROperand->u.reg.dataType);

        if ((ROperand->arrayIndex.mode != slvINDEX_NONE && ROperand->arrayIndex.mode != slvINDEX_CONSTANT) ||
            (ROperand->matrixIndex.mode != slvINDEX_NONE && ROperand->matrixIndex.mode != slvINDEX_CONSTANT))
        {
            isIndexedMatrix = gcvTRUE;
            constantOffset = gcvFALSE;
        }
    }
    else {
        targetDataType = ROperand->u.reg.dataType;
    }
    slsIOPERAND_New(Compiler, iOperand, targetDataType, ROperand->u.reg.precision);

    /*
    ** If this matrix is array or matrix indexed, we use a specified pattern to evaluate offset,
    ** so on BE, we can use this pattern to convert such LOAD instructions to MOV instructions.
    */
    if (!isIndexedMatrix)
    {
        switch (ROperand->arrayIndex.mode)
        {
        case slvINDEX_NONE:
            if (isRowMajor)
            {
                addressOffset += MatrixIndex * 4;
            }
            else
            {
                addressOffset += MatrixIndex * matrixStride;
            }
            break;

        case slvINDEX_REG:
        case slvINDEX_REG_Y:
        case slvINDEX_REG_Z:
        case slvINDEX_REG_W:
            constantOffset = gcvFALSE;
            /* If the right operand is a struct, we need to get array stride from struct. */
            if (arrayStride > 0)
            {
                constantValue->uintValue = arrayStride;
            }
            else if(gcIsVectorDataType(ROperand->u.reg.dataType)) /* check for vector dynamic indexing */
            {
                /* force it to 1, as offset has already been embedded in the register index */
                constantValue->uintValue = 1;
            }
            else
            {
                if(ROperand->u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER)
                {
                    gcUNIFORM parentUniform, structUniform;

                    gcmASSERT(ROperand->u.reg.u.uniform->parent != -1);

                    status = gcSHADER_GetUniform(binary,
                                                 ROperand->u.reg.u.uniform->parent,
                                                 &parentUniform);
                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                    gcmASSERT(parentUniform->parent != -1 &&
                              isUniformStruct(parentUniform));

                    status = gcSHADER_GetUniform(binary,
                                                 parentUniform->parent,
                                                 &structUniform);
                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                    gcmASSERT(isUniformArray(structUniform) &&
                              structUniform->arrayStride > 0);

                    constantValue->uintValue = structUniform->arrayStride;
                }
                else
                {
                    gcVARIABLE parentVariable, structVariable;

                    gcmASSERT(ROperand->u.reg.qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER);
                    gcmASSERT(ROperand->u.reg.u.variable->parent != -1);

                    status = gcSHADER_GetVariable(binary,
                                                  ROperand->u.reg.u.variable->parent,
                                                  &parentVariable);
                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                    gcmASSERT(isVariableStruct(parentVariable));

                    gcmASSERT(parentVariable->parent != -1);
                    status = gcSHADER_GetVariable(binary,
                                                  parentVariable->parent,
                                                  &structVariable);
                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                    gcmASSERT(isVariableArray(structVariable) &&
                              structVariable->arrayStride > 0);
                    if (!(isVariableArray(structVariable) &&
                        structVariable->arrayStride > 0))
                    {
                        gcmFOOTER(); return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                    }

                    constantValue->uintValue = structVariable->arrayStride;
                }
            }

            if (ROperand->arrayIndex.mode == slvINDEX_REG)
            {
                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X1,
                                              gcSHADER_PRECISION_MEDIUM,
                                              ROperand->arrayIndex.u.indexRegIndex);
            }
            else
            {
                gctREG_INDEX index = 0;

                switch (ROperand->arrayIndex.mode)
                {
                case slvINDEX_REG_Y:
                    index = 1;
                    break;
                case slvINDEX_REG_Z:
                    index = 2;
                    break;
                case slvINDEX_REG_W:
                    index = 3;
                    break;
                default:
                    gcmASSERT(0);
                }

                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X4,
                                              gcSHADER_PRECISION_MEDIUM,
                                              ROperand->arrayIndex.u.indexRegIndex);
                intermROperand->dataType = gcSHADER_UINT_X1;
                intermROperand->vectorIndex.mode = slvINDEX_CONSTANT;
                intermROperand->vectorIndex.u.indexRegIndex = index;
            }

            if (constantValue->uintValue > 1 && !_IsROperandInterfaceBlockMember(Compiler, ROperand))
            {
                slsROPERAND_InitializeConstant(constantROperand,
                                               gcSHADER_UINT_X1,
                                               gcSHADER_PRECISION_MEDIUM,
                                               1,
                                               constantValue);
                precision = _slmComputeUintConstantPrecision(constantValue->uintValue * arraySize);
                slsIOPERAND_New(Compiler, intermIOperand, gcSHADER_UINT_X1, precision);
                status = slGenArithmeticExprCode(Compiler,
                                                 0,
                                                 0,
                                                 slvOPCODE_MUL,
                                                 intermIOperand,
                                                 intermROperand,
                                                 constantROperand);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                slsROPERAND_InitializeUsingIOperand(offset, intermIOperand);
            }
            else
            {
                *offset = *intermROperand;
            }
            break;

        default:
            gcmASSERT(0);
            gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }
    }

    if (isIndexedMatrix)
    {
        /* Evaluate array index and matrix index, even if one of them is constant. */
        slsIOPERAND matrixIndexIOperand[1];

        if (gcIsScalarDataType(ROperand->dataType))
        {
            switch (ROperand->vectorIndex.mode)
            {
            case slvINDEX_CONSTANT:
                componentSelection = _ConvVectorIndexToComponentSelection(
                                                ROperand->vectorIndex.u.indexRegIndex);

                componentSelection = _SwizzleComponentSelection(componentSelection,
                                                                ROperand->u.reg.componentSelection);

                hasComponentSelection = gcvTRUE;
                break;

            default:
                if (ROperand->arrayIndex.mode ==  slvINDEX_NONE)
                {
                    gcmASSERT(0);
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
                else
                {
                    componentSelection = _ConvVectorIndexToComponentSelection(0);

                    componentSelection = _SwizzleComponentSelection(componentSelection,
                                                                    ROperand->u.reg.componentSelection);

                    hasComponentSelection = gcvTRUE;
                }
                break;
            }
        }
        else if (gcIsVectorDataType(ROperand->dataType) || gcIsMatrixDataType(ROperand->dataType))
        {
            if (gcIsVectorDataType(ROperand->dataType))
            {
                componentSelection = _SwizzleComponentSelection(ReversedComponentSelection,
                                                                ROperand->u.reg.componentSelection);
                componentCount = gcmMAX(componentSelection.components, gcGetDataTypeComponentCount(ROperand->dataType));
                ROperand->dataType = gcGetVectorSliceDataType(iOperand->dataType, componentCount);
                hasComponentSelection = gcvTRUE;
            }
        }

        /* I: Get matrix index. */
        if (ROperand->matrixIndex.mode == slvINDEX_CONSTANT ||
            ROperand->matrixIndex.mode == slvINDEX_NONE)
        {
            gcmASSERT(matrixStride);

            if (ROperand->matrixIndex.mode == slvINDEX_CONSTANT)
            {
                constantValue->uintValue = ROperand->matrixIndex.u.constant;
            }
            else
            {
                constantValue->uintValue = 0;
            }
            slsROPERAND_InitializeConstant(intermROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);

            if (isRowMajor)
            {
                rowMajorStride = matrixStride;
                constantValue->uintValue = _GetDataTypeComponentByteSize(ROperand->u.reg.dataType);
            }
            else
            {
                constantValue->uintValue =  matrixStride;
            }
            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);
            slsIOPERAND_New(Compiler, matrixIndexIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);
            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_MUL,
                                             matrixIndexIOperand,
                                             intermROperand,
                                             constantROperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else
        {
            constantOffset = gcvFALSE;
            gcmASSERT(matrixStride);

            if(isRowMajor) {
                rowMajorStride = matrixStride;
                constantValue->uintValue = _GetDataTypeComponentByteSize(ROperand->u.reg.dataType);
            }
            else {
                constantValue->uintValue = matrixStride;
            }

            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);

            if (ROperand->matrixIndex.mode == slvINDEX_REG)
            {
                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X1,
                                              gcSHADER_PRECISION_MEDIUM,
                                              ROperand->matrixIndex.u.indexRegIndex);
            }
            else
            {
                gctREG_INDEX index = 0;

                switch (ROperand->matrixIndex.mode)
                {
                case slvINDEX_REG_Y:
                    index = 1;
                    break;
                case slvINDEX_REG_Z:
                    index = 2;
                    break;
                case slvINDEX_REG_W:
                    index = 3;
                    break;
                default:
                    gcmASSERT(0);
                }

                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X4,
                                              gcSHADER_PRECISION_MEDIUM,
                                              ROperand->matrixIndex.u.indexRegIndex);
                intermROperand->dataType = gcSHADER_UINT_X1;
                intermROperand->vectorIndex.mode = slvINDEX_CONSTANT;
                intermROperand->vectorIndex.u.indexRegIndex = index;
            }
            /*
            ** If this matrix is array indexed,
            ** then the value of matrix index has been added the array index, we need to minus it.
            */
            if (ROperand->arrayIndex.mode != slvINDEX_NONE && ROperand->arrayIndex.mode != slvINDEX_CONSTANT)
            {
                slsIOPERAND_New(Compiler, intermIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);

                if (ROperand->arrayIndex.mode == slvINDEX_REG)
                {
                    slsROPERAND_InitializeTempReg(intermROperand1,
                                                  slvSTORAGE_QUALIFIER_NONE,
                                                  gcSHADER_UINT_X1,
                                                  gcSHADER_PRECISION_MEDIUM,
                                                  ROperand->arrayIndex.u.indexRegIndex);
                }
                else
                {
                    gctREG_INDEX index = 0;

                    switch (ROperand->arrayIndex.mode)
                    {
                    case slvINDEX_REG_Y:
                        index = 1;
                        break;
                    case slvINDEX_REG_Z:
                        index = 2;
                        break;
                    case slvINDEX_REG_W:
                        index = 3;
                        break;
                    default:
                        gcmASSERT(0);
                    }

                    slsROPERAND_InitializeTempReg(intermROperand1,
                                                  slvSTORAGE_QUALIFIER_NONE,
                                                  gcSHADER_UINT_X4,
                                                  gcSHADER_PRECISION_MEDIUM,
                                                  ROperand->arrayIndex.u.indexRegIndex);
                    intermROperand1->dataType = gcSHADER_UINT_X1;
                    intermROperand1->vectorIndex.mode = slvINDEX_CONSTANT;
                    intermROperand1->vectorIndex.u.indexRegIndex = index;
                }

                status = slGenArithmeticExprCode(Compiler,
                                              0,
                                              0,
                                              slvOPCODE_SUB,
                                              intermIOperand,
                                              intermROperand,
                                              intermROperand1);
                slsROPERAND_InitializeUsingIOperand(intermROperand, intermIOperand);
            }

            slsIOPERAND_New(Compiler, matrixIndexIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);
            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_MUL,
                                             matrixIndexIOperand,
                                             intermROperand,
                                             constantROperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        /* II: Get the array index. */
        if (ROperand->arrayIndex.mode == slvINDEX_NONE || ROperand->arrayIndex.mode == slvINDEX_CONSTANT)
        {
            constantValue->uintValue = ROperand->u.reg.regIndex / (arrayStride == 0 ? 1 : arrayStride);
            slsROPERAND_InitializeConstant(intermROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);

            constantValue->uintValue = (arrayStride == 0) ? 16 : arrayStride;
            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);
        }
        else
        {
            if (ROperand->arrayIndex.mode == slvINDEX_REG)
            {
                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X1,
                                              gcSHADER_PRECISION_MEDIUM,
                                              ROperand->arrayIndex.u.indexRegIndex);
            }
            else
            {
                gctREG_INDEX index = 0;

                switch (ROperand->arrayIndex.mode)
                {
                case slvINDEX_REG_Y:
                    index = 1;
                    break;
                case slvINDEX_REG_Z:
                    index = 2;
                    break;
                case slvINDEX_REG_W:
                    index = 3;
                    break;
                default:
                    gcmASSERT(0);
                }

                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X4,
                                              gcSHADER_PRECISION_MEDIUM,
                                              ROperand->arrayIndex.u.indexRegIndex);
                intermROperand->dataType = gcSHADER_UINT_X1;
                intermROperand->vectorIndex.mode = slvINDEX_CONSTANT;
                intermROperand->vectorIndex.u.indexRegIndex = index;
            }

            constantValue->uintValue = (arrayStride == 0) ? 16 : arrayStride;
            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);
        }

        /* III: add array offset and matrix offset. */
        intermROperand1[0] = intermROperand[0];
        slsROPERAND_InitializeUsingIOperand(intermROperand, matrixIndexIOperand);

        slsIOPERAND_New(Compiler, intermIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);
        status = slGenArithmeticExprCode(Compiler,
                                         0,
                                         0,
                                         slvOPCODE_ADD,
                                         intermIOperand,
                                         intermROperand,
                                         intermROperand1);
        /* IV: evaluate the matrix index. */
        if (gcIsMatrixDataType(ROperand->dataType) && MatrixIndex != 0)
        {
            slsROPERAND matrixROperand[1];
            slsIOPERAND matrixIOperand[1];

            if (isRowMajor)
            {
                constantValue->uintValue = MatrixIndex * 4;
            }
            else
            {
                constantValue->uintValue = MatrixIndex * matrixStride;
            }
            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);

            slsROPERAND_InitializeUsingIOperand(matrixROperand, intermIOperand);
            slsIOPERAND_New(Compiler, matrixIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);

            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_ADD,
                                             matrixIOperand,
                                             matrixROperand,
                                             constantROperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slsROPERAND_InitializeUsingIOperand(offset, matrixIOperand);
        }
        else
        {
            slsROPERAND_InitializeUsingIOperand(offset, intermIOperand);
        }
    }
    else if (gcIsSamplerDataType(ROperand->dataType))
    {
        gcmASSERT(gcIsSamplerDataType(ROperand->u.reg.dataType));

        componentSelection = slGetDefaultComponentSelection(ROperand->dataType);

        componentSelection = _SwizzleComponentSelection(ReversedComponentSelection,
                                                        componentSelection);
        componentCount = gcmMAX(componentSelection.components, gcGetDataTypeComponentCount(ROperand->dataType));
        ROperand->dataType = gcGetVectorSliceDataType(iOperand->dataType, componentCount);
        hasComponentSelection = gcvTRUE;
    }
    else if (gcIsImageDataType(ROperand->dataType))
    {
        gcmASSERT(gcIsImageDataType(ROperand->u.reg.dataType));

        componentSelection = slGetDefaultComponentSelection(ROperand->dataType);

        componentSelection = _SwizzleComponentSelection(ReversedComponentSelection,
                                                        componentSelection);
        componentCount = gcmMAX(componentSelection.components, gcGetDataTypeComponentCount(ROperand->dataType));
        ROperand->dataType = gcGetVectorSliceDataType(iOperand->dataType, componentCount);
        hasComponentSelection = gcvTRUE;
    }
    else if (gcIsScalarDataType(ROperand->dataType))
    {
        if (gcIsScalarDataType(ROperand->u.reg.dataType))
        {
            componentSelection = slGetDefaultComponentSelection(ROperand->dataType);

            componentSelection = _SwizzleComponentSelection(ReversedComponentSelection,
                                                            componentSelection);
        }
        else
        {
            gcmASSERT(gcIsVectorDataType(ROperand->u.reg.dataType)
                        || gcIsMatrixDataType(ROperand->u.reg.dataType));

            switch (ROperand->vectorIndex.mode)
            {
            case slvINDEX_CONSTANT:
                componentSelection = _ConvVectorIndexToComponentSelection(
                                                ROperand->vectorIndex.u.indexRegIndex);

                componentSelection = _SwizzleComponentSelection(componentSelection,
                                                                ROperand->u.reg.componentSelection);

                hasComponentSelection = gcvTRUE;
                break;

            default:
                if (ROperand->arrayIndex.mode ==  slvINDEX_NONE)
                {
                    gcmASSERT(0);
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
                else
                {
                    componentSelection = _ConvVectorIndexToComponentSelection(0);

                    componentSelection = _SwizzleComponentSelection(componentSelection,
                                                                    ROperand->u.reg.componentSelection);

                    hasComponentSelection = gcvTRUE;
                }
                break;
            }

            if (gcIsMatrixDataType(ROperand->u.reg.dataType))
            {
                gctINT matrixOffset;

                if (ROperand->matrixIndex.mode == slvINDEX_CONSTANT ||
                    ROperand->matrixIndex.mode == slvINDEX_NONE)
                {
                    gcmASSERT(matrixStride);
                    if (ROperand->matrixIndex.mode == slvINDEX_CONSTANT)
                    {
                        if (isRowMajor) {
                            rowMajorStride = matrixStride;
                            matrixOffset = ROperand->matrixIndex.u.constant * _GetDataTypeComponentByteSize(ROperand->u.reg.dataType);
                        }
                        else {
                            matrixOffset = ROperand->matrixIndex.u.constant * matrixStride;
                        }
                    }
                    else
                    {
                        matrixOffset = 0;
                    }
                    if(constantOffset) {
                        addressOffset += matrixOffset;
                    }
                    else {
                        constantValue->uintValue = matrixOffset;

                        slsROPERAND_InitializeConstant(constantROperand,
                                                       gcSHADER_UINT_X1,
                                                       gcSHADER_PRECISION_MEDIUM,
                                                       1,
                                                       constantValue);
                        slsIOPERAND_New(Compiler, intermIOperand, gcSHADER_UINT_X1, offset->u.reg.precision);
                        status = slGenArithmeticExprCode(Compiler,
                                                         0,
                                                         0,
                                                         slvOPCODE_ADD,
                                                         intermIOperand,
                                                         offset,
                                                         constantROperand);
                        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                        slsROPERAND_InitializeUsingIOperand(offset, intermIOperand);
                    }
                }
                else
                {
                    gcmASSERT(0);
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
            }
        }
    }
    else if (gcIsVectorDataType(ROperand->dataType) || gcIsMatrixDataType(ROperand->dataType))
    {
        gcmASSERT(gcIsVectorDataType(ROperand->u.reg.dataType)
                    || gcIsMatrixDataType(ROperand->u.reg.dataType));

        if (gcIsVectorDataType(ROperand->dataType))
        {
            componentSelection = _SwizzleComponentSelection(ReversedComponentSelection,
                                                            ROperand->u.reg.componentSelection);
            componentCount = gcmMAX(componentSelection.components, gcGetDataTypeComponentCount(ROperand->dataType));
            ROperand->dataType = gcGetVectorSliceDataType(iOperand->dataType, componentCount);

            hasComponentSelection = gcvTRUE;
        }

        if (gcIsMatrixDataType(ROperand->u.reg.dataType))
        {
            gctINT matrixOffset;

            if (ROperand->matrixIndex.mode == slvINDEX_CONSTANT ||
                ROperand->matrixIndex.mode == slvINDEX_NONE)
            {
                gcmASSERT(matrixStride);

                if (ROperand->matrixIndex.mode == slvINDEX_CONSTANT)
                {
                    if(isRowMajor) {
                        rowMajorStride = matrixStride;
                        matrixOffset = ROperand->matrixIndex.u.constant * _GetDataTypeComponentByteSize(ROperand->u.reg.dataType);
                    }
                    else {
                        matrixOffset = ROperand->matrixIndex.u.constant * matrixStride;
                    }
                }
                else
                {
                    matrixOffset = 0;
                }

                if(constantOffset) {
                    addressOffset += matrixOffset;
                }
                else {
                    constantValue->uintValue = matrixOffset;

                    slsROPERAND_InitializeConstant(constantROperand,
                                                   gcSHADER_UINT_X1,
                                                   gcSHADER_PRECISION_MEDIUM,
                                                   1,
                                                   constantValue);
                    slsIOPERAND_New(Compiler, intermIOperand, gcSHADER_UINT_X1, offset->u.reg.precision);
                    status = slGenArithmeticExprCode(Compiler,
                                                     0,
                                                     0,
                                                     slvOPCODE_ADD,
                                                     intermIOperand,
                                                     offset,
                                                     constantROperand);
                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                    slsROPERAND_InitializeUsingIOperand(offset, intermIOperand);
                }
                }
            else
            {
                gcmASSERT(0);
                gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }
        }
    }
    else
    {
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    if(rowMajorStride) {
        if(hasComponentSelection) {
            gctBOOL selVectorIndex[sldMAX_VECTOR_COMPONENT] = {gcvFALSE,};
            gctREG_INDEX vectorIndex, i;
            slsROPERAND intermOffset[1];

            vectorIndex = _ConvComponentToVectorIndex(componentSelection.x);
            selVectorIndex[vectorIndex] = gcvTRUE;
            if (componentSelection.components >= 2) {
                vectorIndex = _ConvComponentToVectorIndex(componentSelection.y);
                selVectorIndex[vectorIndex] = gcvTRUE;
            }
            if (componentSelection.components >= 3) {
                vectorIndex = _ConvComponentToVectorIndex(componentSelection.z);
                selVectorIndex[vectorIndex] = gcvTRUE;
            }
            if (componentSelection.components >= 4) {
                vectorIndex = _ConvComponentToVectorIndex(componentSelection.w);
                selVectorIndex[vectorIndex] = gcvTRUE;
            }

            slsLOPERAND_InitializeUsingIOperand(lOperand, iOperand);

            *intermLOperand = *lOperand;
            intermLOperand->dataType = gcGetComponentDataType(targetDataType);
            intermLOperand->vectorIndex.mode = slvINDEX_CONSTANT;

            for(i = 0; i < sldMAX_VECTOR_COMPONENT; i++) {
                if(selVectorIndex[i]) {
                    slsIOPERAND_New(Compiler,
                                    intermIOperand,
                                    intermLOperand->dataType,
                                    intermLOperand->reg.precision);
                    slsROPERAND_InitializeUsingIOperand(intermROperand, intermIOperand);

                    status = _ConvIOperandToTarget(Compiler,
                                                   intermIOperand,
                                                   target);
                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                    if(constantOffset) {
                        gcSHADER_PRECISION precision;
                        gcsSOURCE_CONSTANT sourceConstant;

                        sourceConstant.u.intConstant = addressOffset + rowMajorStride * i;
                        precision =_slmComputeIntConstantPrecision(sourceConstant.u.intConstant);
                        gcsSOURCE_InitializeConstant(offsetSource,
                                                     gcSHADER_INTEGER_X1,
                                                     precision,
                                                     sourceConstant);
                    }
                    else {
                        constantValue->uintValue = rowMajorStride * i;

                        slsROPERAND_InitializeConstant(constantROperand,
                                                       gcSHADER_UINT_X1,
                                                       gcSHADER_PRECISION_MEDIUM,
                                                       1,
                                                       constantValue);
                        slsIOPERAND_New(Compiler,
                                        intermIOperand,
                                        offset->dataType,
                                        offset->u.reg.precision);
                        status = slGenArithmeticExprCode(Compiler,
                                                         0,
                                                         0,
                                                         slvOPCODE_ADD,
                                                         intermIOperand,
                                                         offset,
                                                         constantROperand);
                        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                        slsROPERAND_InitializeUsingIOperand(intermOffset, intermIOperand);

                        /*
                        ** If the offset is indexed, we need to add the offset of the uniform itseft.
                        ** We also need this offset to convert this LOAD instruction to MOV instruction if needed.
                        */
                        constantValue->uintValue = (gctUINT32)addressOffset;
                        slsROPERAND_InitializeConstant(constantROperand,
                                                       gcSHADER_UINT_X1,
                                                       gcSHADER_PRECISION_MEDIUM,
                                                       1,
                                                       constantValue);
                        slsIOPERAND_New(Compiler, offsetIOperand, gcSHADER_UINT_X1, offset->u.reg.precision);

                        status = slGenArithmeticExprCode(Compiler,
                                                         0,
                                                         0,
                                                         slvOPCODE_ADD,
                                                         offsetIOperand,
                                                         intermOffset,
                                                         constantROperand);
                        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                        slsROPERAND_InitializeUsingIOperand(intermOffset, offsetIOperand);

                        sourceReg.indexMode = gcSL_NOT_INDEXED;
                        sourceReg.indexRegIndex = 0;
                        sourceReg.swizzle = gcSL_SWIZZLE_X;
                        sourceReg.u.uniform   = gcvNULL;
                        sourceReg.regIndex = intermOffset->u.reg.regIndex;
                        gcsSOURCE_InitializeReg(offsetSource,
                                                _ConvQualifierToSourceType(slvSTORAGE_QUALIFIER_NONE),
                                                gcSHADER_INTEGER_X1,
                                                offset->u.reg.precision,
                                                sourceReg);
                    }
                    status = slEmitCode2(Compiler,
                                         0,
                                         0,
                                         slvOPCODE_LOAD,
                                         target,
                                         address,
                                         offsetSource);
                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                    intermLOperand->vectorIndex.u.constant = i;
                    status = slGenAssignCode(Compiler,
                                             0,
                                             0,
                                             intermLOperand,
                                             intermROperand);
                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
            }
        }
    }
    else {
        status = _ConvIOperandToTarget(Compiler,
                                       iOperand,
                                       target);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if(constantOffset)
        {
            gcsSOURCE_CONSTANT sourceConstant;

            sourceConstant.u.intConstant = addressOffset;
            precision = _slmComputeIntConstantPrecision(addressOffset);
            gcsSOURCE_InitializeConstant(offsetSource,
                                         gcSHADER_INTEGER_X1,
                                         precision,
                                         sourceConstant);
        }
        else
        {
            /*
            ** If the offset is indexed, we need to add the offset of the uniform itseft.
            ** We also need this offset to convert this LOAD instruction to MOV instruction if needed.
            */
            constantValue->uintValue = (gctUINT32)addressOffset;
            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);
            slsIOPERAND_New(Compiler, offsetIOperand, gcSHADER_UINT_X1, offset->u.reg.precision);

            status = slGenArithmeticExprCode(Compiler,
                                           0,
                                           0,
                                           slvOPCODE_ADD,
                                           offsetIOperand,
                                           offset,
                                           constantROperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slsROPERAND_InitializeUsingIOperand(offset, offsetIOperand);

            sourceReg.indexMode = gcSL_NOT_INDEXED;
            sourceReg.indexRegIndex = 0;
            sourceReg.swizzle = gcSL_SWIZZLE_X;
            sourceReg.u.uniform   = gcvNULL;
            sourceReg.regIndex = offset->u.reg.regIndex;
            gcsSOURCE_InitializeReg(offsetSource,
                                    _ConvQualifierToSourceType(slvSTORAGE_QUALIFIER_NONE),
                                    gcSHADER_INTEGER_X1,
                                    offset->u.reg.precision,
                                    sourceReg);
        }
        status = slEmitCode2(Compiler,
                             0,
                             0,
                             slvOPCODE_LOAD,
                             target,
                             address,
                             offsetSource);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    if (ROperand->u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER)
    {
        if(offsetSource->type != gcvSOURCE_CONSTANT)
        {
            /*
            ** If there is a indirectly access for a member of a user defined UBO,
            ** we can only use LOAD instruction.
            */
            ptr.uniformBlock->_useLoadInst = gcvTRUE;
            SetUniformFlag(ROperand->u.reg.u.uniform, gcvUNIFORM_FLAG_INDIRECTLY_ADDRESSED);
        }
        else
        {
            SetUniformFlag(ROperand->u.reg.u.uniform, gcvUNIFORM_FLAG_DIRECTLY_ADDRESSED);
        }
    }
    if(hasComponentSelection) {
        componentSelection.components = gcGetDataTypeComponentCount(ROperand->dataType);
        if(_IsResultSwizzled(iOperand, &componentSelection)) {
            slsROPERAND_InitializeUsingIOperand(intermROperand, iOperand);
            slsIOPERAND_New(Compiler,
                            iOperand,
                            ROperand->dataType,
                            ROperand->u.reg.precision);
            slsLOPERAND_InitializeUsingIOperand(lOperand, iOperand);
            sloIR_ROperandComponentSelect(Compiler,
                                          intermROperand,
                                          componentSelection,
                                          rOperand);

            status = slGenAssignCode(Compiler,
                                     0,
                                     0,
                                     lOperand,
                                     rOperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else {
            gcmASSERT(gcGetComponentDataType(iOperand->dataType) ==
                      gcGetComponentDataType(ROperand->dataType));

            iOperand->dataType = ROperand->dataType;
        }
    }

    slsROPERAND_InitializeUsingIOperand(ResOperand, iOperand);
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gctINT
_GetInputArraySizeByPrimitiveType(
    IN slvGS_PRIMITIVE Primitive
    )
{
    switch (Primitive)
    {
    case slvGS_POINTS:
        return 1;
    case slvGS_LINES:
        return 2;
    case slvGS_LINES_ADJACENCY:
        return 4;
    case slvGS_TRIANGLES:
        return 3;
    case slvGS_TRIANGLES_ADJACENCY:
        return 6;
    default:
        return 1;
    }
}

/*
** When storing per-vertex/per-patch members,
** the array index is saved by gcdSL_INDEX_Index, and the matrix index is saved by gcdSL_INDEX_ConstValue,
** and the vectore index is saved by swizzle.
** So we can't support dynamically indexed for matrix and vector,
** All matrix indexed and vector indexed have been convert constant indexed.
*/
static gceSTATUS
_LoadPerVertexMember(
    IN sloCOMPILER Compiler,
    IN slsROPERAND * ROperand,
    IN slsCOMPONENT_SELECTION ReversedComponentSelection,
    IN gctINT MatrixIndex,
    IN OUT slsROPERAND *ResOperand
    )
{
    gceSTATUS           status = gcvSTATUS_OK;
    gcsSOURCE_REG       vertexSourceReg = {{0}}, arraySourceReg = {{0}};
    gcsSOURCE_CONSTANT  vertexSourceConstant = {{0}};
    gcsSOURCE           vertexSource[1], arraySource[1];
    gceSOURCE_TYPE      arraySourceType;
    gcsTARGET           target[1];
    slsIOPERAND         iOperand[1];
    gcSHADER_TYPE       targetDataType;
    slsLAYOUT_QUALIFIER inLayout;
    sleSHADER_TYPE      shaderType;

    gcmHEADER();

    gcmASSERT((ROperand->vectorIndex.mode == slvINDEX_NONE || ROperand->vectorIndex.mode == slvINDEX_CONSTANT) ||
              (ROperand->matrixIndex.mode == slvINDEX_NONE || ROperand->matrixIndex.mode == slvINDEX_CONSTANT));

    gcmONERROR(sloCOMPILER_GetShaderType(Compiler, &shaderType));

    if ((MatrixIndex != -1 || ROperand->matrixIndex.mode == slvINDEX_CONSTANT)
        &&
        gcIsMatrixDataType(ROperand->dataType))
    {
        targetDataType = gcGetMatrixColumnDataType(ROperand->dataType);
    }
    else
    {
        targetDataType = ROperand->dataType;
    }

    /* I: Get the vertex index. */
    if (ROperand->vertexIndex.mode == slvINDEX_NONE)
    {
        gcsSOURCE_InitializeConstant(vertexSource,
                                     gcSHADER_INTEGER_X1,
                                     gcSHADER_PRECISION_HIGH,
                                     vertexSourceConstant);
    }
    else if (ROperand->vertexIndex.mode == slvINDEX_CONSTANT)
    {
        vertexSourceConstant.u.intConstant = (gctINT)ROperand->vertexIndex.u.constant;
        gcsSOURCE_InitializeConstant(vertexSource,
                                     gcSHADER_INTEGER_X1,
                                     gcSHADER_PRECISION_HIGH,
                                     vertexSourceConstant);
    }
    else if (ROperand->vertexIndex.mode != slvINDEX_NONE)
    {
        gcSL_INDEXED indexed = _ConvertIndexModeToIndexed(ROperand->vertexIndex.mode);
        vertexSourceReg.regIndex    = ROperand->vertexIndex.u.indexRegIndex;
        vertexSourceReg.indexMode   = gcSL_NOT_INDEXED;
        vertexSourceReg.swizzle     = (gctUINT8)gcmComposeSwizzle(indexed - 1,
                                                                  indexed - 1,
                                                                  indexed - 1,
                                                                  indexed - 1);
        gcsSOURCE_InitializeReg(vertexSource,
                                gcvSOURCE_TEMP,
                                gcSHADER_INTEGER_X1,
                                gcSHADER_PRECISION_HIGH,
                                vertexSourceReg);
    }

    /* Out of vertices check */
    if (shaderType == slvSHADER_TYPE_GS)
    {
        if (vertexSource->type == gcvSOURCE_CONSTANT)
        {
            gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &inLayout, slvSTORAGE_QUALIFIER_IN));
            if (vertexSource->u.sourceConstant.u.intConstant > _GetInputArraySizeByPrimitiveType(inLayout.gsPrimitive))
            {
                gcmFOOTER_NO();
                return gcvSTATUS_INVALID_ARGUMENT;
            }
        }
    }

    /* II: Get the array index. */
    if (ROperand->u.reg.qualifier == slvSTORAGE_QUALIFIER_IN_IO_BLOCK_MEMBER ||
        ROperand->u.reg.qualifier == slvSTORAGE_QUALIFIER_VARYING_IN)
    {
        arraySourceReg.u.attribute = ROperand->u.reg.u.attribute;
        arraySourceType = gcvSOURCE_ATTRIBUTE;
    }
    else
    {
        arraySourceReg.u.output = ROperand->u.reg.u.output;
        arraySourceType = gcvSOURCE_OUTPUT;
    }
    if (ROperand->arrayIndex.mode == slvINDEX_NONE)
    {
        arraySourceReg.regIndex         = 0;
        arraySourceReg.swizzle          = gcGetDefaultSwizzle(targetDataType);
        arraySourceReg.indexMode        = gcSL_NOT_INDEXED;
        arraySourceReg.indexRegIndex    = 0;
    }
    else if (ROperand->arrayIndex.mode == slvINDEX_CONSTANT)
    {
        gctREG_INDEX        indexRegIndex;
        slsIOPERAND         iOperand[1];
        slsLOPERAND         lOperand[1];
        slsROPERAND         rOperand[1];
        sluCONSTANT_VALUE   constantValue[1];

        constantValue[0].intValue = (gctINT)ROperand->arrayIndex.u.constant;

        indexRegIndex = slNewTempRegs(Compiler, 1);
        slsIOPERAND_Initialize(iOperand,
                               gcSHADER_INTEGER_X1,
                               gcSHADER_PRECISION_HIGH,
                               indexRegIndex);

        slsLOPERAND_InitializeUsingIOperand(lOperand, iOperand);
        slsROPERAND_InitializeConstant(&rOperand[0],
                                       gcSHADER_INTEGER_X1,
                                       gcSHADER_PRECISION_HIGH,
                                       1,
                                       constantValue);

        gcmONERROR(slGenAssignCode(Compiler,
                                   0,
                                   0,
                                   lOperand,
                                   rOperand));

        arraySourceReg.regIndex         = 0;
        arraySourceReg.swizzle          = gcGetDefaultSwizzle(targetDataType);
        arraySourceReg.indexMode        = gcSL_INDEXED_X;
        arraySourceReg.indexRegIndex    = indexRegIndex;
    }
    else if (ROperand->arrayIndex.mode != slvINDEX_NONE)
    {
        gcSL_INDEXED indexed = _ConvertIndexModeToIndexed(ROperand->arrayIndex.mode);
        arraySourceReg.regIndex         = 0;
        arraySourceReg.swizzle          = gcGetDefaultSwizzle(targetDataType);
        arraySourceReg.indexMode        = indexed;
        arraySourceReg.indexRegIndex    = ROperand->arrayIndex.u.indexRegIndex;
    }

    /* Get the vector indexed. */
    if (ROperand->vectorIndex.mode == slvINDEX_CONSTANT)
    {
        arraySourceReg.swizzle          = (gctUINT8)gcmComposeSwizzle(ROperand->vectorIndex.u.constant,
                                                                      ROperand->vectorIndex.u.constant,
                                                                      ROperand->vectorIndex.u.constant,
                                                                      ROperand->vectorIndex.u.constant);
    }
    else
    {
        gctINT i = 0;
        gctUINT8 swizzle[4];

        arraySourceReg.swizzle = 0;

        swizzle[i] = ROperand->u.reg.componentSelection.x; i++;
        swizzle[i] = ROperand->u.reg.componentSelection.y; i++;
        swizzle[i] = ROperand->u.reg.componentSelection.z; i++;
        swizzle[i] = ROperand->u.reg.componentSelection.w;

        for (i = 0; i < ROperand->u.reg.componentSelection.components; i++)
        {
            arraySourceReg.swizzle |= (swizzle[i] << (i * 2));
            if (i == ROperand->u.reg.componentSelection.components - 1)
            {
                for (i = ROperand->u.reg.componentSelection.components; i < 4; i++)
                {
                    arraySourceReg.swizzle |= (swizzle[ROperand->u.reg.componentSelection.components - 1] << (i * 2));
                }
                break;
            }
        }
    }

    /* Get the matrix indexed. */
    if (MatrixIndex != -1)
    {
        arraySourceReg.regIndex = (gctREG_INDEX)MatrixIndex;
    }
    else if (ROperand->matrixIndex.mode != slvINDEX_NONE)
    {
        arraySourceReg.regIndex = ROperand->matrixIndex.u.constant;
    }

    gcsSOURCE_InitializeReg(arraySource,
                            arraySourceType,
                            gcGetComponentDataType(targetDataType),
                            ROperand->u.reg.precision,
                            arraySourceReg);

    /* III: Get the target.*/
    slsIOPERAND_New(Compiler, iOperand, targetDataType, ROperand->u.reg.precision);

    gcmONERROR(_ConvIOperandToTarget(Compiler,
                                     iOperand,
                                     target));
    gcmONERROR(slEmitCode2(Compiler,
                           0,
                           0,
                           slvOPCODE_ATTR_LD,
                           target,
                           arraySource,
                           vertexSource));

    slsROPERAND_InitializeUsingIOperand(ResOperand, iOperand);
OnError:
    gcmFOOTER_NO();
    return status;
}

struct _slsStoreInfo {
    slsCOMPONENT_SELECTION reversedComponentSelection;
    gctUINT8 enable;
    gcsSOURCE address;
    gctINT rowMajorStride;
    gctINT offset;
};

static gceSTATUS
_UpdateEnableForStore(
    IN sloCOMPILER Compiler,
    IN gctINT ComponentByteSize,
    IN OUT struct _slsStoreInfo *Res
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctINT addressOffset = 0;

    gcmASSERT(Res->enable);
    while (Res->enable) {
        if(Res->enable & 0x1) break;

        Res->enable >>= 1;

        Res->reversedComponentSelection.x = Res->reversedComponentSelection.y;
        Res->reversedComponentSelection.y = Res->reversedComponentSelection.z;
        Res->reversedComponentSelection.z = Res->reversedComponentSelection.w;

        addressOffset += ComponentByteSize;
    }

    if(addressOffset) {
        gcSHADER_PRECISION precision;
        gcsSOURCE_CONSTANT sourceConstant;
        gcsSOURCE offsetSource[1];
        slsIOPERAND addressIOperand[1];
        gcsTARGET addressTarget[1];
        gcsSOURCE addressSource[1];

        sourceConstant.u.intConstant = addressOffset;
        precision =_slmComputeIntConstantPrecision(sourceConstant.u.intConstant);
        gcsSOURCE_InitializeConstant(offsetSource,
                                     gcSHADER_INTEGER_X1,
                                     precision,
                                     sourceConstant);

        slsIOPERAND_New(Compiler, addressIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_HIGH);
        gcsTARGET_InitializeUsingIOperand(addressTarget, addressIOperand);
        gcsSOURCE_InitializeUsingIOperand(addressSource, addressIOperand);

        status = slEmitCode2(Compiler,
                             0,
                             0,
                             slvOPCODE_ADD,
                             addressTarget,
                             &Res->address,
                             offsetSource);
        if (gcmIS_ERROR(status)) { return status; }

        Res->address = *addressSource;
    }
    return status;
}

static gceSTATUS
_MakeStoreSource(
    IN sloCOMPILER Compiler,
    IN slsLOPERAND * LOperand,
    IN gctUINT MatrixIndex,
    OUT struct _slsStoreInfo *Res
    )
{
    gceSTATUS status;
    union _sluObjPtrs ptr;
    gcUNIFORM blockAddressUniform = gcvNULL;
    gcSHADER binary;
    slsIOPERAND addressIOperand[1];
    gcsSOURCE_REG  sourceReg = { {0} };
    gcsSOURCE baseAddress[1];
    gcsSOURCE offsetSource[1];
    gcsTARGET addressTarget[1];
    gcsSOURCE addressSource[1];
    gcsSOURCE *address;
    slsROPERAND offset[1];
    gctINT addressOffset;
    gctBOOL constantOffset = gcvTRUE;
    slsCOMPONENT_SELECTION  reversedComponentSelection = { 0 };
    gctUINT8 enable = gcSL_ENABLE_X;
    slsROPERAND constantROperand[1];
    sluCONSTANT_VALUE constantValue[1];
    slsROPERAND intermROperand[1], intermROperand1[1];
    slsIOPERAND intermIOperand[1];
    slsIOPERAND offsetIOperand[1];
    gctINT rowMajorStride = 0;
    gctBOOL isRowMajor = gcvFALSE;
    gctBOOL isArray = gcvFALSE;
    gctINT arrayStride = 0;
    gctINT matrixStride = 0;
    gctINT arraySize = 1;
    gcSHADER_PRECISION precision;
    gctBOOL isIndexedMatrix = gcvFALSE;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LOperand &&
              LOperand->reg.qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER);

    gcmASSERT(Res);

    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));
    if(LOperand->reg.qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER) {
        addressOffset = LOperand->reg.u.variable->offset + LOperand->reg.regIndex;
        isRowMajor = GetVariableIsRowMajor(LOperand->reg.u.variable);
        matrixStride = LOperand->reg.u.variable->matrixStride;
        arraySize = LOperand->reg.u.variable->arraySize;
        isArray = isVariableArray(LOperand->reg.u.variable);
        arrayStride = LOperand->reg.u.variable->arrayStride;
        status = gcSHADER_GetStorageBlock(binary,
                                          LOperand->reg.u.variable->blockIndex,
                                          &ptr.storageBlock);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        reversedComponentSelection = slGetDefaultComponentSelection(LOperand->dataType);
    }
    else {
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    sourceReg.indexMode = gcSL_NOT_INDEXED;
    sourceReg.indexRegIndex = 0;
    sourceReg.swizzle = gcSL_SWIZZLE_X;
    if(GetIBIFlag(ptr.interfaceBlock) & gceIB_FLAG_FOR_SHARED_VARIABLE) {
        sourceReg.u.uniform   = gcvNULL;
        gcmASSERT(GetIBISharedVariableBaseAddress(ptr.interfaceBlock) != -1);
        sourceReg.regIndex = GetIBISharedVariableBaseAddress(ptr.interfaceBlock);
        gcsSOURCE_InitializeReg(baseAddress,
                                _ConvQualifierToSourceType(slvSTORAGE_QUALIFIER_NONE),
                                gcSHADER_UINT_X1,
                                LOperand->reg.precision,
                                sourceReg);
    }
    else {
        status = gcSHADER_GetUniform(binary,
                                     GetIBIIndex(ptr.interfaceBlock),
                                     &blockAddressUniform);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        sourceReg.u.uniform   = blockAddressUniform;
        sourceReg.regIndex = 0;
        gcsSOURCE_InitializeReg(baseAddress,
                                _ConvQualifierToSourceType(slvSTORAGE_QUALIFIER_UNIFORM),
                                gcSHADER_UINT_X1,
                                LOperand->reg.precision,
                                sourceReg);
    }

    slsIOPERAND_New(Compiler, addressIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_HIGH);
    gcsTARGET_InitializeUsingIOperand(addressTarget, addressIOperand);
    gcsSOURCE_InitializeUsingIOperand(addressSource, addressIOperand);
    address = addressSource;

    if(gcIsMatrixDataType(LOperand->reg.dataType)) {
        if ((LOperand->arrayIndex.mode != slvINDEX_NONE && LOperand->arrayIndex.mode != slvINDEX_CONSTANT && isArray) ||
            (LOperand->matrixIndex.mode != slvINDEX_NONE && LOperand->matrixIndex.mode != slvINDEX_CONSTANT))
        {
            isIndexedMatrix = gcvTRUE;
            constantOffset = gcvFALSE;
        }
    }

    /*
    ** If this matrix is array or matrix indexed, we use a specified pattern to evaluate offset,
    ** so on BE, we can use this pattern to convert such LOAD instructions to MOV instructions.
    */
    if (!isIndexedMatrix)
    {
        switch (LOperand->arrayIndex.mode)
        {
        case slvINDEX_NONE:
            if (isRowMajor)
            {
                addressOffset += MatrixIndex * 4;
            }
            else
            {
                addressOffset += MatrixIndex * matrixStride;
            }
            break;

        case slvINDEX_REG:
            case slvINDEX_REG_Y:
            case slvINDEX_REG_Z:
            case slvINDEX_REG_W:
            constantOffset = gcvFALSE;
                /* If the operand is a struct, we need to get array stride from struct variable. */
            if (arrayStride > 0)
            {
                constantValue->uintValue = arrayStride;
            }
            else if(gcIsVectorDataType(LOperand->reg.dataType)) /* check for vector dynamic indexing */
            {
                /* force it to 1, as offset has already been embedded in the register index */
                constantValue->uintValue = 1;
            }
            else
            {
                gcVARIABLE parentVariable, structVariable;

                gcmASSERT(LOperand->reg.qualifier == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER);
                gcmASSERT(LOperand->reg.u.variable->parent != 0);

                status = gcSHADER_GetVariable(binary,
                                              LOperand->reg.u.variable->parent,
                                              &parentVariable);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                gcmASSERT(parentVariable->parent != -1 &&
                          isVariableStruct(parentVariable));

                status = gcSHADER_GetVariable(binary,
                                             parentVariable->parent,
                                             &structVariable);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                constantValue->uintValue = structVariable->arrayStride;
            }

            if (LOperand->arrayIndex.mode == slvINDEX_REG)
            {
                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X1,
                                              gcSHADER_PRECISION_MEDIUM,
                                              LOperand->arrayIndex.u.indexRegIndex);
            }
            else
            {
                gctREG_INDEX index = 0;

                switch (LOperand->arrayIndex.mode)
                {
                case slvINDEX_REG_Y:
                    index = 1;
                    break;
                case slvINDEX_REG_Z:
                    index = 2;
                    break;
                case slvINDEX_REG_W:
                    index = 3;
                    break;
                default:
                    gcmASSERT(0);
                }

                slsROPERAND_InitializeTempReg(intermROperand,
                                                slvSTORAGE_QUALIFIER_NONE,
                                                gcSHADER_UINT_X4,
                                                gcSHADER_PRECISION_MEDIUM,
                                                LOperand->arrayIndex.u.indexRegIndex);
                intermROperand->dataType = gcSHADER_UINT_X1;
                intermROperand->vectorIndex.mode = slvINDEX_CONSTANT;
                intermROperand->vectorIndex.u.indexRegIndex = index;
            }

            if (constantValue->uintValue > 1 && !_IsLOperandInterfaceBlockMember(Compiler, LOperand))
            {
                slsROPERAND_InitializeConstant(constantROperand,
                                               gcSHADER_UINT_X1,
                                               gcSHADER_PRECISION_MEDIUM,
                                               1,
                                               constantValue);
                precision = _slmComputeUintConstantPrecision(constantValue->uintValue * arraySize);
                slsIOPERAND_New(Compiler, intermIOperand, gcSHADER_UINT_X1, precision);
                status = slGenArithmeticExprCode(Compiler,
                                                 0,
                                                 0,
                                                 slvOPCODE_MUL,
                                                 intermIOperand,
                                                 intermROperand,
                                                 constantROperand);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                slsROPERAND_InitializeUsingIOperand(offset, intermIOperand);
            }
            else
            {
                *offset = *intermROperand;
            }
            break;

        default:
            gcmASSERT(0);
            gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }
    }

    if (isIndexedMatrix)
    {
        /* Evaluate array index and matrix index, even if one of them is constant. */
        slsIOPERAND matrixIndexIOperand[1], arrayIndexIOperand[1];

        if (gcIsScalarDataType(LOperand->dataType))
        {
            switch (LOperand->vectorIndex.mode)
            {
            case slvINDEX_CONSTANT:
                reversedComponentSelection = _ConvVectorIndexToComponentSelection(
                                                        LOperand->vectorIndex.u.indexRegIndex);

                reversedComponentSelection = _SwizzleComponentSelection(
                                                        reversedComponentSelection,
                                                        LOperand->reg.componentSelection);

                enable = _ConvComponentSelectionToEnable(reversedComponentSelection);

                reversedComponentSelection = _ReverseComponentSelection(reversedComponentSelection);

                break;

            default:
                if (LOperand->arrayIndex.mode ==  slvINDEX_NONE)
                {
                    gcmASSERT(0);
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
                else
                {
                    reversedComponentSelection = _ConvVectorIndexToComponentSelection(0);

                    reversedComponentSelection = _SwizzleComponentSelection(reversedComponentSelection,
                                                                            LOperand->reg.componentSelection);

                    enable = gcSL_ENABLE_X;

                    reversedComponentSelection = _ReverseComponentSelection(reversedComponentSelection);
                }
                break;
            }
        }
        else if (gcIsVectorDataType(LOperand->dataType) || gcIsMatrixDataType(LOperand->dataType))
        {
            enable = _ConvComponentSelectionToEnable(LOperand->reg.componentSelection);

            reversedComponentSelection = _ReverseComponentSelection(LOperand->reg.componentSelection);
        }

        /* I: Get matrix index. */
        if (LOperand->matrixIndex.mode == slvINDEX_CONSTANT ||
            LOperand->matrixIndex.mode == slvINDEX_NONE)
        {
            gcmASSERT(matrixStride);

            if (LOperand->matrixIndex.mode == slvINDEX_CONSTANT)
            {
                constantValue->uintValue = LOperand->matrixIndex.u.constant;
            }
            else
            {
                constantValue->uintValue = 0;
            }
            slsROPERAND_InitializeConstant(intermROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);

            if (isRowMajor)
            {
                rowMajorStride = matrixStride;
                constantValue->uintValue = _GetDataTypeComponentByteSize(LOperand->reg.dataType);
            }
            else
            {
                constantValue->uintValue =  matrixStride;
            }
            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);
            slsIOPERAND_New(Compiler, matrixIndexIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);
            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_MUL,
                                             matrixIndexIOperand,
                                             intermROperand,
                                             constantROperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else
        {
            constantOffset = gcvFALSE;
            gcmASSERT(matrixStride);

            if(isRowMajor) {
                rowMajorStride = matrixStride;
                constantValue->uintValue = _GetDataTypeComponentByteSize(LOperand->reg.dataType);
            }
            else {
                constantValue->uintValue = matrixStride;
            }

            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);

            if (LOperand->matrixIndex.mode == slvINDEX_REG)
            {
                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X1,
                                              gcSHADER_PRECISION_MEDIUM,
                                              LOperand->matrixIndex.u.indexRegIndex);
            }
            else
            {
                gctREG_INDEX index = 0;

                switch (LOperand->matrixIndex.mode)
                {
                case slvINDEX_REG_Y:
                    index = 1;
                    break;
                case slvINDEX_REG_Z:
                    index = 2;
                    break;
                case slvINDEX_REG_W:
                    index = 3;
                    break;
                default:
                    gcmASSERT(0);
                }

                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X4,
                                              gcSHADER_PRECISION_MEDIUM,
                                              LOperand->matrixIndex.u.indexRegIndex);
                intermROperand->dataType = gcSHADER_UINT_X1;
                intermROperand->vectorIndex.mode = slvINDEX_CONSTANT;
                intermROperand->vectorIndex.u.indexRegIndex = index;
            }
            /*
            ** If this matrix is array indexed,
            ** then the value of matrix index has been added the array index, we need to minus it.
            */
            if (LOperand->arrayIndex.mode != slvINDEX_NONE && LOperand->arrayIndex.mode != slvINDEX_CONSTANT)
            {
                slsIOPERAND_New(Compiler, intermIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);

                if (LOperand->arrayIndex.mode == slvINDEX_REG)
                {
                    slsROPERAND_InitializeTempReg(intermROperand1,
                                                  slvSTORAGE_QUALIFIER_NONE,
                                                  gcSHADER_UINT_X1,
                                                  gcSHADER_PRECISION_MEDIUM,
                                                  LOperand->arrayIndex.u.indexRegIndex);
                }
                else
                {
                    gctREG_INDEX index = 0;

                    switch (LOperand->arrayIndex.mode)
                    {
                    case slvINDEX_REG_Y:
                        index = 1;
                        break;
                    case slvINDEX_REG_Z:
                        index = 2;
                        break;
                    case slvINDEX_REG_W:
                        index = 3;
                        break;
                    default:
                        gcmASSERT(0);
                    }

                    slsROPERAND_InitializeTempReg(intermROperand1,
                                                  slvSTORAGE_QUALIFIER_NONE,
                                                  gcSHADER_UINT_X4,
                                                  gcSHADER_PRECISION_MEDIUM,
                                                  LOperand->arrayIndex.u.indexRegIndex);
                    intermROperand1->dataType = gcSHADER_UINT_X1;
                    intermROperand1->vectorIndex.mode = slvINDEX_CONSTANT;
                    intermROperand1->vectorIndex.u.indexRegIndex = index;
                }

                status = slGenArithmeticExprCode(Compiler,
                                                 0,
                                                 0,
                                                 slvOPCODE_SUB,
                                                 intermIOperand,
                                                 intermROperand,
                                                 intermROperand1);
                slsROPERAND_InitializeUsingIOperand(intermROperand, intermIOperand);
            }

            slsIOPERAND_New(Compiler, matrixIndexIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);
            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_MUL,
                                             matrixIndexIOperand,
                                             intermROperand,
                                             constantROperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        /* II: Get the array index. */
        if (LOperand->arrayIndex.mode == slvINDEX_NONE || LOperand->arrayIndex.mode == slvINDEX_CONSTANT)
        {
            constantValue->uintValue = LOperand->reg.regIndex / (arrayStride == 0 ? 1 : arrayStride);
            slsROPERAND_InitializeConstant(intermROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);

            constantValue->uintValue = arrayStride;
            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);
        }
        else
        {
            if (LOperand->arrayIndex.mode == slvINDEX_REG)
            {
                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X1,
                                              gcSHADER_PRECISION_MEDIUM,
                                              LOperand->arrayIndex.u.indexRegIndex);
            }
            else
            {
                gctREG_INDEX index = 0;

                switch (LOperand->arrayIndex.mode)
                {
                case slvINDEX_REG_Y:
                    index = 1;
                    break;
                case slvINDEX_REG_Z:
                    index = 2;
                    break;
                case slvINDEX_REG_W:
                    index = 3;
                    break;
                default:
                    gcmASSERT(0);
                }

                slsROPERAND_InitializeTempReg(intermROperand,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              gcSHADER_UINT_X4,
                                              gcSHADER_PRECISION_MEDIUM,
                                              LOperand->arrayIndex.u.indexRegIndex);
                intermROperand->dataType = gcSHADER_UINT_X1;
                intermROperand->vectorIndex.mode = slvINDEX_CONSTANT;
                intermROperand->vectorIndex.u.indexRegIndex = index;
            }

            constantValue->uintValue = arrayStride;

            /* If this variable is a matrix, and its array index has been multiplied the size, we need to divide it here. */
            if (gcIsMatrixDataType(LOperand->reg.dataType) && isArray)
            {
                constantValue->uintValue = 1;
            }

            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);
        }

        slsIOPERAND_New(Compiler, arrayIndexIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);
        status = slGenArithmeticExprCode(Compiler,
                                         0,
                                         0,
                                         slvOPCODE_MUL,
                                         arrayIndexIOperand,
                                         intermROperand,
                                         constantROperand);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        /* III: add array offset and matrix offset. */
        slsROPERAND_InitializeUsingIOperand(intermROperand, matrixIndexIOperand);
        slsROPERAND_InitializeUsingIOperand(intermROperand1, arrayIndexIOperand);

        slsIOPERAND_New(Compiler, intermIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);
        status = slGenArithmeticExprCode(Compiler,
                                         0,
                                         0,
                                         slvOPCODE_ADD,
                                         intermIOperand,
                                         intermROperand,
                                         intermROperand1);
        /* IV: evaluate the matrix index. */
        if (gcIsMatrixDataType(LOperand->dataType) && MatrixIndex != 0)
        {
            slsROPERAND matrixROperand[1];
            slsIOPERAND matrixIOperand[1];

            if (isRowMajor)
            {
                constantValue->uintValue = MatrixIndex * 4;
            }
            else
            {
                constantValue->uintValue = MatrixIndex * matrixStride;
            }
            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);

            slsROPERAND_InitializeUsingIOperand(matrixROperand, intermIOperand);
            slsIOPERAND_New(Compiler, matrixIOperand, gcSHADER_UINT_X1, gcSHADER_PRECISION_MEDIUM);

            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_ADD,
                                             matrixIOperand,
                                             matrixROperand,
                                             constantROperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slsROPERAND_InitializeUsingIOperand(offset, matrixIOperand);
        }
        else
        {
            slsROPERAND_InitializeUsingIOperand(offset, intermIOperand);
        }
    }
    else if (gcIsSamplerDataType(LOperand->dataType))
    {
        gcmASSERT(gcIsSamplerDataType(LOperand->reg.dataType));

        enable                      = gcGetDefaultEnable(LOperand->dataType);
        reversedComponentSelection  = slGetDefaultComponentSelection(LOperand->dataType);
    }
    else if (gcIsImageDataType(LOperand->dataType))
    {
        gcmASSERT(gcIsImageDataType(LOperand->reg.dataType));

        enable                      = gcGetDefaultEnable(LOperand->dataType);
        reversedComponentSelection  = slGetDefaultComponentSelection(LOperand->dataType);
    }
    else if (gcIsScalarDataType(LOperand->dataType))
    {
        if (gcIsScalarDataType(LOperand->reg.dataType))
        {
            enable                      = gcGetDefaultEnable(LOperand->dataType);
            reversedComponentSelection  = slGetDefaultComponentSelection(LOperand->dataType);
        }
        else
        {
            gcmASSERT(gcIsVectorDataType(LOperand->reg.dataType)
                        || gcIsMatrixDataType(LOperand->reg.dataType));

            switch (LOperand->vectorIndex.mode)
            {
            case slvINDEX_CONSTANT:
                reversedComponentSelection = _ConvVectorIndexToComponentSelection(
                                                        LOperand->vectorIndex.u.indexRegIndex);

                reversedComponentSelection = _SwizzleComponentSelection(
                                                        reversedComponentSelection,
                                                        LOperand->reg.componentSelection);

                enable = _ConvComponentSelectionToEnable(reversedComponentSelection);
                break;

            default:
                if (LOperand->arrayIndex.mode ==  slvINDEX_NONE)
                {
                    gcmASSERT(0);
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
                else
                {
                    reversedComponentSelection = _ConvVectorIndexToComponentSelection(0);

                    reversedComponentSelection = _SwizzleComponentSelection(reversedComponentSelection,
                                                                            LOperand->reg.componentSelection);

                    enable = gcSL_ENABLE_X;
                }
            }

            if (gcIsMatrixDataType(LOperand->reg.dataType))
            {
                gctINT matrixOffset;

                if (LOperand->matrixIndex.mode == slvINDEX_CONSTANT ||
                    LOperand->matrixIndex.mode == slvINDEX_NONE)
                {
                    gcmASSERT(matrixStride);
                    if (LOperand->matrixIndex.mode == slvINDEX_CONSTANT)
                    {
                        if (isRowMajor) {
                            rowMajorStride = matrixStride;
                            matrixOffset = LOperand->matrixIndex.u.constant * _GetDataTypeComponentByteSize(LOperand->reg.dataType);
                        }
                        else {
                            matrixOffset = LOperand->matrixIndex.u.constant * matrixStride;
                        }
                    }
                    else
                    {
                        matrixOffset = 0;
                    }
                    if(constantOffset) {
                        addressOffset += matrixOffset;
                    }
                    else {
                        constantValue->uintValue = matrixOffset;

                        slsROPERAND_InitializeConstant(constantROperand,
                                                       gcSHADER_UINT_X1,
                                                       gcSHADER_PRECISION_MEDIUM,
                                                       1,
                                                       constantValue);
                        slsIOPERAND_New(Compiler, intermIOperand, gcSHADER_UINT_X1, offset->u.reg.precision);
                        status = slGenArithmeticExprCode(Compiler,
                                                         0,
                                                         0,
                                                         slvOPCODE_ADD,
                                                         intermIOperand,
                                                         offset,
                                                         constantROperand);
                        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                        slsROPERAND_InitializeUsingIOperand(offset, intermIOperand);
                    }
                }
                else
                {
                    gcmASSERT(0);
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
            }
        }
    }
    else if (gcIsVectorDataType(LOperand->dataType) || gcIsMatrixDataType(LOperand->dataType))
    {
        gcmASSERT(gcIsVectorDataType(LOperand->reg.dataType)
                    || gcIsMatrixDataType(LOperand->reg.dataType));

        enable = _ConvComponentSelectionToEnable(LOperand->reg.componentSelection);
        reversedComponentSelection = _ReverseComponentSelection(LOperand->reg.componentSelection);

        if (gcIsMatrixDataType(LOperand->reg.dataType))
        {
            gctINT matrixOffset;

            if (LOperand->matrixIndex.mode == slvINDEX_CONSTANT ||
                LOperand->matrixIndex.mode == slvINDEX_NONE)
            {
                gcmASSERT(matrixStride);

                if(isRowMajor) {
                    rowMajorStride = matrixStride;
                }

                if (LOperand->matrixIndex.mode == slvINDEX_CONSTANT)
                {
                    if(isRowMajor) {
                        matrixOffset = LOperand->matrixIndex.u.constant * _GetDataTypeComponentByteSize(LOperand->reg.dataType);
                    }
                    else {
                        matrixOffset = LOperand->matrixIndex.u.constant * matrixStride;
                    }
                }
                else
                {
                    matrixOffset = 0;
                }

                if (LOperand->arrayIndex.mode != slvINDEX_NONE)
                {
                    if (isRowMajor)
                    {
                        matrixOffset += MatrixIndex * 4;
                    }
                    else
                    {
                        matrixOffset += MatrixIndex * matrixStride;
                    }
                }

                if(constantOffset) {
                    addressOffset += matrixOffset;
                }
                else {
                    constantValue->uintValue = matrixOffset;

                    slsROPERAND_InitializeConstant(constantROperand,
                                                   gcSHADER_UINT_X1,
                                                   gcSHADER_PRECISION_MEDIUM,
                                                   1,
                                                   constantValue);
                    slsIOPERAND_New(Compiler, intermIOperand, gcSHADER_UINT_X1, offset->u.reg.precision);
                    status = slGenArithmeticExprCode(Compiler,
                                                     0,
                                                     0,
                                                     slvOPCODE_ADD,
                                                     intermIOperand,
                                                     offset,
                                                     constantROperand);
                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                    slsROPERAND_InitializeUsingIOperand(offset, intermIOperand);
                }
            }
            else
            {
                gcmASSERT(0);
                gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }
        }
    }
    else
    {
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    if(rowMajorStride) {
        if(constantOffset) {
            address = baseAddress;
        }
        else {
            slsROPERAND addressROperand[1];
            slsLOGICAL_REG reg[1];

            gcmASSERT(offset->isReg);
            slsLOGICAL_REG_InitializeUniform(reg,
                                             slvSTORAGE_QUALIFIER_UNIFORM,
                                             GetUniformType(blockAddressUniform),
                                             GetUniformPrecision(blockAddressUniform),
                                             blockAddressUniform,
                                             0);
            slsROPERAND_InitializeReg(addressROperand,
                                      reg);

            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_ADD,
                                             addressIOperand,
                                             addressROperand,
                                             offset);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
    }
    else {
        if(constantOffset)
        {
            gcsSOURCE_CONSTANT sourceConstant;

            sourceConstant.u.intConstant = addressOffset;
            precision = _slmComputeIntConstantPrecision(addressOffset);
            gcsSOURCE_InitializeConstant(offsetSource,
                                         gcSHADER_INTEGER_X1,
                                         precision,
                                         sourceConstant);
        }
        else
        {
            /*
            ** If the offset is indexed, we need to add the offset of the uniform itseft.
            ** We also need this offset to convert this LOAD instruction to MOV instruction if needed.
            */
            constantValue->uintValue = (gctUINT32)addressOffset;
            slsROPERAND_InitializeConstant(constantROperand,
                                           gcSHADER_UINT_X1,
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           constantValue);
            slsIOPERAND_New(Compiler, offsetIOperand, gcSHADER_UINT_X1, offset->u.reg.precision);

            status = slGenArithmeticExprCode(Compiler,
                                           0,
                                           0,
                                           slvOPCODE_ADD,
                                           offsetIOperand,
                                           offset,
                                           constantROperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slsROPERAND_InitializeUsingIOperand(offset, offsetIOperand);

            sourceReg.indexMode = gcSL_NOT_INDEXED;
            sourceReg.indexRegIndex = 0;
            sourceReg.swizzle = gcSL_SWIZZLE_X;
            sourceReg.u.uniform = gcvNULL;
            sourceReg.regIndex = offset->u.reg.regIndex;
            gcsSOURCE_InitializeReg(offsetSource,
                                    _ConvQualifierToSourceType(slvSTORAGE_QUALIFIER_NONE),
                                    gcSHADER_INTEGER_X1,
                                    offset->u.reg.precision,
                                    sourceReg);
        }

        status = slEmitCode2(Compiler,
                             0,
                             0,
                             slvOPCODE_ADD,
                             addressTarget,
                             baseAddress,
                             offsetSource);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    Res->reversedComponentSelection = reversedComponentSelection;
    Res->enable = enable;
    Res->address = *address;

    if(rowMajorStride)
    {
        Res->rowMajorStride = rowMajorStride;
        Res->offset = addressOffset;
    }
    else
    {
        status = _UpdateEnableForStore(Compiler,
                                       _GetDataTypeComponentByteSize(LOperand->dataType),
                                       Res);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        Res->rowMajorStride = 0;
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvROperandToSourceReg(
    IN sloCOMPILER Compiler,
    IN slsROPERAND * ROperand,
    IN slsCOMPONENT_SELECTION ReversedComponentSelection,
    OUT gcsSOURCE * Source
    )
{
    gcsSOURCE_REG sourceReg = { {0} };
    slsCOMPONENT_SELECTION  componentSelection;
    slsROPERAND rOperand[1];
    gctBOOL isUseAttrCode = (ROperand->vertexIndex.mode != slvINDEX_NONE);

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand);
    gcmASSERT(ROperand->isReg);
    gcmASSERT(!gcIsMatrixDataType(ROperand->dataType));
    gcmASSERT(Source);

    if (_IsROperandInterfaceBlockMember(Compiler, ROperand))
    {
       gceSTATUS status;

       status =  _LoadInterfaceBlockMember(Compiler,
                                           ROperand,
                                           ReversedComponentSelection,
                                           0,
                                           rOperand);
       if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

       /* Reset the reversed component selection as it has been used already */
       ReversedComponentSelection =
           _slmDefaultComponentSelectionByComponents(ReversedComponentSelection.components);
       ROperand = rOperand;
    }
    else if (isUseAttrCode)
    {
        gceSTATUS status;

        status =  _LoadPerVertexMember(Compiler,
                                       ROperand,
                                       ReversedComponentSelection,
                                       -1,
                                       rOperand);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Reset the reversed component selection as it has been used already */
        ReversedComponentSelection =
            _slmDefaultComponentSelectionByComponents(ReversedComponentSelection.components);
        ROperand = rOperand;
    }

    sourceReg.u.attribute   = ROperand->u.reg.u.attribute;
    sourceReg.regIndex      = ROperand->u.reg.regIndex;

    switch (ROperand->arrayIndex.mode)
    {
    case slvINDEX_NONE:
        sourceReg.indexMode     = gcSL_NOT_INDEXED;
        sourceReg.indexRegIndex = 0;
        break;

    case slvINDEX_REG:
        sourceReg.indexMode     = gcSL_INDEXED_X;
        sourceReg.indexRegIndex = ROperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Y:
        sourceReg.indexMode     = gcSL_INDEXED_Y;
        sourceReg.indexRegIndex = ROperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Z:
        sourceReg.indexMode     = gcSL_INDEXED_Z;
        sourceReg.indexRegIndex = ROperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_W:
        sourceReg.indexMode     = gcSL_INDEXED_W;
        sourceReg.indexRegIndex = ROperand->arrayIndex.u.indexRegIndex;
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    switch (ROperand->indexLevel)
    {
    case slvINDEX_LEVEL_LEAF:
        sourceReg.indexedLevel = gcSL_LEAF_INDEXED;
        break;

    case slvINDEX_LEVEL_NODE:
        sourceReg.indexedLevel = gcSL_NODE_INDEXED;
        break;

    case slvINDEX_LEVEL_LEAF_AND_NODE:
        sourceReg.indexedLevel = gcSL_LEAF_AND_NODE_INDEXED;
        break;

    default:
        sourceReg.indexedLevel = gcSL_NONE_INDEXED;
        break;
    }

    if (gcIsSamplerDataType(ROperand->dataType) ||
        gcIsImageDataType(ROperand->dataType) ||
        gcIsAtomicDataType(ROperand->dataType))
    {
        gcmASSERT(gcIsSamplerDataType(ROperand->u.reg.dataType) ||
                  gcIsImageDataType(ROperand->u.reg.dataType) ||
                  gcIsAtomicDataType(ROperand->u.reg.dataType));

        componentSelection = slGetDefaultComponentSelection(ROperand->dataType);

        componentSelection = _SwizzleComponentSelection(ReversedComponentSelection,
                                                        componentSelection);

        sourceReg.swizzle = _ConvComponentSelectionToSwizzle(componentSelection);
    }
    else if (gcIsScalarDataType(ROperand->dataType))
    {
        if (gcIsScalarDataType(ROperand->u.reg.dataType))
        {
            componentSelection = slGetDefaultComponentSelection(ROperand->dataType);

            componentSelection = _SwizzleComponentSelection(ReversedComponentSelection,
                                                            componentSelection);

            sourceReg.swizzle = _ConvComponentSelectionToSwizzle(componentSelection);
        }
        else
        {
            gcmASSERT(gcIsVectorDataType(ROperand->u.reg.dataType)
                        || gcIsMatrixDataType(ROperand->u.reg.dataType));

            switch (ROperand->vectorIndex.mode)
            {
            case slvINDEX_CONSTANT:
                componentSelection = _ConvVectorIndexToComponentSelection(
                                                ROperand->vectorIndex.u.indexRegIndex);

                componentSelection = _SwizzleComponentSelection(componentSelection,
                                                                ROperand->u.reg.componentSelection);

                componentSelection = _SwizzleComponentSelection(ReversedComponentSelection,
                                                                componentSelection);

                sourceReg.swizzle = _ConvComponentSelectionToSwizzle(componentSelection);
                break;

            default:
                gcmASSERT(0);
                gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }

            if (gcIsMatrixDataType(ROperand->u.reg.dataType))
            {
                switch (ROperand->matrixIndex.mode)
                {
                case slvINDEX_CONSTANT:
                    sourceReg.regIndex += ROperand->matrixIndex.u.constant;
                    break;

                case slvINDEX_REG:
                    gcmASSERT(ROperand->arrayIndex.mode != slvINDEX_REG);

                    sourceReg.indexMode     = gcSL_INDEXED_X;
                    sourceReg.indexRegIndex = ROperand->matrixIndex.u.indexRegIndex;
                    break;

                case slvINDEX_REG_Y:
                    gcmASSERT(ROperand->arrayIndex.mode != slvINDEX_REG);

                    sourceReg.indexMode     = gcSL_INDEXED_Y;
                    sourceReg.indexRegIndex = ROperand->matrixIndex.u.indexRegIndex;
                    break;

                case slvINDEX_REG_Z:
                    gcmASSERT(ROperand->arrayIndex.mode != slvINDEX_REG);

                    sourceReg.indexMode     = gcSL_INDEXED_Z;
                    sourceReg.indexRegIndex = ROperand->matrixIndex.u.indexRegIndex;
                    break;

                case slvINDEX_REG_W:
                    gcmASSERT(ROperand->arrayIndex.mode != slvINDEX_REG);

                    sourceReg.indexMode     = gcSL_INDEXED_W;
                    sourceReg.indexRegIndex = ROperand->matrixIndex.u.indexRegIndex;
                    break;

                default:
                    gcmASSERT(0);
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
            }
        }
    }
    else if (gcIsVectorDataType(ROperand->dataType))
    {
        gcmASSERT(gcIsVectorDataType(ROperand->u.reg.dataType)
                    || gcIsMatrixDataType(ROperand->u.reg.dataType));

        componentSelection = _SwizzleComponentSelection(ReversedComponentSelection,
                                                        ROperand->u.reg.componentSelection);

        sourceReg.swizzle = _ConvComponentSelectionToSwizzle(componentSelection);

        if (gcIsMatrixDataType(ROperand->u.reg.dataType))
        {
            switch (ROperand->matrixIndex.mode)
            {
            case slvINDEX_CONSTANT:
                sourceReg.regIndex += ROperand->matrixIndex.u.constant;
                break;

            case slvINDEX_REG:
                sourceReg.indexMode     = gcSL_INDEXED_X;
                sourceReg.indexRegIndex = ROperand->matrixIndex.u.indexRegIndex;
                break;

            case slvINDEX_REG_Y:
                sourceReg.indexMode     = gcSL_INDEXED_Y;
                sourceReg.indexRegIndex = ROperand->matrixIndex.u.indexRegIndex;
                break;

            case slvINDEX_REG_Z:
                sourceReg.indexMode     = gcSL_INDEXED_Z;
                sourceReg.indexRegIndex = ROperand->matrixIndex.u.indexRegIndex;
                break;

            case slvINDEX_REG_W:
                sourceReg.indexMode     = gcSL_INDEXED_W;
                sourceReg.indexRegIndex = ROperand->matrixIndex.u.indexRegIndex;
                break;

            default:
                gcmASSERT(0);
                gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }
        }
    }
    else
    {
        gcmASSERT(0);
    }

    gcsSOURCE_InitializeReg(Source,
                            _ConvQualifierToSourceType(ROperand->u.reg.qualifier),
                            ROperand->dataType,
                            ROperand->u.reg.precision,
                            sourceReg);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvROperandToMatrixColumnSourceReg(
    IN sloCOMPILER Compiler,
    IN slsROPERAND * ROperand,
    IN gctUINT MatrixIndex,
    OUT gcsSOURCE * Source
    )
{
    gceSTATUS status;
    gcsSOURCE_REG           sourceReg;
    slsROPERAND rOperand[1];
    gcSHADER_TYPE dataType = ROperand->dataType;
    gctBOOL isInterfaceBlockMember = _IsROperandInterfaceBlockMember(Compiler, ROperand);
    gctBOOL isUseAttrCode = (ROperand->vertexIndex.mode != slvINDEX_NONE);

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand);
    gcmASSERT(ROperand->isReg);
    gcmASSERT(gcIsMatrixDataType(ROperand->dataType));
    gcmASSERT(gcIsMatrixDataType(ROperand->u.reg.dataType));
    gcmASSERT(Source);

    if(isInterfaceBlockMember)
    {
        slsROPERAND columnRoperand[1];
        gcSHADER_TYPE targetDataType;
        gctBOOL isRowMajor;

        slsROPERAND_InitializeReg(columnRoperand, &(ROperand->u.reg));

        if(_IsROperandUniformBlockMember(Compiler, ROperand))
        {
            isRowMajor = ROperand->u.reg.u.uniform->isRowMajor;
        }
        else
        {
            isRowMajor = GetVariableIsRowMajor(ROperand->u.reg.u.variable);
        }

        /* If the layout of this matrix is row_major, we need to split it to vectors then load them. */
        if (isRowMajor)
        {
            gcmASSERT(gcIsMatrixDataType(ROperand->u.reg.dataType));

            targetDataType = gcGetMatrixColumnDataType(ROperand->u.reg.dataType);
            columnRoperand->dataType = targetDataType;

            columnRoperand->arrayIndex.mode = ROperand->arrayIndex.mode;
            columnRoperand->arrayIndex.u.indexRegIndex = ROperand->arrayIndex.u.indexRegIndex;

            columnRoperand->matrixIndex.mode = slvINDEX_CONSTANT;
            columnRoperand->matrixIndex.u.constant = MatrixIndex;

            status =  _LoadInterfaceBlockMember(Compiler,
                                                columnRoperand,
                                                slGetDefaultComponentSelection(dataType),
                                                0,
                                                rOperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            ROperand = rOperand;
        }
        else
        {
            status =  _LoadInterfaceBlockMember(Compiler,
                                                ROperand,
                                                slGetDefaultComponentSelection(dataType),
                                                MatrixIndex,
                                                rOperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            ROperand = rOperand;
        }
    }
    else if (isUseAttrCode)
    {
        status =  _LoadPerVertexMember(Compiler,
                                       ROperand,
                                       slGetDefaultComponentSelection(dataType),
                                       (gctINT)MatrixIndex,
                                       rOperand);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        ROperand = rOperand;
    }

    sourceReg.u.attribute   = ROperand->u.reg.u.attribute;
    sourceReg.swizzle       = _ConvComponentSelectionToSwizzle(
                                            slGetDefaultComponentSelection(dataType));
    if(isInterfaceBlockMember || isUseAttrCode)
    {
        sourceReg.regIndex  = ROperand->u.reg.regIndex;
    }
    else
    {
        sourceReg.regIndex  = (gctREG_INDEX) (ROperand->u.reg.regIndex + MatrixIndex);
    }

    switch (ROperand->arrayIndex.mode)
    {
    case slvINDEX_NONE:
        sourceReg.indexMode     = gcSL_NOT_INDEXED;
        sourceReg.indexRegIndex = 0;
        break;

    case slvINDEX_REG:
        gcmASSERT(ROperand->matrixIndex.mode != slvINDEX_REG);

        sourceReg.indexMode     = gcSL_INDEXED_X;
        sourceReg.indexRegIndex = ROperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Y:
        gcmASSERT(ROperand->matrixIndex.mode != slvINDEX_REG);

        sourceReg.indexMode     = gcSL_INDEXED_Y;
        sourceReg.indexRegIndex = ROperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_Z:
        gcmASSERT(ROperand->matrixIndex.mode != slvINDEX_REG);

        sourceReg.indexMode     = gcSL_INDEXED_Z;
        sourceReg.indexRegIndex = ROperand->arrayIndex.u.indexRegIndex;
        break;

    case slvINDEX_REG_W:
        gcmASSERT(ROperand->matrixIndex.mode != slvINDEX_REG);

        sourceReg.indexMode     = gcSL_INDEXED_W;
        sourceReg.indexRegIndex = ROperand->arrayIndex.u.indexRegIndex;
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    switch (ROperand->indexLevel)
    {
    case slvINDEX_LEVEL_LEAF:
        sourceReg.indexedLevel = gcSL_LEAF_INDEXED;
        break;

    case slvINDEX_LEVEL_NODE:
        sourceReg.indexedLevel = gcSL_NODE_INDEXED;
        break;

    case slvINDEX_LEVEL_LEAF_AND_NODE:
        sourceReg.indexedLevel = gcSL_LEAF_AND_NODE_INDEXED;
        break;

    default:
        sourceReg.indexedLevel = gcSL_NONE_INDEXED;
        break;
    }

    gcsSOURCE_InitializeReg(Source,
                            _ConvQualifierToSourceType(ROperand->u.reg.qualifier),
                            gcGetMatrixColumnDataType(dataType),
                            ROperand->u.reg.precision,
                            sourceReg);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvROperandToSourceConstant(
    IN sloCOMPILER Compiler,
    IN slsROPERAND * ROperand,
    OUT gcsSOURCE * Source
    )
{
    gcsSOURCE_CONSTANT sourceConstant;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand);
    gcmASSERT(!ROperand->isReg);
    gcmASSERT(gcIsScalarDataType(ROperand->dataType));
    gcmASSERT(Source);

    switch (ROperand->u.constant.dataType)
    {
    case gcSHADER_FLOAT_X1:
        sourceConstant.u.floatConstant  = ROperand->u.constant.values[0].floatValue;
        break;

    case gcSHADER_BOOLEAN_X1:
        sourceConstant.u.boolConstant   = ROperand->u.constant.values[0].boolValue;
        break;

    case gcSHADER_INTEGER_X1:
        sourceConstant.u.intConstant    = ROperand->u.constant.values[0].intValue;
        break;

    case gcSHADER_UINT_X1:
        sourceConstant.u.uintConstant    = ROperand->u.constant.values[0].uintValue;
        break;

    case gcSHADER_FLOAT_X2:
    case gcSHADER_FLOAT_X3:
    case gcSHADER_FLOAT_X4:
        gcmASSERT(ROperand->vectorIndex.mode == slvINDEX_CONSTANT);
        sourceConstant.u.floatConstant  =
                ROperand->u.constant.values[ROperand->vectorIndex.u.constant].floatValue;
        break;

    case gcSHADER_BOOLEAN_X2:
    case gcSHADER_BOOLEAN_X3:
    case gcSHADER_BOOLEAN_X4:
        gcmASSERT(ROperand->vectorIndex.mode == slvINDEX_CONSTANT);
        sourceConstant.u.boolConstant   =
                ROperand->u.constant.values[ROperand->vectorIndex.u.constant].boolValue;
        break;

    case gcSHADER_INTEGER_X2:
    case gcSHADER_INTEGER_X3:
    case gcSHADER_INTEGER_X4:
        gcmASSERT(ROperand->vectorIndex.mode == slvINDEX_CONSTANT);
        sourceConstant.u.intConstant    =
                ROperand->u.constant.values[ROperand->vectorIndex.u.constant].intValue;
        break;

    case gcSHADER_UINT_X2:
    case gcSHADER_UINT_X3:
    case gcSHADER_UINT_X4:
        gcmASSERT(ROperand->vectorIndex.mode == slvINDEX_CONSTANT);
        sourceConstant.u.uintConstant    =
                ROperand->u.constant.values[ROperand->vectorIndex.u.constant].uintValue;
        break;

    case gcSHADER_FLOAT_2X2:
    case gcSHADER_FLOAT_2X3:
    case gcSHADER_FLOAT_2X4:
    case gcSHADER_FLOAT_3X2:
    case gcSHADER_FLOAT_3X3:
    case gcSHADER_FLOAT_3X4:
    case gcSHADER_FLOAT_4X2:
    case gcSHADER_FLOAT_4X3:
    case gcSHADER_FLOAT_4X4:
        gcmASSERT(ROperand->matrixIndex.mode == slvINDEX_CONSTANT);
        gcmASSERT(ROperand->vectorIndex.mode == slvINDEX_CONSTANT);
        sourceConstant.u.floatConstant  =
                ROperand->u.constant.values[
                    ROperand->matrixIndex.u.constant
                        * gcGetMatrixDataTypeRowCount(ROperand->u.constant.dataType)
                        + ROperand->vectorIndex.u.constant].floatValue;
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    gcsSOURCE_InitializeConstant(Source, ROperand->dataType, ROperand->u.reg.precision, sourceConstant);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvROperandToSpecialVectorSourceConstant(
    IN sloCOMPILER Compiler,
    IN slsROPERAND * ROperand,
    OUT gcsSOURCE * Source
    )
{
    gcsSOURCE_CONSTANT  sourceConstant;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand);
    gcmASSERT(!ROperand->isReg);
    gcmASSERT(gcIsVectorDataType(ROperand->dataType));
    gcmASSERT(slsROPERAND_CONSTANT_IsAllVectorComponentsEqual(ROperand));
    gcmASSERT(Source);

    switch (gcGetVectorComponentDataType(ROperand->dataType))
    {
    case gcSHADER_FLOAT_X1:
        sourceConstant.u.floatConstant  = ROperand->u.constant.values[0].floatValue;
        break;

    case gcSHADER_BOOLEAN_X1:
        sourceConstant.u.boolConstant   = ROperand->u.constant.values[0].boolValue;
        break;

    case gcSHADER_INTEGER_X1:
        sourceConstant.u.intConstant    = ROperand->u.constant.values[0].intValue;
        break;

    case gcSHADER_UINT_X1:
        if (sloCOMPILER_IsHaltiVersion(Compiler)) {
           sourceConstant.u.uintConstant    = ROperand->u.constant.values[0].uintValue;
           break;
        }
        /* fall through */

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    gcsSOURCE_InitializeConstant(Source, ROperand->dataType, ROperand->u.reg.precision, sourceConstant);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvROperandToVectorComponentSourceConstant(
    IN sloCOMPILER Compiler,
    IN slsROPERAND * ROperand,
    IN gctUINT VectorIndex,
    OUT gcsSOURCE * Source
    )
{
    gcSHADER_TYPE       dataType;
    gcsSOURCE_CONSTANT  sourceConstant;
    gctUINT             rowCount;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand);
    gcmASSERT(!ROperand->isReg);
    gcmASSERT(gcIsVectorDataType(ROperand->dataType));
    gcmASSERT(ROperand->u.constant.valueCount > VectorIndex);
    gcmASSERT(Source);

    dataType = gcGetVectorComponentDataType(ROperand->dataType);

    if (gcIsMatrixDataType(ROperand->u.constant.dataType))
    {
        gcmASSERT(ROperand->dataType == gcGetMatrixColumnDataType(ROperand->u.constant.dataType));
        gcmASSERT(ROperand->matrixIndex.mode == slvINDEX_CONSTANT);

        rowCount = gcGetMatrixDataTypeRowCount(ROperand->u.constant.dataType);

        switch (dataType)
        {
        case gcSHADER_FLOAT_X1:
            sourceConstant.u.floatConstant  = ROperand->u.constant.values[
                                                    ROperand->matrixIndex.u.constant * rowCount
                                                        + VectorIndex].floatValue;
            break;

        case gcSHADER_BOOLEAN_X1:
            sourceConstant.u.boolConstant   = ROperand->u.constant.values[
                                                    ROperand->matrixIndex.u.constant * rowCount
                                                        + VectorIndex].boolValue;
            break;

        case gcSHADER_INTEGER_X1:
            sourceConstant.u.intConstant    = ROperand->u.constant.values[
                                                    ROperand->matrixIndex.u.constant * rowCount
                                                        + VectorIndex].intValue;
            break;

        case gcSHADER_UINT_X1:
            if (sloCOMPILER_IsHaltiVersion(Compiler)) {
                sourceConstant.u.uintConstant    = ROperand->u.constant.values[
                                                        ROperand->matrixIndex.u.constant * rowCount
                                                            + VectorIndex].uintValue;
                break;

            }
            /* fall through */

        default:
            gcmASSERT(0);
            gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }
    }
    else
    {
        gcmASSERT(gcIsVectorDataType(ROperand->u.constant.dataType));

        switch (dataType)
        {
        case gcSHADER_FLOAT_X1:
            sourceConstant.u.floatConstant  = ROperand->u.constant.values[VectorIndex].floatValue;
            break;

        case gcSHADER_BOOLEAN_X1:
            sourceConstant.u.boolConstant   = ROperand->u.constant.values[VectorIndex].boolValue;
            break;

        case gcSHADER_INTEGER_X1:
            sourceConstant.u.intConstant    = ROperand->u.constant.values[VectorIndex].intValue;
            break;

        case gcSHADER_UINT_X1:
            if (sloCOMPILER_IsHaltiVersion(Compiler)) {
               sourceConstant.u.uintConstant    = ROperand->u.constant.values[VectorIndex].uintValue;
               break;
            }
           /*fall through */

        default:
            gcmASSERT(0);
            gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }
    }

    gcsSOURCE_InitializeConstant(Source, dataType, ROperand->u.reg.precision, sourceConstant);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvROperandToMatrixComponentSourceConstant(
    IN sloCOMPILER Compiler,
    IN slsROPERAND * ROperand,
    IN gctUINT ColumnIndex,
    IN gctUINT VectorIndex,
    OUT gcsSOURCE * Source
    )
{
    gcSHADER_TYPE       dataType;
    gcsSOURCE_CONSTANT  sourceConstant;
    gctUINT             index;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand);
    gcmASSERT(!ROperand->isReg);
    gcmASSERT(gcIsMatrixDataType(ROperand->dataType));
    gcmASSERT(ROperand->u.constant.valueCount > VectorIndex);
    gcmASSERT(Source);

    dataType    = gcGetVectorComponentDataType(gcGetMatrixColumnDataType(ROperand->dataType));
    index       = ColumnIndex * gcGetMatrixDataTypeRowCount(ROperand->dataType) + VectorIndex;

    switch (dataType)
    {
    case gcSHADER_FLOAT_X1:
        sourceConstant.u.floatConstant  = ROperand->u.constant.values[index].floatValue;
        break;

    case gcSHADER_BOOLEAN_X1:
        sourceConstant.u.boolConstant   = ROperand->u.constant.values[index].boolValue;
        break;

    case gcSHADER_INTEGER_X1:
        sourceConstant.u.intConstant    = ROperand->u.constant.values[index].intValue;
        break;

    case gcSHADER_UINT_X1:
        if (sloCOMPILER_IsHaltiVersion(Compiler)) {
           sourceConstant.u.uintConstant    = ROperand->u.constant.values[index].uintValue;
           break;
        }
        /*fall through */

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    gcsSOURCE_InitializeConstant(Source, dataType, ROperand->u.reg.precision, sourceConstant);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvROperandToMatrixColumnROperandConstant(
    IN sloCOMPILER Compiler,
    IN slsROPERAND * ROperand,
    IN gctUINT ColumnIndex,
    OUT slsROPERAND *ConstantROperand
    )
{
    gcSHADER_TYPE       dataType, componentType;
    sluCONSTANT_VALUE   values[sldMAX_VECTOR_COMPONENT];
    gctUINT             index;
    gctUINT8            i, componentCount;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand);
    gcmASSERT(!ROperand->isReg);
    gcmASSERT(gcIsMatrixDataType(ROperand->dataType));
    gcmASSERT(ConstantROperand);

    dataType = gcGetMatrixColumnDataType(ROperand->dataType);
    componentCount = gcGetVectorDataTypeComponentCount(dataType);
    componentType = gcGetVectorComponentDataType(dataType);

    index = ColumnIndex * componentCount;
    gcmASSERT(ROperand->u.constant.valueCount >= (index + componentCount));

    for(i = 0; i < componentCount; i++, index++)
    {
        switch (componentType)
        {
        case gcSHADER_FLOAT_X1:
            values[i].floatValue  = ROperand->u.constant.values[index].floatValue;
            break;

        case gcSHADER_BOOLEAN_X1:
            values[i].boolValue   = ROperand->u.constant.values[index].boolValue;
            break;

        case gcSHADER_INTEGER_X1:
            values[i].intValue    = ROperand->u.constant.values[index].intValue;
            break;

        case gcSHADER_UINT_X1:
            if (sloCOMPILER_IsHaltiVersion(Compiler)) {
               values[i].uintValue    = ROperand->u.constant.values[index].uintValue;
               break;
            }
            /*fall through */

        default:
            gcmASSERT(0);
            gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }
    }

    slsROPERAND_InitializeConstant(ConstantROperand, dataType, ROperand->u.reg.precision, componentCount, values);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvNormalROperandToSource(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsROPERAND * ROperand,
    OUT gcsSOURCE * Source
    );

static gceSTATUS
_StoreRowMajorMatrix(
     IN sloCOMPILER Compiler,
     IN slsLOPERAND *LOperand,
     IN struct _slsStoreInfo  *MatrixInfo,
     IN slsROPERAND *ROperand
     )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctUINT8 selVectorIndex[sldMAX_VECTOR_COMPONENT] = {gcvFALSE,};
    gctUINT8 j;
    slsROPERAND operandBuf[1];
    slsROPERAND *rOperand;
    slsROPERAND *scalarOperand;
    slsIOPERAND addressIOperand[1];
    gcsSOURCE offsetSource[1];
    gcsSOURCE source1[1];
    gctINT addressOffset;
    gcsTARGET addressTarget[1];
    gcsSOURCE *addressSource;
    gcsTARGET target[1];
    gcsSOURCE address[1];
    gcSHADER_TYPE componentType;

    componentType = gcGetComponentDataType(LOperand->dataType);
    gcsTARGET_Initialize(target,
                         componentType,
                         LOperand->reg.precision,
                         0,
                         gcSL_ENABLE_X,
                         gcSL_NOT_INDEXED,
                         (gctREG_INDEX)~0);

    selVectorIndex[0] = gcSL_ENABLE_X;
    selVectorIndex[1] = gcSL_ENABLE_Y;
    selVectorIndex[2] = gcSL_ENABLE_Z;
    selVectorIndex[3] = gcSL_ENABLE_W;

    gcmASSERT(ROperand);

    if (gcIsScalarDataType(ROperand->dataType)) {
        rOperand = ROperand;
    }
    else {
        sloIR_ROperandComponentSelect(Compiler,
                                      ROperand,
                                      MatrixInfo->reversedComponentSelection,
                                      operandBuf);
        rOperand = operandBuf;
    }
    scalarOperand = rOperand;

    addressSource = &MatrixInfo->address;
    addressOffset = MatrixInfo->offset;

    for(j = 0; j < sldMAX_VECTOR_COMPONENT; j++) {
        if(MatrixInfo->enable & selVectorIndex[j]) {
            slsROPERAND operandBuf[1];

            if(addressOffset) {
                gcsSOURCE_CONSTANT  sourceConstant;
                gcSHADER_PRECISION precision;

                sourceConstant.u.intConstant = addressOffset;
                precision =_slmComputeIntConstantPrecision(sourceConstant.u.intConstant);
                gcsSOURCE_InitializeConstant(offsetSource,
                                             gcSHADER_INTEGER_X1,
                                             precision,
                                             sourceConstant);
                slsIOPERAND_New(Compiler, addressIOperand, MatrixInfo->address.dataType, precision);
                gcsTARGET_InitializeUsingIOperand(addressTarget, addressIOperand);
                gcsSOURCE_InitializeUsingIOperand(address, addressIOperand);
                status = slEmitCode2(Compiler,
                                     0,
                                     0,
                                     slvOPCODE_ADD,
                                     addressTarget,
                                     &MatrixInfo->address,
                                     offsetSource);
                if (gcmIS_ERROR(status)) { return status; }
                addressSource = address;
            }

            if (gcIsVectorDataType(rOperand->dataType))
            {
                slGetVectorROperandSlice(rOperand,
                                         j,
                                         1,
                                         operandBuf);
                scalarOperand = operandBuf;
            }

            if (scalarOperand->isReg)
            {
                gcmONERROR(_ConvNormalROperandToSource(Compiler,
                                                       0,
                                                       0,
                                                       scalarOperand,
                                                       source1));
            }
            else
            {
                gcmONERROR(_ConvROperandToSourceConstant(Compiler,
                                                         scalarOperand,
                                                         source1));
            }

            status = slEmitCode2(Compiler,
                                 0,
                                 0,
                                 slvOPCODE_STORE1,
                                 target,
                                 addressSource,
                                 source1);
            if (gcmIS_ERROR(status)) { return status; }
        }

        addressOffset += MatrixInfo->rowMajorStride;
    }

OnError:
    return status;
}

static gceSTATUS
_StoreInterfaceBlockMember(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsLOPERAND * LOperand,
    IN slsROPERAND * ROperand
    )
{
    gceSTATUS               status = gcvSTATUS_OK;
    gcsTARGET               target[1];
    struct _slsStoreInfo    source0Info = { {0}, 0 };
    gcsSOURCE               source1[1];
    gctUINT                 i, j;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LOperand);
    gcmASSERT(ROperand);
    gcmASSERT(LOperand->dataType == ROperand->dataType);

    if (gcIsScalarDataType(LOperand->dataType))
    {
        gcmONERROR(_MakeStoreSource(Compiler,
                                    LOperand,
                                    0,
                                    &source0Info));

        if(source0Info.rowMajorStride) {
            _StoreRowMajorMatrix(Compiler,
                                 LOperand,
                                 &source0Info,
                                 ROperand);
        }
        else {
            gcsTARGET_Initialize(target,
                                 LOperand->dataType,
                                 LOperand->reg.precision,
                                 0,
                                 source0Info.enable,
                                 gcSL_NOT_INDEXED,
                                 (gctREG_INDEX)~0);

            if (ROperand->isReg)
            {
                gcmONERROR(_ConvROperandToSourceReg(Compiler,
                                                    ROperand,
                                                    source0Info.reversedComponentSelection,
                                                    source1));
            }
            else
            {
                gcmONERROR(_ConvROperandToSourceConstant(Compiler,
                                                         ROperand,
                                                         source1));
            }

            gcmONERROR(slEmitCode2(Compiler,
                                   LineNo,
                                   StringNo,
                                   slvOPCODE_STORE1,
                                   target,
                                   &source0Info.address,
                                   source1));
        }
    }
    else if (gcIsVectorDataType(LOperand->dataType))
    {
        gcmONERROR(_MakeStoreSource(Compiler,
                                    LOperand,
                                    0,
                                    &source0Info));

        if(source0Info.rowMajorStride) {
            _StoreRowMajorMatrix(Compiler,
                                 LOperand,
                                 &source0Info,
                                 ROperand);
        }
        else if (ROperand->isReg)
        {
            gcsTARGET_Initialize(target,
                                 LOperand->dataType,
                                 LOperand->reg.precision,
                                 0,
                                 source0Info.enable,
                                 gcSL_NOT_INDEXED,
                                 (gctREG_INDEX)~0);

            gcmONERROR(_ConvROperandToSourceReg(Compiler,
                                                ROperand,
                                                source0Info.reversedComponentSelection,
                                                source1));

            gcmONERROR(slEmitCode2(Compiler,
                                   LineNo,
                                   StringNo,
                                   slvOPCODE_STORE1,
                                   target,
                                   &source0Info.address,
                                   source1));
        }
        else if (slsROPERAND_CONSTANT_IsAllVectorComponentsEqual(ROperand))
        {
            gcsTARGET_Initialize(target,
                                 LOperand->dataType,
                                 LOperand->reg.precision,
                                 0,
                                 source0Info.enable,
                                 gcSL_NOT_INDEXED,
                                 (gctREG_INDEX)~0);

            gcmONERROR(_ConvROperandToSpecialVectorSourceConstant(Compiler,
                                                                  ROperand,
                                                                  source1));

            gcmONERROR(slEmitCode2(Compiler,
                                   LineNo,
                                   StringNo,
                                   slvOPCODE_STORE1,
                                   target,
                                   &source0Info.address,
                                   source1));
        }
        else
        {
            slsROPERAND   operandBuf[1];
            slsROPERAND   *rOperand;
            gcsTARGET     tempTarget[1];
            gctREG_INDEX  tempRegIndex;
            gcSHADER_TYPE componentType;
            gctUINT8 selComponentEnable[sldMAX_VECTOR_COMPONENT] =
                 {gcSL_ENABLE_X, gcSL_ENABLE_Y, gcSL_ENABLE_Z, gcSL_ENABLE_W};

            gcmASSERT(ROperand);

            if (gcIsScalarDataType(ROperand->dataType)) {
                rOperand = ROperand;
            }
            else {
                sloIR_ROperandComponentSelect(Compiler,
                                              ROperand,
                                              source0Info.reversedComponentSelection,
                                              operandBuf);
                rOperand = operandBuf;
            }

            tempRegIndex = slNewTempRegs(Compiler, 1);
            componentType = gcGetVectorComponentDataType(LOperand->dataType);
            for(i = 0; i < sldMAX_VECTOR_COMPONENT; i++) {
                if(source0Info.enable & selComponentEnable[i]) {

                    gcsTARGET_Initialize(tempTarget,
                                         componentType,
                                         rOperand->u.constant.precision,
                                         tempRegIndex,
                                         selComponentEnable[i],
                                         gcSL_NOT_INDEXED,
                                         (gctREG_INDEX)~0);

                    gcmONERROR(_ConvROperandToVectorComponentSourceConstant(Compiler,
                                                                            rOperand,
                                                                            i,
                                                                            source1));

                    gcmONERROR(slEmitCode1(Compiler,
                                           LineNo,
                                           StringNo,
                                           slvOPCODE_ASSIGN,
                                           tempTarget,
                                           source1));
                }
            }

            gcsTARGET_Initialize(target,
                                 LOperand->dataType,
                                 LOperand->reg.precision,
                                 0,
                                 source0Info.enable,
                                 gcSL_NOT_INDEXED,
                                 (gctREG_INDEX)~0);

            gcsSOURCE_InitializeTempReg(source1,
                                        rOperand->dataType,
                                        rOperand->u.constant.precision,
                                        tempRegIndex,
                                        0xe4,
                                        gcSL_NOT_INDEXED,
                                        (gctREG_INDEX)~0);

            gcmONERROR(slEmitCode2(Compiler,
                                   LineNo,
                                   StringNo,
                                   slvOPCODE_STORE1,
                                   target,
                                   &source0Info.address,
                                   source1));
        }
    }
    else
    {
        gctUINT columnCount;
        gcSHADER_TYPE dataType;

        gcmASSERT(gcIsMatrixDataType(LOperand->dataType));

        columnCount = gcGetMatrixDataTypeColumnCount(LOperand->dataType);
        for (i = 0; i < columnCount; i++)
        {
            dataType = gcGetMatrixColumnDataType(LOperand->dataType);
            gcmONERROR(_MakeStoreSource(Compiler,
                                        LOperand,
                                        i,
                                        &source0Info));
            if(source0Info.rowMajorStride)
            {
                slsROPERAND rOperand[1];

                if(ROperand->isReg)
                {
                    slsROPERAND_InitializeAsMatrixColumn(rOperand, ROperand, i);
                }
                else
                {
                    gcmONERROR(_ConvROperandToMatrixColumnROperandConstant(Compiler,
                                                                           ROperand,
                                                                           i,
                                                                           rOperand));
                }
                _StoreRowMajorMatrix(Compiler,
                                     LOperand,
                                     &source0Info,
                                     rOperand);
            }
            else if (ROperand->isReg)
            {
                gcsTARGET_Initialize(target,
                                     dataType,
                                     LOperand->reg.precision,
                                     0,
                                     source0Info.enable,
                                     gcSL_NOT_INDEXED,
                                     (gctREG_INDEX)~0);

                gcmONERROR(_ConvROperandToMatrixColumnSourceReg(Compiler,
                                                                ROperand,
                                                                i,
                                                                source1));

                gcmONERROR(slEmitCode2(Compiler,
                                       LineNo,
                                       StringNo,
                                       slvOPCODE_STORE1,
                                       target,
                                       &source0Info.address,
                                       source1));
            }
            else
            {
                slsROPERAND constantROperand[1];

                gcmONERROR(_ConvROperandToMatrixColumnROperandConstant(Compiler,
                                                                       ROperand,
                                                                       i,
                                                                       constantROperand));

                if (slsROPERAND_CONSTANT_IsAllVectorComponentsEqual(constantROperand))
                {
                    gcsTARGET_Initialize(target,
                                         dataType,
                                         LOperand->reg.precision,
                                         0,
                                         source0Info.enable,
                                         gcSL_NOT_INDEXED,
                                         (gctREG_INDEX)~0);

                    gcmONERROR(_ConvROperandToSpecialVectorSourceConstant(Compiler,
                                                                          constantROperand,
                                                                          source1));

                    gcmONERROR(slEmitCode2(Compiler,
                                           LineNo,
                                           StringNo,
                                           slvOPCODE_STORE1,
                                           target,
                                           &source0Info.address,
                                           source1));
                }
                else
                {
                    gcsTARGET     tempTarget[1];
                    gctREG_INDEX  tempRegIndex;
                    gctUINT8 componentCount;
                    gcSHADER_TYPE componentType;
                    gctUINT8 selComponentEnable[sldMAX_VECTOR_COMPONENT] =
                             {gcSL_ENABLE_X, gcSL_ENABLE_Y, gcSL_ENABLE_Z, gcSL_ENABLE_W};
                    tempRegIndex = slNewTempRegs(Compiler, 1);
                    componentCount = gcGetVectorDataTypeComponentCount(dataType);
                    componentType = gcGetVectorComponentDataType(dataType);
                    for(j = 0; j < componentCount; j++) {
                        gcsTARGET_Initialize(tempTarget,
                                             componentType,
                                             constantROperand->u.constant.precision,
                                             tempRegIndex,
                                             selComponentEnable[j],
                                             gcSL_NOT_INDEXED,
                                             (gctREG_INDEX)~0);

                        gcmONERROR(_ConvROperandToVectorComponentSourceConstant(Compiler,
                                                                                constantROperand,
                                                                                j,
                                                                                source1));

                        gcmONERROR(slEmitCode1(Compiler,
                                               LineNo,
                                               StringNo,
                                               slvOPCODE_ASSIGN,
                                               tempTarget,
                                               source1));
                    }

                    gcsTARGET_Initialize(target,
                                         dataType,
                                         LOperand->reg.precision,
                                         0,
                                         source0Info.enable,
                                         gcSL_NOT_INDEXED,
                                         (gctREG_INDEX)~0);

                    gcsSOURCE_InitializeTempReg(source1,
                                                dataType,
                                                constantROperand->u.constant.precision,
                                                tempRegIndex,
                                                0xe4,
                                                gcSL_NOT_INDEXED,
                                                (gctREG_INDEX)~0);

                    gcmONERROR(slEmitCode2(Compiler,
                                           LineNo,
                                           StringNo,
                                           slvOPCODE_STORE1,
                                           target,
                                           &source0Info.address,
                                           source1));
                }
            }
        }
    }
OnError:
    gcmFOOTER();
    return status;
}

/*
** When storing per-vertex/per-patch members,
** we can't have matrix&vertex reg-index or vector&vertex reg-index at the same time.
** All matrix indexed and vector indexed have been convert constant indexed.
*/
static gceSTATUS
_StorePerVertexMember(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsLOPERAND * LOperand,
    IN slsROPERAND * ROperand
    )
{
    gceSTATUS           status = gcvSTATUS_OK;
    gcsSOURCE_REG       vertexSourceReg = {{0}};
    gcsSOURCE_CONSTANT  vertexSourceConstant = {{0}};
    gcsSOURCE           vertexSource[1], dataSource[1];
    gcsTARGET           target[1];

    gcmHEADER();

    /* I: Get the vertex index. */
    if (LOperand->vertexIndex.mode == slvINDEX_NONE)
    {
        gcsSOURCE_InitializeConstant(vertexSource,
                                     gcSHADER_INTEGER_X1,
                                     gcSHADER_PRECISION_HIGH,
                                     vertexSourceConstant);
    }
    else if (LOperand->vertexIndex.mode == slvINDEX_CONSTANT)
    {
        vertexSourceConstant.u.intConstant = (gctINT)LOperand->vertexIndex.u.constant;
        gcsSOURCE_InitializeConstant(vertexSource,
                                     gcSHADER_INTEGER_X1,
                                     gcSHADER_PRECISION_HIGH,
                                     vertexSourceConstant);
    }
    else if (LOperand->vertexIndex.mode != slvINDEX_NONE)
    {
        gcSL_INDEXED indexed = _ConvertIndexModeToIndexed(LOperand->vertexIndex.mode);
        vertexSourceReg.regIndex    = LOperand->vertexIndex.u.indexRegIndex;
        vertexSourceReg.indexMode   = gcSL_NOT_INDEXED;
        vertexSourceReg.swizzle     = (gctUINT8)gcmComposeSwizzle(indexed - 1,
                                                                  indexed - 1,
                                                                  indexed - 1,
                                                                  indexed - 1);
        gcsSOURCE_InitializeReg(vertexSource,
                                gcvSOURCE_TEMP,
                                gcSHADER_INTEGER_X1,
                                LOperand->reg.precision,
                                vertexSourceReg);
    }

    /* II: Set the data. */
    gcmONERROR(_ConvNormalROperandToSource(Compiler,
                                           LineNo,
                                           StringNo,
                                           ROperand,
                                           dataSource));

    /* III: Set the target. */
    target->format = -1;
    target->dataType = LOperand->dataType;
    target->precision = LOperand->reg.precision;
    target->tempRegIndex = LOperand->reg.u.output->tempIndex;
    /* Set array Index. */
    if (LOperand->arrayIndex.mode == slvINDEX_REG)
    {
        target->indexMode = gcSL_INDEXED_X;
        target->indexRegIndex = LOperand->arrayIndex.u.constant;
    }
    else if (LOperand->arrayIndex.mode == slvINDEX_REG_Y)
    {
        target->indexMode = gcSL_INDEXED_Y;
        target->indexRegIndex = LOperand->arrayIndex.u.constant;
    }
    else if (LOperand->arrayIndex.mode == slvINDEX_REG_Z)
    {
        target->indexMode = gcSL_INDEXED_Z;
        target->indexRegIndex = LOperand->arrayIndex.u.constant;
    }
    else if (LOperand->arrayIndex.mode == slvINDEX_REG_W)
    {
        target->indexMode = gcSL_INDEXED_W;
        target->indexRegIndex = LOperand->arrayIndex.u.constant;
    }
    else if (LOperand->arrayIndex.mode == slvINDEX_CONSTANT)
    {
        gctREG_INDEX        indexRegIndex;
        slsIOPERAND         iOperand[1];
        slsLOPERAND         lOperand[1];
        slsROPERAND         rOperand[1];
        sluCONSTANT_VALUE   constantValue[1];

        constantValue[0].intValue = (gctINT)LOperand->arrayIndex.u.constant;

        indexRegIndex = slNewTempRegs(Compiler, 1);
        slsIOPERAND_Initialize(iOperand,
                               gcSHADER_INTEGER_X1,
                               gcSHADER_PRECISION_HIGH,
                               indexRegIndex);

        slsLOPERAND_InitializeUsingIOperand(lOperand, iOperand);
        slsROPERAND_InitializeConstant(&rOperand[0],
                                       gcSHADER_INTEGER_X1,
                                       gcSHADER_PRECISION_HIGH,
                                       1,
                                       constantValue);

        gcmONERROR(slGenAssignCode(Compiler,
                                   0,
                                   0,
                                   lOperand,
                                   rOperand));
        target->indexMode = gcSL_INDEXED_X;
        target->indexRegIndex = indexRegIndex;
    }
    else
    {
        target->indexMode = gcSL_NOT_INDEXED;
        target->indexRegIndex = 0;
    }
    /* Set matrix Index. */
    if (LOperand->matrixIndex.mode != slvINDEX_NONE)
    {
        gcmASSERT(LOperand->matrixIndex.mode == slvINDEX_CONSTANT);
        target->tempRegIndex += LOperand->matrixIndex.u.constant;
    }
    /* Set the vector index. */
    if (LOperand->vectorIndex.mode != slvINDEX_NONE)
    {
        gcmASSERT(LOperand->vectorIndex.mode == slvINDEX_CONSTANT);
        target->enable = gcSL_ENABLE_X << LOperand->vectorIndex.u.constant;
    }
    else
    {
        target->enable = gcGetDefaultEnable(LOperand->dataType);
    }

    gcmONERROR(slEmitCode2(Compiler,
                           0,
                           0,
                           slvOPCODE_ATTR_ST,
                           target,
                           dataSource,
                           vertexSource
                           ));
OnError:
    gcmFOOTER_NO();
    return status;
}


static gceSTATUS
_SpecialGenAssignCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsLOPERAND * LOperand,
    IN slsROPERAND * ROperand
    )
{
    gceSTATUS               status = gcvSTATUS_OK;
    gcsTARGET               target;
    slsCOMPONENT_SELECTION  reversedComponentSelection;
    gcsSOURCE               source;
    gctUINT                 i, j;
    gctBOOL                 isUseAttrCode = (LOperand->vertexIndex.mode != slvINDEX_NONE);

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LOperand);
    gcmASSERT(ROperand);

    if(_IsLOperandStorageBlockMember(Compiler, LOperand)) {
        return _StoreInterfaceBlockMember(Compiler,
                                          LineNo,
                                          StringNo,
                                          LOperand,
                                          ROperand);
    }

    if (isUseAttrCode)
    {
        if (gcIsMatrixDataType(LOperand->dataType))
        {
            for (i = 0; i < gcGetMatrixDataTypeColumnCount(LOperand->dataType); i++)
            {
                slsLOPERAND lOperand[1];
                slsROPERAND rOperand[1];

                /* Slice target. */
                lOperand[0] = *LOperand;
                lOperand[0].dataType = gcGetMatrixColumnDataType(LOperand->dataType);
                lOperand[0].matrixIndex.mode = slvINDEX_CONSTANT;
                lOperand[0].matrixIndex.u.constant = i;
                /* Slice source. */
                rOperand[0] = *ROperand;
                rOperand[0].dataType = gcGetMatrixColumnDataType(ROperand->dataType);
                rOperand[0].matrixIndex.mode = slvINDEX_CONSTANT;
                rOperand[0].matrixIndex.u.constant = i;

                gcmONERROR(_StorePerVertexMember(Compiler,
                                                 LineNo,
                                                 StringNo,
                                                 lOperand,
                                                 rOperand));
            }

            status =  gcvSTATUS_OK;
        }
        else
        {
            status =  _StorePerVertexMember(Compiler,
                                            LineNo,
                                            StringNo,
                                            LOperand,
                                            ROperand);
        }
        return status;
    }

    gcmASSERT(LOperand->dataType == ROperand->dataType);

    if (gcIsScalarDataType(LOperand->dataType))
    {
        gcmONERROR(_ConvLOperandToTarget(Compiler,
                                         LOperand,
                                         &target,
                                         &reversedComponentSelection));

        if (ROperand->isReg)
        {
            gcmONERROR(_ConvROperandToSourceReg(Compiler,
                                                ROperand,
                                                reversedComponentSelection,
                                                &source));
        }
        else
        {
            gcmONERROR(_ConvROperandToSourceConstant(Compiler,
                                                     ROperand,
                                                     &source));
        }

        gcmONERROR(slEmitAssignCode(Compiler,
                                    LineNo,
                                    StringNo,
                                    &target,
                                    &source));
    }
    else if (gcIsVectorDataType(LOperand->dataType) ||
             gcIsSamplerDataType(LOperand->dataType) ||
             gcIsImageDataType(LOperand->dataType))
    {
        if (ROperand->isReg)
        {
            gcmONERROR(_ConvLOperandToTarget(Compiler,
                                             LOperand,
                                             &target,
                                             &reversedComponentSelection));

            gcmONERROR(_ConvROperandToSourceReg(Compiler,
                                                ROperand,
                                                reversedComponentSelection,
                                                &source));
            gcmONERROR(slEmitAssignCode(Compiler,
                                        LineNo,
                                        StringNo,
                                        &target,
                                        &source));
        }
        else
        {
            gcmASSERT(!gcIsSamplerDataType(LOperand->dataType) &&
                      !gcIsImageDataType(LOperand->dataType));

            if (slsROPERAND_CONSTANT_IsAllVectorComponentsEqual(ROperand))
            {
                gcmONERROR(_ConvLOperandToTarget(Compiler,
                                                 LOperand,
                                                 &target,
                                                 &reversedComponentSelection));

                gcmONERROR(_ConvROperandToSpecialVectorSourceConstant(Compiler,
                                                                      ROperand,
                                                                      &source));

                gcmONERROR(slEmitAssignCode(Compiler,
                                            LineNo,
                                            StringNo,
                                            &target,
                                            &source));
            }
            else
            {
                for (i = 0; i < gcGetVectorDataTypeComponentCount(LOperand->dataType); i++)
                {
                    gcmONERROR(_ConvLOperandToVectorComponentTarget(Compiler,
                                                                    LOperand,
                                                                    i,
                                                                    &target));

                    gcmONERROR(_ConvROperandToVectorComponentSourceConstant(Compiler,
                                                                            ROperand,
                                                                            i,
                                                                            &source));

                    gcmONERROR(slEmitAssignCode(Compiler,
                                                LineNo,
                                                StringNo,
                                                &target,
                                                &source));
                }
            }
        }
    }
    else
    {
        gcmASSERT(gcIsMatrixDataType(LOperand->dataType));

        if (ROperand->isReg)
        {
            for (i = 0; i < gcGetMatrixDataTypeColumnCount(LOperand->dataType); i++)
            {
                gcmONERROR(_ConvLOperandToMatrixColumnTarget(Compiler,
                                                             LOperand,
                                                             i,
                                                             &target));

                gcmONERROR(_ConvROperandToMatrixColumnSourceReg(Compiler,
                                                                ROperand,
                                                                i,
                                                                &source));

                gcmONERROR(slEmitAssignCode(Compiler,
                                            LineNo,
                                            StringNo,
                                            &target,
                                            &source));
            }
        }
        else
        {
            for (i = 0; i < gcGetMatrixDataTypeColumnCount(LOperand->dataType); i++)
            {
                for (j = 0; j < gcGetMatrixDataTypeRowCount(LOperand->dataType); j++)
                {
                    gcmONERROR(_ConvLOperandToMatrixComponentTarget(Compiler,
                                                                    LOperand,
                                                                    i,
                                                                    j,
                                                                    &target));

                    gcmONERROR(_ConvROperandToMatrixComponentSourceConstant(Compiler,
                                                                            ROperand,
                                                                            i,
                                                                            j,
                                                                            &source));


                    gcmONERROR(slEmitAssignCode(Compiler,
                                                LineNo,
                                                StringNo,
                                                &target,
                                                &source));
                }
            }
        }
    }
OnError:
    gcmFOOTER();
    return status;
}

gceSTATUS
slGenAssignSamplerCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsLOPERAND * LOperand,
    IN slsROPERAND * ROperand
    )
{
    gceSTATUS       status;
    slsLOPERAND     realLOperand;
    slsROPERAND     realROperand;
    slsIOPERAND     intermIOperands[1];

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LOperand);
    gcmASSERT(gcIsSamplerDataType(LOperand->dataType));
    gcmASSERT(ROperand);
    gcmASSERT(LOperand->dataType == ROperand->dataType);
    gcmASSERT(ROperand->isReg);

    realLOperand                = *LOperand;
    realLOperand.dataType       = realLOperand.reg.dataType = gcSHADER_INTEGER_X1;

    if (ROperand->u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM)
    {
        intermIOperands[0].dataType = gcSHADER_INTEGER_X1;
        intermIOperands[0].precision = LOperand->reg.precision;
        intermIOperands[0].tempRegIndex = realLOperand.reg.regIndex;

        status = slGenGenericCode1(Compiler,
                                   LineNo,
                                   StringNo,
                                   slvOPCODE_GET_SAMPLER_IDX,
                                   intermIOperands,
                                   ROperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        intermIOperands[0].dataType = gcSHADER_INTEGER_X1;
        intermIOperands[0].precision = LOperand->reg.precision;
        intermIOperands[0].tempRegIndex = realLOperand.reg.regIndex;

        realROperand            = *ROperand;
        realROperand.dataType   = realROperand.u.reg.dataType   = gcSHADER_INTEGER_X1;

        status = slGenGenericCode1(
                                Compiler,
                                LineNo,
                                StringNo,
                                slvOPCODE_SAMPLER_ASSIGN,
                                &intermIOperands[0],
                                &realROperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenAssignCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsLOPERAND * LOperand,
    IN slsROPERAND * ROperand
    )
{
    gceSTATUS       status;
    slsROPERAND     newROperand;
    slsIOPERAND     intermIOperand;
    slsLOPERAND     intermLOperand;
    slsROPERAND     intermROperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(LOperand);
    gcmASSERT(LOperand->vectorIndex.mode != slvINDEX_REG);
    gcmASSERT(ROperand);
    gcmASSERT(ROperand->vectorIndex.mode != slvINDEX_REG);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<OPERATION line=\"%d\" string=\"%d\" type=\"assign\">",
                            LineNo,
                            StringNo));

    gcmVERIFY_OK(slsLOPERAND_Dump(Compiler, LOperand));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand));

    gcmASSERT(ROperand->isReg || (ROperand->arrayIndex.mode != slvINDEX_REG));

    if (!ROperand->isReg && (ROperand->matrixIndex.mode == slvINDEX_REG))
    {
        newROperand = *ROperand;
        newROperand.matrixIndex.mode = slvINDEX_NONE;

        slsIOPERAND_New(Compiler, &intermIOperand, ROperand->dataType, LOperand->reg.precision);
        slsLOPERAND_InitializeUsingIOperand(&intermLOperand, &intermIOperand);

        status = _SpecialGenAssignCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    &intermLOperand,
                                    &newROperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);
        intermROperand.matrixIndex = ROperand->matrixIndex;

        status = _SpecialGenAssignCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    LOperand,
                                    &intermROperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        status = _SpecialGenAssignCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    LOperand,
                                    ROperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</OPERATION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvIOperandToVectorComponentTarget(
    IN sloCOMPILER Compiler,
    IN slsIOPERAND * IOperand,
    IN gctUINT VectorIndex,
    OUT gcsTARGET * Target
    )
{
    gceSTATUS       status;
    slsIOPERAND     componentIOperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(gcIsVectorDataType(IOperand->dataType));
    gcmASSERT(Target);

    componentIOperand           = *IOperand;
    componentIOperand.dataType  = gcGetVectorComponentDataType(IOperand->dataType);

    status =  _ConvIOperandToTarget(
                                    Compiler,
                                    &componentIOperand,
                                    Target);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    switch (VectorIndex)
    {
    case 0: Target->enable = gcSL_ENABLE_X; break;
    case 1: Target->enable = gcSL_ENABLE_Y; break;
    case 2: Target->enable = gcSL_ENABLE_Z; break;
    case 3: Target->enable = gcSL_ENABLE_W; break;

    default: gcmASSERT(0);
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_ConvIOperandToMatrixColumnTarget(
    IN sloCOMPILER Compiler,
    IN slsIOPERAND * IOperand,
    IN gctUINT MatrixIndex,
    OUT gcsTARGET * Target
    )
{
    slsIOPERAND     columnIOperand[1];
    gceSTATUS       status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(gcIsMatrixDataType(IOperand->dataType));
    gcmASSERT(Target);

    slsIOPERAND_InitializeAsMatrixColumn(columnIOperand, IOperand, MatrixIndex);

    status = _ConvIOperandToTarget(
                                Compiler,
                                columnIOperand,
                                Target);
    gcmFOOTER();
    return status;
}

static gceSTATUS
_ConvNormalROperandToSource(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsROPERAND * ROperand,
    OUT gcsSOURCE * Source
    )
{
    gceSTATUS               status = gcvSTATUS_OK;
    slsIOPERAND             intermIOperand;
    slsLOPERAND             intermLOperand;
    slsROPERAND             intermROperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand);
    gcmASSERT(!gcIsMatrixDataType(ROperand->dataType));
    gcmASSERT(Source);

    /* Assign the non-scalar constant operand to a new register operand */
    if (!ROperand->isReg && gcIsScalarDataType(ROperand->dataType))
    {
        gcmONERROR(_ConvROperandToSourceConstant(
                                                Compiler,
                                                ROperand,
                                                Source));
    }
    else if (!ROperand->isReg && gcIsVectorDataType(ROperand->dataType)
            && slsROPERAND_CONSTANT_IsAllVectorComponentsEqual(ROperand))
    {
        gcmONERROR(_ConvROperandToSpecialVectorSourceConstant(
                                                                Compiler,
                                                                ROperand,
                                                                Source));
    }
    else
    {
        if (!ROperand->isReg)
        {
            gcmASSERT(gcIsVectorDataType(ROperand->dataType));

            slsIOPERAND_New(Compiler, &intermIOperand, ROperand->dataType, ROperand->u.reg.precision);
            slsLOPERAND_InitializeUsingIOperand(&intermLOperand, &intermIOperand);

            gcmONERROR(slGenAssignCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    &intermLOperand,
                                    ROperand));

            slsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);
            ROperand = &intermROperand;
        }

        gcmONERROR(_ConvROperandToSourceReg(
                                            Compiler,
                                            ROperand,
                                            slGetDefaultComponentSelection(ROperand->dataType),
                                            Source));
    }
OnError:
    gcmFOOTER();
    return status;
}

static gceSTATUS
_ConvNormalROperandToMatrixColumnSource(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsROPERAND * ROperand,
    IN gctUINT MatrixIndex,
    OUT gcsSOURCE * Source
    )
{
    gcSHADER_TYPE           dataType;
    slsROPERAND             columnROperand;
    gceSTATUS               status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ROperand);
    gcmASSERT(gcIsMatrixDataType(ROperand->dataType));
    gcmASSERT(ROperand->matrixIndex.mode == slvINDEX_NONE);
    gcmASSERT(Source);

    dataType = gcGetMatrixColumnDataType(ROperand->dataType);

    columnROperand                          = *ROperand;
    columnROperand.dataType                 = dataType;
    columnROperand.matrixIndex.mode         = slvINDEX_CONSTANT;
    columnROperand.matrixIndex.u.constant   = (gctREG_INDEX)MatrixIndex;

    status = _ConvNormalROperandToSource(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    &columnROperand,
                                    Source);
    gcmFOOTER();
    return status;
}

static gceSTATUS
_GenMatrixMulVectorCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1
    );

gceSTATUS
slGenArithmeticExprCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN sleOPCODE Opcode,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1
    )
{
    gceSTATUS   status;
    gcsTARGET   target;
    gcsSOURCE   source0;
    gcsSOURCE   source1;
    gctUINT     i;
    slsIOPERAND columnIOperand;
    slsROPERAND columnROperand1;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(ROperand0);
    gcmASSERT(ROperand1);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<OPERATION line=\"%d\" string=\"%d\" type=\"%s\">",
                            LineNo,
                            StringNo,
                            slGetOpcodeName(Opcode)));

    gcmVERIFY_OK(slsIOPERAND_Dump(Compiler, IOperand));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand0));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand1));

    switch (Opcode)
    {
    case slvOPCODE_ADD:
    case slvOPCODE_SUB:
    case slvOPCODE_MUL:
    case slvOPCODE_MULHI:
    case slvOPCODE_DIV:
    case slvOPCODE_IDIV:
    case slvOPCODE_MOD:
    case slvOPCODE_CMP:
    case slvOPCODE_ATOMADD:
    case slvOPCODE_ATOMSUB:
    case slvOPCODE_ATOMMIN:
    case slvOPCODE_ATOMMAX:
    case slvOPCODE_ATOMAND:
    case slvOPCODE_ATOMOR:
    case slvOPCODE_ATOMXOR:
    case slvOPCODE_ATOMXCHG:
    case slvOPCODE_ATOMCMPXCHG:
    case slvOPCODE_IMAGE_ADDRESS:
    case slvOPCODE_IMAGE_ADDRESS_3D:
        break;

    default: gcmASSERT(0);
    }

    if ((Opcode == slvOPCODE_MUL) &&
        gcIsVectorDataType(ROperand0->dataType) && gcIsMatrixDataType(ROperand1->dataType))
    {
        gcmASSERT(gcGetVectorDataTypeComponentCount(IOperand->dataType)
                    == gcGetMatrixDataTypeColumnCount(ROperand1->dataType));
        gcmASSERT(gcGetVectorDataTypeComponentCount(ROperand0->dataType)
                    == gcGetMatrixDataTypeRowCount(ROperand1->dataType));

        status = _ConvNormalROperandToSource(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            ROperand0,
                                            &source0);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        for (i = 0; i < gcGetVectorDataTypeComponentCount(IOperand->dataType); i++)
        {
            gcmVERIFY_OK(_ConvIOperandToVectorComponentTarget(Compiler, IOperand, i, &target));

            status = _ConvNormalROperandToMatrixColumnSource(
                                                            Compiler,
                                                            LineNo,
                                                            StringNo,
                                                            ROperand1,
                                                            i,
                                                            &source1);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = slEmitCode2(
                                Compiler,
                                LineNo,
                                StringNo,
                                slvOPCODE_DOT,
                                &target,
                                &source0,
                                &source1);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
    }
    else if ((Opcode == slvOPCODE_MUL) &&
        gcIsMatrixDataType(ROperand0->dataType) && gcIsSymmetricalMatrixDataType(ROperand0->dataType) &&
        gcIsVectorDataType(ROperand1->dataType))
    {
        status = _GenMatrixMulVectorCode(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        IOperand,
                                        ROperand0,
                                        ROperand1);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

#if gcdUSE_WCLIP_PATCH
        if (ROperand0->dataType == gcSHADER_FLOAT_4X4 &&
            ROperand0->isReg &&
            (ROperand0->u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM || ROperand0->u.reg.qualifier == slvSTORAGE_QUALIFIER_NONE) &&
            ROperand1->dataType == gcSHADER_FLOAT_X4 &&
            ROperand1->isReg &&
            (ROperand1->u.reg.qualifier == slvSTORAGE_QUALIFIER_ATTRIBUTE || ROperand1->u.reg.qualifier == slvSTORAGE_QUALIFIER_NONE))
        {
            gctINT index0, index1;
            gctUINT16 index;
            gcSL_TYPE type0, type1;
            gcUNIFORM uniform = ROperand0->u.reg.u.uniform;
            gcATTRIBUTE attribute = ROperand1->u.reg.u.attribute;

            type0 = type1 = gcSL_TEMP;

            if (ROperand0->u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM)
            {
                type0 = gcSL_UNIFORM;
                uniform = ROperand0->u.reg.u.uniform;
                sloCOMPILER_GetUniformIndex(Compiler, uniform, &index);
                index0 = index;
            }
            else
            {
                gctINT uniformIndex1, uniformIndex2;

                index0 = ROperand0->u.reg.regIndex;
                if (sloCOMPILER_FindWClipForUniformList(Compiler, index0, &uniformIndex1, &uniformIndex2) == gcvSTATUS_TRUE)
                {
                    type0 = gcSL_CONSTANT;
                    index0 = uniformIndex2;
                    index0 = (index0 << 8) | uniformIndex1;
                }
            }
            index0 = (index0 << 16) | type0;

            if (ROperand1->u.reg.qualifier == slvSTORAGE_QUALIFIER_ATTRIBUTE)
            {
                type1 = gcSL_ATTRIBUTE;
                attribute = ROperand1->u.reg.u.attribute;
                sloCOMPILER_GetAttributeIndex(Compiler, attribute, &index);
                index1 = index;
            }
            else
            {
                index1 = ROperand1->u.reg.regIndex;
            }
            index1 = (index1 << 16) | type1;

            status = sloCOMPILER_InsertWClipList(Compiler, IOperand->tempRegIndex, index0, index1);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
#endif
    }
    else if ((Opcode == slvOPCODE_MUL) &&
        gcIsMatrixDataType(ROperand0->dataType) && gcIsMatrixDataType(ROperand1->dataType))
    {
        gcmASSERT(gcGetMatrixDataTypeColumnCount(IOperand->dataType)
                    == gcGetMatrixDataTypeColumnCount(ROperand1->dataType));
        gcmASSERT(gcGetMatrixDataTypeRowCount(IOperand->dataType)
                    == gcGetMatrixDataTypeRowCount(ROperand0->dataType));
        gcmASSERT(gcGetMatrixDataTypeColumnCount(ROperand0->dataType)
                    == gcGetMatrixDataTypeRowCount(ROperand1->dataType));

        for (i = 0; i < gcGetMatrixDataTypeColumnCount(IOperand->dataType); i++)
        {
            slsIOPERAND_InitializeAsMatrixColumn(&columnIOperand, IOperand, i);
            slsROPERAND_InitializeAsMatrixColumn(&columnROperand1, ROperand1, i);

            status = _GenMatrixMulVectorCode(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            &columnIOperand,
                                            ROperand0,
                                            &columnROperand1);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }

#if gcdUSE_WCLIP_PATCH
        if (ROperand0->dataType == gcSHADER_FLOAT_4X4 &&
            ROperand0->isReg &&
            (ROperand0->u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM) &&
            ROperand1->dataType == gcSHADER_FLOAT_4X4 &&
            ROperand1->isReg &&
            (ROperand1->u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM))
        {
            gctUINT16 index0, index1;
            gcUNIFORM uniform;

            uniform = ROperand0->u.reg.u.uniform;
            sloCOMPILER_GetUniformIndex(Compiler, uniform, &index0);
            uniform = ROperand1->u.reg.u.uniform;
            sloCOMPILER_GetUniformIndex(Compiler, uniform, &index1);

            status = sloCOMPILER_InsertWClipForUniformList(Compiler, IOperand->tempRegIndex, index0, index1);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
#endif
    }
     /* es30 support a asymmetric matrix multiply a vector. */
    else if ((Opcode == slvOPCODE_MUL) &&
        gcIsMatrixDataType(ROperand0->dataType) && gcIsVectorDataType(ROperand1->dataType))
    {
        gctUINT columnCount;

        slsIOPERAND        intermIOperands[5];
        gcsTARGET        intermTargets[5];
        gcsSOURCE        intermSources[5];

        gcmASSERT(gcGetMatrixDataTypeRowCount(IOperand->dataType)
                    == gcGetMatrixDataTypeRowCount(ROperand0->dataType));
        gcmASSERT(gcGetMatrixDataTypeColumnCount(IOperand->dataType)
                    == gcGetMatrixDataTypeColumnCount(ROperand1->dataType));
        gcmASSERT(gcGetMatrixDataTypeColumnCount(ROperand0->dataType)
                == gcGetMatrixDataTypeRowCount(ROperand1->dataType));

        columnCount = gcGetMatrixDataTypeRowCount(ROperand1->dataType);

        slsIOPERAND_New(Compiler, &intermIOperands[columnCount], IOperand->dataType, IOperand->precision);
        gcsTARGET_InitializeUsingIOperand(&intermTargets[columnCount], &intermIOperands[columnCount]);
        gcsSOURCE_InitializeUsingIOperand(&intermSources[columnCount], &intermIOperands[columnCount]);

        for (i = 0; i < columnCount; i++)
        {
            slsIOPERAND_New(Compiler, &intermIOperands[i], IOperand->dataType, IOperand->precision);
            gcsTARGET_InitializeUsingIOperand(&intermTargets[i], &intermIOperands[i]);
            gcsSOURCE_InitializeUsingIOperand(&intermSources[i], &intermIOperands[i]);

            status = _ConvNormalROperandToMatrixColumnSource(
                                                            Compiler,
                                                            LineNo,
                                                            StringNo,
                                                            ROperand0,
                                                            i,
                                                            &source0);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = _ConvROperandToSourceReg(
                                            Compiler,
                                            ROperand1,
                                            _ConvVectorIndexToComponentSelection(i),
                                            &source1);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = slEmitCode2(
                                Compiler,
                                LineNo,
                                StringNo,
                                Opcode,
                                &intermTargets[i],
                                &source0,
                                &source1);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            if (i == 0)
            {
                status = slEmitCode1(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    slvOPCODE_ASSIGN,
                                    &intermTargets[columnCount],
                                    &intermSources[0]);
            }
            else
            {
                status = slEmitCode2(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    slvOPCODE_ADD,
                                    &intermTargets[columnCount],
                                    &intermSources[columnCount],
                                    &intermSources[i]);
            }
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        status = _ConvIOperandToTarget(
                                                        Compiler,
                                                        IOperand,
                                                        &target);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        status = slEmitCode1(
                            Compiler,
                            LineNo,
                            StringNo,
                            slvOPCODE_ASSIGN,
                            &target,
                            &intermSources[columnCount]);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        if (ROperand0->dataType == ROperand1->dataType)
        {
            if (gcIsScalarDataType(ROperand0->dataType) || gcIsVectorDataType(ROperand0->dataType))
            {
                status = _ConvIOperandToTarget(
                                                Compiler,
                                                IOperand,
                                                &target);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                status = _ConvNormalROperandToSource(
                                                    Compiler,
                                                    LineNo,
                                                    StringNo,
                                                    ROperand0,
                                                    &source0);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                status = _ConvNormalROperandToSource(
                                                    Compiler,
                                                    LineNo,
                                                    StringNo,
                                                    ROperand1,
                                                    &source1);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                status = slEmitCode2(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    Opcode,
                                    &target,
                                    &source0,
                                    &source1);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
            else
            {
                gcmASSERT(gcIsMatrixDataType(ROperand0->dataType));

                for (i = 0; i < gcGetMatrixDataTypeColumnCount(ROperand0->dataType); i++)
                {
                    gcmVERIFY_OK(_ConvIOperandToMatrixColumnTarget(Compiler, IOperand, i, &target));

                    status = _ConvNormalROperandToMatrixColumnSource(
                                                                    Compiler,
                                                                    LineNo,
                                                                    StringNo,
                                                                    ROperand0,
                                                                    i,
                                                                    &source0);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                    status = _ConvNormalROperandToMatrixColumnSource(
                                                                    Compiler,
                                                                    LineNo,
                                                                    StringNo,
                                                                    ROperand1,
                                                                    i,
                                                                    &source1);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                    status = slEmitCode2(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        Opcode,
                                        &target,
                                        &source0,
                                        &source1);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
            }
        }
        else
        {
            if (gcIsMatrixDataType(ROperand0->dataType))
            {
                gcmASSERT(gcIsScalarDataType(ROperand1->dataType));

                status = _ConvNormalROperandToSource(
                                                    Compiler,
                                                    LineNo,
                                                    StringNo,
                                                    ROperand1,
                                                    &source1);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                for (i = 0; i < gcGetMatrixDataTypeColumnCount(ROperand0->dataType); i++)
                {
                    gcmVERIFY_OK(_ConvIOperandToMatrixColumnTarget(Compiler, IOperand, i, &target));

                    status = _ConvNormalROperandToMatrixColumnSource(
                                                                    Compiler,
                                                                    LineNo,
                                                                    StringNo,
                                                                    ROperand0,
                                                                    i,
                                                                    &source0);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                    status = slEmitCode2(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        Opcode,
                                        &target,
                                        &source0,
                                        &source1);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
            }
            else if (gcIsMatrixDataType(ROperand1->dataType))
            {
                gcmASSERT(gcIsScalarDataType(ROperand0->dataType));

                status = _ConvNormalROperandToSource(
                                                    Compiler,
                                                    LineNo,
                                                    StringNo,
                                                    ROperand0,
                                                    &source0);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                for (i = 0; i < gcGetMatrixDataTypeColumnCount(ROperand1->dataType); i++)
                {
                    gcmVERIFY_OK(_ConvIOperandToMatrixColumnTarget(Compiler, IOperand, i, &target));

                    status = _ConvNormalROperandToMatrixColumnSource(
                                                                    Compiler,
                                                                    LineNo,
                                                                    StringNo,
                                                                    ROperand1,
                                                                    i,
                                                                    &source1);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                    status = slEmitCode2(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        Opcode,
                                        &target,
                                        &source0,
                                        &source1);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
            }
            else
            {
                gcmASSERT((gcIsVectorDataType(ROperand0->dataType)
                                && gcIsScalarDataType(ROperand1->dataType))
                        || (gcIsScalarDataType(ROperand0->dataType)
                                && gcIsVectorDataType(ROperand1->dataType))
                        || Opcode == slvOPCODE_CMP
                        || Opcode == slvOPCODE_ATOMADD
                        || Opcode == slvOPCODE_ATOMSUB
                        || Opcode == slvOPCODE_ATOMMIN
                        || Opcode == slvOPCODE_ATOMMAX
                        || Opcode == slvOPCODE_ATOMAND
                        || Opcode == slvOPCODE_ATOMOR
                        || Opcode == slvOPCODE_ATOMXOR
                        || Opcode == slvOPCODE_ATOMXCHG
                        || Opcode == slvOPCODE_IMAGE_ADDRESS
                        || Opcode == slvOPCODE_IMAGE_ADDRESS_3D);

                status = _ConvIOperandToTarget(
                                                Compiler,
                                                IOperand,
                                                &target);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                status = _ConvNormalROperandToSource(
                                                    Compiler,
                                                    LineNo,
                                                    StringNo,
                                                    ROperand0,
                                                    &source0);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                status = _ConvNormalROperandToSource(
                                                    Compiler,
                                                    LineNo,
                                                    StringNo,
                                                    ROperand1,
                                                    &source1);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                status = slEmitCode2(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    Opcode,
                                    &target,
                                    &source0,
                                    &source1);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
        }
    }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</OPERATION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenBuiltinVivAsmCode(
    IN sloCOMPILER   Compiler,
    IN sloIR_VIV_ASM VivAsm,
    IN gctUINT       LineNo,
    IN gctUINT       StringNo,
    IN gcSL_OPCODE   Opcode,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1,
    IN slsROPERAND * ROperand2
    )
{
    gceSTATUS   status;
    gcsTARGET   target;
    gcsSOURCE   source[3];
    gctBOOL     genIOperand  = IOperand  ? gcvTRUE : gcvFALSE;
    gctBOOL     genROperand0 = ROperand0 ? gcvTRUE : gcvFALSE;
    gctBOOL     genROperand1 = ROperand1 ? gcvTRUE : gcvFALSE;

    gctBOOL     genIOperandMod  = IOperand  ? gcvTRUE : gcvFALSE;
    gctBOOL     genROperand0Mod = ROperand0 ? gcvTRUE : gcvFALSE;
    gctBOOL     genROperand1Mod = ROperand1 ? gcvTRUE : gcvFALSE;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<OPERATION line=\"%d\" string=\"%d\" type=\"%s\">",
                            LineNo,
                            StringNo,
                            GetOpcodeName(Opcode)));

    if (IOperand)
    {
        status = _ConvIOperandToTarget(
                                        Compiler,
                                        IOperand,
                                        &target);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    if (ROperand0)
    {
        status = _ConvNormalROperandToSource(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            ROperand0,
                                            &source[0]);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    if (ROperand1)
    {
        status = _ConvNormalROperandToSource(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            ROperand1,
                                            &source[1]);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    }

    if (ROperand2)
    {
        status = _ConvNormalROperandToSource(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            ROperand2,
                                            &source[2]);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    status = slEmitBuiltinAsmCode(
                        Compiler,
                        LineNo,
                        StringNo,
                        Opcode,
                        &VivAsm->opcode,
                        genIOperand ? &target : gcvNULL,
                        genIOperandMod ? VivAsm->opndMods[0] : gcvNULL,
                        genROperand0 ? &source[0] : gcvNULL,
                        genROperand0Mod ? VivAsm->opndMods[1] : gcvNULL,
                        genROperand1 ? &source[1] : gcvNULL,
                        genROperand1Mod ? VivAsm->opndMods[2] : gcvNULL);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</OPERATION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenAtomicCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN sleOPCODE Opcode,
    IN slsIOPERAND *IOperand,
    IN slsROPERAND *ROperand,
    IN slsROPERAND *ValOperand
    )
{
    gceSTATUS status;
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(ROperand);
    gcmASSERT(ValOperand);

    switch(Opcode) {
    case slvOPCODE_ATOMADD:
    case slvOPCODE_ATOMSUB:
    case slvOPCODE_ATOMMIN:
    case slvOPCODE_ATOMMAX:
    case slvOPCODE_ATOMOR:
    case slvOPCODE_ATOMAND:
    case slvOPCODE_ATOMXOR:
    case slvOPCODE_ATOMXCHG:
        gcmONERROR(slGenGenericCode2Atomic(Compiler,
                                     LineNo,
                                     StringNo,
                                     Opcode,
                                     IOperand,
                                     ROperand,
                                     ValOperand));
        break;
    default:
        gcmASSERT(0);
        status = gcvSTATUS_INVALID_DATA;
        break;
    }

OnError:
    gcmFOOTER_NO();
    return status;
}

gceSTATUS
slGenGenericNullTargetCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN sleOPCODE Opcode,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1
    )
{
    gceSTATUS   status;
    gcsSOURCE   source0Buf[1];
    gcsSOURCE   source1Buf[1];
    gcsSOURCE   *source0 = gcvNULL;
    gcsSOURCE   *source1 = gcvNULL;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);

    gcmVERIFY_OK(sloCOMPILER_Dump(Compiler,
                                  slvDUMP_CODE_GENERATOR,
                                  "<OPERATION line=\"%d\" string=\"%d\" type=\"%s\">",
                                  LineNo,
                                  StringNo,
                                  slGetOpcodeName(Opcode)));

    switch (Opcode)
    {
    case slvOPCODE_BARRIER:
    case slvOPCODE_MEMORY_BARRIER:
    case slvOPCODE_EMIT_VERTEX:
    case slvOPCODE_END_PRIMITIVE:
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_NO();
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    if(ROperand0) {
        gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand0));
        status = _ConvNormalROperandToSource(Compiler,
                                             LineNo,
                                             StringNo,
                                             ROperand0,
                                             source0Buf);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        source0 = source0Buf;
    }

    if(ROperand1) {
        gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand1));
        status = _ConvNormalROperandToSource(Compiler,
                                             LineNo,
                                             StringNo,
                                             ROperand1,
                                             source1Buf);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        source1 = source1Buf;
    }

    status = slEmitNullTargetCode(Compiler,
                                  LineNo,
                                  StringNo,
                                  Opcode,
                                  source0,
                                  source1);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmVERIFY_OK(sloCOMPILER_Dump(Compiler,
                                  slvDUMP_CODE_GENERATOR,
                                  "</OPERATION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenGenericCode1(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN sleOPCODE Opcode,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * ROperand
    )
{
    gceSTATUS   status;
    gcsTARGET   target;
    gcsSOURCE   source;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(ROperand);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<OPERATION line=\"%d\" string=\"%d\" type=\"%s\">",
                            LineNo,
                            StringNo,
                            slGetOpcodeName(Opcode)));

    gcmVERIFY_OK(slsIOPERAND_Dump(Compiler, IOperand));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand));

    switch (Opcode)
    {
    case slvOPCODE_FLOAT_TO_INT:
    case slvOPCODE_FLOAT_TO_UINT:
    case slvOPCODE_FLOAT_TO_BOOL:
    case slvOPCODE_FLOAT_TO_HALF:
    case slvOPCODE_HALF_TO_FLOAT:
    case slvOPCODE_INT_TO_BOOL:
    case slvOPCODE_INT_TO_FLOAT:
    case slvOPCODE_INT_TO_UINT:
    case slvOPCODE_UINT_TO_FLOAT:
    case slvOPCODE_UINT_TO_INT:
    case slvOPCODE_UINT_TO_BOOL:
    case slvOPCODE_BOOL_TO_FLOAT:
    case slvOPCODE_BOOL_TO_INT:
    case slvOPCODE_BOOL_TO_UINT:

    case slvOPCODE_INVERSE:

    case slvOPCODE_ANY:
    case slvOPCODE_ALL:
    case slvOPCODE_NOT:

    case slvOPCODE_BITWISE_NOT:

    case slvOPCODE_SIN:
    case slvOPCODE_COS:
    case slvOPCODE_TAN:

    case slvOPCODE_ASIN:
    case slvOPCODE_ACOS:
    case slvOPCODE_ATAN:

    case slvOPCODE_EXP2:
    case slvOPCODE_LOG2:
    case slvOPCODE_SQRT:
    case slvOPCODE_INVERSE_SQRT:

    case slvOPCODE_ABS:
    case slvOPCODE_SIGN:
    case slvOPCODE_FLOOR:
    case slvOPCODE_CEIL:
    case slvOPCODE_FRACT:
    case slvOPCODE_SATURATE:

    case slvOPCODE_NORMALIZE:

    case slvOPCODE_DFDX:
    case slvOPCODE_DFDY:
    case slvOPCODE_FWIDTH:
        break;

    case slvOPCODE_POPCOUNT:
    case slvOPCODE_FINDLSB:
    case slvOPCODE_FINDMSB:
    case slvOPCODE_BIT_REVERSAL:
    case slvOPCODE_BIT_EXTRACT:
    case slvOPCODE_BIT_RANGE1:

    case slvOPCODE_TEXTURE_U:

    case slvOPCODE_SAMPLER_ASSIGN:
    case slvOPCODE_GET_SAMPLER_IDX:
    case slvOPCODE_GET_SAMPLER_LMM:
    case slvOPCODE_GET_SAMPLER_LBS:
        break;

    default: gcmASSERT(0);
    }

    status = _ConvIOperandToTarget(
                                    Compiler,
                                    IOperand,
                                    &target);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand,
                                        &source);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = slEmitCode1(
                        Compiler,
                        LineNo,
                        StringNo,
                        Opcode,
                        &target,
                        &source);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</OPERATION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenGenericCode2(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN sleOPCODE Opcode,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1
    )
{
    return slGenGenericCode2WithFormat( Compiler,
                                        LineNo,
                                        StringNo,
                                        Opcode,
                                        IOperand,
                                        ROperand0,
                                        ROperand1,
                                        gcSL_INVALID
                                       );

}

gceSTATUS
slGenGenericCode2Atomic(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN sleOPCODE Opcode,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1
    )
{
    gceSTATUS   status;
    gcsTARGET   target;
    gcsSOURCE   source0;
    gcsSOURCE   source1;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(ROperand0);
    gcmASSERT(ROperand1);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<OPERATION line=\"%d\" string=\"%d\" type=\"%s\">",
                            LineNo,
                            StringNo,
                            slGetOpcodeName(Opcode)));

    gcmVERIFY_OK(slsIOPERAND_Dump(Compiler, IOperand));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand0));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand1));

    switch (Opcode)
    {
    case slvOPCODE_ATOMADD:
    case slvOPCODE_ATOMSUB:
    case slvOPCODE_ATOMMIN:
    case slvOPCODE_ATOMMAX:
    case slvOPCODE_ATOMOR:
    case slvOPCODE_ATOMAND:
    case slvOPCODE_ATOMXOR:
    case slvOPCODE_ATOMXCHG:
        break;

    default: gcmASSERT(0);
    }

    status = _ConvIOperandToTarget(
                                    Compiler,
                                    IOperand,
                                    &target);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand1,
                                        &source1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand0,
                                        &source0);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = slEmitCode2(
                        Compiler,
                        LineNo,
                        StringNo,
                        Opcode,
                        &target,
                        &source0,
                        &source1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</OPERATION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenGenericCode3(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN sleOPCODE Opcode1,
    IN sleOPCODE Opcode2,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1,
    IN slsROPERAND * ROperand2
    )
{
    gceSTATUS   status;
    gcsTARGET   target;
    gcsSOURCE   source0;
    gcsSOURCE   source1;
    gcsSOURCE   source2;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(ROperand0);
    gcmASSERT(ROperand1);
    gcmASSERT(ROperand2);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<OPERATION line=\"%d\" string=\"%d\" type1=\"%s type2=\"%s\">",
                            LineNo,
                            StringNo,
                            slGetOpcodeName(Opcode1),
                            slGetOpcodeName(Opcode2)));

    gcmVERIFY_OK(slsIOPERAND_Dump(Compiler, IOperand));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand0));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand1));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand2));

    switch (Opcode1)
    {
    case slvOPCODE_TEXTURE_LOAD:
    case slvOPCODE_TEXTURE_LOAD_U:
    case slvOPCODE_TEXTURE_LOAD_PCF:
    case slvOPCODE_TEXTURE_LOAD_PROJ:
    case slvOPCODE_TEXTURE_LOAD_PCFPROJ:
    case slvOPCODE_TEXTURE_BIAS:
    case slvOPCODE_TEXTURE_LOD:
    case slvOPCODE_TEXTURE_GRAD:
    case slvOPCODE_TEXTURE_GATHER:
    case slvOPCODE_TEXTURE_FETCH_MS:

    case slvOPCODE_LESS_THAN:
    case slvOPCODE_LESS_THAN_EQUAL:
    case slvOPCODE_GREATER_THAN:
    case slvOPCODE_GREATER_THAN_EQUAL:
    case slvOPCODE_EQUAL:
    case slvOPCODE_NOT_EQUAL:

    case slvOPCODE_ATAN2:

    case slvOPCODE_POW:

    case slvOPCODE_MIN:
    case slvOPCODE_MAX:
    case slvOPCODE_STEP:
    case slvOPCODE_DOT:
    case slvOPCODE_CROSS:

    case slvOPCODE_LOAD:
    case slvOPCODE_STORE1:
    case slvOPCODE_BITWISE_AND:
    case slvOPCODE_BITWISE_OR:
    case slvOPCODE_BITWISE_XOR:
    case slvOPCODE_LSHIFT:
    case slvOPCODE_RSHIFT:

    case slvOPCODE_BIT_RANGE:
    case slvOPCODE_BIT_INSERT:

    case slvOPCODE_UCARRY:

    case slvOPCODE_ATOMADD:
    case slvOPCODE_ATOMSUB:
    case slvOPCODE_ATOMMIN:
    case slvOPCODE_ATOMMAX:
    case slvOPCODE_ATOMOR:
    case slvOPCODE_ATOMAND:
    case slvOPCODE_ATOMXOR:
    case slvOPCODE_ATOMXCHG:
    case slvOPCODE_ATOMCMPXCHG:

    case slvOPCODE_SET:
    case slvOPCODE_CMP:

    case slvOPCODE_IMAGE_READ:
    case slvOPCODE_IMAGE_WRITE:
    case slvOPCODE_IMAGE_ADDRESS:
    case slvOPCODE_IMAGE_ADDRESS_3D:
        break;

    default: gcmASSERT(0);
    }


    switch (Opcode2)
    {
    case slvOPCODE_FLOAT_TO_INT:
    case slvOPCODE_FLOAT_TO_UINT:
    case slvOPCODE_FLOAT_TO_BOOL:
    case slvOPCODE_FLOAT_TO_HALF:
    case slvOPCODE_HALF_TO_FLOAT:
    case slvOPCODE_INT_TO_BOOL:
    case slvOPCODE_INT_TO_FLOAT:
    case slvOPCODE_INT_TO_UINT:
    case slvOPCODE_UINT_TO_FLOAT:
    case slvOPCODE_UINT_TO_INT:
    case slvOPCODE_UINT_TO_BOOL:
    case slvOPCODE_BOOL_TO_FLOAT:
    case slvOPCODE_BOOL_TO_INT:
    case slvOPCODE_BOOL_TO_UINT:

    case slvOPCODE_INVERSE:

    case slvOPCODE_ANY:
    case slvOPCODE_ALL:
    case slvOPCODE_NOT:

    case slvOPCODE_BITWISE_NOT:

    case slvOPCODE_SIN:
    case slvOPCODE_COS:
    case slvOPCODE_TAN:

    case slvOPCODE_ASIN:
    case slvOPCODE_ACOS:
    case slvOPCODE_ATAN:

    case slvOPCODE_EXP2:
    case slvOPCODE_LOG2:
    case slvOPCODE_SQRT:
    case slvOPCODE_INVERSE_SQRT:

    case slvOPCODE_ABS:
    case slvOPCODE_SIGN:
    case slvOPCODE_FLOOR:
    case slvOPCODE_CEIL:
    case slvOPCODE_FRACT:
    case slvOPCODE_SATURATE:

    case slvOPCODE_NORMALIZE:

    case slvOPCODE_DFDX:
    case slvOPCODE_DFDY:
    case slvOPCODE_FWIDTH:
        break;

    case slvOPCODE_POPCOUNT:
    case slvOPCODE_FINDLSB:
    case slvOPCODE_FINDMSB:
    case slvOPCODE_BIT_REVERSAL:
    case slvOPCODE_BIT_EXTRACT:
    case slvOPCODE_BIT_RANGE1:

    case slvOPCODE_TEXTURE_U:
        break;

    default: gcmASSERT(0);
    }

    status = _ConvIOperandToTarget(
                                    Compiler,
                                    IOperand,
                                    &target);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand0,
                                        &source0);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand1,
                                        &source1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand2,
                                        &source2);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = slEmitCode2(
                        Compiler,
                        LineNo,
                        StringNo,
                        Opcode1,
                        &target,
                        &source0,
                        &source1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }


    status = slEmitCode1(
                        Compiler,
                        LineNo,
                        StringNo,
                        Opcode2,
                        &target,
                        &source2);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }


    status = _ConvIOperandToTarget(
                                    Compiler,
                                    IOperand,
                                    &target);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</OPERATION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenGenericCode3AtomicCmpXchg(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1,
    IN slsROPERAND * ROperand2
    )
{
    gceSTATUS   status;
    gcsTARGET   target;
    gcsTARGET   intermTarget[1];
    gcsSOURCE   source0;
    gcsSOURCE   source1;
    gcsSOURCE   source2;
    gcsSOURCE   intermSource[1];
    slsIOPERAND intermIOperand[1];
    slsLOPERAND intermLOperand[1];
    slsROPERAND intermROperand[1];
    slsCOMPONENT_SELECTION reversedComponentSelection;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(ROperand0);
    gcmASSERT(ROperand1);
    gcmASSERT(ROperand2);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<OPERATION line=\"%d\" string=\"%d\">",
                            LineNo,
                            StringNo));

    gcmVERIFY_OK(slsIOPERAND_Dump(Compiler, IOperand));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand0));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand1));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand2));

    status = _ConvIOperandToTarget(
                                    Compiler,
                                    IOperand,
                                    &target);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand1,
                                        &source1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand2,
                                        &source2);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slsIOPERAND_New(Compiler, intermIOperand, ROperand1->dataType == gcSHADER_INTEGER_X1 ? gcSHADER_INTEGER_X2 : gcSHADER_UINT_X2, ROperand1->u.reg.precision);
    slsLOPERAND_InitializeUsingIOperand(intermLOperand, intermIOperand);
    status = _ConvLOperandToTarget(Compiler,
                          intermLOperand,
                          intermTarget,
                          &reversedComponentSelection);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    intermTarget->enable = gcSL_ENABLE_Y;
    status = slEmitAssignCode(Compiler,
                                    LineNo,
                                    StringNo,
                                    intermTarget,
                                    &source1);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    intermTarget->enable = gcSL_ENABLE_X;
    status = slEmitAssignCode(Compiler,
                                    LineNo,
                                    StringNo,
                                    intermTarget,
                                    &source2);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand0,
                                        &source0);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slsROPERAND_InitializeUsingIOperand(intermROperand, intermIOperand);
    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        intermROperand,
                                        intermSource);

    status = slEmitCode2(
                        Compiler,
                        LineNo,
                        StringNo,
                        slvOPCODE_ATOMCMPXCHG,
                        &target,
                        &source0,
                        intermSource);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }


    status = _ConvIOperandToTarget(
                                    Compiler,
                                    IOperand,
                                    &target);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</OPERATION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenTestJumpCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN gctLABEL Label,
    IN gctBOOL TrueJump,
    IN slsROPERAND * ROperand
    )
{
    gceSTATUS   status;
    gcsSOURCE   source;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(ROperand);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<TEST line=\"%d\" string=\"%d\" trueJump=\"%s\">",
                            LineNo,
                            StringNo,
                            TrueJump ? "true" : "false"));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand));

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand,
                                        &source);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = slEmitTestBranchCode(
                                Compiler,
                                LineNo,
                                StringNo,
                                slvOPCODE_JUMP,
                                Label,
                                TrueJump,
                                &source);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</TEST>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenCompareJumpCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN gctLABEL Label,
    IN gctBOOL TrueJump,
    IN sleCONDITION CompareCondition,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1
    )
{
    gceSTATUS   status;
    gcsSOURCE   source0;
    gcsSOURCE   source1;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(ROperand0);
    gcmASSERT(ROperand1);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<CONDITION line=\"%d\" string=\"%d\""
                            " trueJump=\"%s\" compareType=\"%s\">",
                            LineNo,
                            StringNo,
                            TrueJump ? "true" : "false",
                            slGetConditionName(CompareCondition)));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand0));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand1));

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand0,
                                        &source0);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand1,
                                        &source1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }


    status = slEmitCompareBranchCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    slvOPCODE_JUMP,
                                    TrueJump ?
                                        CompareCondition : slGetNotCondition(CompareCondition),
                                    Label,
                                    &source0,
                                    &source1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</CONDITION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenGenericCode2WithFormat(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN sleOPCODE Opcode,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1,
    IN gcSL_FORMAT Format
    )
{
    gceSTATUS   status;
    gcsTARGET   target;
    gcsSOURCE   source0;
    gcsSOURCE   source1;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(ROperand0);
    gcmASSERT(ROperand1);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<OPERATION line=\"%d\" string=\"%d\" type=\"%s\">",
                            LineNo,
                            StringNo,
                            slGetOpcodeName(Opcode)));

    gcmVERIFY_OK(slsIOPERAND_Dump(Compiler, IOperand));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand0));

    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand1));

    switch (Opcode)
    {
    case slvOPCODE_TEXTURE_LOAD:
    case slvOPCODE_TEXTURE_LOAD_U:
    case slvOPCODE_TEXTURE_LOAD_PCF:
    case slvOPCODE_TEXTURE_LOAD_PROJ:
    case slvOPCODE_TEXTURE_LOAD_PCFPROJ:
    case slvOPCODE_TEXTURE_BIAS:
    case slvOPCODE_TEXTURE_LOD:
    case slvOPCODE_TEXTURE_GRAD:
    case slvOPCODE_TEXTURE_GATHER:
    case slvOPCODE_TEXTURE_FETCH_MS:

    case slvOPCODE_TEXTURE_U_LOD:

    case slvOPCODE_LESS_THAN:
    case slvOPCODE_LESS_THAN_EQUAL:
    case slvOPCODE_GREATER_THAN:
    case slvOPCODE_GREATER_THAN_EQUAL:
    case slvOPCODE_EQUAL:
    case slvOPCODE_NOT_EQUAL:

    case slvOPCODE_ATAN2:

    case slvOPCODE_POW:

    case slvOPCODE_MIN:
    case slvOPCODE_MAX:
    case slvOPCODE_STEP:
    case slvOPCODE_DOT:
    case slvOPCODE_CROSS:

    case slvOPCODE_LOAD:
    case slvOPCODE_STORE1:
    case slvOPCODE_BITWISE_AND:
    case slvOPCODE_BITWISE_OR:
    case slvOPCODE_BITWISE_XOR:
    case slvOPCODE_LSHIFT:
    case slvOPCODE_RSHIFT:

    case slvOPCODE_BIT_RANGE:
    case slvOPCODE_BIT_INSERT:

    case slvOPCODE_UCARRY:

    case slvOPCODE_ATOMADD:
    case slvOPCODE_ATOMSUB:
    case slvOPCODE_ATOMMIN:
    case slvOPCODE_ATOMMAX:
    case slvOPCODE_ATOMOR:
    case slvOPCODE_ATOMAND:
    case slvOPCODE_ATOMXOR:
    case slvOPCODE_ATOMXCHG:
    case slvOPCODE_ATOMCMPXCHG:

    case slvOPCODE_SET:
    case slvOPCODE_CMP:

    case slvOPCODE_IMAGE_READ:
    case slvOPCODE_IMAGE_WRITE:
    case slvOPCODE_IMAGE_ADDRESS:
    case slvOPCODE_IMAGE_ADDRESS_3D:
    case slvOPCODE_IMAGE_READ_3D:
    case slvOPCODE_IMAGE_WRITE_3D:
    case slvOPCODE_CLAMP0MAX:
        break;

    default: gcmASSERT(0);
    }

    status = _ConvIOperandToTarget(
                                    Compiler,
                                    IOperand,
                                    &target);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Format != gcSL_INVALID)
    {
        target.format = Format;
    }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand0,
                                        &source0);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _ConvNormalROperandToSource(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        ROperand1,
                                        &source1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = slEmitCode2(
                        Compiler,
                        LineNo,
                        StringNo,
                        Opcode,
                        &target,
                        &source0,
                        &source1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</OPERATION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_EXPR CondExpr,
    IN gctLABEL Label,
    IN gctBOOL TrueJump
    );

static gceSTATUS
_GenSplitOperandConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sleCONDITION Condition,
    IN slsROPERAND *CondOperand,
    IN sloIR_EXPR RightExpr,
    IN gctLABEL Label,
    IN gctBOOL TrueJump
    );

gceSTATUS
sloIR_BINARY_EXPR_GenRelationalConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN gctLABEL Label,
    IN gctBOOL TrueJump
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  leftParameters, rightParameters;
    sleCONDITION            condition;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &leftParameters,
                                    gcvFALSE,
                                    gcvTRUE);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->leftOperand->base,
                                &CodeGenerator->visitor,
                                &leftParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmASSERT(leftParameters.operandCount == 1);

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &rightParameters,
                                    gcvFALSE,
                                    gcvTRUE);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->rightOperand->base,
                                &CodeGenerator->visitor,
                                &rightParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmASSERT(rightParameters.operandCount == 1);

    /* Generate the condition code */
    switch (BinaryExpr->type)
    {
    case slvBINARY_GREATER_THAN:
        condition = slvCONDITION_GREATER_THAN;
        break;

    case slvBINARY_LESS_THAN:
        condition = slvCONDITION_LESS_THAN;
        break;

    case slvBINARY_GREATER_THAN_EQUAL:
        condition = slvCONDITION_GREATER_THAN_EQUAL;
        break;

    case slvBINARY_LESS_THAN_EQUAL:
        condition = slvCONDITION_LESS_THAN_EQUAL;
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    status = slGenCompareJumpCode(
                                Compiler,
                                CodeGenerator,
                                BinaryExpr->exprBase.base.lineNo,
                                BinaryExpr->exprBase.base.stringNo,
                                Label,
                                TrueJump,
                                condition,
                                &leftParameters.rOperands[0],
                                &rightParameters.rOperands[0]);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenSplitOperandConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sleCONDITION Condition,
    IN slsROPERAND *CondOperand,
    IN sloIR_EXPR RightExpr,
    IN gctLABEL Label,
    IN gctBOOL TrueJump
    )
{
    gceSTATUS  status;
    slsGEN_CODE_PARAMETERS rightParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);

    gcmASSERT(CondOperand);
    gcmASSERT(RightExpr);

    /* Generate the code of the right expression */

    slsGEN_CODE_PARAMETERS_Initialize(&rightParameters,
                                      gcvFALSE,
                                      gcvTRUE);

    status = sloIR_OBJECT_Accept(Compiler,
                                 &RightExpr->base,
                                 &CodeGenerator->visitor,
                                 &rightParameters);
    if (gcmIS_ERROR(status)) {
        gcmFOOTER();
        return status;
    }

    gcmASSERT(rightParameters.operandCount == 1);

    /* Generate the condition code */
    status = slGenCompareJumpCode(Compiler,
                                  CodeGenerator,
                                  RightExpr->base.lineNo,
                                  RightExpr->base.stringNo,
                                  Label,
                                  TrueJump,
                                  Condition,
                                  CondOperand,
                                  &rightParameters.rOperands[0]);
    if (gcmIS_ERROR(status)) {
        gcmFOOTER();
        return status;
    }

    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenMultiplyEqualityConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN gctLABEL Label,
    IN gctBOOL TrueJump,
    IN sleCONDITION CompareCondition,
    IN gctUINT OperandCount,
    IN gcSHADER_TYPE * DataTypes,
    IN slsROPERAND * ROperands0,
    IN slsROPERAND * ROperands1
    )
{
    gceSTATUS       status;
    gctUINT         i, j, k;
    slsROPERAND     rOperand0;
    slsROPERAND     rOperand1;
    gctLABEL        endLabel;
    gctLABEL        targetLabel;
    sleCONDITION    compareCondition;
    gctBOOL        needBranch;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(CompareCondition == slvCONDITION_EQUAL
                || CompareCondition == slvCONDITION_NOT_EQUAL);
    gcmASSERT(OperandCount >= 1);
    gcmASSERT(DataTypes);
    gcmASSERT(ROperands0);
    gcmASSERT(ROperands1);

    if (!TrueJump) CompareCondition = slGetNotCondition(CompareCondition);

    if (CompareCondition == slvCONDITION_NOT_EQUAL)
    {
        for (i = 0; i < OperandCount; i++)
        {
            if (gcIsScalarDataType(DataTypes[i]))
            {
                status = slGenCompareJumpCode(
                                            Compiler,
                                            CodeGenerator,
                                            LineNo,
                                            StringNo,
                                            Label,
                                            gcvTRUE,
                                            CompareCondition,
                                            &ROperands0[i],
                                            &ROperands1[i]);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
            else if (gcIsVectorDataType(DataTypes[i]))
            {
/*klc:- do vector compare instead of per component basis*/
                if(!TrueJump) {
                   targetLabel = slNewLabel(Compiler);
                   compareCondition = slGetNotCondition(CompareCondition);
                   needBranch = gcvTRUE;
                }
                else {
                   targetLabel = Label;
                   compareCondition = CompareCondition;
                   needBranch = gcvFALSE;
                }
                status = slGenCompareJumpCode(Compiler,
                                              CodeGenerator,
                                              LineNo,
                                              StringNo,
                                              targetLabel,
                                              gcvTRUE,
                                              compareCondition,
                                              &ROperands0[i],
                                              &ROperands1[i]);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                if(needBranch) {
                   status = slEmitAlwaysBranchCode(Compiler,
                                                   LineNo,
                                                   StringNo,
                                                   slvOPCODE_JUMP,
                                                   Label);
                   if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                   status = slSetLabel(Compiler,
                                       LineNo,
                                       StringNo,
                                       targetLabel);
                   if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
            }
            else
            {
                gctUINT columnCount;
                gctUINT rowCount;

                gcmASSERT(gcIsMatrixDataType(DataTypes[i]));
                columnCount = gcGetMatrixDataTypeColumnCount(DataTypes[i]);
                rowCount = gcGetMatrixDataTypeRowCount(DataTypes[i]);
                for (j = 0; j < columnCount; j++)
                {
                    for (k = 0; k < rowCount; k++)
                    {
                        slsROPERAND_InitializeAsMatrixComponent(&rOperand0, &ROperands0[i], j, k);
                        slsROPERAND_InitializeAsMatrixComponent(&rOperand1, &ROperands1[i], j, k);

                        status = slGenCompareJumpCode(
                                                    Compiler,
                                                    CodeGenerator,
                                                    LineNo,
                                                    StringNo,
                                                    Label,
                                                    gcvTRUE,
                                                    CompareCondition,
                                                    &rOperand0,
                                                    &rOperand1);

                        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                    }
                }
            }
        }   /* for (i = 0; i < OperandCount; i++) */
    }
    else
    {
        endLabel = slNewLabel(Compiler);

        for (i = 0; i < OperandCount; i++)
        {
            if (gcIsScalarDataType(DataTypes[i]))
            {
                if (i == OperandCount - 1)
                {
                    targetLabel = Label;
                    TrueJump    = gcvTRUE;
                }
                else
                {
                    targetLabel = endLabel;
                    TrueJump    = gcvFALSE;
                }

                status = slGenCompareJumpCode(
                                            Compiler,
                                            CodeGenerator,
                                            LineNo,
                                            StringNo,
                                            targetLabel,
                                            TrueJump,
                                            CompareCondition,
                                            &ROperands0[i],
                                            &ROperands1[i]);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
            else if (gcIsVectorDataType(DataTypes[i]))
            {
                for (j = 0; j < gcGetVectorDataTypeComponentCount(DataTypes[i]); j++)
                {
                    if (i == OperandCount - 1
                        && j == (gctUINT) gcGetVectorDataTypeComponentCount(DataTypes[i]) - 1)
                    {
                        targetLabel = Label;
                        TrueJump    = gcvTRUE;
                    }
                    else
                    {
                        targetLabel = endLabel;
                        TrueJump    = gcvFALSE;
                    }

                    slsROPERAND_InitializeAsVectorComponent(&rOperand0, &ROperands0[i], j);
                    slsROPERAND_InitializeAsVectorComponent(&rOperand1, &ROperands1[i], j);

                    status = slGenCompareJumpCode(
                                                Compiler,
                                                CodeGenerator,
                                                LineNo,
                                                StringNo,
                                                targetLabel,
                                                TrueJump,
                                                CompareCondition,
                                                &rOperand0,
                                                &rOperand1);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
            }
            else
            {
                gctUINT columnCount, rowCount;

                gcmASSERT(gcIsMatrixDataType(DataTypes[i]));
                columnCount = gcGetMatrixDataTypeColumnCount(DataTypes[i]);
                rowCount = gcGetMatrixDataTypeRowCount(DataTypes[i]);
                for (j = 0; j < columnCount; j++)
                {
                    for (k = 0; k < rowCount; k++)
                    {
                        if (i == OperandCount - 1
                            && j == columnCount - 1
                            && k == rowCount - 1)
                        {
                            targetLabel = Label;
                            TrueJump    = gcvTRUE;
                        }
                        else
                        {
                            targetLabel = endLabel;
                            TrueJump    = gcvFALSE;
                        }

                        slsROPERAND_InitializeAsMatrixComponent(&rOperand0, &ROperands0[i], j, k);
                        slsROPERAND_InitializeAsMatrixComponent(&rOperand1, &ROperands1[i], j, k);

                        status = slGenCompareJumpCode(
                                                    Compiler,
                                                    CodeGenerator,
                                                    LineNo,
                                                    StringNo,
                                                    targetLabel,
                                                    TrueJump,
                                                    CompareCondition,
                                                    &rOperand0,
                                                    &rOperand1);

                        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                    }
                }
            }
        }   /* for (i = 0; i < OperandCount; i++) */

        /* end: */
        status = slSetLabel(
                            Compiler,
                            LineNo,
                            StringNo,
                            endLabel);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenEqualityConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN gctLABEL Label,
    IN gctBOOL TrueJump
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  leftParameters, rightParameters;
    sleCONDITION            condition;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &leftParameters,
                                    gcvFALSE,
                                    gcvTRUE);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->leftOperand->base,
                                &CodeGenerator->visitor,
                                &leftParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &rightParameters,
                                    gcvFALSE,
                                    gcvTRUE);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->rightOperand->base,
                                &CodeGenerator->visitor,
                                &rightParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Get the condition code */
    switch (BinaryExpr->type)
    {
    case slvBINARY_EQUAL:
        condition = slvCONDITION_EQUAL;
        break;

    case slvBINARY_NOT_EQUAL:
    case slvBINARY_XOR:
        condition = slvCONDITION_NOT_EQUAL;
        break;

    default:
        gcmASSERT(0);
        status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        gcmFOOTER();
        return status;
    }

    if (slsDATA_TYPE_IsScalar(BinaryExpr->leftOperand->dataType))
    {
        gcmASSERT(leftParameters.operandCount == 1);
        gcmASSERT(rightParameters.operandCount == 1);

        status = slGenCompareJumpCode(
                                    Compiler,
                                    CodeGenerator,
                                    BinaryExpr->exprBase.base.lineNo,
                                    BinaryExpr->exprBase.base.stringNo,
                                    Label,
                                    TrueJump,
                                    condition,
                                    &leftParameters.rOperands[0],
                                    &rightParameters.rOperands[0]);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        gcmASSERT(leftParameters.operandCount == rightParameters.operandCount);

        status = _GenMultiplyEqualityConditionCode(
                                                    Compiler,
                                                    CodeGenerator,
                                                    BinaryExpr->exprBase.base.lineNo,
                                                    BinaryExpr->exprBase.base.stringNo,
                                                    Label,
                                                    TrueJump,
                                                    condition,
                                                    leftParameters.operandCount,
                                                    leftParameters.dataTypes,
                                                    leftParameters.rOperands,
                                                    rightParameters.rOperands);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenAndConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN gctLABEL Label,
    IN gctBOOL TrueJump
    )
{
    gceSTATUS   status;
    gctLABEL    endLabel;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);

    if (TrueJump)
    {
        endLabel = slNewLabel(Compiler);

        /* jump end if !(left) */
        gcmASSERT(BinaryExpr->leftOperand);

        status = _GenConditionCode(
                                    Compiler,
                                    CodeGenerator,
                                    BinaryExpr->leftOperand,
                                    endLabel,
                                    gcvFALSE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* jump label if (right) */
        gcmASSERT(BinaryExpr->rightOperand);

        status = _GenConditionCode(
                                    Compiler,
                                    CodeGenerator,
                                    BinaryExpr->rightOperand,
                                    Label,
                                    gcvTRUE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* end: */
        status = slSetLabel(
                            Compiler,
                            BinaryExpr->exprBase.base.lineNo,
                            BinaryExpr->exprBase.base.stringNo,
                            endLabel);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        /* jump label if !(left) */
        gcmASSERT(BinaryExpr->leftOperand);

        status = _GenConditionCode(
                                    Compiler,
                                    CodeGenerator,
                                    BinaryExpr->leftOperand,
                                    Label,
                                    gcvFALSE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* jump label if !(right) */
        gcmASSERT(BinaryExpr->rightOperand);

        status = _GenConditionCode(
                                    Compiler,
                                    CodeGenerator,
                                    BinaryExpr->rightOperand,
                                    Label,
                                    gcvFALSE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenOrConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN gctLABEL Label,
    IN gctBOOL TrueJump
    )
{
    gceSTATUS   status;
    gctLABEL    endLabel;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);

    if (TrueJump)
    {
        /* jump label if (left) */
        gcmASSERT(BinaryExpr->leftOperand);

        status = _GenConditionCode(
                                    Compiler,
                                    CodeGenerator,
                                    BinaryExpr->leftOperand,
                                    Label,
                                    gcvTRUE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* jump label if (right) */
        gcmASSERT(BinaryExpr->rightOperand);

        status = _GenConditionCode(
                                    Compiler,
                                    CodeGenerator,
                                    BinaryExpr->rightOperand,
                                    Label,
                                    gcvTRUE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        endLabel = slNewLabel(Compiler);

        /* jump end if (left) */
        gcmASSERT(BinaryExpr->leftOperand);

        status = _GenConditionCode(
                                    Compiler,
                                    CodeGenerator,
                                    BinaryExpr->leftOperand,
                                    endLabel,
                                    gcvTRUE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* jump label if !(right) */
        gcmASSERT(BinaryExpr->rightOperand);

        status = _GenConditionCode(
                                    Compiler,
                                    CodeGenerator,
                                    BinaryExpr->rightOperand,
                                    Label,
                                    gcvFALSE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* end: */
        status = slSetLabel(
                            Compiler,
                            BinaryExpr->exprBase.base.lineNo,
                            BinaryExpr->exprBase.base.stringNo,
                            endLabel);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_EXPR CondExpr,
    IN gctLABEL Label,
    IN gctBOOL TrueJump
    )
{
    gceSTATUS               status;
    sloIR_BINARY_EXPR       binaryExpr;
    sloIR_UNARY_EXPR        unaryExpr;
    slsGEN_CODE_PARAMETERS  condParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(CondExpr);

    switch (sloIR_OBJECT_GetType(&CondExpr->base))
    {
    case slvIR_BINARY_EXPR:
        binaryExpr = (sloIR_BINARY_EXPR)CondExpr;

        switch (binaryExpr->type)
        {
        case slvBINARY_GREATER_THAN:
        case slvBINARY_LESS_THAN:
        case slvBINARY_GREATER_THAN_EQUAL:
        case slvBINARY_LESS_THAN_EQUAL:
            status = sloIR_BINARY_EXPR_GenRelationalConditionCode(
                                                                Compiler,
                                                                CodeGenerator,
                                                                binaryExpr,
                                                                Label,
                                                                TrueJump);
            gcmFOOTER();
            return status;

        case slvBINARY_EQUAL:
        case slvBINARY_NOT_EQUAL:
        case slvBINARY_XOR:
            status = sloIR_BINARY_EXPR_GenEqualityConditionCode(
                                                            Compiler,
                                                            CodeGenerator,
                                                            binaryExpr,
                                                            Label,
                                                            TrueJump);
            gcmFOOTER();
            return status;

        case slvBINARY_AND:
            status = sloIR_BINARY_EXPR_GenAndConditionCode(
                                                        Compiler,
                                                        CodeGenerator,
                                                        binaryExpr,
                                                        Label,
                                                        TrueJump);
            gcmFOOTER();
            return status;

        case slvBINARY_OR:
            status = sloIR_BINARY_EXPR_GenOrConditionCode(
                                                        Compiler,
                                                        CodeGenerator,
                                                        binaryExpr,
                                                        Label,
                                                        TrueJump);
            gcmFOOTER();
            return status;

        default: break;
        }
        break;

    case slvIR_UNARY_EXPR:
        unaryExpr = (sloIR_UNARY_EXPR)CondExpr;
        gcmASSERT(unaryExpr->operand);

        switch (unaryExpr->type)
        {
        case slvUNARY_NOT:
            status = _GenConditionCode(
                                    Compiler,
                                    CodeGenerator,
                                    unaryExpr->operand,
                                    Label,
                                    !TrueJump);
            gcmFOOTER();
            return status;

        default: break;
        }
        break;

    default: break;
    }

    slsGEN_CODE_PARAMETERS_Initialize(&condParameters, gcvFALSE, gcvTRUE);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &CondExpr->base,
                                &CodeGenerator->visitor,
                                &condParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = slGenTestJumpCode(
                                Compiler,
                                CodeGenerator,
                                CondExpr->base.lineNo,
                                CondExpr->base.stringNo,
                                Label,
                                TrueJump,
                                &condParameters.rOperands[0]);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slsGEN_CODE_PARAMETERS_Finalize(&condParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slDefineSelectionBegin(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN gctBOOL HasFalseOperand,
    OUT slsSELECTION_CONTEXT * SelectionContext
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(SelectionContext);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<SELECTION hasFalseOperand=\"%s\">",
                            HasFalseOperand ? "true" : "false"));

    SelectionContext->hasFalseOperand    = HasFalseOperand;
    SelectionContext->endLabel           = slNewLabel(Compiler);
    SelectionContext->isNegativeCond     = gcvFALSE;

    if (HasFalseOperand)
    {
        SelectionContext->beginLabelOfFalseOperand  = slNewLabel(Compiler);
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slDefineSelectionEnd(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsSELECTION_CONTEXT * SelectionContext
    )
{
    gceSTATUS       status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(SelectionContext);

    status = slSetLabel(
                        Compiler,
                        0,
                        0,
                        SelectionContext->endLabel);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</SELECTION>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gctLABEL
_GetSelectionConditionLabel(
    IN slsSELECTION_CONTEXT * SelectionContext
    )
{
    gcmASSERT(SelectionContext);

    return (SelectionContext->hasFalseOperand) ?
                SelectionContext->beginLabelOfFalseOperand : SelectionContext->endLabel;
}

gceSTATUS
slGenSelectionTestConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsSELECTION_CONTEXT * SelectionContext,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsROPERAND * ROperand
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(SelectionContext);
    gcmASSERT(ROperand);

    status = slGenTestJumpCode(
                            Compiler,
                            CodeGenerator,
                            LineNo,
                            StringNo,
                            _GetSelectionConditionLabel(SelectionContext),
                            gcvFALSE,
                            ROperand);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenSelectionCompareConditionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsSELECTION_CONTEXT * SelectionContext,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN sleCONDITION CompareCondition,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(SelectionContext);
    gcmASSERT(ROperand0);
    gcmASSERT(ROperand1);

    status = slGenCompareJumpCode(
                                Compiler,
                                CodeGenerator,
                                LineNo,
                                StringNo,
                                _GetSelectionConditionLabel(SelectionContext),
                                gcvFALSE,
                                CompareCondition,
                                ROperand0,
                                ROperand1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slDefineSelectionTrueOperandBegin(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsSELECTION_CONTEXT * SelectionContext
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(SelectionContext);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<TRUE_OPERAND>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slDefineSelectionTrueOperandEnd(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsSELECTION_CONTEXT * SelectionContext,
    IN gctBOOL HasReturn
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(SelectionContext);

    if (SelectionContext->hasFalseOperand && !HasReturn)
    {
        status = slEmitAlwaysBranchCode(
                                        Compiler,
                                        0,
                                        0,
                                        slvOPCODE_JUMP,
                                        SelectionContext->endLabel);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</TRUE_OPERAND>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slDefineSelectionFalseOperandBegin(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsSELECTION_CONTEXT * SelectionContext
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(SelectionContext);
    gcmASSERT(SelectionContext->hasFalseOperand);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "<FALSE_OPERAND>"));

    status = slSetLabel(
                        Compiler,
                        0,
                        0,
                        SelectionContext->beginLabelOfFalseOperand);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slDefineSelectionFalseOperandEnd(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsSELECTION_CONTEXT * SelectionContext
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(SelectionContext);
    gcmASSERT(SelectionContext->hasFalseOperand);

    gcmVERIFY_OK(sloCOMPILER_Dump(
                            Compiler,
                            slvDUMP_CODE_GENERATOR,
                            "</FALSE_OPERAND>"));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenMatrixMulVectorCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1
    )
{
    gceSTATUS       status;
    slsIOPERAND     intermIOperands[6];
    slsROPERAND     rOperand0;
    slsROPERAND     rOperand1;
    gcSHADER_TYPE dataType;
    gcSHADER_PRECISION precision;
    gctUINT columnCount;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(ROperand0);
    gcmASSERT(ROperand1);

    columnCount = gcGetMatrixDataTypeColumnCount(ROperand0->dataType);
    dataType = gcGetMatrixColumnDataType(ROperand0->dataType);

    /* mul t0, m[0], v.x */
    if(slmROPERAND_IsHigherPrecision(ROperand1, ROperand0)) {
        precision = ROperand1->u.reg.precision;
    }
    else {
        precision = ROperand0->u.reg.precision;
    }
    slsIOPERAND_New(Compiler, &intermIOperands[0], dataType, precision);
    slsROPERAND_InitializeAsMatrixColumn(&rOperand0, ROperand0, 0);
    slsROPERAND_InitializeAsVectorComponent(&rOperand1, ROperand1, 0);

    status = slGenArithmeticExprCode(Compiler,
                                     LineNo,
                                     StringNo,
                                     slvOPCODE_MUL,
                                     &intermIOperands[0],
                                     &rOperand0,
                                     &rOperand1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* mul t1, m[1], v.y */
    slsIOPERAND_New(Compiler, &intermIOperands[1], dataType, precision);
    slsROPERAND_InitializeAsMatrixColumn(&rOperand0, ROperand0, 1);
    slsROPERAND_InitializeAsVectorComponent(&rOperand1, ROperand1, 1);

    status = slGenArithmeticExprCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    slvOPCODE_MUL,
                                    &intermIOperands[1],
                                    &rOperand0,
                                    &rOperand1);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (columnCount == 2)
    {
        /* add result, t0, t1 */
        slsROPERAND_InitializeUsingIOperand(&rOperand0, &intermIOperands[0]);
        slsROPERAND_InitializeUsingIOperand(&rOperand1, &intermIOperands[1]);

        status = slGenArithmeticExprCode(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        slvOPCODE_ADD,
                                        IOperand,
                                        &rOperand0,
                                        &rOperand1);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        /* add t2, t0, t1 */
        slsIOPERAND_New(Compiler, &intermIOperands[2], dataType, precision);
        slsROPERAND_InitializeUsingIOperand(&rOperand0, &intermIOperands[0]);
        slsROPERAND_InitializeUsingIOperand(&rOperand1, &intermIOperands[1]);

        status = slGenArithmeticExprCode(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        slvOPCODE_ADD,
                                        &intermIOperands[2],
                                        &rOperand0,
                                        &rOperand1);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* mul t3, m[2], v.z */
        slsIOPERAND_New(Compiler, &intermIOperands[3], dataType, precision);
        slsROPERAND_InitializeAsMatrixColumn(&rOperand0, ROperand0, 2);
        slsROPERAND_InitializeAsVectorComponent(&rOperand1, ROperand1, 2);

        status = slGenArithmeticExprCode(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        slvOPCODE_MUL,
                                        &intermIOperands[3],
                                        &rOperand0,
                                        &rOperand1);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (columnCount == 3)
        {
            /* add result, t2, t3 */
            slsROPERAND_InitializeUsingIOperand(&rOperand0, &intermIOperands[2]);
            slsROPERAND_InitializeUsingIOperand(&rOperand1, &intermIOperands[3]);

            status = slGenArithmeticExprCode(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            slvOPCODE_ADD,
                                            IOperand,
                                            &rOperand0,
                                            &rOperand1);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else
        {
            /* add t4, t2, t3 */
            slsIOPERAND_New(Compiler, &intermIOperands[4], dataType, precision);
            slsROPERAND_InitializeUsingIOperand(&rOperand0, &intermIOperands[2]);
            slsROPERAND_InitializeUsingIOperand(&rOperand1, &intermIOperands[3]);

            status = slGenArithmeticExprCode(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            slvOPCODE_ADD,
                                            &intermIOperands[4],
                                            &rOperand0,
                                            &rOperand1);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* mul t5, m[3], v.w */
            slsIOPERAND_New(Compiler, &intermIOperands[5], dataType, precision);
            slsROPERAND_InitializeAsMatrixColumn(&rOperand0, ROperand0, 3);
            slsROPERAND_InitializeAsVectorComponent(&rOperand1, ROperand1, 3);

            status = slGenArithmeticExprCode(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            slvOPCODE_MUL,
                                            &intermIOperands[5],
                                            &rOperand0,
                                            &rOperand1);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* add result, t4, t5 */
            slsROPERAND_InitializeUsingIOperand(&rOperand0, &intermIOperands[4]);
            slsROPERAND_InitializeUsingIOperand(&rOperand1, &intermIOperands[5]);

            status = slGenArithmeticExprCode(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            slvOPCODE_ADD,
                                            IOperand,
                                            &rOperand0,
                                            &rOperand1);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/* CODE_GENERATOR */
gceSTATUS
slsGEN_CODE_PARAMETERS_AllocateOperands(
    IN sloCOMPILER Compiler,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters,
    IN slsDATA_TYPE * DataType
    )
{
    gceSTATUS   status;
    gctUINT     start = 0;
    gctPOINTER pointer = gcvNULL;
    gcSHADER_PRECISION binaryPrecision;
    gctSIZE_T i;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(Parameters);
    gcmASSERT(DataType);

    gcmASSERT(Parameters->operandCount == 0);
    gcmASSERT(Parameters->needLOperand || Parameters->needROperand);

    Parameters->operandCount = _GetLogicalOperandCount(DataType, gcvFALSE);
    gcmASSERT(Parameters->operandCount > 0);

    status = sloCOMPILER_Allocate(
                                Compiler,
                                (gctSIZE_T)sizeof(gcSHADER_TYPE) * Parameters->operandCount,
                                &pointer);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    Parameters->dataTypes = pointer;

    status = _ConvDataType(
                        DataType,
                        Parameters->dataTypes,
                        &start);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmASSERT(start == Parameters->operandCount);

    binaryPrecision = _ConvElementDataPrecision(DataType);
    if (Parameters->needLOperand)
    {
        status = sloCOMPILER_Allocate(
                                    Compiler,
                                    (gctSIZE_T)sizeof(slsLOPERAND) * Parameters->operandCount,
                                    &pointer);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOPERAND) * Parameters->operandCount);

        Parameters->lOperands = pointer;
        for(i = 0; i < Parameters->operandCount; i++) {
            Parameters->lOperands[i].reg.precision = binaryPrecision;
        }
    }

    if (Parameters->needROperand)
    {
        status = sloCOMPILER_Allocate(
                                    Compiler,
                                    (gctSIZE_T)sizeof(slsROPERAND) * Parameters->operandCount,
                                    &pointer);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsROPERAND) * Parameters->operandCount);

        Parameters->rOperands = pointer;
        for(i = 0; i < Parameters->operandCount; i++) {
            Parameters->rOperands[i].u.reg.precision = binaryPrecision;
        }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

#define MAX_NAME_TABLE_SIZE         10
#define INVALID_VECTOR_INDEX        (0xffffffff)
#define MAX_LEVEL                   (0xffffffff)

typedef struct _slsUSING_SINGLE_VECTOR_INDEX_PARAMETERS
{
    gctBOOL             usingSingleVectorIndex;

    gctUINT             vectorIndex;

    gctUINT             currentLevel;

    gctUINT             maxLevel;

    gctUINT             inputNameCount;

    slsNAME *           inputNameTable[MAX_NAME_TABLE_SIZE];

    gctUINT             outputNameCount;

    slsNAME *           outputNameTable[MAX_NAME_TABLE_SIZE];

    gctUINT             outputNameLevelTable[MAX_NAME_TABLE_SIZE];
}
slsUSING_SINGLE_VECTOR_INDEX_PARAMETERS;

#define slsUSING_SINGLE_VECTOR_INDEX_PARAMETERS_Initialize(parameters) \
    do \
    { \
        (parameters)->usingSingleVectorIndex    = gcvTRUE; \
        (parameters)->vectorIndex               = INVALID_VECTOR_INDEX; \
        (parameters)->currentLevel              = 0; \
        (parameters)->maxLevel                  = 0; \
        (parameters)->inputNameCount            = 0; \
        (parameters)->outputNameCount           = 0; \
    } \
    while (gcvFALSE)

static gctBOOL
_IsNameListEqual(
    IN gctUINT NameCount0,
    IN slsNAME * NameTable0[MAX_NAME_TABLE_SIZE],
    IN gctUINT NameCount1,
    IN slsNAME * NameTable1[MAX_NAME_TABLE_SIZE]
    )
{
    gctUINT     i;

    /* Verify the arguments. */
    gcmASSERT(NameTable0);
    gcmASSERT(NameTable1);

    if (NameCount0 != NameCount1)   return gcvFALSE;

    for (i = 0; i < NameCount0; i++)
    {
        if (NameTable0[i] != NameTable1[i]) return gcvFALSE;
    }

    return gcvTRUE;
}

static gctUINT
_FindNameInList(
    IN slsNAME * Name,
    IN gctUINT NameCount,
    IN slsNAME * NameTable[MAX_NAME_TABLE_SIZE]
    )
{
    gctUINT     i;

    /* Verify the arguments. */
    gcmASSERT(Name);
    gcmASSERT(NameTable);

    for (i = 0; i < NameCount; i++)
    {
        if (NameTable[i] == Name) return i;
    }

    return MAX_NAME_TABLE_SIZE;
}

static gceSTATUS
_AddNameToList(
    IN slsNAME * Name,
    IN gctUINT Level,
    IN OUT gctUINT * NameCount,
    IN OUT slsNAME * NameTable[MAX_NAME_TABLE_SIZE],
    IN OUT gctUINT NameLevelTable[MAX_NAME_TABLE_SIZE]
    )
{
    gctUINT     i;

    gcmHEADER();

    /* Verify the arguments. */
    gcmASSERT(Name);
    gcmASSERT(NameCount);
    gcmASSERT(NameTable);

    for (i = 0; i < *NameCount; i++)
    {
        if (Name == NameTable[i])
        {
            if (NameLevelTable != gcvNULL && Level < NameLevelTable[i])
            {
                NameLevelTable[i] = Level;
            }

            gcmFOOTER_NO();
            return gcvSTATUS_OK;
        }
    }

    if (*NameCount == MAX_NAME_TABLE_SIZE)
    {
        gceSTATUS status = gcvSTATUS_BUFFER_TOO_SMALL;
        gcmFOOTER();
        return status;
    }

    NameTable[*NameCount]   = Name;

    if (NameLevelTable != gcvNULL) NameLevelTable[*NameCount] = Level;

    (*NameCount)++;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_AddNameToParameters(
    IN sloCOMPILER Compiler,
    IN slsNAME * Name,
    IN gctUINT VectorIndex,
    IN gctBOOL NeedLValue,
    IN gctBOOL NeedRValue,
    IN OUT slsUSING_SINGLE_VECTOR_INDEX_PARAMETERS * Parameters
    )
{
    gceSTATUS   status;
    gctUINT     nameIndex;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(Name);
    gcmASSERT(Parameters);

    do
    {
        if (Parameters->vectorIndex == INVALID_VECTOR_INDEX)
        {
            Parameters->vectorIndex = VectorIndex;
        }
        else
        {
            if (Parameters->vectorIndex != VectorIndex) break;
        }

        if (NeedRValue)
        {
            nameIndex = _FindNameInList(
                                        Name,
                                        Parameters->outputNameCount,
                                        Parameters->outputNameTable);

            if (nameIndex == MAX_NAME_TABLE_SIZE
                || Parameters->currentLevel < Parameters->outputNameLevelTable[nameIndex])
            {
                status = _AddNameToList(
                                        Name,
                                        Parameters->currentLevel,
                                        &Parameters->inputNameCount,
                                        Parameters->inputNameTable,
                                        gcvNULL);

                if (gcmIS_ERROR(status)) break;
            }
        }

        if (NeedLValue)
        {
            status = _AddNameToList(
                                    Name,
                                    Parameters->currentLevel,
                                    &Parameters->outputNameCount,
                                    Parameters->outputNameTable,
                                    Parameters->outputNameLevelTable);

            if (gcmIS_ERROR(status)) break;
        }

        Parameters->usingSingleVectorIndex = gcvTRUE;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    Parameters->usingSingleVectorIndex = gcvFALSE;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BASE_UsingSingleVectorIndex(
    IN sloCOMPILER Compiler,
    IN sloIR_BASE Base,
    IN gctBOOL NeedLValue,
    IN gctBOOL NeedRValue,
    IN OUT slsUSING_SINGLE_VECTOR_INDEX_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    sloIR_SET               set             = gcvNULL;
    sloIR_VARIABLE          variable        = gcvNULL;
    sloIR_CONSTANT          constant        = gcvNULL;
    sloIR_UNARY_EXPR        unaryExpr       = gcvNULL;
    sloIR_BINARY_EXPR       binaryExpr      = gcvNULL;
    sloIR_SELECTION         selection       = gcvNULL;
    sloIR_POLYNARY_EXPR     polynaryExpr    = gcvNULL;
    sloIR_BASE              member;
    gctBOOL                 needLValue0 = gcvFALSE;
    gctBOOL                 needLValue1 = gcvFALSE;
    gctBOOL                 needRValue0 = gcvFALSE;
    gctBOOL                 needRValue1 = gcvFALSE;
    slsNAME *               name;
    gctUINT                 i, vectorIndex;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(Base);
    gcmASSERT(Parameters);

    switch (sloIR_OBJECT_GetType(Base))
    {
    case slvIR_SET:
        set = (sloIR_SET)Base;

        FOR_EACH_DLINK_NODE(&set->members, struct _sloIR_BASE, member)
        {
            /* Check all members */
            status = sloIR_BASE_UsingSingleVectorIndex(
                                                        Compiler,
                                                        member,
                                                        gcvFALSE,
                                                        NeedRValue,
                                                        Parameters);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            if (!Parameters->usingSingleVectorIndex) break;
        }
        gcmFOOTER_NO();
        return gcvSTATUS_OK;

    case slvIR_VARIABLE:
        variable = (sloIR_VARIABLE)Base;

        Parameters->usingSingleVectorIndex =
                    slsDATA_TYPE_IsScalar(variable->exprBase.dataType);
        gcmFOOTER_NO();
        return gcvSTATUS_OK;

    case slvIR_CONSTANT:
        constant = (sloIR_CONSTANT)Base;

        Parameters->usingSingleVectorIndex =
                    slsDATA_TYPE_IsScalar(constant->exprBase.dataType);
        gcmFOOTER_NO();
        return gcvSTATUS_OK;

    case slvIR_UNARY_EXPR:
        unaryExpr = (sloIR_UNARY_EXPR)Base;
        gcmASSERT(unaryExpr->operand);

        switch (unaryExpr->type)
        {
        case slvUNARY_FIELD_SELECTION:
            Parameters->usingSingleVectorIndex =
                    slsDATA_TYPE_IsScalar(unaryExpr->exprBase.dataType);
            gcmFOOTER_NO();
            return gcvSTATUS_OK;

        case slvUNARY_COMPONENT_SELECTION:
            if (!slsDATA_TYPE_IsScalar(unaryExpr->exprBase.dataType)
                || sloIR_OBJECT_GetType(&unaryExpr->operand->base) != slvIR_VARIABLE)
            {
                Parameters->usingSingleVectorIndex = gcvFALSE;
                gcmFOOTER_NO();
                return gcvSTATUS_OK;
            }

            name = ((sloIR_VARIABLE)unaryExpr->operand)->name;
            gcmASSERT(name);

            vectorIndex = unaryExpr->u.componentSelection.x;

            status = _AddNameToParameters(
                                        Compiler,
                                        name,
                                        vectorIndex,
                                        NeedLValue,
                                        NeedRValue,
                                        Parameters);
            gcmFOOTER();
            return status;

        case slvUNARY_POST_INC:
        case slvUNARY_POST_DEC:
        case slvUNARY_PRE_INC:
        case slvUNARY_PRE_DEC:
            needLValue0 = gcvTRUE;
            needRValue0 = gcvTRUE;
            break;

        case slvUNARY_NEG:

        case slvUNARY_NOT:
        case slvUNARY_BITWISE_NOT:
            needLValue0 = gcvFALSE;
            needRValue0 = NeedRValue;
            break;

        default: gcmASSERT(0);
        }

        /* Check the operand */
        status = sloIR_BASE_UsingSingleVectorIndex(
                                                    Compiler,
                                                    &unaryExpr->operand->base,
                                                    needLValue0,
                                                    needRValue0,
                                                    Parameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmFOOTER_NO();
        return gcvSTATUS_OK;

    case slvIR_BINARY_EXPR:
        binaryExpr = (sloIR_BINARY_EXPR)Base;
        gcmASSERT(binaryExpr->leftOperand);
        gcmASSERT(binaryExpr->rightOperand);

        switch (binaryExpr->type)
        {
        case slvBINARY_SUBSCRIPT:
            if (!slsDATA_TYPE_IsBVecOrIVecOrVec(binaryExpr->leftOperand->dataType)
                || sloIR_OBJECT_GetType(&binaryExpr->leftOperand->base) != slvIR_VARIABLE
                || sloIR_OBJECT_GetType(&binaryExpr->rightOperand->base) != slvIR_CONSTANT)
            {
                Parameters->usingSingleVectorIndex = gcvFALSE;
                gcmFOOTER_NO();
                return gcvSTATUS_OK;
            }

            name = ((sloIR_VARIABLE)binaryExpr->leftOperand)->name;
            gcmASSERT(name);

            gcmASSERT(((sloIR_CONSTANT)binaryExpr->rightOperand)->valueCount == 1);
            vectorIndex = ((sloIR_CONSTANT)binaryExpr->rightOperand)->values[0].intValue;

            status = _AddNameToParameters(
                                        Compiler,
                                        name,
                                        vectorIndex,
                                        NeedLValue,
                                        NeedRValue,
                                        Parameters);
            gcmFOOTER();
            return status;

        case slvBINARY_ADD:
        case slvBINARY_SUB:
        case slvBINARY_MUL:
        case slvBINARY_DIV:
        case slvBINARY_MOD:
        case slvBINARY_RSHIFT:
        case slvBINARY_LSHIFT:

        case slvBINARY_GREATER_THAN:
        case slvBINARY_LESS_THAN:
        case slvBINARY_GREATER_THAN_EQUAL:
        case slvBINARY_LESS_THAN_EQUAL:

        case slvBINARY_EQUAL:
        case slvBINARY_NOT_EQUAL:

        case slvBINARY_AND:
        case slvBINARY_OR:
        case slvBINARY_XOR:

        case slvBINARY_BITWISE_AND:
        case slvBINARY_BITWISE_OR:
        case slvBINARY_BITWISE_XOR:

            needLValue0 = gcvFALSE;
            needRValue0 = NeedRValue;
            needLValue1 = gcvFALSE;
            needRValue1 = NeedRValue;
            break;

        case slvBINARY_SEQUENCE:
            needLValue0 = gcvFALSE;
            needRValue0 = gcvFALSE;
            needLValue1 = gcvFALSE;
            needRValue1 = NeedRValue;
            break;

        case slvBINARY_ASSIGN:
            needLValue0 = gcvTRUE;
            needRValue0 = gcvFALSE;
            needLValue1 = gcvFALSE;
            needRValue1 = gcvTRUE;
            break;

        case slvBINARY_MUL_ASSIGN:
        case slvBINARY_DIV_ASSIGN:
        case slvBINARY_ADD_ASSIGN:
        case slvBINARY_SUB_ASSIGN:
        case slvBINARY_LEFT_ASSIGN:
        case slvBINARY_RIGHT_ASSIGN:
        case slvBINARY_AND_ASSIGN:
        case slvBINARY_XOR_ASSIGN:
        case slvBINARY_OR_ASSIGN:
        case slvBINARY_MOD_ASSIGN:
            needLValue0 = gcvTRUE;
            needRValue0 = gcvTRUE;
            needLValue1 = gcvFALSE;
            needRValue1 = gcvTRUE;
            break;

        default:
            gcmASSERT(0);
        }

        /* Check the left operand */
        status = sloIR_BASE_UsingSingleVectorIndex(
                                                    Compiler,
                                                    &binaryExpr->leftOperand->base,
                                                    needLValue0,
                                                    needRValue0,
                                                    Parameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (!Parameters->usingSingleVectorIndex) { gcmFOOTER_NO(); return gcvSTATUS_OK; }

        /* Check the right operand */
        status = sloIR_BASE_UsingSingleVectorIndex(
                                                    Compiler,
                                                    &binaryExpr->rightOperand->base,
                                                    needLValue1,
                                                    needRValue1,
                                                    Parameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmFOOTER_NO();
        return gcvSTATUS_OK;

    case slvIR_SELECTION:
        selection = (sloIR_SELECTION)Base;
        gcmASSERT(selection->condExpr);

        /* Check the condition expression */
        status = sloIR_BASE_UsingSingleVectorIndex(
                                                    Compiler,
                                                    &selection->condExpr->base,
                                                    gcvFALSE,
                                                    gcvTRUE,
                                                    Parameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (!Parameters->usingSingleVectorIndex) { gcmFOOTER_NO(); return gcvSTATUS_OK; }

        Parameters->currentLevel++;
        Parameters->maxLevel++;

        /* Check the true operand */
        if (selection->trueOperand != gcvNULL)
        {
            status = sloIR_BASE_UsingSingleVectorIndex(
                                                        Compiler,
                                                        selection->trueOperand,
                                                        gcvFALSE,
                                                        NeedRValue,
                                                        Parameters);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            if (!Parameters->usingSingleVectorIndex) { gcmFOOTER_NO(); return gcvSTATUS_OK; }

            for (i = 0; i < Parameters->outputNameCount; i++)
            {
                if (Parameters->outputNameLevelTable[i] == i)
                {
                    Parameters->outputNameLevelTable[i] = MAX_LEVEL;
                }
            }
        }

        /* Check the false operand */
        if (selection->falseOperand != gcvNULL)
        {
            status = sloIR_BASE_UsingSingleVectorIndex(
                                                        Compiler,
                                                        selection->falseOperand,
                                                        gcvFALSE,
                                                        NeedRValue,
                                                        Parameters);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            if (!Parameters->usingSingleVectorIndex) { gcmFOOTER_NO(); return gcvSTATUS_OK; }

            for (i = 0; i < Parameters->outputNameCount; i++)
            {
                if (Parameters->outputNameLevelTable[i] == i)
                {
                    Parameters->outputNameLevelTable[i] = MAX_LEVEL;
                }
            }
        }

        Parameters->currentLevel--;
        gcmFOOTER_NO();
        return gcvSTATUS_OK;

    case slvIR_POLYNARY_EXPR:
        polynaryExpr = (sloIR_POLYNARY_EXPR)Base;

        if (polynaryExpr->type == slvPOLYNARY_FUNC_CALL
            && !polynaryExpr->funcName->isBuiltIn)
        {
            Parameters->usingSingleVectorIndex = gcvFALSE;
            gcmFOOTER_NO();
            return gcvSTATUS_OK;
        }

        if (polynaryExpr->operands != gcvNULL)
        {
            /* Check all operands */
            status = sloIR_BASE_UsingSingleVectorIndex(
                                                        Compiler,
                                                        &polynaryExpr->operands->base,
                                                        gcvFALSE,
                                                        gcvTRUE,
                                                        Parameters);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }

        gcmFOOTER_NO();
        return gcvSTATUS_OK;

    default:
        Parameters->usingSingleVectorIndex = gcvFALSE;
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
}

gctBOOL
sloIR_BASE_IsEqualExceptVectorIndex(
    IN sloCOMPILER Compiler,
    IN sloIR_BASE Base0,
    IN sloIR_BASE Base1
    )
{
    sloIR_SET               set0, set1;
    sloIR_VARIABLE          variable0, variable1;
    sloIR_CONSTANT          constant0, constant1;
    sloIR_UNARY_EXPR        unaryExpr0, unaryExpr1;
    sloIR_BINARY_EXPR       binaryExpr0, binaryExpr1;
    sloIR_SELECTION         selection0, selection1;
    sloIR_POLYNARY_EXPR     polynaryExpr0, polynaryExpr1;
    sloIR_BASE              member0, member1;
    gctUINT                 i;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(Base0);
    gcmASSERT(Base1);

    if (sloIR_OBJECT_GetType(Base0) != sloIR_OBJECT_GetType(Base1)) { gcmFOOTER_NO(); return gcvFALSE; }

    switch (sloIR_OBJECT_GetType(Base0))
    {
    case slvIR_SET:
        set0 = (sloIR_SET)Base0;
        set1 = (sloIR_SET)Base1;

        if (set0->type != set1->type) { gcmFOOTER_NO(); return gcvFALSE; }

        for (member0 = slsDLINK_LIST_First(&set0->members, struct _sloIR_BASE),
                member1 = slsDLINK_LIST_First(&set1->members, struct _sloIR_BASE);
            (slsDLINK_NODE *)member0 != &set0->members
                && (slsDLINK_NODE *)member1 != &set1->members;
            member0 = slsDLINK_NODE_Next(&member0->node, struct _sloIR_BASE),
                member1 = slsDLINK_NODE_Next(&member1->node, struct _sloIR_BASE))
        {
            if (!sloIR_BASE_IsEqualExceptVectorIndex(
                                                    Compiler,
                                                    member0,
                                                     member1)) { gcmFOOTER_NO(); return gcvFALSE; }
        }

        if ((slsDLINK_NODE *)member0 != &set0->members
            && (slsDLINK_NODE *)member1 != &set1->members) { gcmFOOTER_NO(); return gcvFALSE; }

        gcmFOOTER_NO();
        return gcvTRUE;

    case slvIR_VARIABLE:
        variable0 = (sloIR_VARIABLE)Base0;
        variable1 = (sloIR_VARIABLE)Base1;

        gcmFOOTER_NO();
        return (variable0->name == variable1->name);

    case slvIR_CONSTANT:
        constant0 = (sloIR_CONSTANT)Base0;
        constant1 = (sloIR_CONSTANT)Base1;

            if (constant0->valueCount != constant1->valueCount) { gcmFOOTER_NO(); return gcvFALSE; }

        for (i = 0; i < constant0->valueCount; i++)
        {
            if (constant0->values[i].intValue != constant1->values[i].intValue) { gcmFOOTER_NO(); return gcvFALSE; }
        }

        gcmFOOTER_NO(); return gcvTRUE;

    case slvIR_UNARY_EXPR:
        unaryExpr0 = (sloIR_UNARY_EXPR)Base0;
        unaryExpr1 = (sloIR_UNARY_EXPR)Base1;

            if (unaryExpr0->type != unaryExpr1->type) { gcmFOOTER_NO(); return gcvFALSE; }

        if (unaryExpr0->type == slvUNARY_FIELD_SELECTION
            && unaryExpr0->u.fieldName != unaryExpr1->u.fieldName) { gcmFOOTER_NO(); return gcvFALSE; }

        gcmFOOTER_NO();
        return sloIR_BASE_IsEqualExceptVectorIndex(
                                                Compiler,
                                                &unaryExpr0->operand->base,
                                                &unaryExpr1->operand->base);

    case slvIR_BINARY_EXPR:
        binaryExpr0 = (sloIR_BINARY_EXPR)Base0;
        binaryExpr1 = (sloIR_BINARY_EXPR)Base1;

        if (!sloIR_BASE_IsEqualExceptVectorIndex(
                                                Compiler,
                                                &binaryExpr0->leftOperand->base,
                                                 &binaryExpr1->leftOperand->base)) { gcmFOOTER_NO(); return gcvFALSE; }

        if (binaryExpr0->type != slvBINARY_SUBSCRIPT)
        {
            if (!sloIR_BASE_IsEqualExceptVectorIndex(
                                                    Compiler,
                                                    &binaryExpr0->rightOperand->base,
                                                    &binaryExpr1->rightOperand->base))
            {
                gcmFOOTER_NO(); return gcvFALSE;
            }
        }

        gcmFOOTER_NO(); return gcvTRUE;

    case slvIR_SELECTION:
        selection0 = (sloIR_SELECTION)Base0;
        selection1 = (sloIR_SELECTION)Base1;

        /* Check the condition expression */
        if (!sloIR_BASE_IsEqualExceptVectorIndex(
                                                Compiler,
                                                &selection0->condExpr->base,
                                                 &selection1->condExpr->base)) { gcmFOOTER_NO(); return gcvFALSE; }

        /* Check the true operand */
        if (selection0->trueOperand != gcvNULL)
        {
            if (selection1->trueOperand == gcvNULL) { gcmFOOTER_NO(); return gcvFALSE; }

            if (!sloIR_BASE_IsEqualExceptVectorIndex(
                                                    Compiler,
                                                    selection0->trueOperand,
                                                     selection1->trueOperand)) { gcmFOOTER_NO(); return gcvFALSE; }
        }
        else
        {
            if (selection1->trueOperand != gcvNULL) { gcmFOOTER_NO(); return gcvFALSE; }
        }

        /* Check the false operand */
        if (selection0->falseOperand != gcvNULL)
        {
            if (selection1->falseOperand == gcvNULL) { gcmFOOTER_NO(); return gcvFALSE; }

            if (!sloIR_BASE_IsEqualExceptVectorIndex(
                                                    Compiler,
                                                    selection0->falseOperand,
                                                     selection1->falseOperand)) { gcmFOOTER_NO(); return gcvFALSE; }
        }
        else
        {
            if (selection1->falseOperand != gcvNULL) { gcmFOOTER_NO(); return gcvFALSE; }
        }

        gcmFOOTER_NO(); return gcvTRUE;

    case slvIR_POLYNARY_EXPR:
        polynaryExpr0 = (sloIR_POLYNARY_EXPR)Base0;
        polynaryExpr1 = (sloIR_POLYNARY_EXPR)Base1;

            if (polynaryExpr0->type != polynaryExpr1->type) { gcmFOOTER_NO(); return gcvFALSE; }

        if (polynaryExpr0->operands != gcvNULL)
        {
            if (polynaryExpr1->operands == gcvNULL) { gcmFOOTER_NO(); return gcvFALSE; }

            if (!sloIR_BASE_IsEqualExceptVectorIndex(
                                                    Compiler,
                                                    &polynaryExpr0->operands->base,
                                                    &polynaryExpr1->operands->base))
            {
                gcmFOOTER_NO(); return gcvFALSE;
            }
        }
        else
        {
            if (polynaryExpr1->operands != gcvNULL) { gcmFOOTER_NO(); return gcvFALSE; }
        }

        gcmFOOTER_NO(); return gcvTRUE;

    default:
        gcmFOOTER_NO(); return gcvFALSE;
    }
}

typedef struct _slsCOMPARE_ALL_NAMES_COMPONENT_PARAMETERS
{
    gctUINT         nameCount;

    slsNAME * *     nameTable;

    gctUINT         vectorIndex0;

    gctUINT         vectorIndex1;

    gctBOOL         compareResults[MAX_NAME_TABLE_SIZE];
}
slsCOMPARE_ALL_NAMES_COMPONENT_PARAMETERS;

#define slsCOMPARE_ALL_NAMES_COMPONENT_PARAMETERS_Initialize( \
                                                            parameters, \
                                                            _nameCount, \
                                                            _nameTable, \
                                                            _vectorIndex0, \
                                                            _vectorIndex1) \
    do \
    { \
        gctUINT _i; \
        \
        (parameters)->nameCount     = (_nameCount); \
        (parameters)->nameTable     = (_nameTable); \
        (parameters)->vectorIndex0  = (_vectorIndex0); \
        (parameters)->vectorIndex1  = (_vectorIndex1); \
        \
        for (_i = 0; _i < (_nameCount); _i++) \
        { \
            (parameters)->compareResults[_i] = gcvFALSE; \
        } \
    } \
    while (gcvFALSE)

#define slsCOMPARE_ALL_NAMES_COMPONENT_PARAMETERS_ClearResults(parameters) \
    do \
    { \
        gctUINT _i; \
        \
        for (_i = 0; _i < (parameters)->nameCount; _i++) \
        { \
            (parameters)->compareResults[_i] = gcvFALSE; \
        } \
    } \
    while (gcvFALSE)

gctBOOL
sloIR_BASE_CompareAllNamesComponent(
    IN sloCOMPILER Compiler,
    IN sloIR_BASE Base,
    IN OUT slsCOMPARE_ALL_NAMES_COMPONENT_PARAMETERS * Parameters,
    OUT gctBOOL * NeedClearResults
    )
{
    sloIR_VARIABLE          variable        = gcvNULL;
    sloIR_CONSTANT          constant        = gcvNULL;
    sloIR_UNARY_EXPR        unaryExpr       = gcvNULL;
    sloIR_BINARY_EXPR       binaryExpr      = gcvNULL;
    sloIR_POLYNARY_EXPR     polynaryExpr    = gcvNULL;
    gctUINT8                components[4];
    slsNAME *               name;
    gctUINT                 nameIndex;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(Base);
    gcmASSERT(Parameters);
    gcmASSERT(NeedClearResults);

    *NeedClearResults = gcvFALSE;

    switch (sloIR_OBJECT_GetType(Base))
    {
    case slvIR_VARIABLE:
        variable = (sloIR_VARIABLE)Base;

        gcmFOOTER_NO();
        return slsDATA_TYPE_IsScalar(variable->exprBase.dataType);

    case slvIR_CONSTANT:
        constant = (sloIR_CONSTANT)Base;

            if (slsDATA_TYPE_IsScalar(constant->exprBase.dataType)) { gcmFOOTER_NO(); return gcvTRUE; }

        if (slsDATA_TYPE_IsBVecOrIVecOrVec(constant->exprBase.dataType))
        {
            if (slmDATA_TYPE_vectorSize_NOCHECK_GET(constant->exprBase.dataType) > Parameters->vectorIndex0
                && slmDATA_TYPE_vectorSize_NOCHECK_GET(constant->exprBase.dataType) > Parameters->vectorIndex1)
            {
                gcmFOOTER_NO();
                return (constant->values[Parameters->vectorIndex0].intValue
                            == constant->values[Parameters->vectorIndex1].intValue);
            }
        }
        gcmFOOTER_NO();
        return gcvFALSE;

    case slvIR_UNARY_EXPR:
        unaryExpr = (sloIR_UNARY_EXPR)Base;
        gcmASSERT(unaryExpr->operand);

            if (slsDATA_TYPE_IsScalar(unaryExpr->exprBase.dataType)) { gcmFOOTER_NO(); return gcvTRUE; }

        switch (unaryExpr->type)
        {
        case slvUNARY_FIELD_SELECTION:
            gcmFOOTER_NO();
            return gcvFALSE;

        case slvUNARY_COMPONENT_SELECTION:
            components[0] = unaryExpr->u.componentSelection.x;
            components[1] = unaryExpr->u.componentSelection.y;
            components[2] = unaryExpr->u.componentSelection.z;
            components[3] = unaryExpr->u.componentSelection.w;
            gcmFOOTER_NO();
            return (components[Parameters->vectorIndex0] == components[Parameters->vectorIndex1]);

        case slvUNARY_POST_INC:
        case slvUNARY_POST_DEC:
        case slvUNARY_PRE_INC:
        case slvUNARY_PRE_DEC:

        case slvUNARY_NEG:

        case slvUNARY_NOT:
            gcmFOOTER_NO();
            return sloIR_BASE_CompareAllNamesComponent(
                                                        Compiler,
                                                        &unaryExpr->operand->base,
                                                        Parameters,
                                                        NeedClearResults);

        default:
            gcmASSERT(0);
            gcmFOOTER_NO();
            return gcvFALSE;
        }

    case slvIR_BINARY_EXPR:
        binaryExpr = (sloIR_BINARY_EXPR)Base;
        gcmASSERT(binaryExpr->leftOperand);
        gcmASSERT(binaryExpr->rightOperand);

            if (slsDATA_TYPE_IsScalar(binaryExpr->exprBase.dataType)) { gcmFOOTER_NO(); return gcvTRUE; }

        switch (binaryExpr->type)
        {
        case slvBINARY_SUBSCRIPT:
            gcmFOOTER_NO();
            return gcvFALSE;

        case slvBINARY_ADD:
        case slvBINARY_SUB:
        case slvBINARY_MUL:
        case slvBINARY_DIV:

            if (!sloIR_BASE_CompareAllNamesComponent(
                                                    Compiler,
                                                    &binaryExpr->leftOperand->base,
                                                    Parameters,
                                                     NeedClearResults)) { gcmFOOTER_NO(); return gcvFALSE; }

            if (!sloIR_BASE_CompareAllNamesComponent(
                                                    Compiler,
                                                    &binaryExpr->rightOperand->base,
                                                    Parameters,
                                                     NeedClearResults)) { gcmFOOTER_NO(); return gcvFALSE; }

            gcmFOOTER_NO();
            return gcvTRUE;

        case slvBINARY_GREATER_THAN:
        case slvBINARY_LESS_THAN:
        case slvBINARY_GREATER_THAN_EQUAL:
        case slvBINARY_LESS_THAN_EQUAL:

        case slvBINARY_EQUAL:
        case slvBINARY_NOT_EQUAL:

        case slvBINARY_AND:
        case slvBINARY_OR:
        case slvBINARY_XOR:
            gcmFOOTER_NO();
            return gcvTRUE;

        case slvBINARY_SEQUENCE:
            if (!sloIR_BASE_CompareAllNamesComponent(
                                                    Compiler,
                                                    &binaryExpr->rightOperand->base,
                                                    Parameters,
                                                     NeedClearResults)) { gcmFOOTER_NO(); return gcvFALSE; }

            gcmFOOTER_NO();
            return gcvTRUE;

        case slvBINARY_ASSIGN:

        case slvBINARY_MUL_ASSIGN:
        case slvBINARY_DIV_ASSIGN:
        case slvBINARY_ADD_ASSIGN:
        case slvBINARY_SUB_ASSIGN:

            if (binaryExpr->type != slvBINARY_ASSIGN
                && !sloIR_BASE_CompareAllNamesComponent(
                                                        Compiler,
                                                        &binaryExpr->leftOperand->base,
                                                        Parameters,
                                                        NeedClearResults)) { gcmFOOTER_NO(); return gcvFALSE; }

            if (sloIR_OBJECT_GetType(&binaryExpr->leftOperand->base) == slvIR_VARIABLE)
            {
                name = ((sloIR_VARIABLE)binaryExpr->leftOperand)->name;
                gcmASSERT(name);

                nameIndex = _FindNameInList(
                                            name,
                                            Parameters->nameCount,
                                            Parameters->nameTable);

                if (nameIndex != MAX_NAME_TABLE_SIZE)
                {
                    Parameters->compareResults[nameIndex] =
                            sloIR_BASE_CompareAllNamesComponent(
                                                                Compiler,
                                                                &binaryExpr->rightOperand->base,
                                                                Parameters,
                                                                NeedClearResults);

                    gcmFOOTER_NO();
                    return Parameters->compareResults[nameIndex];
                }
            }

            gcmFOOTER_NO();
            return sloIR_BASE_CompareAllNamesComponent(
                                                    Compiler,
                                                    &binaryExpr->rightOperand->base,
                                                    Parameters,
                                                    NeedClearResults);

        default:
            gcmASSERT(0);
            gcmFOOTER_NO();
            return gcvFALSE;
        }

    case slvIR_POLYNARY_EXPR:
        polynaryExpr = (sloIR_POLYNARY_EXPR)Base;

        if (polynaryExpr->type == slvPOLYNARY_FUNC_CALL
            && !polynaryExpr->funcName->isBuiltIn)
        {
            *NeedClearResults = gcvTRUE;
            gcmFOOTER_NO();
            return gcvFALSE;
        }

        gcmFOOTER_NO();
        return slsDATA_TYPE_IsScalar(polynaryExpr->exprBase.dataType);

    default:
        *NeedClearResults = gcvTRUE;
        gcmFOOTER_NO();
        return gcvFALSE;
    }
}

gctBOOL
sloIR_SET_CompareAllNamesComponent(
    IN sloCOMPILER Compiler,
    IN sloIR_SET StatementSet,
    IN sloIR_BASE StopStatement,
    IN gctUINT NameCount,
    IN slsNAME * NameTable[MAX_NAME_TABLE_SIZE],
    IN gctUINT VectorIndex0,
    IN gctUINT VectorIndex1
    )
{
    slsCOMPARE_ALL_NAMES_COMPONENT_PARAMETERS   parameters;
    gctUINT                                     i;
    sloIR_BASE                                  statement;
    gctBOOL                                     needClearResults;

    slsCOMPARE_ALL_NAMES_COMPONENT_PARAMETERS_Initialize(
                                                        &parameters,
                                                        NameCount,
                                                        NameTable,
                                                        VectorIndex0,
                                                        VectorIndex1);

    FOR_EACH_DLINK_NODE(&StatementSet->members, struct _sloIR_BASE, statement)
    {
        if (statement == StopStatement) break;

        sloIR_BASE_CompareAllNamesComponent(Compiler, statement, &parameters, &needClearResults);

        if (needClearResults)
        {
            slsCOMPARE_ALL_NAMES_COMPONENT_PARAMETERS_ClearResults(&parameters);
        }
    }

    for (i = 0; i < parameters.nameCount; i++)
    {
        if (!parameters.compareResults[i]) return gcvFALSE;
    }

    return gcvTRUE;
}

typedef struct _slsSPECIAL_STATEMENT_CONTEXT
{
    gctBOOL                                     codeGenerated;

    sloIR_BASE                                  prevStatement;

    slsUSING_SINGLE_VECTOR_INDEX_PARAMETERS     prevParameters;
}
slsSPECIAL_STATEMENT_CONTEXT;

#define slsSPECIAL_STATEMENT_CONTEXT_Initialize(context) \
    do \
    { \
        (context)->codeGenerated    = gcvFALSE; \
        (context)->prevStatement    = gcvNULL; \
        slsUSING_SINGLE_VECTOR_INDEX_PARAMETERS_Initialize(&(context)->prevParameters); \
    } \
    while (gcvFALSE)

gceSTATUS
sloIR_SET_TryToGenSpecialStatementCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_SET StatementSet,
    IN sloIR_BASE Statement,
    IN OUT slsSPECIAL_STATEMENT_CONTEXT * StatementContext
    )
{
    gceSTATUS                                   status;
    slsUSING_SINGLE_VECTOR_INDEX_PARAMETERS     parameters;
    gctUINT                                     i;
    slsNAME *                                   name;
    slsLOPERAND                                 lOperand, componentLOperand;
    slsROPERAND                                 rOperand, componentROperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(StatementSet, slvIR_SET);
    gcmASSERT(Statement);
    gcmASSERT(StatementContext);

    do
    {
        /* Check the current statement */
        slsUSING_SINGLE_VECTOR_INDEX_PARAMETERS_Initialize(&parameters);

        status = sloIR_BASE_UsingSingleVectorIndex(
                                                Compiler,
                                                Statement,
                                                gcvFALSE,
                                                gcvFALSE,
                                                &parameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (!parameters.usingSingleVectorIndex
            || parameters.vectorIndex == INVALID_VECTOR_INDEX) break;

        if (parameters.maxLevel == 0) break;

        /* Check the previous statement */
        if (StatementContext->prevStatement == gcvNULL) break;

        gcmASSERT(StatementContext->prevParameters.usingSingleVectorIndex);
        gcmASSERT(StatementContext->prevParameters.vectorIndex != INVALID_VECTOR_INDEX);

        /* Compare the results */
        if (parameters.vectorIndex == StatementContext->prevParameters.vectorIndex) break;

        if (!_IsNameListEqual(
                            parameters.inputNameCount,
                            parameters.inputNameTable,
                            StatementContext->prevParameters.inputNameCount,
                            StatementContext->prevParameters.inputNameTable)) break;

        if (!_IsNameListEqual(
                            parameters.outputNameCount,
                            parameters.outputNameTable,
                            StatementContext->prevParameters.outputNameCount,
                            StatementContext->prevParameters.outputNameTable)) break;

        /* Compare the statements */
        if (!sloIR_BASE_IsEqualExceptVectorIndex(
                                                Compiler,
                                                Statement,
                                                StatementContext->prevStatement)) break;

        /* Check all input names */
        if (!sloIR_SET_CompareAllNamesComponent(
                                                Compiler,
                                                StatementSet,
                                                StatementContext->prevStatement,
                                                parameters.inputNameCount,
                                                parameters.inputNameTable,
                                                StatementContext->prevParameters.vectorIndex,
                                                parameters.vectorIndex)) break;

        /* Generate the special assign code */
        for (i = 0; i < parameters.outputNameCount; i++)
        {
            name = parameters.outputNameTable[i];
            gcmASSERT(slsDATA_TYPE_IsBVecOrIVecOrVec(name->dataType));
            gcmASSERT(name->context.logicalRegCount == 1);

            slsLOPERAND_Initialize(&lOperand, &name->context.logicalRegs[0]);
            slsROPERAND_InitializeReg(&rOperand, &name->context.logicalRegs[0]);

            slsLOPERAND_InitializeAsVectorComponent(
                                                    &componentLOperand,
                                                    &lOperand,
                                                    parameters.vectorIndex);
            slsROPERAND_InitializeAsVectorComponent(
                                                    &componentROperand,
                                                    &rOperand,
                                                    StatementContext->prevParameters.vectorIndex);

            status = slGenAssignCode(
                                    Compiler,
                                    Statement->lineNo,
                                    Statement->stringNo,
                                    &componentLOperand,
                                    &componentROperand);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }

        StatementContext->codeGenerated = gcvTRUE;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    StatementContext->codeGenerated = gcvFALSE;

    if (parameters.usingSingleVectorIndex
        && parameters.vectorIndex != INVALID_VECTOR_INDEX)
    {
        StatementContext->prevStatement     = Statement;
        StatementContext->prevParameters    = parameters;
    }
    else
    {
        StatementContext->prevStatement = gcvNULL;
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gctBOOL
sloIR_BASE_HasReturn(
    IN sloCOMPILER Compiler,
    IN sloIR_BASE Statement
    )
{
    sloIR_SELECTION     selection;
    sloIR_SET           set;
    sloIR_BASE          member;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(Statement);

    switch (sloIR_OBJECT_GetType(Statement))
    {
    case slvIR_JUMP:
        gcmFOOTER_NO();
        return (((sloIR_JUMP)Statement)->type == slvRETURN);

    case slvIR_SELECTION:
        selection = (sloIR_SELECTION)Statement;

        if (selection->trueOperand == gcvNULL
            || selection->falseOperand == gcvNULL) { gcmFOOTER_NO(); return gcvFALSE; }

        gcmFOOTER_NO();
        return sloIR_BASE_HasReturn(Compiler, selection->trueOperand)
                && sloIR_BASE_HasReturn(Compiler, selection->falseOperand);

    case slvIR_SET:
        set = (sloIR_SET)Statement;

            if (set->type != slvSTATEMENT_SET) { gcmFOOTER_NO(); return gcvFALSE; }

        FOR_EACH_DLINK_NODE(&set->members, struct _sloIR_BASE, member)
        {
            if (sloIR_BASE_HasReturn(Compiler, member)) { gcmFOOTER_NO(); return gcvTRUE; }
        }

        gcmFOOTER_NO();
        return gcvFALSE;

    default:
        gcmFOOTER_NO();
        return gcvFALSE;
    }
}

static gceSTATUS
_GenWorkGroupSize(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctSTRING variableName = "gl_NumWorkGroups";
    slsNAME *numGroup = gcvNULL;
    sleSHADER_TYPE shaderType;

    gcmONERROR(sloCOMPILER_GetShaderType(Compiler, &shaderType));

    if (sloCOMPILER_IsES31VersionOrAbove(Compiler) &&
        shaderType == slvSHADER_TYPE_COMPUTE)
    {
        gcmONERROR(sloCOMPILER_SearchBuiltinName(Compiler,
                                                 variableName,
                                                 &numGroup));

        gcmONERROR(slsNAME_AllocLogicalRegs(Compiler,
                                            CodeGenerator,
                                            numGroup));
    }
OnError:
    return status;
}

static gceSTATUS
_GenInitSpecialVariables(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    slsNAME *localInvocationIndex;
    slsNAME *localId;
    slsLAYOUT_QUALIFIER layout[1];
    slsIOPERAND invocationIndex[1];
    gctREG_INDEX tempRegIndex;
    slsIOPERAND iOperand[1];
    slsROPERAND rOperand1[1];
    slsROPERAND rOperand2[1];
    slsROPERAND localIdOperand[1];
    slsROPERAND localSize[1];
    gctSTRING variableName;
    slsNAME *sharedVariableStorageBlock;

    if (!sloCOMPILER_IsShaderType(Compiler, slvSHADER_TYPE_COMPUTE))
        return gcvSTATUS_OK;

    variableName = "gl_LocalInvocationIndex";
    status = sloCOMPILER_SearchBuiltinName(Compiler,
                                           variableName,
                                           &localInvocationIndex);
    if(status != gcvSTATUS_OK)
    {
        gcmONERROR(gcvSTATUS_COMPILER_FE_PARSER_ERROR);
    }

    /* check if gl_LocationInvocationIndex is referenced in compute shader */
    if(localInvocationIndex->u.variableInfo.isReferenced) {
        gcmONERROR(slsNAME_AllocLogicalRegs(Compiler,
                                            CodeGenerator,
                                            localInvocationIndex));

    /* Compute local invocation index */
        variableName = "gl_LocalInvocationID";
        status = sloCOMPILER_SearchBuiltinName(Compiler,
                                               variableName,
                                               &localId);
        if(status != gcvSTATUS_OK)
        {
            gcmONERROR(gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        }

        gcmONERROR(slsNAME_AllocLogicalRegs(Compiler,
                                            CodeGenerator,
                                            localId));

        gcmONERROR(sloCOMPILER_GetDefaultLayout(Compiler,
                                                layout,
                                                slvSTORAGE_QUALIFIER_IN));

        if(!(layout->id & sldLAYOUT_WORK_GROUP_SIZE_FIELDS))
        {
            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                            localId->lineNo,
                                            localId->stringNo,
                                            slvREPORT_ERROR,
                                            "input layout qualifiers local_size_x, local_size_y, local_size_z "
                                            "have not been specified for special variable 'gl_LocalInvocationIndex'"));
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }

    /* Compute local invocation index :
       Z * I * J + Y * I + X
       where local Id = (X, Y, Z) and
             work group size = (I, J, K)  */

    /* Compute: (Z, Y) * I */
        slsROPERAND_InitializeReg(localIdOperand,
                                  localId->context.logicalRegs);

        slGetVectorROperandSlice(localIdOperand,
                                 1,
                                 2,
                                 rOperand1);

        tempRegIndex = slNewTempRegs(Compiler, 1);
        slsIOPERAND_Initialize(iOperand, rOperand1->dataType, gcSHADER_PRECISION_MEDIUM, tempRegIndex);

        slsROPERAND_InitializeIntOrIVecConstant(localSize,
                                                localInvocationIndex->context.logicalRegs->dataType,
                                                gcSHADER_PRECISION_MEDIUM,
                                                layout->workGroupSize[0]);

        gcmONERROR(slGenArithmeticExprCode(Compiler,
                                           localId->lineNo,
                                           localId->stringNo,
                                           slvOPCODE_MUL,
                                           iOperand,
                                           rOperand1,
                                           localSize));

    /* Compute (Z * I) * J */
        slsROPERAND_InitializeUsingIOperand(rOperand1, iOperand);
        slsROPERAND_InitializeIntOrIVecConstant(localSize,
                                                localInvocationIndex->context.logicalRegs->dataType,
                                                gcSHADER_PRECISION_MEDIUM,
                                                layout->workGroupSize[1]);
        slmROPERAND_vectorComponent_GET(rOperand1, rOperand1, slvCOMPONENT_Y);
        slsIOPERAND_New(Compiler,
                        invocationIndex,
                        localInvocationIndex->context.logicalRegs->dataType,
                        gcSHADER_PRECISION_MEDIUM);
        gcmONERROR(slGenArithmeticExprCode(Compiler,
                                           localInvocationIndex->lineNo,
                                           localInvocationIndex->stringNo,
                                           slvOPCODE_MUL,
                                           invocationIndex,
                                           rOperand1,
                                           localSize));

    /* Compute (Z * I * J) + (Y * I) */
        slsROPERAND_InitializeUsingIOperand(rOperand1, invocationIndex);
        slsROPERAND_InitializeUsingIOperand(rOperand2, iOperand);
        slmROPERAND_vectorComponent_GET(rOperand2, rOperand2, slvCOMPONENT_X);
        slsIOPERAND_Initialize(invocationIndex,
                               localInvocationIndex->context.logicalRegs->dataType,
                               gcSHADER_PRECISION_MEDIUM,
                               localInvocationIndex->context.logicalRegs->regIndex);
        gcmONERROR(slGenArithmeticExprCode(Compiler,
                                           localInvocationIndex->lineNo,
                                           localInvocationIndex->stringNo,
                                           slvOPCODE_ADD,
                                           invocationIndex,
                                           rOperand1,
                                           rOperand2));

    /* Compute (Z * I * J) + (Y * I) + X */
        slsROPERAND_InitializeUsingIOperand(rOperand1, invocationIndex);
        slmROPERAND_vectorComponent_GET(rOperand2, localIdOperand, slvCOMPONENT_X);
        gcmONERROR(slGenArithmeticExprCode(Compiler,
                                           localInvocationIndex->lineNo,
                                           localInvocationIndex->stringNo,
                                           slvOPCODE_ADD,
                                           invocationIndex,
                                           rOperand1,
                                           rOperand2));
    }

/* Create shared variable storage block */
    gcmONERROR(slCreateSharedVariableStorageBlock(Compiler,
                                                  &sharedVariableStorageBlock));

    if(sharedVariableStorageBlock) {
        gcSHADER binary;
        slsINTERFACE_BLOCK_MEMBER *blockMember;
        gcUNIFORM blockAddressUniform;
        slsNAME *groupId;
        slsNAME *numGroup = gcvNULL;
        slsROPERAND groupIdOperand[1];
        slsROPERAND numGroupOperand[1];
        slsIOPERAND groupIndex[1];

        blockMember = slsDLINK_LIST_First(&sharedVariableStorageBlock->u.interfaceBlockContent.members, slsINTERFACE_BLOCK_MEMBER);
        gcmONERROR(slsNAME_AllocLogicalRegs(Compiler,
                                            CodeGenerator,
                                            blockMember->name));
        gcmASSERT(sharedVariableStorageBlock->u.interfaceBlockContent.u.storageBlock);
        SetSBFlag(sharedVariableStorageBlock->u.interfaceBlockContent.u.storageBlock, gceIB_FLAG_FOR_SHARED_VARIABLE);
        SetSBSharedVariableBaseAddress(sharedVariableStorageBlock->u.interfaceBlockContent.u.storageBlock,
                                       slNewTempRegs(Compiler, 1));

        variableName = "gl_WorkGroupID";
        gcmONERROR(sloCOMPILER_SearchBuiltinName(Compiler,
                                                 variableName,
                                                 &groupId));
        gcmONERROR(slsNAME_AllocLogicalRegs(Compiler,
                                            CodeGenerator,
                                            groupId));

        variableName = "gl_NumWorkGroups";
        gcmONERROR(sloCOMPILER_SearchBuiltinName(Compiler,
                                                 variableName,
                                                 &numGroup));

        gcmASSERT(numGroup != gcvNULL);
        /* Compute group index :
           Z * I * J + Y * I + X
           where group Id = (X, Y, Z) and
                 num work group = (I, J, K)  */

        /* Compute: (Z, Y) * I */
        slsROPERAND_InitializeReg(groupIdOperand,
                                  groupId->context.logicalRegs);

        slsROPERAND_InitializeReg(numGroupOperand,
                                  numGroup->context.logicalRegs);

        slGetVectorROperandSlice(groupIdOperand,
                                 1,
                                 2,
                                 rOperand1);

        slmROPERAND_vectorComponent_GET(rOperand2, numGroupOperand, slvCOMPONENT_X);

        tempRegIndex = slNewTempRegs(Compiler, 1);
        slsIOPERAND_Initialize(iOperand, rOperand1->dataType, gcSHADER_PRECISION_MEDIUM, tempRegIndex);

        gcmONERROR(slGenArithmeticExprCode(Compiler,
                                           groupId->lineNo,
                                           groupId->stringNo,
                                           slvOPCODE_MUL,
                                           iOperand,
                                           rOperand1,
                                           rOperand2));

        /* Compute (Z * I) * J */
        slsROPERAND_InitializeUsingIOperand(rOperand1, iOperand);
        slmROPERAND_vectorComponent_GET(rOperand1, rOperand1, slvCOMPONENT_Y);
        slmROPERAND_vectorComponent_GET(rOperand2, numGroupOperand, slvCOMPONENT_Y);
        slsIOPERAND_New(Compiler,
                        groupIndex,
                        gcGetComponentDataType(numGroup->context.logicalRegs->dataType),
                        gcSHADER_PRECISION_MEDIUM);
        gcmONERROR(slGenArithmeticExprCode(Compiler,
                                           groupId->lineNo,
                                           groupId->stringNo,
                                           slvOPCODE_MUL,
                                           groupIndex,
                                           rOperand1,
                                           rOperand2));

        /* Compute (Z * I * J) + (Y * I) */
        slsROPERAND_InitializeUsingIOperand(rOperand1, groupIndex);
        slsROPERAND_InitializeUsingIOperand(rOperand2, iOperand);
        slmROPERAND_vectorComponent_GET(rOperand2, rOperand2, slvCOMPONENT_X);
        gcmONERROR(slGenArithmeticExprCode(Compiler,
                                           groupId->lineNo,
                                           groupId->stringNo,
                                           slvOPCODE_ADD,
                                           groupIndex,
                                           rOperand1,
                                           rOperand2));

        /* Compute (Z * I * J) + (Y * I) + X */
        slsROPERAND_InitializeUsingIOperand(rOperand1, groupIndex);
        slmROPERAND_vectorComponent_GET(rOperand2, groupIdOperand, slvCOMPONENT_X);
        gcmONERROR(slGenArithmeticExprCode(Compiler,
                                           groupId->lineNo,
                                           groupId->stringNo,
                                           slvOPCODE_ADD,
                                           groupIndex,
                                           rOperand1,
                                           rOperand2));

        gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &binary));

        status = gcSHADER_GetUniform(binary,
                                     GetSBIndex(sharedVariableStorageBlock->u.interfaceBlockContent.u.storageBlock),
                                     &blockAddressUniform);
        if (gcmIS_ERROR(status)) { return status; }

        {
            slsROPERAND addressROperand[1];
            slsIOPERAND addressIOperand[1];
            slsIOPERAND intermIOperand[1];
            slsLOGICAL_REG reg[1];
            gcSHADER_TYPE addressType;
            slsROPERAND constantROperand[1];
            gctINT32 blockSize;

            addressType = gcGetComponentDataType(GetUniformType(blockAddressUniform));
            slsROPERAND_InitializeUsingIOperand(rOperand1, groupIndex);
            blockSize = (gctINT32)GetSBBlockSize(sharedVariableStorageBlock->u.interfaceBlockContent.u.storageBlock);
            slsROPERAND_InitializeIntOrIVecConstant(constantROperand,
                                                    addressType,
                                                    GetUniformPrecision(blockAddressUniform),
                                                    blockSize);

            slsIOPERAND_New(Compiler,
                            intermIOperand,
                            addressType,
                            GetUniformPrecision(blockAddressUniform));
            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_MUL,
                                             intermIOperand,
                                             rOperand1,
                                             constantROperand);
            if (gcmIS_ERROR(status)) { return status; }

            slsROPERAND_InitializeUsingIOperand(rOperand1, intermIOperand);
            slsLOGICAL_REG_InitializeUniform(reg,
                                             slvSTORAGE_QUALIFIER_UNIFORM,
                                             addressType,
                                             GetUniformPrecision(blockAddressUniform),
                                             blockAddressUniform,
                                             0);
            slsROPERAND_InitializeReg(addressROperand,
                                      reg);

            gcmASSERT(GetSBSharedVariableBaseAddress(sharedVariableStorageBlock->u.interfaceBlockContent.u.storageBlock) != - 1);
            slsIOPERAND_Initialize(addressIOperand,
                                   addressType,
                                   GetUniformPrecision(blockAddressUniform),
                                   GetSBSharedVariableBaseAddress(sharedVariableStorageBlock->u.interfaceBlockContent.u.storageBlock));

            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_ADD,
                                             addressIOperand,
                                             addressROperand,
                                             rOperand1);
            if (gcmIS_ERROR(status)) { return status; }
        }
    }

    return gcvSTATUS_OK;

OnError:
    gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                    localInvocationIndex->lineNo,
                                    localInvocationIndex->stringNo,
                                    slvREPORT_ERROR,
                                    "error in parsing special variable '%s'", variableName));
    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
}

static gceSTATUS
_CheckLayout(
    IN sloCOMPILER Compiler
    )
{
    sleSHADER_TYPE shaderType;
    slsLAYOUT_QUALIFIER layout;
    gceSTATUS status = gcvSTATUS_OK;

    gcmVERIFY_OK(sloCOMPILER_GetShaderType(Compiler, &shaderType));

    if (shaderType == slvSHADER_TYPE_TES)
    {
        gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &layout, slvSTORAGE_QUALIFIER_IN));
        if (layout.tesPrimitiveMode == slvTES_PRIMITIVE_MODE_NONE)
        {
            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                            0,
                                            0,
                                            slvREPORT_WARN,
                                            "The tessellation evaluation shader object in a program must declare a "
                                            "primitive mode in its input layout."));
            sloCOMPILER_SetNotStagesRelatedLinkError(Compiler, gcvSTATUS_MISSING_PRIMITIVE_TYPE);
        }
    }
    else if (shaderType == slvSHADER_TYPE_TCS)
    {
        gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &layout, slvSTORAGE_QUALIFIER_OUT));
        if (layout.verticesNumber == -1)
        {
            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                            0,
                                            0,
                                            slvREPORT_WARN,
                                            "The output patch vertex count is not specified in the "
                                            "compiled tessellation control shader object."));
            sloCOMPILER_SetNotStagesRelatedLinkError(Compiler, gcvSTATUS_MISSING_OUTPUT_VERTEX_COUNT);
        }
    }
    else if (shaderType == slvSHADER_TYPE_GS)
    {
        /* Check input layout. */
        gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &layout, slvSTORAGE_QUALIFIER_IN));
        if (layout.gsPrimitive == slvGS_PRIMITIVE_NONE)
        {
            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                            0,
                                            0,
                                            slvREPORT_WARN,
                                            "The geometry shader object in a program must declare "
                                            "the input primitive layout."));
            sloCOMPILER_SetNotStagesRelatedLinkError(Compiler, gcvSTATUS_MISSING_PRIMITIVE_TYPE);
        }
        /* Check output layout. */
        gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &layout, slvSTORAGE_QUALIFIER_OUT));
        if (layout.gsPrimitive == slvGS_PRIMITIVE_NONE)
        {
            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                            0,
                                            0,
                                            slvREPORT_WARN,
                                            "The geometry shader object in a program must declare "
                                            "the output primitive layout."));
            sloCOMPILER_SetNotStagesRelatedLinkError(Compiler, gcvSTATUS_MISSING_PRIMITIVE_TYPE);
        }
        if (layout.maxGSVerticesNumber == -1)
        {
            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                            0,
                                            0,
                                            slvREPORT_WARN,
                                            "The geometry shader object in a program must declare "
                                            "the output max_vertices layout."));
            sloCOMPILER_SetNotStagesRelatedLinkError(Compiler, gcvSTATUS_MISSING_OUTPUT_VERTEX_COUNT);
        }
    }
    return status;
}

static gceSTATUS
_CheckQualifier(
    IN sloCOMPILER Compiler
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    slsNAME * name;
    slsNAME_SPACE *nameSpace = sloCOMPILER_GetGlobalSpace(Compiler);

    FOR_EACH_DLINK_NODE(&nameSpace->names, slsNAME, name)
    {
        if (name->type != slvVARIABLE_NAME)
            continue;

        /*Check auxiliary qualifiers. */
        if (slsQUALIFIERS_GET_AUXILIARY(&name->dataType->qualifiers))
        {
            if (name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_ATTRIBUTE)
            {
                gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                name->lineNo,
                                                name->stringNo,
                                                slvREPORT_ERROR,
                                                "\"sample\\centroid\" can not be used in a vertex shader input."));
            }
            else if (name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_FRAGMENT_OUT)
            {
                gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                name->lineNo,
                                                name->stringNo,
                                                slvREPORT_ERROR,
                                                "\"sample\\centroid\" can not be used in a fragment shader input."));
            }
        }
    }

    /* Check layout qualifier. */
    gcmONERROR(_CheckLayout(Compiler));

OnError:
    return status;
}

static gceSTATUS
_CheckArraySizeForTSNormalVariable(
    IN sloCOMPILER Compiler,
    IN slsLAYOUT_QUALIFIER InLayout,
    IN slsLAYOUT_QUALIFIER OutLayout,
    IN sleSHADER_TYPE ShaderType,
    IN gctBOOL IsInput,
    IN slsNAME * Name,
    IN gctINT ArrayLength,
    IN gctINT MaxArrayLength
    )
{
    gceSTATUS status = gcvSTATUS_OK;

    if (Name->dataType->arrayLengthCount == 0)
        return status;

    if (Name->dataType->arrayLength != -1)
    {
        if (Name->dataType->arrayLength > MaxArrayLength)
        {
            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                            Name->lineNo,
                                            Name->stringNo,
                                            slvREPORT_ERROR,
                                            "The length of \"%s\" is "
                                            "greater than the implementation-dependent maximum value.",
                                            Name->symbol));

            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }

        if (Name->dataType->arrayLength != ArrayLength)
        {
            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                            Name->lineNo,
                                            Name->stringNo,
                                            slvREPORT_ERROR,
                                            "The length of \"%s\" is wrong.",
                                            Name->symbol));

            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }

        if (ShaderType == slvSHADER_TYPE_TCS && !IsInput)
        {
            if (Name->dataType->arrayLength != OutLayout.verticesNumber)
            {
                gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                Name->lineNo,
                                                Name->stringNo,
                                                slvREPORT_ERROR,
                                                "The length of \"%s\" is wrong.",
                                                Name->symbol));

                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }
        }
    }
    else
    {
        gctPOINTER pointer = gcvNULL;

        status = sloCOMPILER_Allocate(Compiler,
                                      (gctSIZE_T)gcmSIZEOF(gctINT),
                                      &pointer);
        if (gcmIS_ERROR(status)) return status;

        gcoOS_ZeroMemory(pointer, gcmSIZEOF(gctINT));

        Name->dataType->arrayLengthList = (gctINT *)pointer;
        Name->dataType->arrayLengthList[0] = ArrayLength;
        Name->dataType->arrayLength = ArrayLength;
    }

    return status;
}

static gceSTATUS
_CheckArraySizeForTS(
    IN sloCOMPILER Compiler,
    IN slsNAME_SPACE * NameSpace,
    IN gctBOOL IsBuiltIn
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    sleSHADER_TYPE shaderType;
    slsLAYOUT_QUALIFIER outLayout, inLayout;
    gctINT arrayLength = 0;
    gctINT maxArrayLength = 0;
    slsNAME * name;
    gctBOOL isInput = gcvFALSE;

    gcmVERIFY_OK(sloCOMPILER_GetShaderType(Compiler, &shaderType));
    gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &outLayout, slvSTORAGE_QUALIFIER_OUT));
    gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &inLayout, slvSTORAGE_QUALIFIER_IN));

    if (shaderType != slvSHADER_TYPE_TCS && shaderType != slvSHADER_TYPE_TES)
        return status;

    /* Only check per-vertex variables. */
    FOR_EACH_DLINK_NODE(&NameSpace->names, slsNAME, name)
    {
        if (slsQUALIFIERS_HAS_FLAG(&name->dataType->qualifiers, slvQUALIFIERS_FLAG_PATCH))
            continue;

        if (name->type != slvVARIABLE_NAME)
            continue;

        /* Check inputs for TCS/TES. */
        if (name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_VARYING_IN ||
            name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_IN_IO_BLOCK ||
            name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_IN_IO_BLOCK_MEMBER)
        {
            arrayLength = inLayout.maxVerticesNumber;
            maxArrayLength = inLayout.maxVerticesNumber;
            isInput = gcvTRUE;
        }
        /* Check outputs for TCS only. */
        else if (name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_VARYING_OUT ||
                 name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_OUT_IO_BLOCK ||
                 name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_OUT_IO_BLOCK_MEMBER)
        {
            if (shaderType != slvSHADER_TYPE_TCS)
            {
                continue;
            }

            arrayLength = outLayout.maxVerticesNumber;

#if defined(ANDROID) && (ANDROID_SDK_VERSION <= 22)
            {
                gcePATCH_ID patchId = sloCOMPILER_GetPatchID(Compiler);

                if (patchId == gcvPATCH_DEQP)
                {
                    arrayLength = outLayout.verticesNumber;
                }
            }
#endif
            maxArrayLength = outLayout.maxVerticesNumber;
            isInput = gcvFALSE;
        }
        else
        {
            continue;
        }

        /* Check built-in variables. */
        if (IsBuiltIn)
        {
            if (name->dataType->arrayLengthCount > 0)
            {
                slsNAME_SetPerVertexArray(name, gcvTRUE);
                slsDATA_TYPE_SetPerVertexArray(name->dataType, gcvTRUE);
            }

            /* Update the array size for built-in variables. */
            if (name->dataType->arrayLengthCount != 0)
            {
                name->dataType->arrayLength = arrayLength;
                name->dataType->arrayLengthList[0] = arrayLength;
            }
        }
        /* Check IO block. */
        else if (slsDATA_TYPE_IsUnderlyingIOBlock(name->dataType))
        {
            slsNAME * blockMemberName = gcvNULL;

            /* The array length count of an IO block can't be greater than 2. */
            if (name->dataType->arrayLengthCount != 0)
            {
                if (name->dataType->arrayLengthCount > 2)
                {
                    gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                    name->lineNo,
                                                    name->stringNo,
                                                    slvREPORT_ERROR,
                                                    "Variable \"%s\" cann't be an arrays of arrays.",
                                                    name->symbol));

                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
                else
                {
                    /* Check the array size. */
                    status = _CheckArraySizeForTSNormalVariable(Compiler,
                                                                inLayout,
                                                                outLayout,
                                                                shaderType,
                                                                isInput,
                                                                name,
                                                                arrayLength,
                                                                maxArrayLength);
                    if (gcmIS_ERROR(status)) return status;

                    slsNAME_SetPerVertexArray(name, gcvTRUE);
                    slsDATA_TYPE_SetPerVertexArray(name->dataType, gcvTRUE);
                }
            }

            FOR_EACH_DLINK_NODE(&(name->dataType->fieldSpace->names), slsNAME, blockMemberName)
            {
                /* If this IO block is not an array, its members must be arrays. */
                if (!slsNAME_IsPerVertexArray(name))
                {
                    /* According to specs, we should generate a LINK error for such usage. */
                    if (blockMemberName->dataType->arrayLengthCount == 0)
                    {
                        blockMemberName->isPerVertexNotAnArray = gcvTRUE;
                    }
                    else if (blockMemberName->dataType->arrayLengthCount > 2)
                    {
                        gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                        blockMemberName->lineNo,
                                                        blockMemberName->stringNo,
                                                        slvREPORT_ERROR,
                                                        "Variable \"%s\" cann't be an arrays of arrays.",
                                                        blockMemberName->symbol));

                        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                    }
                    else
                    {
                        /* Check the array size. */
                        status = _CheckArraySizeForTSNormalVariable(Compiler,
                                                                    inLayout,
                                                                    outLayout,
                                                                    shaderType,
                                                                    isInput,
                                                                    blockMemberName,
                                                                    arrayLength,
                                                                    maxArrayLength);
                        if (gcmIS_ERROR(status)) return status;

                        slsNAME_SetPerVertexArray(blockMemberName, gcvTRUE);
                        slsDATA_TYPE_SetPerVertexArray(blockMemberName->dataType, gcvTRUE);
                    }
                }
                else
                {
                    if (blockMemberName->dataType->arrayLengthCount > 1)
                    {
                        gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                        blockMemberName->lineNo,
                                                        blockMemberName->stringNo,
                                                        slvREPORT_ERROR,
                                                        "Variable \"%s\" cann't be an arrays of arrays.",
                                                        blockMemberName->symbol));

                        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                    }
                }
            }
        }
        /* Check normal variables. */
        else
        {
            /* The array length count must be greater than 1, but less than 3. */
            /* According to specs, we should generate a LINK error for such usage. */
            if (name->dataType->arrayLengthCount == 0)
            {
                name->isPerVertexNotAnArray = gcvTRUE;
            }
            else if (name->dataType->arrayLengthCount > 2)
            {
                gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                name->lineNo,
                                                name->stringNo,
                                                slvREPORT_ERROR,
                                                "Variable \"%s\" cann't be an arrays of arrays.",
                                                name->symbol));

                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }
            else
            {
                status = _CheckArraySizeForTSNormalVariable(Compiler,
                                                            inLayout,
                                                            outLayout,
                                                            shaderType,
                                                            isInput,
                                                            name,
                                                            arrayLength,
                                                            maxArrayLength);
                if (gcmIS_ERROR(status)) return status;

                slsNAME_SetPerVertexArray(name, gcvTRUE);
                slsDATA_TYPE_SetPerVertexArray(name->dataType, gcvTRUE);
            }
        }
    }

    return status;
}

static gceSTATUS
_CheckInputOutputForTS(
    IN sloCOMPILER Compiler
    )
{
    gceSTATUS status = gcvSTATUS_OK;

    gcmHEADER();

    status = _CheckArraySizeForTS(Compiler, sloCOMPILER_GetGlobalSpace(Compiler), gcvFALSE);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _CheckArraySizeForTS(Compiler, sloCOMPILER_GetBuiltInSpace(Compiler), gcvTRUE);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER();
    return status;
}

static gceSTATUS
_CheckArraySizeForGSNormalVariable(
    IN sloCOMPILER Compiler,
    IN slsNAME * Name,
    IN gctINT InputArraySize
    )
{
    gceSTATUS status = gcvSTATUS_OK;

    /* Set array length for a unsized array. */
    if (Name->dataType->arrayLength == -1)
    {
        Name->dataType->arrayLength = InputArraySize;
        Name->dataType->arrayLengthList[0] = InputArraySize;
    }
    else if (Name->dataType->arrayLengthCount != 0 &&
             Name->dataType->arrayLength != InputArraySize)
    {
        gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                        0,
                                        0,
                                        slvREPORT_WARN,
                                        "The array size of input \"%s\" doesn't match the layout declaration's array size.",
                                        Name->symbol));

        sloCOMPILER_SetNotStagesRelatedLinkError(Compiler, gcvSTATUS_INPUT_ARRAY_SIZE_MISMATCH);
    }

    return status;
}


static gceSTATUS
_CheckArraySizeForGS(
    IN sloCOMPILER Compiler,
    IN slsNAME_SPACE * NameSpace,
    IN gctBOOL IsBuiltIn
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    slsLAYOUT_QUALIFIER inLayout;
    gctINT inputArraySize;
    slsNAME * name;

    gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &inLayout, slvSTORAGE_QUALIFIER_IN));
    inputArraySize = _GetInputArraySizeByPrimitiveType(inLayout.gsPrimitive);

    FOR_EACH_DLINK_NODE(&NameSpace->names, slsNAME, name)
    {
        gctBOOL isUseAttrCode = _IsUseAttrCodeForVariable(Compiler, name->dataType->qualifiers.storage);

        if (slsQUALIFIERS_HAS_FLAG(&name->dataType->qualifiers, slvQUALIFIERS_FLAG_PATCH))
            continue;

        if (name->type != slvVARIABLE_NAME)
            continue;

        /* The array length count must be greater than 1, but less than 3. */
        if (isUseAttrCode)
        {
            if (IsBuiltIn)
            {
                if (name->dataType->arrayLengthCount > 0)
                {
                    slsNAME_SetPerVertexArray(name, gcvTRUE);
                    slsDATA_TYPE_SetPerVertexArray(name->dataType, gcvTRUE);
                }
            }
            else if (slsDATA_TYPE_IsUnderlyingIOBlock(name->dataType))
            {
                slsNAME * blockMemberName = gcvNULL;

                /* The array length count of an IO block can't be greater than 2. */
                if (name->dataType->arrayLengthCount != 0)
                {
                    if (name->dataType->arrayLengthCount > 2)
                    {
                        gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                        name->lineNo,
                                                        name->stringNo,
                                                        slvREPORT_ERROR,
                                                        "Variable \"%s\" cann't be an arrays of arrays.",
                                                        name->symbol));

                        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                    }
                    else
                    {
                        /* Check the array size. */
                        status = _CheckArraySizeForGSNormalVariable(Compiler,
                                                                    name,
                                                                    inputArraySize);
                        if (gcmIS_ERROR(status)) return status;

                        slsNAME_SetPerVertexArray(name, gcvTRUE);
                        slsDATA_TYPE_SetPerVertexArray(name->dataType, gcvTRUE);
                    }
                }

                FOR_EACH_DLINK_NODE(&(name->dataType->fieldSpace->names), slsNAME, blockMemberName)
                {
                    /* If this IO block is not an array, its members must be arrays. */
                    if (!slsNAME_IsPerVertexArray(name))
                    {
                        /* According to specs, we should generate a LINK error for such usage. */
                        if (blockMemberName->dataType->arrayLengthCount == 0)
                        {
                            blockMemberName->isPerVertexNotAnArray = gcvTRUE;
                        }
                        else if (blockMemberName->dataType->arrayLengthCount > 2)
                        {
                            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                            blockMemberName->lineNo,
                                                            blockMemberName->stringNo,
                                                            slvREPORT_ERROR,
                                                            "Variable \"%s\" cann't be an arrays of arrays.",
                                                            blockMemberName->symbol));

                            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                        }
                        else
                        {
                            /* Check the array size. */
                            status = _CheckArraySizeForGSNormalVariable(Compiler,
                                                                        blockMemberName,
                                                                        inputArraySize);
                            if (gcmIS_ERROR(status)) return status;

                            slsNAME_SetPerVertexArray(blockMemberName, gcvTRUE);
                            slsDATA_TYPE_SetPerVertexArray(blockMemberName->dataType, gcvTRUE);
                        }
                    }
                    else
                    {
                        if (blockMemberName->dataType->arrayLengthCount > 1)
                        {
                            gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                            blockMemberName->lineNo,
                                                            blockMemberName->stringNo,
                                                            slvREPORT_ERROR,
                                                            "Variable \"%s\" cann't be an arrays of arrays.",
                                                            blockMemberName->symbol));

                            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                        }
                    }
                }
            }
            else
            {
                /* According to specs, we should generate a LINK error for such usage. */
                if (name->dataType->arrayLengthCount == 0)
                {
                    name->isPerVertexNotAnArray = gcvTRUE;
                }
                else if (name->dataType->arrayLengthCount > 2)
                {
                    gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                    name->lineNo,
                                                    name->stringNo,
                                                    slvREPORT_ERROR,
                                                    "Variable \"%s\" cann't be an arrays of arrays.",
                                                    name->symbol));

                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }
                else
                {
                    /* Check the array size. */
                    status = _CheckArraySizeForGSNormalVariable(Compiler,
                                                                name,
                                                                inputArraySize);
                    if (gcmIS_ERROR(status)) return status;

                    slsNAME_SetPerVertexArray(name, gcvTRUE);
                    slsDATA_TYPE_SetPerVertexArray(name->dataType, gcvTRUE);
                }
            }
        }
    }
    return status;
}
static gceSTATUS
_CheckGS(
    IN sloCOMPILER Compiler
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    sleSHADER_TYPE shaderType;
    slsLAYOUT_QUALIFIER inLayout;

    gcmHEADER();

    gcmVERIFY_OK(sloCOMPILER_GetShaderType(Compiler, &shaderType));

    if (shaderType != slvSHADER_TYPE_GS)
    {
        gcmFOOTER();
        return status;
    }

    gcmVERIFY_OK(sloCOMPILER_GetDefaultLayout(Compiler, &inLayout, slvSTORAGE_QUALIFIER_IN));

    /* I: Check the array size. */
    status = _CheckArraySizeForGS(Compiler, sloCOMPILER_GetGlobalSpace(Compiler), gcvFALSE);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _CheckArraySizeForGS(Compiler, sloCOMPILER_GetBuiltInSpace(Compiler), gcvTRUE);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* II: set the invocation value. */
    if (inLayout.gsInvocationTime == -1)
    {
        inLayout.gsInvocationTime = 1;
        sloCOMPILER_UpdateDefaultLayout(Compiler,
                                        inLayout,
                                        slvSTORAGE_QUALIFIER_IN);
    }

    gcmFOOTER();
    return status;
}

static gceSTATUS
_GenVecConstants(
    IN sloCOMPILER Compiler,
    IN sltELEMENT_TYPE ElementType
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    slsDLINK_LIST *constantList, *cList;
    gctUINT i;
    slsNAME *constVar;

    gcmHEADER();

    if (!sloCOMPILER_OptimizationEnabled(Compiler, slvOPTIMIZATION_SHARE_VEC_CONSTANTS))
    {
        gcmFOOTER();
        return status;
    }

    status = sloCOMPILER_GetVecConstantLists(Compiler,
                                             ElementType,
                                             &constantList);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    for(i = sldMAX_VECTOR_COMPONENT - 1; i >= 1; i--) {
        cList = &constantList[i];
        FOR_EACH_DLINK_NODE(cList, slsNAME, constVar) {
            if (constVar->context.logicalRegCount == 0) {
                slsROPERAND constantROperand[1];
                slsIOPERAND intermIOperand[1];
                slsLOPERAND intermLOperand[1];
                gcSHADER_TYPE binaryDataType;
                gcSHADER_PRECISION binaryPrecision;
                gctPOINTER pointer = gcvNULL;

                binaryDataType = _ConvElementDataType(constVar->dataType);
                binaryPrecision = _ConvElementDataPrecision(constVar->dataType);
                /*load constant into a temp */
                slsROPERAND_InitializeConstant(constantROperand,
                                               binaryDataType,
                                               binaryPrecision,
                                               constVar->u.variableInfo.constant->valueCount,
                                               constVar->u.variableInfo.constant->values);

                slsIOPERAND_New(Compiler, intermIOperand, binaryDataType, binaryPrecision);
                slsLOPERAND_InitializeUsingIOperand(intermLOperand, intermIOperand);

                status = slGenAssignCode(Compiler,
                                         constVar->lineNo,
                                         constVar->stringNo,
                                         intermLOperand,
                                         constantROperand);

                status = sloCOMPILER_Allocate(Compiler,
                                              (gctSIZE_T)sizeof(slsLOGICAL_REG),
                                              &pointer);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG));

                constVar->context.logicalRegCount = 1;
                constVar->context.logicalRegs = pointer;
                slsLOGICAL_REG_InitializeTemp(constVar->context.logicalRegs,
                                              slvSTORAGE_QUALIFIER_NONE,
                                              binaryDataType,
                                              binaryPrecision,
                                              intermIOperand->tempRegIndex);
            }
        }
    }
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_CheckBindingForUniformAndBlock(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    slsNAME* name;

    if (!sloCOMPILER_IsES31VersionOrAbove(Compiler))
    {
        return status;
    }

    FOR_EACH_DLINK_NODE(&sloCOMPILER_GetGlobalSpace(Compiler)->names, slsNAME, name)
    {
        if ((slsDATA_TYPE_IsOpaque(name->dataType) ||
             slsDATA_TYPE_IsUnderlyingInterfaceBlock(name->dataType)) &&
            slmDATA_TYPE_layoutId_GET(name->dataType) & slvLAYOUT_BINDING)
        {
            gctINT maxSize = 0;
            gctINT layoutBinding = slmDATA_TYPE_layoutBinding_GET(name->dataType);

            if (slsDATA_TYPE_IsOpaque(name->dataType))
            {
                if (slsDATA_TYPE_IsImage(name->dataType))
                {
                    maxSize = (gctINT)GetGLMaxImageUnits();
                }
                else if (slsDATA_TYPE_IsSampler(name->dataType))
                {
                    maxSize = (gctINT)GetGLMaxCombinedTextureImageUnits();
                }
                else
                {
                    maxSize = (gctINT)GetGLMaxAtomicCounterBindings();
                }
            }
            else if (slsDATA_TYPE_IsUnderlyingUniformBlock(name->dataType))
            {
                maxSize = (gctINT)GetGLMaxUniformBufferBindings();
            }
            else
            {
                gcmASSERT(slsDATA_TYPE_IsUnderlyingStorageBlock(name->dataType));
                maxSize = (gctINT)GetGLMaxShaderStorageBufferBindings();
            }

            if ((layoutBinding + _GetLogicalCountForAnArray(name->dataType)) > maxSize)
            {
                gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                name->lineNo,
                                                name->stringNo,
                                                slvREPORT_ERROR,
                                                "binding value of \"%s\" exceed the maximum value %d.",
                                                name->symbol,
                                                maxSize));

                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }

            if (layoutBinding < 0)
            {
                gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                name->lineNo,
                                                name->stringNo,
                                                slvREPORT_ERROR,
                                                "binding value of \"%s\" is less than zero.",
                                                name->symbol));

                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }
        }
    }

    return status;
}

static gceSTATUS
_GenUniformAndUBO(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcePATCH_ID patchId = sloCOMPILER_GetPatchID(Compiler);
    slsNAME*name, *uniformBlock;
    gctBOOL genAllUniforms = (patchId == gcvPATCH_GTFES30) ? gcvTRUE : gcvFALSE;

    FOR_EACH_DLINK_NODE(&sloCOMPILER_GetGlobalSpace(Compiler)->names, slsNAME, name)
    {
        gctBOOL generated = gcvFALSE;
        gctBOOL isUniform = gcvFALSE;
        gctBOOL isUBO = gcvFALSE;

        /* Check if this variable is a uniform or UBO. */
        if (name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_UNIFORM)
        {
            isUniform = gcvTRUE;
        }
        else if (name->type == slvVARIABLE_NAME &&
                 name->u.variableInfo.interfaceBlock &&
                 name->u.variableInfo.interfaceBlock->dataType &&
                 slsDATA_TYPE_IsUnderlyingUniformBlock(name->u.variableInfo.interfaceBlock->dataType))
        {
            isUBO = gcvTRUE;
        }

        if (!isUniform && !isUBO)
        {
            continue;
        }

        /* Check if we need to generate this uniform/UBO. */
        if (genAllUniforms)
        {
            generated = gcvTRUE;
        }
        else if ((name->u.variableInfo.isReferenced || (name->dataType->qualifiers.layout.id & slvLAYOUT_LOCATION)))
        {
            generated = gcvTRUE;
        }
        else if (isUBO)
        {
            uniformBlock = name->u.variableInfo.interfaceBlock;
            if ((uniformBlock->dataType->qualifiers.layout.id & slvLAYOUT_SHARED) ||
                (uniformBlock->dataType->qualifiers.layout.id & slvLAYOUT_STD140))
            {
                generated = gcvTRUE;
            }
        }

        if (generated)
        {
            status = slsNAME_AllocLogicalRegs(Compiler, CodeGenerator, name);

            if (gcmIS_ERROR(status)) { return status; }
        }
    }

    return status;
}

static gceSTATUS
_GenFragmentOutputs(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    slsNAME* name;
    sleSHADER_TYPE shaderType = slvSHADER_TYPE_VERTEX;

    sloCOMPILER_GetShaderType(Compiler, &shaderType);

    if (shaderType != slvSHADER_TYPE_FRAGMENT)
    {
        return status;
    }

    FOR_EACH_DLINK_NODE(&sloCOMPILER_GetBuiltInSpace(Compiler)->names, slsNAME, name)
    {
        if (name->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_FRAGMENT_OUT &&
            name->type == slvVARIABLE_NAME &&
            name->u.variableInfo.isReferenced)
        {
            status = slsNAME_AllocLogicalRegs(Compiler, CodeGenerator, name);

            if (gcmIS_ERROR(status)) { return status; }
        }
    }

    return status;
}

static gctBOOL
_hasUniformType(
    IN gcUNIFORM Uniform
)
{
    if ((isUniformNormal(Uniform) ||
        isUniformBlockMember(Uniform) ||
        isUniformBlockAddress(Uniform) ||
        isUniformLodMinMax(Uniform) ||
        isUniformLevelBaseSize(Uniform)))
    {
        return gcvTRUE;
    }

    return gcvFALSE;
}

static gctBOOL
_isAtomicType(
    IN gcSHADER_TYPE Type
)
{
    if (Type == gcSHADER_ATOMIC_UINT)
    {
        return gcvTRUE;
    }

    return gcvFALSE;
}

/*
    Set the base addr uniform idx which is the smallest
    offset uniform's idx at the same binding to
    each atomic counter uniform.
*/
static gceSTATUS
_GenAtomicCounterBindingUniform(
    IN sloCOMPILER Compiler
    )
{
    typedef struct BindingBlock
    {
        gcUNIFORM        Uniform;
    } BindingBlock;

    gctUINT       i                    = 0;
    gctUINT       maxBindings          = 0;
    BindingBlock *bindingUniforms      = gcvNULL;
    gctPOINTER    pointer              = gcvNULL;
    gceSTATUS     status               = gcvSTATUS_OK;
    gcSHADER      shader               = gcvNULL;

    gcmHEADER_ARG("Compiler=0x%x", Compiler);

    gcmASSERT(Compiler);

    sloCOMPILER_GetBinary(Compiler, &shader);

    /* Walk all uniforms, find out the max number of bindings. */
    for (i = 0; i < shader->uniformCount; i++)
    {
        /* Get the gcUNIFORM pointer. */
        gcUNIFORM uniform = shader->uniforms[i];

        if (uniform == gcvNULL)
        {
            continue;
        }

        if (!_hasUniformType(uniform))
        {
            continue;
        }

        if (!_isAtomicType(uniform->u.type))
        {
            continue;
        }

        gcmASSERT(uniform->binding >= 0);

        if((gctUINT)uniform->binding + 1 > maxBindings)
        {
            maxBindings = uniform->binding + 1;
        }
    }

    if(maxBindings <= 0)
    {
        gcmFOOTER();
        return status;
    }

    status = gcoOS_Allocate(gcvNULL,
        sizeof(BindingBlock) * maxBindings,
        &pointer);

    if (status != gcvSTATUS_OK)
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    gcoOS_ZeroMemory(pointer,
        sizeof(BindingBlock) * maxBindings);

    bindingUniforms = (BindingBlock *)pointer;

    /* Walk all uniforms, find out the smallest offset uniform. */
    for (i = 0; i < shader->uniformCount; i++)
    {
        /* Get the gcUNIFORM pointer. */
        gcUNIFORM uniform = shader->uniforms[i];

        if (uniform == gcvNULL)
        {
            continue;
        }

        if (!_hasUniformType(uniform))
        {
            continue;
        }

        if (!_isAtomicType(uniform->u.type))
        {
            continue;
        }

        gcmASSERT(uniform->binding >= 0);

        if(bindingUniforms[uniform->binding].Uniform == gcvNULL)
        {
            bindingUniforms[uniform->binding].Uniform = uniform;
        }
        else if(bindingUniforms[uniform->binding].Uniform->offset > uniform->offset)
        {
            bindingUniforms[uniform->binding].Uniform = uniform;
        }

        {
            gctINT16  matrixStride;
            gctINT16  alignment;
            gctINT32  arrayStride;
            gctBOOL   isArray = isUniformArray(uniform);

            uniform->offset =  _GetDataTypeByteOffset(uniform->offset,
                                                    uniform->u.type,
                                                    gcvFALSE,
                                                    gcvINTERFACE_BLOCK_NONE,
                                                    isArray,
                                                    &matrixStride,
                                                    &arrayStride,
                                                    &alignment);

            uniform->arrayStride  = isArray ? arrayStride : 0;
            uniform->matrixStride = matrixStride;
        }
    }

    /* Walk all uniforms. Set baseBindingIdx. */
    for (i = 0; i < shader->uniformCount; i++)
    {
        /* Get the gcUNIFORM pointer. */
        gcUNIFORM uniform = shader->uniforms[i];

        if (uniform == gcvNULL)
        {
            continue;
        }

        if (!_hasUniformType(uniform))
        {
            continue;
        }

        if (!_isAtomicType(uniform->u.type))
        {
            continue;
        }

        gcmASSERT(uniform->binding >= 0);

        uniform->baseBindingIdx = bindingUniforms[uniform->binding].Uniform->index;
    }

    gcoOS_Free(gcvNULL, bindingUniforms);

    return status;
}

gceSTATUS
sloIR_SET_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_SET Set,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS                       status;
    gctBOOL                         isRoot;
    sloIR_BASE                      member;
    slsGEN_CODE_PARAMETERS          memberParameters;
    gctBOOL                         isLastCodeReturn = gcvFALSE;
    slsSPECIAL_STATEMENT_CONTEXT    specialStatementContext;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(Set, slvIR_SET);
    gcmASSERT(Parameters);

    switch (Set->type)
    {
    case slvDECL_SET:
        gcmVERIFY_OK(sloIR_SET_IsRoot(Compiler, Set, &isRoot));

        if (isRoot)
        {
            status = _CheckQualifier(Compiler);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = _CheckGS(Compiler);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Check the invalid of inputs/outputs for TS. */
            status = _CheckInputOutputForTS(Compiler);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Generate the vector constants which can potentially be shared */
            status = _GenVecConstants(Compiler,
                                      slvTYPE_FLOAT);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = _GenVecConstants(Compiler,
                                      slvTYPE_INT);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = _GenWorkGroupSize(Compiler, CodeGenerator);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = _GenInitSpecialVariables(Compiler, CodeGenerator);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = _CheckBindingForUniformAndBlock(Compiler, CodeGenerator);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = _GenUniformAndUBO(Compiler, CodeGenerator);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = _GenFragmentOutputs(Compiler, CodeGenerator);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = _GenAtomicCounterBindingUniform(Compiler);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            FOR_EACH_DLINK_NODE(&Set->members, struct _sloIR_BASE, member)
            {
                /* Generate the initalization code of all global variables */
                if (sloIR_OBJECT_GetType(member) == slvIR_BINARY_EXPR)
                {
                    slsGEN_CODE_PARAMETERS_Initialize(&memberParameters, gcvFALSE, gcvFALSE);

                    status = sloIR_OBJECT_Accept(
                                                Compiler,
                                                member,
                                                &CodeGenerator->visitor,
                                                &memberParameters);
                    slsGEN_CODE_PARAMETERS_Finalize(&memberParameters);
                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }

                if (sloCOMPILER_OptimizationEnabled(Compiler, slvOPTIMIZATION_SHARE_VEC_CONSTANTS))
                {
                    /* Generate the initalization code of all global constant variables */
                    if (sloIR_OBJECT_GetType(member) == slvIR_CONSTANT)
                    {
                        sloIR_CONSTANT constant = (sloIR_CONSTANT)member;

                        if (constant->variable && !constant->variable->isBuiltIn)
                        {
                            slsGEN_CODE_PARAMETERS_Initialize(&memberParameters, gcvFALSE, gcvTRUE);

                            status = sloIR_OBJECT_Accept(Compiler,
                                                         member,
                                                         &CodeGenerator->visitor,
                                                         &memberParameters);
                            slsGEN_CODE_PARAMETERS_Finalize(&memberParameters);
                            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                        }
                    }
                }
            }
        }

        FOR_EACH_DLINK_NODE(&Set->members, struct _sloIR_BASE, member)
        {
            if (!isRoot || sloIR_OBJECT_GetType(member) != slvIR_BINARY_EXPR)
            {
                slsGEN_CODE_PARAMETERS_Initialize(&memberParameters, gcvFALSE, gcvFALSE);

                status = sloIR_OBJECT_Accept(
                                            Compiler,
                                            member,
                                            &CodeGenerator->visitor,
                                            &memberParameters);
                slsGEN_CODE_PARAMETERS_Finalize(&memberParameters);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
        }
        break;

    case slvSTATEMENT_SET:
        /* Allocate all constant variables within this SET. */
        if (sloCOMPILER_OptimizationEnabled(Compiler, slvOPTIMIZATION_SHARE_VEC_CONSTANTS))
        {
            FOR_EACH_DLINK_NODE(&Set->members, struct _sloIR_BASE, member)
            {
                if (sloIR_OBJECT_GetType(member) == slvIR_CONSTANT)
                {
                    sloIR_CONSTANT constant = (sloIR_CONSTANT)member;

                    if (constant->variable && !constant->variable->isBuiltIn)
                    {
                        slsGEN_CODE_PARAMETERS_Initialize(&memberParameters, gcvFALSE, gcvTRUE);

                        status = sloIR_OBJECT_Accept(Compiler,
                                                     member,
                                                     &CodeGenerator->visitor,
                                                     &memberParameters);
                        slsGEN_CODE_PARAMETERS_Finalize(&memberParameters);
                        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                    }
                }
            }
        }

        if (Set->funcName != gcvNULL)
        {
            status = _DefineFuncBegin(Compiler, CodeGenerator, Set);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            isLastCodeReturn = gcvFALSE;
        }

        slsSPECIAL_STATEMENT_CONTEXT_Initialize(&specialStatementContext);

        FOR_EACH_DLINK_NODE(&Set->members, struct _sloIR_BASE, member)
        {
            if (Set->funcName != gcvNULL)
            {
                if (sloIR_BASE_HasReturn(Compiler, member))
                {
                    isLastCodeReturn = gcvTRUE;
                }
                else
                {
                    isLastCodeReturn = gcvFALSE;
                }
            }

            if (sloCOMPILER_OptimizationEnabled(Compiler, slvOPTIMIZATION_SPECIAL))
            {
                status = sloIR_SET_TryToGenSpecialStatementCode(
                                                                Compiler,
                                                                CodeGenerator,
                                                                Set,
                                                                member,
                                                                &specialStatementContext);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                if (specialStatementContext.codeGenerated) continue;
            }

            slsGEN_CODE_PARAMETERS_Initialize(&memberParameters, gcvFALSE, gcvFALSE);

            status = sloIR_OBJECT_Accept(
                                        Compiler,
                                        member,
                                        &CodeGenerator->visitor,
                                        &memberParameters);

            slsGEN_CODE_PARAMETERS_Finalize(&memberParameters);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }

        if (Set->funcName != gcvNULL)
        {
            status = _DefineFuncEnd(Compiler, CodeGenerator, Set, isLastCodeReturn);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        break;

    case slvEXPR_SET:
        gcmASSERT(0);
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenDefineUnrolledIterationBegin(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * LoopIndexName,
    IN gctBOOL OnlyDoTheCheck,
    OUT slsITERATION_CONTEXT * CurrentIterationContext
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(LoopIndexName);
    gcmASSERT(CurrentIterationContext);

    CurrentIterationContext->prevContext                    = CodeGenerator->currentIterationContext;
    CodeGenerator->currentIterationContext                  = CurrentIterationContext;

    CurrentIterationContext->isUnrolled                     = gcvTRUE;

    CurrentIterationContext->u.unrolledInfo.loopIndexName   = LoopIndexName;

    if (!OnlyDoTheCheck)
    {
        CurrentIterationContext->endLabel                   = slNewLabel(Compiler);
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slGenDefineUnrolledIterationEnd(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN gctBOOL OnlyDoTheCheck
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);

    gcmASSERT(CodeGenerator->currentIterationContext);
    gcmASSERT(CodeGenerator->currentIterationContext->isUnrolled);

    if (!OnlyDoTheCheck)
    {
        status = slSetLabel(Compiler,
                            0,
                            0,
                            CodeGenerator->currentIterationContext->endLabel);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    CodeGenerator->currentIterationContext = CodeGenerator->currentIterationContext->prevContext;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_DefineUnrolledIterationBodyBegin(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sluCONSTANT_VALUE LoopIndexValue
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);

    gcmASSERT(CodeGenerator->currentIterationContext);
    gcmASSERT(CodeGenerator->currentIterationContext->isUnrolled);

    CodeGenerator->currentIterationContext->u.unrolledInfo.loopIndexValue   = LoopIndexValue;
    CodeGenerator->currentIterationContext->u.unrolledInfo.bodyEndLabel     = slNewLabel(Compiler);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_DefineUnrolledIterationBodyEnd(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);

    gcmASSERT(CodeGenerator->currentIterationContext);
    gcmASSERT(CodeGenerator->currentIterationContext->isUnrolled);

    status = slSetLabel(
                        Compiler,
                        0,
                        0,
                        CodeGenerator->currentIterationContext->u.unrolledInfo.bodyEndLabel);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_CloneIterationContextForSwitch(
IN sloCOMPILER Compiler,
IN sloCODE_GENERATOR CodeGenerator,
OUT slsITERATION_CONTEXT * CurrentIterationContext
)
{
   gcmHEADER();
/* Verify the arguments. */
   slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
   slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
   gcmASSERT(CurrentIterationContext);

   if(CodeGenerator->currentIterationContext) {
       *CurrentIterationContext = *CodeGenerator->currentIterationContext;
   }
   else {
       gcoOS_ZeroMemory(CurrentIterationContext, gcmSIZEOF(slsITERATION_CONTEXT));
   }
   /* When clone iteration context for a switch, we need to set this context is rolled. */
   CurrentIterationContext->isUnrolled      = gcvFALSE;
   CurrentIterationContext->prevContext     = CodeGenerator->currentIterationContext;
   CodeGenerator->currentIterationContext   = CurrentIterationContext;

   CurrentIterationContext->endLabel = slNewLabel(Compiler);

   gcmFOOTER_NO();
   return gcvSTATUS_OK;
}

static gceSTATUS
_DefineIterationBegin(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN gctBOOL IsTestFirst,
    IN gctBOOL HasRestExpr,
    OUT slsITERATION_CONTEXT * CurrentIterationContext
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(CurrentIterationContext);

    CurrentIterationContext->prevContext    = CodeGenerator->currentIterationContext;
    CodeGenerator->currentIterationContext  = CurrentIterationContext;

    CurrentIterationContext->isUnrolled     = gcvFALSE;

    CurrentIterationContext->u.genericInfo.isTestFirst      = IsTestFirst;
    CurrentIterationContext->u.genericInfo.hasRestExpr      = HasRestExpr;
    CurrentIterationContext->u.genericInfo.loopBeginLabel   = slNewLabel(Compiler);

    if (HasRestExpr)
    {
        CurrentIterationContext->u.genericInfo.restBeginLabel = slNewLabel(Compiler);
    }

    CurrentIterationContext->endLabel       = slNewLabel(Compiler);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_DefineIterationEnd(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);

    gcmASSERT(CodeGenerator->currentIterationContext);
    gcmASSERT(!CodeGenerator->currentIterationContext->isUnrolled);

    status = slSetLabel(
                        Compiler,
                        0,
                        0,
                        CodeGenerator->currentIterationContext->endLabel);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    CodeGenerator->currentIterationContext = CodeGenerator->currentIterationContext->prevContext;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

#define _DefineSwitchEnd(Compiler, CodeGen)  _DefineIterationEnd(Compiler, CodeGen)

static gceSTATUS
_DefineIterationRestExprBegin(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);

    gcmASSERT(CodeGenerator->currentIterationContext);
    gcmASSERT(!CodeGenerator->currentIterationContext->isUnrolled);
    gcmASSERT(CodeGenerator->currentIterationContext->u.genericInfo.hasRestExpr);

    status = slSetLabel(
                        Compiler,
                        0,
                        0,
                        CodeGenerator->currentIterationContext->u.genericInfo.restBeginLabel);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}


static gceSTATUS
_DefineIterationBodyBegin(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);

    gcmASSERT(CodeGenerator->currentIterationContext);
    gcmASSERT(!CodeGenerator->currentIterationContext->isUnrolled);

    if (!CodeGenerator->currentIterationContext->u.genericInfo.hasRestExpr)
    {
        status = slSetLabel(
                            Compiler,
                            0,
                            0,
                            CodeGenerator->currentIterationContext->u.genericInfo.loopBeginLabel);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_DefineIterationBodyEnd(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);

    gcmASSERT(CodeGenerator->currentIterationContext);
    gcmASSERT(!CodeGenerator->currentIterationContext->isUnrolled);

    if (CodeGenerator->currentIterationContext->u.genericInfo.isTestFirst)
    {
        status = slEmitAlwaysBranchCode(
                                        Compiler,
                                        0,
                                        0,
                                        slvOPCODE_JUMP,
                                        CodeGenerator->currentIterationContext->
                                            u.genericInfo.loopBeginLabel);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gctLABEL
_GetIterationContinueLabel(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gctLABEL theLabel;

    gcmHEADER();
    /* Verify the arguments. */
    slmASSERT_OBJECT(Compiler, slvOBJ_COMPILER);
    slmASSERT_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);

    gcmASSERT(CodeGenerator->currentIterationContext);

    if (CodeGenerator->currentIterationContext->isUnrolled)
    {
        theLabel = CodeGenerator->currentIterationContext->u.unrolledInfo.bodyEndLabel;
    }
    else
    {
        if (CodeGenerator->currentIterationContext->u.genericInfo.hasRestExpr)
        {
            theLabel = CodeGenerator->currentIterationContext->u.genericInfo.restBeginLabel;
        }
        else {
            theLabel = CodeGenerator->currentIterationContext->u.genericInfo.loopBeginLabel;
        }
    }
    gcmFOOTER_NO();
    return theLabel;
}

static gctLABEL
_GetIterationEndLabel(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmASSERT_OBJECT(Compiler, slvOBJ_COMPILER);
    slmASSERT_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);

    gcmASSERT(CodeGenerator->currentIterationContext);

    gcmFOOTER_NO();
    return CodeGenerator->currentIterationContext->endLabel;
}

static gctBOOL
_IsUnrolledLoopIndexRecursively(
    IN sloCOMPILER Compiler,
    IN slsITERATION_CONTEXT * IterationContext,
    IN slsNAME * Name,
    OUT sluCONSTANT_VALUE * UnrolledLoopIndexValue
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IterationContext);
    gcmASSERT(Name);
    gcmASSERT(UnrolledLoopIndexValue);

    if (IterationContext->isUnrolled && Name == IterationContext->u.unrolledInfo.loopIndexName)
    {
        *UnrolledLoopIndexValue = IterationContext->u.unrolledInfo.loopIndexValue;
        gcmFOOTER_NO();
        return gcvTRUE;
    }

    if (IterationContext->prevContext == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvFALSE;
    }
    else
    {
        gcmFOOTER_NO();
        return _IsUnrolledLoopIndexRecursively(
                                            Compiler,
                                            IterationContext->prevContext,
                                            Name,
                                            UnrolledLoopIndexValue);
    }
}

static gctBOOL
_IsUnrolledLoopIndex(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * Name,
    OUT sluCONSTANT_VALUE * UnrolledLoopIndexValue
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    gcmASSERT(Name);
    gcmASSERT(UnrolledLoopIndexValue);

    if (CodeGenerator->currentIterationContext == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvFALSE;
    }

    gcmFOOTER_NO();
    return _IsUnrolledLoopIndexRecursively(
                                        Compiler,
                                        CodeGenerator->currentIterationContext,
                                        Name,
                                        UnrolledLoopIndexValue);
}

typedef struct _slsITERATION_UNROLL_INFO
{
    gctBOOL             unrollable;

    slsNAME *           loopIndexName;

    sleCONDITION        condition;

    sluCONSTANT_VALUE   conditionConstantValue;

    sluCONSTANT_VALUE   initialConstantValue;

    sluCONSTANT_VALUE   incrementConstantValue;

    gctUINT             loopCount;
}
slsITERATION_UNROLL_INFO;

static gceSTATUS
_CheckAsUnrollableCondition(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN slsNAME_SPACE * ForSpace,
    OUT slsITERATION_UNROLL_INFO * IterationUnrollInfo
    )
{
    gceSTATUS               status;
    sloIR_CONSTANT          conditionConstant   = gcvNULL;
    slsGEN_CODE_PARAMETERS  conditionParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(ForSpace);
    gcmASSERT(IterationUnrollInfo);

    do
    {
        /* Check the loop index */
        if (sloIR_OBJECT_GetType(&BinaryExpr->leftOperand->base) != slvIR_VARIABLE) break;

        IterationUnrollInfo->loopIndexName = ((sloIR_VARIABLE)BinaryExpr->leftOperand)->name;

        if (IterationUnrollInfo->loopIndexName->mySpace != ForSpace) break;

        if (!slsDATA_TYPE_IsInt(IterationUnrollInfo->loopIndexName->dataType)
            && !slsDATA_TYPE_IsFloat(IterationUnrollInfo->loopIndexName->dataType))
        {
            break;
        }

        if (!IterationUnrollInfo->loopIndexName->u.variableInfo.isCanUsedAsUnRollLoopIndex)
        {
            break;
        }

        /* Check the relation operator */
        switch (BinaryExpr->type)
        {
        case slvBINARY_GREATER_THAN:
            IterationUnrollInfo->condition = slvCONDITION_GREATER_THAN;
            break;

        case slvBINARY_LESS_THAN:
            IterationUnrollInfo->condition = slvCONDITION_LESS_THAN;
            break;

        case slvBINARY_GREATER_THAN_EQUAL:
            IterationUnrollInfo->condition = slvCONDITION_GREATER_THAN_EQUAL;
            break;

        case slvBINARY_LESS_THAN_EQUAL:
            IterationUnrollInfo->condition = slvCONDITION_LESS_THAN_EQUAL;
            break;

        case slvBINARY_EQUAL:
            IterationUnrollInfo->condition = slvCONDITION_EQUAL;
            break;

        case slvBINARY_NOT_EQUAL:
            IterationUnrollInfo->condition = slvCONDITION_NOT_EQUAL;
            break;

        default:
            gcmASSERT(0);
            IterationUnrollInfo->condition = slvCONDITION_INVALID;
        }

        if (IterationUnrollInfo->condition == slvCONDITION_INVALID) break;

        /* Try to evaluate the condition operand */
        gcmASSERT(BinaryExpr->rightOperand);

        slsGEN_CODE_PARAMETERS_Initialize(
                                        &conditionParameters,
                                        gcvFALSE,
                                        gcvTRUE);

        conditionParameters.hint = slvEVALUATE_ONLY;

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    &BinaryExpr->rightOperand->base,
                                    &CodeGenerator->visitor,
                                    &conditionParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        conditionConstant               = conditionParameters.constant;
        conditionParameters.constant    = gcvNULL;

        slsGEN_CODE_PARAMETERS_Finalize(&conditionParameters);

        if (conditionConstant == gcvNULL) break;

        if (!slsDATA_TYPE_IsInt(conditionConstant->exprBase.dataType)
            && !slsDATA_TYPE_IsFloat(conditionConstant->exprBase.dataType))
        {
            break;
        }

        IterationUnrollInfo->conditionConstantValue = conditionConstant->values[0];

        /* OK */
        IterationUnrollInfo->unrollable = gcvTRUE;

        gcmVERIFY_OK(sloIR_OBJECT_Destroy(Compiler, &conditionConstant->exprBase.base));

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    IterationUnrollInfo->unrollable = gcvFALSE;

    if (conditionConstant != gcvNULL)
    {
        gcmVERIFY_OK(sloIR_OBJECT_Destroy(Compiler, &conditionConstant->exprBase.base));
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_CheckAsUnrollableInitializer(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsITERATION_UNROLL_INFO * IterationUnrollInfo
    )
{
    gceSTATUS               status;
    sloIR_CONSTANT          initialConstant = gcvNULL;
    slsGEN_CODE_PARAMETERS  initialParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(IterationUnrollInfo);

    do
    {
        /* Check the loop index */
        if (sloIR_OBJECT_GetType(&BinaryExpr->leftOperand->base) != slvIR_VARIABLE) break;

        if (((sloIR_VARIABLE)BinaryExpr->leftOperand)->name != IterationUnrollInfo->loopIndexName)
        {
            break;
        }

        /* Check the relation operator */
        if (BinaryExpr->type != slvBINARY_ASSIGN) break;

        /* Try to evaluate the initial operand */
        gcmASSERT(BinaryExpr->rightOperand);

        slsGEN_CODE_PARAMETERS_Initialize(
                                        &initialParameters,
                                        gcvFALSE,
                                        gcvTRUE);

        initialParameters.hint = slvEVALUATE_ONLY;

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    &BinaryExpr->rightOperand->base,
                                    &CodeGenerator->visitor,
                                    &initialParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        initialConstant             = initialParameters.constant;
        initialParameters.constant  = gcvNULL;

        slsGEN_CODE_PARAMETERS_Finalize(&initialParameters);

        if (initialConstant == gcvNULL) break;

        if (!slsDATA_TYPE_IsInt(initialConstant->exprBase.dataType)
            && !slsDATA_TYPE_IsFloat(initialConstant->exprBase.dataType))
        {
            break;
        }

        IterationUnrollInfo->initialConstantValue = initialConstant->values[0];

        /* OK */
        IterationUnrollInfo->unrollable = gcvTRUE;

        gcmVERIFY_OK(sloIR_OBJECT_Destroy(Compiler, &initialConstant->exprBase.base));

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    IterationUnrollInfo->unrollable = gcvFALSE;

    if (initialConstant != gcvNULL)
    {
        gcmVERIFY_OK(sloIR_OBJECT_Destroy(Compiler, &initialConstant->exprBase.base));
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_CheckAsUnrollableRestExpr1(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_UNARY_EXPR UnaryExpr,
    IN OUT slsITERATION_UNROLL_INFO * IterationUnrollInfo
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_IR_OBJECT(UnaryExpr, slvIR_UNARY_EXPR);
    gcmASSERT(IterationUnrollInfo);

    do
    {
        /* Check the loop index */
        if (sloIR_OBJECT_GetType(&UnaryExpr->operand->base) != slvIR_VARIABLE) break;

        if (((sloIR_VARIABLE)&UnaryExpr->operand->base)->name != IterationUnrollInfo->loopIndexName)
        {
            break;
        }

        /* Check the relation operator */
        if (UnaryExpr->type == slvUNARY_POST_INC || UnaryExpr->type == slvUNARY_PRE_INC)
        {
            if (slsDATA_TYPE_IsInt(IterationUnrollInfo->loopIndexName->dataType))
            {
                IterationUnrollInfo->incrementConstantValue.intValue = 1;
            }
            else
            {
                gcmASSERT(slsDATA_TYPE_IsFloat(IterationUnrollInfo->loopIndexName->dataType));

                IterationUnrollInfo->incrementConstantValue.floatValue = (gctFLOAT)1.0;
            }
        }
        else if (UnaryExpr->type == slvUNARY_POST_DEC || UnaryExpr->type == slvUNARY_PRE_DEC)
        {
            if (slsDATA_TYPE_IsInt(IterationUnrollInfo->loopIndexName->dataType))
            {
                IterationUnrollInfo->incrementConstantValue.intValue = -1;
            }
            else
            {
                gcmASSERT(slsDATA_TYPE_IsFloat(IterationUnrollInfo->loopIndexName->dataType));

                IterationUnrollInfo->incrementConstantValue.floatValue = (gctFLOAT)-1.0;
            }
        }
        else
        {
            break;
        }

        /* OK */
        IterationUnrollInfo->unrollable = gcvTRUE;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    IterationUnrollInfo->unrollable = gcvFALSE;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_CheckAsUnrollableRestExpr2(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsITERATION_UNROLL_INFO * IterationUnrollInfo
    )
{
    gceSTATUS               status;
    sloIR_CONSTANT          incrementConstant   = gcvNULL;
    slsGEN_CODE_PARAMETERS  incrementParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(IterationUnrollInfo);

    do
    {
        /* Check the loop index */
        if (sloIR_OBJECT_GetType(&BinaryExpr->leftOperand->base) != slvIR_VARIABLE) break;

        if (((sloIR_VARIABLE)BinaryExpr->leftOperand)->name != IterationUnrollInfo->loopIndexName)
        {
            break;
        }

        /* Try to evaluate the increment operand */
        gcmASSERT(BinaryExpr->rightOperand);

        slsGEN_CODE_PARAMETERS_Initialize(
                                        &incrementParameters,
                                        gcvFALSE,
                                        gcvTRUE);

        incrementParameters.hint = slvEVALUATE_ONLY;

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    &BinaryExpr->rightOperand->base,
                                    &CodeGenerator->visitor,
                                    &incrementParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        incrementConstant               = incrementParameters.constant;
        incrementParameters.constant    = gcvNULL;

        slsGEN_CODE_PARAMETERS_Finalize(&incrementParameters);

        if (incrementConstant == gcvNULL) break;

        if (!slsDATA_TYPE_IsInt(incrementConstant->exprBase.dataType)
            && !slsDATA_TYPE_IsFloat(incrementConstant->exprBase.dataType))
        {
            break;
        }

        IterationUnrollInfo->incrementConstantValue = incrementConstant->values[0];

        /* Check the operator */
        if (BinaryExpr->type == slvBINARY_ADD_ASSIGN)
        {
            /* Nothing to do */
        }
        else if (BinaryExpr->type == slvBINARY_SUB_ASSIGN)
        {
            if (slsDATA_TYPE_IsInt(IterationUnrollInfo->loopIndexName->dataType))
            {
                IterationUnrollInfo->incrementConstantValue.intValue =
                        -IterationUnrollInfo->incrementConstantValue.intValue;
            }
            else
            {
                gcmASSERT(slsDATA_TYPE_IsFloat(IterationUnrollInfo->loopIndexName->dataType));

                IterationUnrollInfo->incrementConstantValue.floatValue =
                        -IterationUnrollInfo->incrementConstantValue.floatValue;
            }
        }
        else
        {
            break;
        }

        /* OK */
        IterationUnrollInfo->unrollable = gcvTRUE;

        gcmVERIFY_OK(sloIR_OBJECT_Destroy(Compiler, &incrementConstant->exprBase.base));

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    IterationUnrollInfo->unrollable = gcvFALSE;

    if (incrementConstant != gcvNULL)
    {
        gcmVERIFY_OK(sloIR_OBJECT_Destroy(Compiler, &incrementConstant->exprBase.base));
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

#define __MAX_UNROLL_ITERATION_COUNT__      10
#define __MAX_ATOMIC_OPERATION_COUNT__      20

static gceSTATUS
_CheckIterationCount(
    IN gcePATCH_ID PatchId,
    IN OUT slsITERATION_UNROLL_INFO * IterationUnrollInfo
    )
{
    gctUINT             i;
    sluCONSTANT_VALUE   loopIndexValue;
    gctBOOL             loopTestResult = gcvFALSE;

    gcmHEADER();

    loopIndexValue = IterationUnrollInfo->initialConstantValue;

    for (i = 0; gcvTRUE; i++)
    {
        /* Use the condition */
        if (slsDATA_TYPE_IsInt(IterationUnrollInfo->loopIndexName->dataType))
        {
            switch (IterationUnrollInfo->condition)
            {
            case slvCONDITION_EQUAL:
                loopTestResult = (loopIndexValue.intValue
                                    == IterationUnrollInfo->conditionConstantValue.intValue);
                break;

            case slvCONDITION_NOT_EQUAL:
                loopTestResult = (loopIndexValue.intValue
                                    != IterationUnrollInfo->conditionConstantValue.intValue);
                break;

            case slvCONDITION_LESS_THAN:
                loopTestResult = (loopIndexValue.intValue
                                    < IterationUnrollInfo->conditionConstantValue.intValue);
                break;

            case slvCONDITION_LESS_THAN_EQUAL:
                loopTestResult = (loopIndexValue.intValue
                                    <= IterationUnrollInfo->conditionConstantValue.intValue);
                break;

            case slvCONDITION_GREATER_THAN:
                loopTestResult = (loopIndexValue.intValue
                                    > IterationUnrollInfo->conditionConstantValue.intValue);
                break;

            case slvCONDITION_GREATER_THAN_EQUAL:
                loopTestResult = (loopIndexValue.intValue
                                    >= IterationUnrollInfo->conditionConstantValue.intValue);
                break;

            default:
                gcmASSERT(0);
            }
        }
        else
        {
            gcmASSERT(slsDATA_TYPE_IsFloat(IterationUnrollInfo->loopIndexName->dataType));

            switch (IterationUnrollInfo->condition)
            {
            case slvCONDITION_EQUAL:
                loopTestResult = (loopIndexValue.floatValue
                                    == IterationUnrollInfo->conditionConstantValue.floatValue);
                break;

            case slvCONDITION_NOT_EQUAL:
                loopTestResult = (loopIndexValue.floatValue
                                    != IterationUnrollInfo->conditionConstantValue.floatValue);
                break;

            case slvCONDITION_LESS_THAN:
                loopTestResult = (loopIndexValue.floatValue
                                    < IterationUnrollInfo->conditionConstantValue.floatValue);
                break;

            case slvCONDITION_LESS_THAN_EQUAL:
                loopTestResult = (loopIndexValue.floatValue
                                    <= IterationUnrollInfo->conditionConstantValue.floatValue);
                break;

            case slvCONDITION_GREATER_THAN:
                loopTestResult = (loopIndexValue.floatValue
                                    > IterationUnrollInfo->conditionConstantValue.floatValue);
                break;

            case slvCONDITION_GREATER_THAN_EQUAL:
                loopTestResult = (loopIndexValue.floatValue
                                    >= IterationUnrollInfo->conditionConstantValue.floatValue);
                break;

            default:
                gcmASSERT(0);
            }
        }

        if (!loopTestResult) break;

        /* Check the count */
        if (i >= __MAX_UNROLL_ITERATION_COUNT__ &&
            PatchId != gcvPATCH_GTFES30)
        {
            IterationUnrollInfo->unrollable = gcvFALSE;

            gcmFOOTER_NO();
            return gcvSTATUS_OK;
        }

        /* Use the increment */
        if (slsDATA_TYPE_IsInt(IterationUnrollInfo->loopIndexName->dataType))
        {
            loopIndexValue.intValue += IterationUnrollInfo->incrementConstantValue.intValue;
        }
        else
        {
            gcmASSERT(slsDATA_TYPE_IsFloat(IterationUnrollInfo->loopIndexName->dataType));

            loopIndexValue.floatValue += IterationUnrollInfo->incrementConstantValue.floatValue;
        }
    }

    /* OK */
    IterationUnrollInfo->loopCount  = i;

    IterationUnrollInfo->unrollable = gcvTRUE;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_ITERATION_GenUnrolledCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_ITERATION Iteration,
    IN slsITERATION_UNROLL_INFO * IterationUnrollInfo,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    gctUINT                 i;
    slsGEN_CODE_PARAMETERS  loopBodyParameters;
    slsITERATION_CONTEXT    iterationContext;
    sluCONSTANT_VALUE       unrolledLoopIndexValue;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Iteration, slvIR_ITERATION);
    gcmASSERT(IterationUnrollInfo);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand && !Parameters->needROperand);

    if (Iteration->loopBody == gcvNULL) { gcmFOOTER_NO(); return gcvSTATUS_OK; }

    status = slGenDefineUnrolledIterationBegin(Compiler,
                                               CodeGenerator,
                                               IterationUnrollInfo->loopIndexName,
                                               gcvFALSE,
                                               &iterationContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    unrolledLoopIndexValue  = IterationUnrollInfo->initialConstantValue;

    for (i = 0; i < IterationUnrollInfo->loopCount; i++)
    {
        status = _DefineUnrolledIterationBodyBegin(
                                                Compiler,
                                                CodeGenerator,
                                                unrolledLoopIndexValue);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Generate the code of the loop body */
        slsGEN_CODE_PARAMETERS_Initialize(&loopBodyParameters, gcvFALSE, gcvFALSE);

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    Iteration->loopBody,
                                    &CodeGenerator->visitor,
                                    &loopBodyParameters);

        slsGEN_CODE_PARAMETERS_Finalize(&loopBodyParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        status = _DefineUnrolledIterationBodyEnd(
                                                Compiler,
                                                CodeGenerator);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Use the increment */
        if (slsDATA_TYPE_IsInt(IterationUnrollInfo->loopIndexName->dataType))
        {
            unrolledLoopIndexValue.intValue +=
                    IterationUnrollInfo->incrementConstantValue.intValue;
        }
        else
        {
            gcmASSERT(slsDATA_TYPE_IsFloat(IterationUnrollInfo->loopIndexName->dataType));

            unrolledLoopIndexValue.floatValue +=
                    IterationUnrollInfo->incrementConstantValue.floatValue;
        }
    }

    status = slGenDefineUnrolledIterationEnd(Compiler,
                                             CodeGenerator,
                                             gcvFALSE);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gctBOOL
_CanUnRoll(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_ITERATION Iteration,
    IN gcePATCH_ID PatchID,
    IN gctINT LoopCount,
    IN gctINT * CurrentIterationCount,
    IN gctINT * PrevIterationCount
    )
{
    gctBOOL unRoll = gcvTRUE;
    gctINT prevIterationCount = -1, currentIterationCount = -1;

    /* Save current iteration count. */
    sloCOMPILER_GetCurrentIterationCount(Compiler, &prevIterationCount);

    /* Calculate current iteration count. */
    /* A WAR for CTS30: we don't calculate the previous iteration count. */
    if (PatchID == gcvPATCH_GTFES30)
    {
        currentIterationCount = LoopCount;
    }
    else
    {
        currentIterationCount = prevIterationCount * LoopCount;
    }

    if (currentIterationCount > __MAX_UNROLL_ITERATION_COUNT__)
    {
        unRoll = gcvFALSE;
    }

    /*
    ** A WAR for dEQP:
    ** If there are too many atomic-related operations inside this iteration, don't unroll it.
    ** Fix random hang for "dEQP-GLES31.functional.atomic_counter.layout".
    */
    if (PatchID == gcvPATCH_DEQP)
    {
        if (Iteration->atomicOpCount > __MAX_ATOMIC_OPERATION_COUNT__)
        {
            unRoll = gcvFALSE;
        }
    }

    if (CurrentIterationCount)
    {
        *CurrentIterationCount = currentIterationCount;
    }

    if (PrevIterationCount)
    {
        *PrevIterationCount = prevIterationCount;
    }

    return unRoll;
}

gceSTATUS
sloIR_ITERATION_TryToGenUnrolledCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_ITERATION Iteration,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters,
    OUT gctBOOL * IsUnrolled
    )
{
    gceSTATUS                   status = gcvSTATUS_OK;
    slsITERATION_UNROLL_INFO    iterationUnrollInfo;
    gcePATCH_ID                 patchId = sloCOMPILER_GetPatchID(Compiler);
    gctINT                      prevIterationCount = -1, currentIterationCount = -1;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Iteration, slvIR_ITERATION);
    gcmASSERT(Parameters);
    gcmASSERT(IsUnrolled);

    do
    {
        if (Iteration->type != slvFOR) break;

        gcmASSERT(Iteration->forSpace);

        /* Check the condition part */
        if (Iteration->condExpr == gcvNULL
            || sloIR_OBJECT_GetType(&Iteration->condExpr->base) != slvIR_BINARY_EXPR) break;

        status = _CheckAsUnrollableCondition(Compiler,
                                             CodeGenerator,
                                             (sloIR_BINARY_EXPR)Iteration->condExpr,
                                             Iteration->forSpace,
                                             &iterationUnrollInfo);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (!iterationUnrollInfo.unrollable) break;

        /* Check the initial part */
        if (Iteration->forInitStatement == gcvNULL
            || sloIR_OBJECT_GetType(Iteration->forInitStatement) != slvIR_BINARY_EXPR) break;

        status = _CheckAsUnrollableInitializer(Compiler,
                                               CodeGenerator,
                                               (sloIR_BINARY_EXPR)Iteration->forInitStatement,
                                               &iterationUnrollInfo);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (!iterationUnrollInfo.unrollable) break;

        /* Check the rest part */
        if (Iteration->forRestExpr == gcvNULL) break;

        if (sloIR_OBJECT_GetType(&Iteration->forRestExpr->base) == slvIR_UNARY_EXPR)
        {
            status = _CheckAsUnrollableRestExpr1(Compiler,
                                                 CodeGenerator,
                                                 (sloIR_UNARY_EXPR)Iteration->forRestExpr,
                                                 &iterationUnrollInfo);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            if (!iterationUnrollInfo.unrollable) break;
        }
        else if (sloIR_OBJECT_GetType(&Iteration->forRestExpr->base) == slvIR_BINARY_EXPR)
        {
            status = _CheckAsUnrollableRestExpr2(Compiler,
                                                 CodeGenerator,
                                                 (sloIR_BINARY_EXPR)Iteration->forRestExpr,
                                                 &iterationUnrollInfo);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            if (!iterationUnrollInfo.unrollable) break;
        }
        else
        {
            break;
        }

        /* Check the iteration count */
        status = _CheckIterationCount(patchId, &iterationUnrollInfo);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (!iterationUnrollInfo.unrollable) break;

        /* Check if we can unroll this. */
        if (!_CanUnRoll(Compiler,
                        CodeGenerator,
                        Iteration,
                        patchId,
                        (gctINT)iterationUnrollInfo.loopCount,
                        &currentIterationCount,
                        &prevIterationCount))
        {
            break;
        }

        status = sloCOMPILER_SetCurrentIterationCount(Compiler, currentIterationCount);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Generate the unrolled code */
        status = sloIR_ITERATION_GenUnrolledCode(Compiler,
                                                 CodeGenerator,
                                                 Iteration,
                                                 &iterationUnrollInfo,
                                                 Parameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Reset current iteration count. */
        status = sloCOMPILER_SetCurrentIterationCount(Compiler, prevIterationCount);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* OK */
        *IsUnrolled = gcvTRUE;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    *IsUnrolled = gcvFALSE;

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_ITERATION_GenForCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_ITERATION Iteration,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsITERATION_CONTEXT    iterationContext;
    slsGEN_CODE_PARAMETERS  initParameters, restParameters, bodyParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Iteration, slvIR_ITERATION);
    gcmASSERT(Parameters);
    gcmASSERT(Iteration->type == slvFOR);

    /********************************************************/
    /*                                                      */
    /*  for (initStmt; condExpr; restExpr)                  */
    /*     loopBody                                         */
    /*                                                      */
    /*  generate code:                                      */
    /*                                                      */
    /*     initStmt                                         */
    /*     JMP L1 if (!condExpr)                            */
    /*  L2:                                                 */
    /*     loopBody                                         */
    /*  L3:                     // continue jumps to here   */
    /*     restExpr                                         */
    /*     JMP L2 if (condExpr)                             */
    /*  L1:                                                 */
    /*                                                      */
    /********************************************************/


    /* The init part */
    if (Iteration->forInitStatement != gcvNULL)
    {
        slsGEN_CODE_PARAMETERS_Initialize(&initParameters, gcvFALSE, gcvFALSE);

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    Iteration->forInitStatement,
                                    &CodeGenerator->visitor,
                                    &initParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsGEN_CODE_PARAMETERS_Finalize(&initParameters);
    }

    status = _DefineIterationBegin(
                                Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                (Iteration->forRestExpr != gcvNULL),
                                &iterationContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* The condition part: jump to loopend if the condExpr is not true
       JMP L1 if (!condExpr)    */
    if (Iteration->condExpr != gcvNULL)
    {
        status = _GenConditionCode(
                                Compiler,
                                CodeGenerator,
                                Iteration->condExpr,
                                _GetIterationEndLabel(Compiler, CodeGenerator),
                                gcvFALSE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    /* The loop body: body begin label */
    status = slSetLabel(
                        Compiler,
                        0,
                        0,
                        CodeGenerator->currentIterationContext->u.genericInfo.loopBeginLabel);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    /* The body part */
    if (Iteration->loopBody != gcvNULL)
    {
        slsGEN_CODE_PARAMETERS_Initialize(&bodyParameters, gcvFALSE, gcvFALSE);

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    Iteration->loopBody,
                                    &CodeGenerator->visitor,
                                    &bodyParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsGEN_CODE_PARAMETERS_Finalize(&bodyParameters);
    }

    /* The rest part */
    if (Iteration->forRestExpr != gcvNULL)
    {
        status = _DefineIterationRestExprBegin(Compiler, CodeGenerator);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsGEN_CODE_PARAMETERS_Initialize(&restParameters, gcvFALSE, gcvFALSE);

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    &Iteration->forRestExpr->base,
                                    &CodeGenerator->visitor,
                                    &restParameters);
        slsGEN_CODE_PARAMETERS_Finalize(&restParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    /* The condition part: jump to loop begin if the exprCond is true
        JMP L2 if (condExpr)   */
    if (Iteration->condExpr != gcvNULL)
    {
        status = _GenConditionCode(
                                Compiler,
                                CodeGenerator,
                                Iteration->condExpr,
                                CodeGenerator->currentIterationContext->
                                            u.genericInfo.loopBeginLabel,
                                gcvTRUE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        /* For the infinite for loop, 'for(;;)', we still need an unconditional branch to begin */
        status = slEmitAlwaysBranchCode(
                                        Compiler,
                                        0,
                                        0,
                                        slvOPCODE_JUMP,
                                        CodeGenerator->currentIterationContext->
                                            u.genericInfo.loopBeginLabel);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    status = _DefineIterationEnd(
                                Compiler,
                                CodeGenerator);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_ITERATION_GenWhileCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_ITERATION Iteration,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsITERATION_CONTEXT    iterationContext;
    slsGEN_CODE_PARAMETERS  bodyParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Iteration, slvIR_ITERATION);
    gcmASSERT(Parameters);
    gcmASSERT(Iteration->type == slvWHILE);

    status = _DefineIterationBegin(
                                Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                gcvFALSE,
                                &iterationContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* The loop body */
    status = _DefineIterationBodyBegin(Compiler, CodeGenerator);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* The condition part */
    if (Iteration->condExpr != gcvNULL)
    {
        status = _GenConditionCode(
                                Compiler,
                                CodeGenerator,
                                Iteration->condExpr,
                                _GetIterationEndLabel(Compiler, CodeGenerator),
                                gcvFALSE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    if (Iteration->loopBody != gcvNULL)
    {
        slsGEN_CODE_PARAMETERS_Initialize(&bodyParameters, gcvFALSE, gcvFALSE);

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    Iteration->loopBody,
                                    &CodeGenerator->visitor,
                                    &bodyParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsGEN_CODE_PARAMETERS_Finalize(&bodyParameters);
    }

    status = _DefineIterationBodyEnd(Compiler, CodeGenerator);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = _DefineIterationEnd(
                                Compiler,
                                CodeGenerator);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_ITERATION_GenDoWhileCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_ITERATION Iteration,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsITERATION_CONTEXT    iterationContext;
    slsGEN_CODE_PARAMETERS  bodyParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Iteration, slvIR_ITERATION);
    gcmASSERT(Parameters);
    gcmASSERT(Iteration->type == slvDO_WHILE);

    status = _DefineIterationBegin(
                                Compiler,
                                CodeGenerator,
                                gcvFALSE,
                                gcvTRUE, /* Set HasRestExpr to TRUE because we need to */
                                         /* reuse this to correctly codegen 'continue' */
                                &iterationContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* do-while must have a loop begin label */
    status = slSetLabel(
                        Compiler,
                        0,
                        0,
                        CodeGenerator->currentIterationContext->u.genericInfo.loopBeginLabel);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* The loop body */
    if (Iteration->loopBody != gcvNULL)
    {
        slsGEN_CODE_PARAMETERS_Initialize(&bodyParameters, gcvFALSE, gcvFALSE);

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    Iteration->loopBody,
                                    &CodeGenerator->visitor,
                                    &bodyParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsGEN_CODE_PARAMETERS_Finalize(&bodyParameters);
    }

    /* Always look condition expression of do-while as rest of loop, so continue statement will branch to it. */
    /* This will not introduce redundant jumps or other side-effects since do-while naturally needs condition */
    /* judgement at the end of loop */
    status = slSetLabel(
                        Compiler,
                        0,
                        0,
                        CodeGenerator->currentIterationContext->u.genericInfo.restBeginLabel);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* The condition part */
    if (Iteration->condExpr != gcvNULL)
    {
        status = _GenConditionCode(
                                Compiler,
                                CodeGenerator,
                                Iteration->condExpr,
                                CodeGenerator->currentIterationContext->
                                            u.genericInfo.loopBeginLabel,
                                gcvTRUE);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    status = _DefineIterationEnd(
                                Compiler,
                                CodeGenerator);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_ITERATION_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_ITERATION Iteration,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS   status;
    gctBOOL     isUnrolled = gcvFALSE;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Iteration, slvIR_ITERATION);
    gcmASSERT(Parameters);

    if (sloCOMPILER_OptimizationEnabled(Compiler, slvOPTIMIZATION_UNROLL_ITERATION))
    {
        status = sloIR_ITERATION_TryToGenUnrolledCode(
                                                    Compiler,
                                                    CodeGenerator,
                                                    Iteration,
                                                    Parameters,
                                                    &isUnrolled);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    if (isUnrolled)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    switch (Iteration->type)
    {
    case slvFOR:
        status = sloIR_ITERATION_GenForCode(
                                        Compiler,
                                        CodeGenerator,
                                        Iteration,
                                        Parameters);
            break;

    case slvWHILE:
        status = sloIR_ITERATION_GenWhileCode(
                                            Compiler,
                                            CodeGenerator,
                                            Iteration,
                                            Parameters);
            break;

    case slvDO_WHILE:
        status = sloIR_ITERATION_GenDoWhileCode(
                                            Compiler,
                                            CodeGenerator,
                                            Iteration,
                                            Parameters);
            break;

    default:
        gcmASSERT(0);
        status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_JUMP_GenContinueCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_JUMP Jump,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Jump, slvIR_JUMP);
    gcmASSERT(Jump->type == slvCONTINUE);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand && !Parameters->needROperand);

    if (CodeGenerator->currentIterationContext == gcvNULL)
    {
        gcmVERIFY_OK(sloCOMPILER_Report(
                                    Compiler,
                                    Jump->base.lineNo,
                                    Jump->base.stringNo,
                                    slvREPORT_ERROR,
                                    "'continue' is only allowed within loops"));

        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    status = slEmitAlwaysBranchCode(
                                    Compiler,
                                    Jump->base.lineNo,
                                    Jump->base.stringNo,
                                    slvOPCODE_JUMP,
                                    _GetIterationContinueLabel(Compiler, CodeGenerator));

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_JUMP_GenBreakCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_JUMP Jump,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Jump, slvIR_JUMP);
    gcmASSERT(Jump->type == slvBREAK);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand && !Parameters->needROperand);

    if (CodeGenerator->currentIterationContext == gcvNULL)
    {
        gcmVERIFY_OK(sloCOMPILER_Report(
                                    Compiler,
                                    Jump->base.lineNo,
                                    Jump->base.stringNo,
                                    slvREPORT_ERROR,
                                    "'break' is only allowed within loops"));

        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    status = slEmitAlwaysBranchCode(
                                    Compiler,
                                    Jump->base.lineNo,
                                    Jump->base.stringNo,
                                    slvOPCODE_JUMP,
                                    _GetIterationEndLabel(Compiler, CodeGenerator));

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_JUMP_GenReturnCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_JUMP Jump,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsNAME *               funcName;
    slsGEN_CODE_PARAMETERS  returnExprParameters;
    gctUINT                 i;
    slsLOPERAND             lOperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Jump, slvIR_JUMP);
    gcmASSERT(Jump->type == slvRETURN);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand && !Parameters->needROperand);

    if (CodeGenerator->currentFuncDefContext.isMain)
    {
        if (Jump->returnExpr != gcvNULL)
        {
            gcmVERIFY_OK(sloCOMPILER_Report(
                                            Compiler,
                                            Jump->base.lineNo,
                                            Jump->base.stringNo,
                                            slvREPORT_ERROR,
                                            "'main' function returning a value"));

            gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }

        status = slEmitAlwaysBranchCode(
                                        Compiler,
                                        Jump->base.lineNo,
                                        Jump->base.stringNo,
                                        slvOPCODE_JUMP,
                                        CodeGenerator->currentFuncDefContext.u.mainEndLabel);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        funcName = CodeGenerator->currentFuncDefContext.u.funcBody->funcName;
        gcmASSERT(funcName);

        if (slsDATA_TYPE_IsVoid(funcName->dataType))
        {
            if (Jump->returnExpr != gcvNULL)
            {
                gcmVERIFY_OK(sloCOMPILER_Report(
                                                Compiler,
                                                Jump->base.lineNo,
                                                Jump->base.stringNo,
                                                slvREPORT_ERROR,
                                                "'void' function: '%s' returning a value",
                                                funcName->symbol));

                gcmFOOTER_ARG("sttus=%s", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }
        }
        else if (Jump->returnExpr == gcvNULL)
        {
            /*
            ** If the return type is not void,
            ** any return statements within the function definition must include a return-expression and the type of the
            ** expression must match the return type
            */
            gcmVERIFY_OK(sloCOMPILER_Report(
                                            Compiler,
                                            Jump->base.lineNo,
                                            Jump->base.stringNo,
                                            slvREPORT_ERROR,
                                            "non-void function: '%s' should return a value",
                                            funcName->symbol));
            gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
            return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        }
        else
        {
            if (!slsDATA_TYPE_IsEqual(funcName->dataType, Jump->returnExpr->dataType))
            {
                gcmVERIFY_OK(sloCOMPILER_Report(
                                                Compiler,
                                                Jump->base.lineNo,
                                                Jump->base.stringNo,
                                                slvREPORT_ERROR,
                                                "require the same typed return expression"));

                gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }

            /* Generate the code of the return expression */
            slsGEN_CODE_PARAMETERS_Initialize(
                                            &returnExprParameters,
                                            gcvFALSE,
                                            gcvTRUE);

            status = sloIR_OBJECT_Accept(
                                        Compiler,
                                        &Jump->returnExpr->base,
                                        &CodeGenerator->visitor,
                                        &returnExprParameters);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Generate the assign code */
            gcmASSERT(returnExprParameters.operandCount == funcName->context.logicalRegCount);
            gcmASSERT(funcName->context.logicalRegs);

            for (i = 0; i < returnExprParameters.operandCount; i++)
            {
                slsLOPERAND_Initialize(&lOperand,
                                       funcName->context.logicalRegs + i);

                status = slGenAssignCode(
                                        Compiler,
                                        Jump->base.lineNo,
                                        Jump->base.stringNo,
                                        &lOperand,
                                        returnExprParameters.rOperands + i);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }

            slsGEN_CODE_PARAMETERS_Finalize(&returnExprParameters);
        }

        status = slEmitAlwaysBranchCode(
                                        Compiler,
                                        Jump->base.lineNo,
                                        Jump->base.stringNo,
                                        slvOPCODE_RETURN,
                                        0);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_JUMP_GenDiscardCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_JUMP Jump,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Jump, slvIR_JUMP);
    gcmASSERT(Jump->type == slvDISCARD);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand && !Parameters->needROperand);

    status = slEmitAlwaysBranchCode(
                                    Compiler,
                                    Jump->base.lineNo,
                                    Jump->base.stringNo,
                                    slvOPCODE_DISCARD,
                                    0);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_JUMP_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_JUMP Jump,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Jump, slvIR_JUMP);
    gcmASSERT(Parameters);

    switch (Jump->type)
    {
    case slvCONTINUE:
        status = sloIR_JUMP_GenContinueCode(
                                        Compiler,
                                        CodeGenerator,
                                        Jump,
                                        Parameters);
        break;

    case slvBREAK:
        status = sloIR_JUMP_GenBreakCode(
                                    Compiler,
                                    CodeGenerator,
                                    Jump,
                                    Parameters);
        break;

    case slvRETURN:
        status = sloIR_JUMP_GenReturnCode(
                                        Compiler,
                                        CodeGenerator,
                                        Jump,
                                        Parameters);
        break;

    case slvDISCARD:
        status = sloIR_JUMP_GenDiscardCode(
                                        Compiler,
                                        CodeGenerator,
                                        Jump,
                                        Parameters);
        break;

    default:
        gcmASSERT(0);
        status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_LABEL_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_LABEL Label,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
   gceSTATUS status;

   gcmHEADER();

/* Verify the arguments. */
   slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
   slmVERIFY_IR_OBJECT(Label, slvIR_LABEL);
   gcmASSERT(Parameters);
   gcmASSERT(!Parameters->needLOperand && !Parameters->needROperand);

   switch(Label->type) {
   case slvCASE:
   case slvDEFAULT:
      gcmASSERT(Label->programCounter);
      status = slSetLabel(Compiler,
                          Label->base.lineNo,
                          Label->base.stringNo,
                          Label->programCounter);
      if (gcmIS_ERROR(status)) {
          gcmFOOTER();
          return status;
      }
      break;

   default:
      gcmASSERT(0);
      gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
      return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
   }

   gcmFOOTER_NO();
   return gcvSTATUS_OK;
}

gceSTATUS
sloIR_VARIABLE_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_VARIABLE Variable,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS           status;
    gctUINT             i;
    sluCONSTANT_VALUE   unrolledLoopIndexValue;
    slsDATA_TYPE *      dataType;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Variable, slvIR_VARIABLE);
    gcmASSERT(Parameters);

    gcmASSERT(Variable->name);

    if (!Parameters->needLOperand && !Parameters->needROperand)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    /* Check if it is the unrolled loop index */
    if (_IsUnrolledLoopIndex(
                            Compiler,
                            CodeGenerator,
                            Variable->name,
                            &unrolledLoopIndexValue))
    {
        gcmASSERT(!Parameters->needLOperand);

        if (Parameters->hint == slvEVALUATE_ONLY)
        {
            gctINT type;

            if (slsDATA_TYPE_IsInt(Variable->exprBase.dataType))
            {
                if (Variable->exprBase.dataType->elementType == slvTYPE_INT)
                {
                    type = T_INT;
                }
                else
                {
                    type = T_UINT;
                }
            }
            else
            {
                type = T_FLOAT;
            }
            /* Create the data type */
            status = sloCOMPILER_CreateDataType(
                                                Compiler,
                                                type,
                                                gcvNULL,
                                                &dataType);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            dataType->qualifiers.storage = slvSTORAGE_QUALIFIER_CONST;

            /* Create the constant */
            status = sloIR_CONSTANT_Construct(
                                            Compiler,
                                            Variable->exprBase.base.lineNo,
                                            Variable->exprBase.base.stringNo,
                                            dataType,
                                            &Parameters->constant);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Add the constant value */
            status = sloIR_CONSTANT_AddValues(
                                            Compiler,
                                            Parameters->constant,
                                            1,
                                            &unrolledLoopIndexValue);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else
        {
            /* Allocate the operands */
            status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                            Compiler,
                                                            Parameters,
                                                            Variable->exprBase.dataType);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            gcmASSERT(Parameters->operandCount == 1);

            slsROPERAND_InitializeConstant(&Parameters->rOperands[0],
                                           Parameters->dataTypes[0],
                                           gcSHADER_PRECISION_MEDIUM,
                                           1,
                                           &unrolledLoopIndexValue);
        }
    }
    else
    {
        if (Parameters->hint == slvEVALUATE_ONLY)
        {
            gcmFOOTER_NO();
            return gcvSTATUS_OK;
        }

        /* Allocate all logical registers */
        status = slsNAME_AllocLogicalRegs(
                                        Compiler,
                                        CodeGenerator,
                                        Variable->name);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsNAME_SetStaticallyUsed(Compiler,
                                  Variable->name,
                                  Variable->name->context.logicalRegs,
                                  Variable->name->context.logicalRegCount);
        /* Allocate the operands */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        Variable->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (Parameters->needLOperand)
        {
            for (i = 0; i < Parameters->operandCount; i++)
            {
                slsLOPERAND_Initialize(Parameters->lOperands + i,
                                       Variable->name->context.logicalRegs + i);
            }
        }

        if (Parameters->needROperand)
        {
            for (i = 0; i < Parameters->operandCount; i++)
            {
                slsROPERAND_InitializeReg(
                                        Parameters->rOperands + i,
                                        Variable->name->context.logicalRegs + i);
            }
        }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_SetOperandConstants(
    IN sloCOMPILER Compiler,
    IN slsDATA_TYPE * DataType,
    IN sluCONSTANT_VALUE * Values,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters,
    IN OUT gctUINT * ValueStart,
    IN OUT gctUINT * Start
    )
{
    gceSTATUS       status;
    gctUINT         count, i;
    slsNAME *       fieldName;
    gcSHADER_TYPE   binaryDataType;
    gcSHADER_PRECISION binaryPrecision;
    gctUINT         componentCount;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(DataType);
    gcmASSERT(Values);
    gcmASSERT(Parameters);
    gcmASSERT(ValueStart);
    gcmASSERT(Start);

    count = _GetLogicalCountForAnArray(DataType);

    for (i = 0; i < count; i++)
    {
        if (DataType->elementType == slvTYPE_STRUCT)
        {
            gcmASSERT(DataType->fieldSpace);

            FOR_EACH_DLINK_NODE(&DataType->fieldSpace->names, slsNAME, fieldName)
            {
                gcmASSERT(fieldName->dataType);

                status = _SetOperandConstants(
                                        Compiler,
                                        fieldName->dataType,
                                        Values,
                                        Parameters,
                                        ValueStart,
                                        Start);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
        }
        else
        {
            binaryDataType  = _ConvElementDataType(DataType);
            binaryPrecision = _ConvElementDataPrecision(DataType);
            componentCount  = gcGetDataTypeComponentCount(binaryDataType);

            slsROPERAND_InitializeConstant(Parameters->rOperands + *Start,
                                           binaryDataType,
                                           binaryPrecision,
                                           componentCount,
                                           Values + *ValueStart);

            (*Start)++;
            (*ValueStart) += componentCount;
        }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenVariableForConstant(
    IN sloCOMPILER Compiler,
    IN sloIR_CONSTANT Constant,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status = gcvSTATUS_OK;
    gctPOINTER              pointer = gcvNULL;
    gctUINT                 i, logicalRegCount = 0;
    slsDATA_TYPE            *dataType = 0;
    slsLOGICAL_REG          *logicalRegs;
    gctUINT8                componentCount;
    gctUINT32               binaryDataTypeSize;
    gcSHADER_TYPE           logicalDataType, binaryDataType;
    gcSHADER_PRECISION      binaryPrecision;
    sluCONSTANT_VALUE       *values;
    slsROPERAND             constantROperand[1];
    slsIOPERAND             intermIOperand[1];
    slsLOPERAND             intermLOperand[1];
    gctSTRING               symbol = gcvNULL;
    gctSIZE_T               length;

    dataType = Constant->variable->dataType;
    logicalRegCount = _GetLogicalOperandCount(dataType, gcvFALSE);
    logicalRegs = Constant->variable->context.logicalRegs;

    if (logicalRegs != gcvNULL)
    {
        for (i = 0; i < logicalRegCount; i++)
        {
            slsROPERAND_InitializeReg(Parameters->rOperands + i,
                                      logicalRegs + i);

        }
        return status;
    }

    /* Get datatype and precision. */
    logicalDataType = _ConvElementDataType(dataType);
    binaryDataTypeSize  = gcGetDataTypeSize(logicalDataType);
    if (dataType->matrixSize.columnCount > 0)
    {
        binaryDataType = gcGetMatrixColumnDataType(logicalDataType);
    }
    else
    {
        binaryDataType = logicalDataType;
    }
    binaryPrecision = _ConvElementDataPrecision(dataType);

    /* Allocate logical regs. */
    status = sloCOMPILER_Allocate(Compiler,
                                    gcmSIZEOF(slsLOGICAL_REG) * logicalRegCount,
                                    &pointer);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcoOS_ZeroMemory(pointer, gcmSIZEOF(slsLOGICAL_REG) * logicalRegCount);
    logicalRegs = (slsLOGICAL_REG *)pointer;

    /* Assign constants to temp regs. */
    values = Constant->values;
    componentCount = gcGetDataTypeComponentCount(binaryDataType);
    for (i = 0; i < logicalRegCount * binaryDataTypeSize; i++)
    {
        slsROPERAND_InitializeConstant(constantROperand,
                                       binaryDataType,
                                       binaryPrecision,
                                       componentCount,
                                       values);
        slsIOPERAND_New(Compiler, intermIOperand, binaryDataType, binaryPrecision);
        slsLOPERAND_InitializeUsingIOperand(intermLOperand, intermIOperand);

        status = slGenAssignCode(Compiler,
                                 Constant->exprBase.base.lineNo,
                                 Constant->exprBase.base.stringNo,
                                 intermLOperand,
                                 constantROperand);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (i % binaryDataTypeSize == 0)
        {
            slsLOGICAL_REG_InitializeTemp(logicalRegs,
                                          slvSTORAGE_QUALIFIER_NONE,
                                          logicalDataType,
                                          binaryPrecision,
                                          intermIOperand->tempRegIndex);

            slsROPERAND_InitializeTempReg(Parameters->rOperands + i / binaryDataTypeSize,
                                          slvSTORAGE_QUALIFIER_NONE,
                                          logicalDataType,
                                          binaryPrecision,
                                          intermIOperand->tempRegIndex);
            logicalRegs++;
        }
        /* Move to next element. */
        values += componentCount;
    }

    Constant->variable->context.logicalRegCount = logicalRegCount;
    Constant->variable->context.logicalRegs = (slsLOGICAL_REG *)pointer;

    Parameters->constantVariable = Constant->variable;

    /* Generate the variable. */
    gcoOS_StrLen(Constant->variable->symbol, &length);
    length += 8;
    status = sloCOMPILER_Allocate(Compiler,
                                  length,
                                  &pointer);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    symbol = (gctSTRING)pointer;

    status = gcoOS_StrCopySafe(symbol, length, "#const_");
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = gcoOS_StrCatSafe(symbol, length, Constant->variable->symbol);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slmNewVariable(Compiler,
                   Constant->variable->lineNo,
                   Constant->variable->stringNo,
                   symbol,
                   _ConvElementDataType(dataType),
                   binaryPrecision,
                   dataType->arrayLengthCount,
                   dataType->arrayLengthList,
                   gcvTRUE,
                   gcvFALSE,
                   gcvFALSE,
                   dataType->isPerVertexArray,
                   Constant->variable->context.logicalRegs[0].regIndex,
                   gcSHADER_VAR_CATEGORY_NORMAL,
                   0,
                   -1,
                   -1,
                   gcvNULL,
                   status);
    sloCOMPILER_Free(Compiler, symbol);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    return status;
}

gceSTATUS
sloIR_CONSTANT_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_CONSTANT Constant,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(Constant, slvIR_CONSTANT);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    if (!Parameters->needROperand)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    if (Parameters->hint == slvEVALUATE_ONLY)
    {
        status = sloIR_CONSTANT_Clone(Compiler,
                                      Constant->exprBase.base.lineNo,
                                      Constant->exprBase.base.stringNo,
                                      Constant,
                                      &Parameters->constant);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    status = slsGEN_CODE_PARAMETERS_AllocateOperands(Compiler,
                                                     Parameters,
                                                     Constant->exprBase.dataType);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Constant->variable &&
        Constant->variable->dataType->elementType != slvTYPE_STRUCT &&
        !slsDATA_TYPE_IsScalar(Constant->variable->dataType))
    {
        status = _GenVariableForConstant(Compiler,
                                         Constant,
                                         Parameters);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    else
    {
        gctUINT     valueStart = 0, start = 0;

        status = _SetOperandConstants(Compiler,
                                      Constant->exprBase.dataType,
                                      Constant->values,
                                      Parameters,
                                      &valueStart,
                                      &start);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        gcmASSERT(valueStart == Constant->valueCount);
        gcmASSERT(start == Parameters->operandCount);

        /* pass along the variable if the constant is associated with a variable */
        if (Constant->variable)
        {
            gcmASSERT(Parameters->constant == gcvNULL);
            Parameters->constantVariable = Constant->variable;
        }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
_ConvertVecToAuxiScalarArray(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsROPERAND * VecOperand,
    IN slsNAME * scalarArrayName
    )
{
    gceSTATUS                   status;
    slsGEN_CODE_PARAMETERS      intermParameters;
    slsIOPERAND                 intermIOperand;
    slsLOPERAND                 intermLOperand;
    slsROPERAND                 intermROperand;
    slsDATA_TYPE                *scalarDataType;
    gcSHADER_TYPE               binaryDataType;
    gcSHADER_PRECISION          binaryPrecision;
    gctSIZE_T                   binaryDataTypeSize;
    gctUINT                     logicalRegCount;
    gctREG_INDEX                tempRegIndex;
    slsCOMPONENT_SELECTION        compSel;
    gctUINT                     i;

    gcmHEADER();

    binaryDataType      = scalarArrayName->context.logicalRegs->dataType;
    binaryPrecision     = scalarArrayName->context.logicalRegs->precision;
    binaryDataTypeSize  = gcGetDataTypeSize(binaryDataType);
    logicalRegCount = scalarArrayName->context.logicalRegCount;
    tempRegIndex = scalarArrayName->context.logicalRegs->regIndex;

    status = sloCOMPILER_CloneDataType(Compiler,
                                slvSTORAGE_QUALIFIER_NONE,
                                scalarArrayName->dataType->qualifiers.precision,
                                scalarArrayName->dataType,
                                &scalarDataType);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    scalarDataType->arrayLength = 0;

    for (i = 0; i < logicalRegCount; i++)
    {
        slsGEN_CODE_PARAMETERS_Initialize(
                                        &intermParameters,
                                        gcvFALSE,
                                        gcvTRUE);

        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                    Compiler,
                                                    &intermParameters,
                                                    scalarDataType);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (i == 0)
            compSel = ComponentSelection_X;
        else if (i == 1)
            compSel = ComponentSelection_Y;
        else if (i == 2)
            compSel = ComponentSelection_Z;
        else if (i == 3)
            compSel = ComponentSelection_W;
        else
        {
            gcmASSERT(gcvFALSE);
            gcmFOOTER();
            return status;
        }

        slsIOPERAND_Initialize(&intermIOperand, binaryDataType, binaryPrecision, tempRegIndex + (gctREG_INDEX)(i * binaryDataTypeSize));
        slsLOPERAND_InitializeUsingIOperand(&intermLOperand, &intermIOperand);

        status = sloIR_ROperandComponentSelect(
                                               Compiler,
                                               VecOperand,
                                               compSel,
                                               &intermParameters.rOperands[0]);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        intermROperand = intermParameters.rOperands[0];

        status = slGenAssignCode(
                                Compiler,
                                0,
                                0,
                                &intermLOperand,
                                &intermROperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsGEN_CODE_PARAMETERS_Finalize(&intermParameters);
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
_ConvertMatrixToAuxiVecArray(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsROPERAND * MatrixOperand,
    IN slsNAME * vecArrayName,
    IN slsDATA_TYPE * MatrixDataType
    )
{
    gceSTATUS                   status;
    slsIOPERAND                 intermIOperand;
    slsLOPERAND                 intermLOperand;
    gcSHADER_TYPE               binaryDataType, orgDataType = MatrixOperand->dataType;
    gcSHADER_PRECISION          binaryPrecision;
    gctSIZE_T                   binaryDataTypeSize;
    gctUINT                     logicalRegCount;
    gctREG_INDEX                tempRegIndex;
    slsINDEX                    orgMatrixIndex = MatrixOperand->matrixIndex;
    gctUINT                     i;

    gcmHEADER();

    binaryDataType      = vecArrayName->context.logicalRegs->dataType;
    binaryPrecision     = vecArrayName->context.logicalRegs->precision;
    binaryDataTypeSize  = gcGetDataTypeSize(binaryDataType);
    logicalRegCount = vecArrayName->context.logicalRegCount;
    tempRegIndex = vecArrayName->context.logicalRegs->regIndex;

    for (i = 0; i < logicalRegCount; i++)
    {
        slsIOPERAND_Initialize(&intermIOperand, binaryDataType, binaryPrecision, tempRegIndex + (gctREG_INDEX)(i * binaryDataTypeSize));
        slsLOPERAND_InitializeUsingIOperand(&intermLOperand, &intermIOperand);

        MatrixOperand->dataType = binaryDataType;
        MatrixOperand->matrixIndex.mode = slvINDEX_CONSTANT;
        MatrixOperand->matrixIndex.u.constant = i;
        status = slGenAssignCode(
                                Compiler,
                                0,
                                0,
                                &intermLOperand,
                                MatrixOperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    MatrixOperand->dataType = orgDataType;
    MatrixOperand->matrixIndex = orgMatrixIndex;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
_ConvertAuxiScalarArrayToMat(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * scalarArrayName,
    IN slsLOPERAND * MatOperand
    )
{
    gceSTATUS                   status = gcvSTATUS_OK;
    slsIOPERAND                 intermIOperand;
    slsROPERAND                 intermROperand;
    gctUINT                     i, logicalRegCount;
    slsDATA_TYPE                *scalarDataType;
    gcSHADER_TYPE               binaryDataType, orgMatDataType = MatOperand->dataType;
    gcSHADER_PRECISION          binaryPrecision;
    gctSIZE_T                   binaryDataTypeSize;
    gctREG_INDEX                tempRegIndex;
    slsINDEX                    orgMatIndex = MatOperand->matrixIndex;

    binaryDataType      = scalarArrayName->context.logicalRegs->dataType;
    binaryPrecision     = scalarArrayName->context.logicalRegs->precision;
    binaryDataTypeSize  = gcGetDataTypeSize(binaryDataType);
    logicalRegCount = scalarArrayName->context.logicalRegCount;
    tempRegIndex = scalarArrayName->context.logicalRegs->regIndex;

    gcmASSERT(gcGetMatrixDataTypeColumnCount(MatOperand->dataType) == logicalRegCount);

    status = sloCOMPILER_CloneDataType(Compiler,
                                       slvSTORAGE_QUALIFIER_NONE,
                                       scalarArrayName->dataType->qualifiers.precision,
                                       scalarArrayName->dataType,
                                       &scalarDataType);
    if (gcmIS_ERROR(status)) { return status; }
    scalarDataType->arrayLength = 0;

    for (i = 0; i < logicalRegCount; i++)
    {
        slsIOPERAND_Initialize(&intermIOperand, binaryDataType, binaryPrecision, tempRegIndex + (gctREG_INDEX)(i * binaryDataTypeSize));
        slsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);

        MatOperand->dataType = binaryDataType;
        MatOperand->matrixIndex.mode = slvINDEX_CONSTANT;
        MatOperand->matrixIndex.u.constant = i;

        status = slGenAssignCode(
                                Compiler,
                                0,
                                0,
                                MatOperand,
                                &intermROperand);

        if (gcmIS_ERROR(status)) {  return status; }
    }

    MatOperand->dataType = orgMatDataType;
    MatOperand->matrixIndex = orgMatIndex;

    return status;
}

gceSTATUS
_ConvertAuxiScalarArrayToVec(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME * scalarArrayName,
    IN slsLOPERAND * VecOperand
    )
{
    gceSTATUS                   status;
    slsGEN_CODE_PARAMETERS      intermParameters;
    slsIOPERAND                 intermIOperand;
    slsLOPERAND                 intermLOperand;
    slsROPERAND                 intermROperand;
    slsDATA_TYPE                *scalarDataType;
    gcSHADER_TYPE               binaryDataType;
    gcSHADER_PRECISION          binaryPrecision;
    gctSIZE_T                   binaryDataTypeSize;
    gctUINT                     logicalRegCount;
    gctREG_INDEX                tempRegIndex;
    slsCOMPONENT_SELECTION      compSel;
    gctUINT                     i;

    gcmHEADER();

    /* It is from a matrix operand. */
    if (gcGetDataTypeSize(VecOperand->dataType) > 1)
    {
        status = _ConvertAuxiScalarArrayToMat(Compiler,
                                              CodeGenerator,
                                              scalarArrayName,
                                              VecOperand);
        gcmFOOTER();
        return status;
    }

    binaryDataType      = scalarArrayName->context.logicalRegs->dataType;
    binaryPrecision     = scalarArrayName->context.logicalRegs->precision;
    binaryDataTypeSize  = gcGetDataTypeSize(binaryDataType);
    logicalRegCount = scalarArrayName->context.logicalRegCount;
    tempRegIndex = scalarArrayName->context.logicalRegs->regIndex;

    status = sloCOMPILER_CloneDataType(Compiler,
                                slvSTORAGE_QUALIFIER_NONE,
                                scalarArrayName->dataType->qualifiers.precision,
                                scalarArrayName->dataType,
                                &scalarDataType);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    scalarDataType->arrayLength = 0;

    for (i = 0; i < logicalRegCount; i++)
    {
        slsGEN_CODE_PARAMETERS_Initialize(
                                        &intermParameters,
                                        gcvTRUE,
                                        gcvFALSE);

        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                    Compiler,
                                                    &intermParameters,
                                                    scalarDataType);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (i == 0)
            compSel = ComponentSelection_X;
        else if (i == 1)
            compSel = ComponentSelection_Y;
        else if (i == 2)
            compSel = ComponentSelection_Z;
        else if (i == 3)
            compSel = ComponentSelection_W;
        else
        {
            gcmASSERT(gcvFALSE);
            gcmFOOTER();
            return status;
        }

        slsIOPERAND_Initialize(&intermIOperand, binaryDataType, binaryPrecision, tempRegIndex + (gctREG_INDEX)(i * binaryDataTypeSize));
        slsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);

        status = sloIR_LOperandComponentSelect(
                                               Compiler,
                                               VecOperand,
                                               compSel,
                                               &intermParameters.lOperands[0]);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        intermLOperand = intermParameters.lOperands[0];

        status = slGenAssignCode(
                                Compiler,
                                0,
                                0,
                                &intermLOperand,
                                &intermROperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsGEN_CODE_PARAMETERS_Finalize(&intermParameters);
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
_ConvertAuxiScalarArray(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr
    )
{
    gceSTATUS                   status = gcvSTATUS_OK;

    gcmHEADER();
    if ((BinaryExpr->leftOperand->base.vptr->type == slvIR_BINARY_EXPR) &&
        (((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.vec2Array ||
         ((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.mat2Array))
    {
        if (((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.vec2Array)
        {
            status = _ConvertAuxiScalarArrayToVec(Compiler,
                                                  CodeGenerator,
                                                  ((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.vec2Array->scalarArrayName,
                                                  &((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.vec2Array->vecOperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = sloCOMPILER_Free(Compiler,
                                      ((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.vec2Array);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            ((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.vec2Array = gcvNULL;
        }
        if (((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.mat2Array)
        {
            status = _ConvertAuxiScalarArrayToVec(Compiler,
                                                  CodeGenerator,
                                                  ((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.mat2Array->scalarArrayName,
                                                  &((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.mat2Array->vecOperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = sloCOMPILER_Free(Compiler,
                                      ((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.mat2Array);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            ((sloIR_BINARY_EXPR)(BinaryExpr->leftOperand))->u.mat2Array = gcvNULL;
        }

        status = _ConvertAuxiScalarArray(Compiler,
                                         CodeGenerator,
                                         (sloIR_BINARY_EXPR)(BinaryExpr->leftOperand));
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    if ((BinaryExpr->rightOperand->base.vptr->type == slvIR_BINARY_EXPR) &&
        (((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.vec2Array ||
         ((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.mat2Array))
    {
        if (((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.vec2Array)
        {
            status = _ConvertAuxiScalarArrayToVec(Compiler,
                                                  CodeGenerator,
                                                  ((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.vec2Array->scalarArrayName,
                                                  &((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.vec2Array->vecOperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = sloCOMPILER_Free(Compiler,
                                      ((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.vec2Array);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            ((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.vec2Array = gcvNULL;
        }
        if (((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.mat2Array)
        {
            status = _ConvertAuxiScalarArrayToVec(Compiler,
                                                  CodeGenerator,
                                                  ((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.mat2Array->scalarArrayName,
                                                  &((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.mat2Array->vecOperand);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = sloCOMPILER_Free(Compiler,
                                      ((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.mat2Array);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            ((sloIR_BINARY_EXPR)(BinaryExpr->rightOperand))->u.mat2Array = gcvNULL;
        }

        status = _ConvertAuxiScalarArray(Compiler,
                                         CodeGenerator,
                                         (sloIR_BINARY_EXPR)(BinaryExpr->rightOperand));
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_UNARY_EXPR_GenFieldSelectionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_UNARY_EXPR UnaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  operandParameters;
    gctSIZE_T               operandFieldOffset = 0;
    gctUINT                 i;
    gctBOOL                 isPerVertexArray = gcvFALSE;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(UnaryExpr, slvIR_UNARY_EXPR);
    gcmASSERT(UnaryExpr->type == slvUNARY_FIELD_SELECTION);
    gcmASSERT(Parameters);

    /* Generate the code of the operand */
    gcmASSERT(UnaryExpr->operand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &operandParameters,
                                    Parameters->needLOperand,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &UnaryExpr->operand->base,
                                &CodeGenerator->visitor,
                                &operandParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Copy all field operands */
    if (Parameters->needLOperand || Parameters->needROperand)
    {
        isPerVertexArray = slsDATA_TYPE_IsPerVertexArray(UnaryExpr->exprBase.dataType);
        slsDATA_TYPE_SetPerVertexArray(UnaryExpr->exprBase.dataType, gcvFALSE);
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        UnaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        slsDATA_TYPE_SetPerVertexArray(UnaryExpr->exprBase.dataType, isPerVertexArray);

        operandFieldOffset  = _GetLogicalOperandFieldOffset(
                                                            UnaryExpr->operand->dataType,
                                                            UnaryExpr->u.fieldName,
                                                            gcvFALSE);

        Parameters->offsetInParent = _GetLogicalOperandFieldOffset(
                                                            UnaryExpr->operand->dataType,
                                                            UnaryExpr->u.fieldName,
                                                            gcvTRUE);;
    }

    if (Parameters->needLOperand)
    {
        for (i = 0; i < Parameters->operandCount; i++)
        {
            Parameters->lOperands[i] = operandParameters.lOperands[operandFieldOffset + i];

            if (slsDATA_TYPE_IsPerVertexArray(UnaryExpr->operand->dataType))
            {
                if (UnaryExpr->u.fieldName->dataType->elementType == slvTYPE_STRUCT)
                {
                    slsDATA_TYPE_SetPerVertexArray(UnaryExpr->exprBase.dataType, gcvTRUE);
                }
                else
                {
                    Parameters->lOperands[i].reg.u = UnaryExpr->u.fieldName->context.logicalRegs->u;
                    Parameters->lOperands[i].reg.qualifier = UnaryExpr->u.fieldName->context.logicalRegs->qualifier;
                    Parameters->lOperands[i].reg.dataType = UnaryExpr->u.fieldName->context.logicalRegs->dataType;
                    Parameters->lOperands[i].dataType = UnaryExpr->u.fieldName->context.logicalRegs->dataType;
                    Parameters->lOperands[i].reg.componentSelection = slGetDefaultComponentSelection(Parameters->lOperands[i].dataType);
                }
            }

            /* ubo indexing should be recorded to vertexIndex, not arrayIndex */
            if (slsDATA_TYPE_IsUnderlyingUniformBlock(UnaryExpr->operand->dataType))
            {
                Parameters->lOperands[i].vertexIndex = operandParameters.lOperands[operandFieldOffset + i].arrayIndex;
                Parameters->lOperands[i].arrayIndex.mode = slvINDEX_NONE;
            }

            if(*(gceOBJECT_TYPE**)(&Parameters->lOperands[i].reg.u))
            {
                switch(**(gceOBJECT_TYPE**)(&Parameters->lOperands[i].reg.u))
                {
                    case gcvOBJ_ATTRIBUTE:
                        gcmATTRIBUTE_SetIsStaticallyUsed(Parameters->lOperands[i].reg.u.attribute, gcvTRUE);
                        break;
                    case gcvOBJ_OUTPUT:
                        gcmOUTPUT_SetIsStaticallyUsed(Parameters->lOperands[i].reg.u.output, gcvTRUE);
                        break;
                    case gcvOBJ_VARIABLE:
                        SetVariableIsStaticallyUsed(Parameters->lOperands[i].reg.u.variable);
                        break;
                    default:
                        gcmASSERT(0);
                }
            }
        }
    }

    if (Parameters->needROperand)
    {
        for (i = 0; i < Parameters->operandCount; i++)
        {
            Parameters->rOperands[i] = operandParameters.rOperands[operandFieldOffset + i];

            if (slsDATA_TYPE_IsPerVertexArray(UnaryExpr->operand->dataType))
            {
                if (UnaryExpr->u.fieldName->dataType->elementType == slvTYPE_STRUCT)
                {
                    slsDATA_TYPE_SetPerVertexArray(UnaryExpr->exprBase.dataType, gcvTRUE);
                }
                else
                {
                    Parameters->rOperands[i].u.reg.u = UnaryExpr->u.fieldName->context.logicalRegs->u;
                    Parameters->rOperands[i].u.reg.qualifier = UnaryExpr->u.fieldName->context.logicalRegs->qualifier;
                    Parameters->rOperands[i].u.reg.dataType = UnaryExpr->u.fieldName->context.logicalRegs->dataType;
                    Parameters->rOperands[i].dataType = UnaryExpr->u.fieldName->context.logicalRegs->dataType;
                    Parameters->rOperands[i].u.reg.componentSelection = slGetDefaultComponentSelection(Parameters->rOperands[i].dataType);
                }
            }

            /* ubo indexing should be recorded to vertexIndex, not arrayIndex */
            if (slsDATA_TYPE_IsUnderlyingUniformBlock(UnaryExpr->operand->dataType))
            {
                Parameters->rOperands[i].vertexIndex = operandParameters.rOperands[operandFieldOffset + i].arrayIndex;
                Parameters->rOperands[i].arrayIndex.mode = slvINDEX_NONE;
            }

            if(*(gceOBJECT_TYPE**)(&Parameters->rOperands[i].u.reg.u))
            {
                switch(**(gceOBJECT_TYPE**)(&Parameters->rOperands[i].u.reg.u))
                {
                    case gcvOBJ_ATTRIBUTE:
                        gcmATTRIBUTE_SetIsStaticallyUsed(Parameters->rOperands[i].u.reg.u.attribute, gcvTRUE);
                        break;
                    case gcvOBJ_OUTPUT:
                        gcmOUTPUT_SetIsStaticallyUsed(Parameters->rOperands[i].u.reg.u.output, gcvTRUE);
                        break;
                    case gcvOBJ_UNIFORM:
                        SetUniformFlag(Parameters->rOperands[i].u.reg.u.uniform, gcvUNIFORM_FLAG_STATICALLY_USED);
                        break;
                    case gcvOBJ_VARIABLE:
                        SetVariableIsStaticallyUsed(Parameters->rOperands[i].u.reg.u.variable);
                        break;
                    default:
                        gcmASSERT(0);
                }
            }
        }
    }

    slsGEN_CODE_PARAMETERS_Finalize(&operandParameters);

    slsDATA_TYPE_SetPerVertexArray(UnaryExpr->operand->dataType, gcvFALSE);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gctREG_INDEX
_ConvComponentToVectorIndex(
    IN gctUINT8 Component
    )
{
    switch (Component)
    {
    case slvCOMPONENT_X: return 0;
    case slvCOMPONENT_Y: return 1;
    case slvCOMPONENT_Z: return 2;
    case slvCOMPONENT_W: return 3;

    default:
        gcmASSERT(0);
        return 0;
    }
}

gceSTATUS
sloIR_ROperandComponentSelect(
    IN sloCOMPILER Compiler,
    IN slsROPERAND *From,
    IN slsCOMPONENT_SELECTION ComponentSelection,
    OUT slsROPERAND *To
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER();

    gcmASSERT(From);
    gcmASSERT(To);

    *To = *From;

    To->dataType = gcGetVectorComponentSelectionDataType(From->dataType,
                                                         ComponentSelection.components);

    if (From->isReg) {
        if (ComponentSelection.components == 1) {
           gcmASSERT(To->vectorIndex.mode == slvINDEX_NONE);
           To->vectorIndex.mode       = slvINDEX_CONSTANT;
           To->vectorIndex.u.constant = _ConvComponentToVectorIndex(ComponentSelection.x);
        }
        else {
           To->u.reg.componentSelection = _SwizzleComponentSelection(ComponentSelection,
                                                                     From->u.reg.componentSelection);
        }
    }
    else {
        status = _SwizzleOperandConstant(&From->u.constant,
                                         ComponentSelection,
                                         &To->u.constant);
    }
    To->componentSelected = gcvTRUE;

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_LOperandComponentSelect(
    IN sloCOMPILER Compiler,
    IN slsLOPERAND *From,
    IN slsCOMPONENT_SELECTION ComponentSelection,
    OUT slsLOPERAND *To
    )
{
    gcmHEADER();

    gcmASSERT(From);
    gcmASSERT(To);

    *To = *From;

    To->dataType = gcGetVectorComponentSelectionDataType(From->dataType,
                                                         ComponentSelection.components);

    if (ComponentSelection.components == 1) {
       gcmASSERT(To->vectorIndex.mode == slvINDEX_NONE);
       To->vectorIndex.mode       = slvINDEX_CONSTANT;
       To->vectorIndex.u.constant = _ConvComponentToVectorIndex(ComponentSelection.x);
    }
    else {
       To->reg.componentSelection = _SwizzleComponentSelection(ComponentSelection,
                                                               From->reg.componentSelection);
    }
    To->componentSelected = gcvTRUE;
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_UNARY_EXPR_GenComponentSelectionCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_UNARY_EXPR UnaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  operandParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(UnaryExpr, slvIR_UNARY_EXPR);
    gcmASSERT(UnaryExpr->type == slvUNARY_COMPONENT_SELECTION);
    gcmASSERT(Parameters);

    /* Generate the code of the operand */
    gcmASSERT(UnaryExpr->operand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &operandParameters,
                                    Parameters->needLOperand,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &UnaryExpr->operand->base,
                                &CodeGenerator->visitor,
                                &operandParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Make the swizzled operand */
    if (Parameters->needLOperand || Parameters->needROperand)
    {
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        UnaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    if (Parameters->needLOperand)
    {
        gcmASSERT(Parameters->operandCount == 1);

        Parameters->lOperands[0]            = operandParameters.lOperands[0];

        Parameters->lOperands[0].dataType   =
            gcGetVectorComponentSelectionDataType(
                                                operandParameters.lOperands[0].dataType,
                                                UnaryExpr->u.componentSelection.components);

        if (UnaryExpr->u.componentSelection.components == 1)
        {
            gcmASSERT(Parameters->lOperands[0].vectorIndex.mode == slvINDEX_NONE);

            Parameters->lOperands[0].vectorIndex.mode       = slvINDEX_CONSTANT;
            Parameters->lOperands[0].vectorIndex.u.constant =
                _ConvComponentToVectorIndex(UnaryExpr->u.componentSelection.x);
        }
        else
        {
            Parameters->lOperands[0].reg.componentSelection =
                _SwizzleComponentSelection(
                                            UnaryExpr->u.componentSelection,
                                            operandParameters.lOperands[0].reg.componentSelection);
        }
    }

    if (Parameters->needROperand)
    {
        gcmASSERT(Parameters->operandCount == 1);

        sloIR_ROperandComponentSelect(Compiler,
                                      &operandParameters.rOperands[0],
                                      UnaryExpr->u.componentSelection,
                                      &Parameters->rOperands[0]);
    }

    slsGEN_CODE_PARAMETERS_Finalize(&operandParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_UNARY_EXPR_GenIncOrDecCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_UNARY_EXPR UnaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    gctBOOL                 isPost, isInc;
    slsGEN_CODE_PARAMETERS  operandParameters;
    slsIOPERAND             intermIOperand, origValueIOperand;
    slsLOPERAND             origValueLOperand;
    slsROPERAND             intermROperand, origValueROperand;
    sluCONSTANT_VALUE       constantValue;
    slsROPERAND             constantROperand;
    gcSHADER_TYPE           componentDataType;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(UnaryExpr, slvIR_UNARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    switch (UnaryExpr->type)
    {
    case slvUNARY_POST_INC: isPost = gcvTRUE;   isInc = gcvTRUE;    break;
    case slvUNARY_POST_DEC: isPost = gcvTRUE;   isInc = gcvFALSE;   break;
    case slvUNARY_PRE_INC:  isPost = gcvFALSE;  isInc = gcvTRUE;    break;
    case slvUNARY_PRE_DEC:  isPost = gcvFALSE;  isInc = gcvFALSE;   break;

    default: gcmASSERT(0);
             gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
             return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    /* Generate the code of the operand */
    gcmASSERT(UnaryExpr->operand);

    slsGEN_CODE_PARAMETERS_Initialize(&operandParameters, gcvTRUE, gcvTRUE);

    status = sloIR_OBJECT_Accept(Compiler,
                                 &UnaryExpr->operand->base,
                                 &CodeGenerator->visitor,
                                 &operandParameters);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Save the orig value. */
    slsIOPERAND_New(Compiler,
                    &origValueIOperand,
                    operandParameters.dataTypes[0],
                    operandParameters.rOperands[0].u.reg.precision);
    slsLOPERAND_InitializeUsingIOperand(&origValueLOperand, &origValueIOperand);

    status = slGenAssignCode(Compiler,
                             UnaryExpr->exprBase.base.lineNo,
                             UnaryExpr->exprBase.base.stringNo,
                             &origValueLOperand,
                             &operandParameters.rOperands[0]);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slsROPERAND_InitializeUsingIOperand(&origValueROperand, &origValueIOperand);

    gcmASSERT(operandParameters.operandCount == 1);

    /* add/sub t0, operand, 1 */
    slsIOPERAND_New(Compiler,
                    &intermIOperand,
                    operandParameters.dataTypes[0],
                    operandParameters.rOperands[0].u.reg.precision);

    componentDataType = gcGetComponentDataType(operandParameters.dataTypes[0]);

    switch (componentDataType)
    {
    case gcSHADER_FLOAT_X1:     constantValue.floatValue    = (gctFLOAT)1.0;    break;
    case gcSHADER_INTEGER_X1:   constantValue.intValue      = 1;                break;
    case gcSHADER_UINT_X1:   constantValue.uintValue      = 1;                break;

    default: gcmASSERT(0);
        constantValue.floatValue    = (gctFLOAT)1.0;
    }

    slsROPERAND_InitializeConstant(&constantROperand,
                                   componentDataType,
                                   gcSHADER_PRECISION_MEDIUM,
                                   1,
                                   &constantValue);

    status = slGenArithmeticExprCode(Compiler,
                                     UnaryExpr->exprBase.base.lineNo,
                                     UnaryExpr->exprBase.base.stringNo,
                                     (isInc) ? slvOPCODE_ADD : slvOPCODE_SUB,
                                     &intermIOperand,
                                     &origValueROperand,
                                     &constantROperand);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* mov operand, t0 */
    slsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);

    status = slGenAssignCode(Compiler,
                             UnaryExpr->exprBase.base.lineNo,
                             UnaryExpr->exprBase.base.stringNo,
                             &operandParameters.lOperands[0],
                             &intermROperand);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        if (isPost)
        {
            status = slsGEN_CODE_PARAMETERS_AllocateOperands(Compiler,
                                                             Parameters,
                                                             UnaryExpr->exprBase.dataType);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &origValueIOperand);
        }
        else
        {
            /* Return the operand directly */
            slsGEN_CODE_PARAMETERS_MoveOperands(Parameters, &operandParameters);
        }
    }

    slsGEN_CODE_PARAMETERS_Finalize(&operandParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_UNARY_EXPR_GenNegCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_UNARY_EXPR UnaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  operandParameters;
    slsIOPERAND             intermIOperand;
    sluCONSTANT_VALUE       constantValue;
    slsROPERAND             constantROperand;
    gcSHADER_TYPE           componentDataType;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(UnaryExpr, slvIR_UNARY_EXPR);
    gcmASSERT(UnaryExpr->type == slvUNARY_NEG);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the operand */
    gcmASSERT(UnaryExpr->operand);

    slsGEN_CODE_PARAMETERS_Initialize(&operandParameters, gcvFALSE, Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &UnaryExpr->operand->base,
                                &CodeGenerator->visitor,
                                &operandParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        gcmASSERT(operandParameters.operandCount == 1);

        /* sub t0, 0, operand */
        slsIOPERAND_New(Compiler,
                        &intermIOperand,
                        operandParameters.dataTypes[0],
                        operandParameters.rOperands[0].u.reg.precision);

        componentDataType = gcGetComponentDataType(operandParameters.dataTypes[0]);

        switch (componentDataType)
        {
        case gcSHADER_FLOAT_X1:     constantValue.floatValue    = (gctFLOAT)0.0;    break;
        case gcSHADER_INTEGER_X1:   constantValue.intValue      = 0;                break;

        case gcSHADER_UINT_X1:
            if (sloCOMPILER_IsHaltiVersion(Compiler)) {
               constantValue.uintValue      = 0;
               break;
            }
            /*fall through */

        default: gcmASSERT(0);
            constantValue.floatValue    = (gctFLOAT)0.0;
        }

        slsROPERAND_InitializeConstant(&constantROperand,
                                       componentDataType,
                                       gcSHADER_PRECISION_MEDIUM,
                                       1,
                                       &constantValue);

        status = slGenArithmeticExprCode(
                                        Compiler,
                                        UnaryExpr->exprBase.base.lineNo,
                                        UnaryExpr->exprBase.base.stringNo,
                                        slvOPCODE_SUB,
                                        &intermIOperand,
                                        &constantROperand,
                                        &operandParameters.rOperands[0]);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Return t0 */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        UnaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &intermIOperand);
    }

    slsGEN_CODE_PARAMETERS_Finalize(&operandParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_UNARY_EXPR_GenNotCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_UNARY_EXPR UnaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  operandParameters;
    slsIOPERAND             intermIOperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(UnaryExpr, slvIR_UNARY_EXPR);
    gcmASSERT(UnaryExpr->type == slvUNARY_NOT);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the operand */
    gcmASSERT(UnaryExpr->operand);

    slsGEN_CODE_PARAMETERS_Initialize(&operandParameters, gcvFALSE, Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &UnaryExpr->operand->base,
                                &CodeGenerator->visitor,
                                &operandParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        gcmASSERT(operandParameters.operandCount == 1);

        /* not t0, operand */
        slsIOPERAND_New(Compiler,
                        &intermIOperand,
                        operandParameters.dataTypes[0],
                        operandParameters.rOperands[0].u.reg.precision);

        status = slGenGenericCode1(
                                Compiler,
                                UnaryExpr->exprBase.base.lineNo,
                                UnaryExpr->exprBase.base.stringNo,
                                slvOPCODE_NOT,
                                &intermIOperand,
                                &operandParameters.rOperands[0]);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Return t0 */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        UnaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &intermIOperand);
    }

    slsGEN_CODE_PARAMETERS_Finalize(&operandParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_UNARY_EXPR_GenBitwiseNotCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_UNARY_EXPR UnaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS    status;
    slsGEN_CODE_PARAMETERS  operandParameters;
    slsIOPERAND intermIOperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(UnaryExpr, slvIR_UNARY_EXPR);
    gcmASSERT(UnaryExpr->type == slvUNARY_BITWISE_NOT);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the operand */
    gcmASSERT(UnaryExpr->operand);

    slsGEN_CODE_PARAMETERS_Initialize(&operandParameters, gcvFALSE, Parameters->needROperand);

    status = sloIR_OBJECT_Accept(Compiler,
                         &UnaryExpr->operand->base,
                         &CodeGenerator->visitor,
                         &operandParameters);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        gcmASSERT(operandParameters.operandCount == 1);

        /* Return t0 */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(Compiler,
                                 Parameters,
                                 UnaryExpr->exprBase.dataType);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* not t0, operand */
        slsIOPERAND_New(Compiler,
                        &intermIOperand,
                        Parameters->dataTypes[0],
                        Parameters->rOperands[0].u.reg.precision);

        status = slGenGenericCode1(Compiler,
                       UnaryExpr->exprBase.base.lineNo,
                       UnaryExpr->exprBase.base.stringNo,
                       slvOPCODE_BITWISE_NOT,
                       &intermIOperand,
                       &operandParameters.rOperands[0]);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &intermIOperand);
    }

    slsGEN_CODE_PARAMETERS_Finalize(&operandParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_UNARY_EXPR_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_UNARY_EXPR UnaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  operandParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(UnaryExpr, slvIR_UNARY_EXPR);
    gcmASSERT(Parameters);

    /* Try to evaluate the operand */
    if (!Parameters->needLOperand && Parameters->needROperand)
    {
        gcmASSERT(UnaryExpr->operand);

        slsGEN_CODE_PARAMETERS_Initialize(
                                        &operandParameters,
                                        gcvFALSE,
                                        gcvTRUE);

        operandParameters.hint = slvEVALUATE_ONLY;

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    &UnaryExpr->operand->base,
                                    &CodeGenerator->visitor,
                                    &operandParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (operandParameters.constant != gcvNULL)
        {
            status = sloIR_UNARY_EXPR_Evaluate(
                                            Compiler,
                                            UnaryExpr->type,
                                            operandParameters.constant,
                                            UnaryExpr->u.fieldName,
                                            &UnaryExpr->u.componentSelection,
                                            &Parameters->constant);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            operandParameters.constant  = gcvNULL;
        }

        slsGEN_CODE_PARAMETERS_Finalize(&operandParameters);

        if (Parameters->hint == slvEVALUATE_ONLY)
        {
            gcmFOOTER_NO();
            return gcvSTATUS_OK;
        }

        if (Parameters->constant != gcvNULL)
        {
            status = sloIR_CONSTANT_GenCode(
                                        Compiler,
                                        CodeGenerator,
                                        Parameters->constant,
                                        Parameters);
            gcmFOOTER();
            return status;
        }
    }

    switch (UnaryExpr->type)
    {
    case slvUNARY_FIELD_SELECTION:
        status = sloIR_UNARY_EXPR_GenFieldSelectionCode(
                                                    Compiler,
                                                    CodeGenerator,
                                                    UnaryExpr,
                                                    Parameters);
        break;

    case slvUNARY_COMPONENT_SELECTION:
        status = sloIR_UNARY_EXPR_GenComponentSelectionCode(
                                                        Compiler,
                                                        CodeGenerator,
                                                        UnaryExpr,
                                                        Parameters);
        break;

    case slvUNARY_POST_INC:
    case slvUNARY_POST_DEC:
    case slvUNARY_PRE_INC:
    case slvUNARY_PRE_DEC:
        status = sloIR_UNARY_EXPR_GenIncOrDecCode(
                                                Compiler,
                                                CodeGenerator,
                                                UnaryExpr,
                                                Parameters);
        break;

    case slvUNARY_NEG:
        status = sloIR_UNARY_EXPR_GenNegCode(
                                        Compiler,
                                        CodeGenerator,
                                        UnaryExpr,
                                        Parameters);
        break;

    case slvUNARY_NOT:
        status = sloIR_UNARY_EXPR_GenNotCode(
                                        Compiler,
                                        CodeGenerator,
                                        UnaryExpr,
                                        Parameters);
        break;

    case slvUNARY_BITWISE_NOT:
        status = sloIR_UNARY_EXPR_GenBitwiseNotCode(Compiler,
                                                    CodeGenerator,
                                                    UnaryExpr,
                                                    Parameters);
        break;

    default:
        gcmASSERT(0);
        status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Restore vec from scalar array if vect is component indexing. */
    if ((UnaryExpr->operand->base.vptr->type == slvIR_BINARY_EXPR) &&
        ((sloIR_BINARY_EXPR)(UnaryExpr->operand))->u.vec2Array)
    {
        status = _ConvertAuxiScalarArrayToVec(
                                             Compiler,
                                             CodeGenerator,
                                             ((sloIR_BINARY_EXPR)(UnaryExpr->operand))->u.vec2Array->scalarArrayName,
                                             &((sloIR_BINARY_EXPR)(UnaryExpr->operand))->u.vec2Array->vecOperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        status = sloCOMPILER_Free(
                                  Compiler,
                                  ((sloIR_BINARY_EXPR)(UnaryExpr->operand))->u.vec2Array);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        ((sloIR_BINARY_EXPR)(UnaryExpr->operand))->u.vec2Array = gcvNULL;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
_GetConstantSubscriptCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN slsGEN_CODE_PARAMETERS * LeftParameters,
    IN slsGEN_CODE_PARAMETERS * RightParameters,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS       status = gcvSTATUS_OK;
    gctINT32        index;
    gctUINT         offset, i;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(LeftParameters);
    gcmASSERT(RightParameters);
    gcmASSERT(Parameters);

    gcmASSERT(RightParameters->operandCount == 1);
    gcmASSERT(RightParameters->dataTypes[0] == gcSHADER_INTEGER_X1 ||
              RightParameters->dataTypes[0] == gcSHADER_UINT_X1);
    gcmASSERT(!RightParameters->rOperands[0].isReg);

    index = RightParameters->rOperands[0].u.constant.values[0].intValue;

    if (slsDATA_TYPE_IsBVecOrIVecOrVec(BinaryExpr->leftOperand->dataType))
    {
        gcmASSERT(Parameters->operandCount == 1);

        if (Parameters->needLOperand)
        {
            Parameters->lOperands[0] = LeftParameters->lOperands[0];

            Parameters->lOperands[0].dataType =
                            gcGetVectorComponentDataType(LeftParameters->lOperands[0].dataType);
            Parameters->lOperands[0].vectorIndex.mode       = slvINDEX_CONSTANT;
            Parameters->lOperands[0].vectorIndex.u.constant = (gctREG_INDEX) index;
        }

        if (Parameters->needROperand)
        {
            Parameters->rOperands[0] = LeftParameters->rOperands[0];

            Parameters->rOperands[0].dataType =
                            gcGetVectorComponentDataType(LeftParameters->rOperands[0].dataType);
            Parameters->rOperands[0].vectorIndex.mode       = slvINDEX_CONSTANT;
            Parameters->rOperands[0].vectorIndex.u.constant = (gctREG_INDEX) index;
        }
    }
    else if (slsDATA_TYPE_IsMat(BinaryExpr->leftOperand->dataType))
    {
        gcmASSERT(Parameters->operandCount == 1);

        if (Parameters->needLOperand)
        {
            Parameters->lOperands[0] = LeftParameters->lOperands[0];

            Parameters->lOperands[0].dataType =
                            gcGetMatrixColumnDataType(LeftParameters->lOperands[0].dataType);
            Parameters->lOperands[0].matrixIndex.mode       = slvINDEX_CONSTANT;
            Parameters->lOperands[0].matrixIndex.u.constant = (gctREG_INDEX) index;
        }

        if (Parameters->needROperand)
        {
            Parameters->rOperands[0] = LeftParameters->rOperands[0];

            Parameters->rOperands[0].dataType =
                            gcGetMatrixColumnDataType(LeftParameters->rOperands[0].dataType);
            Parameters->rOperands[0].matrixIndex.mode       = slvINDEX_CONSTANT;
            Parameters->rOperands[0].matrixIndex.u.constant = (gctREG_INDEX) index;
        }
    }
    else
    {
        gcmASSERT(slsDATA_TYPE_IsArray(BinaryExpr->leftOperand->dataType));

        gcmASSERT((Parameters->operandCount * index) < LeftParameters->operandCount ||
                  slsDATA_TYPE_IsInheritFromUnsizedDataType(BinaryExpr->leftOperand->dataType));

        if (slsDATA_TYPE_IsInheritFromUnsizedDataType(BinaryExpr->leftOperand->dataType))
        {
            gctINT arrayStride;

            if (Parameters->needLOperand)
            {
                gcmASSERT(_IsLOperandStorageBlockMember(Compiler, &LeftParameters->lOperands[0]));
                arrayStride = _GetUnderlyingVariableArrayStride(Compiler,
                                                                BinaryExpr->leftOperand->dataType,
                                                                &LeftParameters->lOperands[0].reg);

                if(arrayStride == -1)
                {
                    gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                    BinaryExpr->exprBase.base.lineNo,
                                                    BinaryExpr->exprBase.base.stringNo,
                                                    slvREPORT_ERROR,
                                                    "unknown array stride"));
                    gcmFOOTER_NO();
                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }

                arrayStride *= index;
                for (i = 0; i < Parameters->operandCount; i++)
                {
                    Parameters->lOperands[i] = LeftParameters->lOperands[i];
                    Parameters->lOperands[i].reg.regIndex += arrayStride;
                }
            }

            if (Parameters->needROperand)
            {
                gcmASSERT(_IsROperandStorageBlockMember(Compiler, &LeftParameters->rOperands[0]));
                arrayStride = _GetUnderlyingVariableArrayStride(Compiler,
                                                                BinaryExpr->leftOperand->dataType,
                                                                &LeftParameters->rOperands[0].u.reg);
                if(arrayStride == -1)
                {
                    gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                    BinaryExpr->exprBase.base.lineNo,
                                                    BinaryExpr->exprBase.base.stringNo,
                                                    slvREPORT_ERROR,
                                                    "unknown array stride"));
                    gcmFOOTER_NO();
                    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                }

                arrayStride *= index;
                for (i = 0; i < Parameters->operandCount; i++)
                {
                    Parameters->rOperands[i] = LeftParameters->rOperands[i];
                    Parameters->rOperands[i].u.reg.regIndex += arrayStride;
                }
            }
        }
        else
        {
            offset = Parameters->operandCount * index;

            if (Parameters->needLOperand)
            {
                for (i = 0; i < Parameters->operandCount; i++)
                {
                    if (LeftParameters->lOperands[i].vertexIndex.mode != slvINDEX_NONE)
                    {
                        if (!slsDATA_TYPE_IsUnderlyingStruct(((BinaryExpr)->leftOperand)->dataType))
                        {
                            offset = index;
                        }

                        Parameters->lOperands[i] = LeftParameters->lOperands[i];

                        if (LeftParameters->lOperands[i].arrayIndex.mode == slvINDEX_CONSTANT ||
                            LeftParameters->lOperands[i].arrayIndex.mode == slvINDEX_NONE)
                        {
                            Parameters->lOperands[i].arrayIndex.mode = slvINDEX_CONSTANT;
                            Parameters->lOperands[i].arrayIndex.u.constant += offset;
                        }
                        else
                        {
                            sluCONSTANT_VALUE offsetConstantValue;
                            slsROPERAND constantROperand[1];
                            slsROPERAND arrayIndexROperand[1];
                            slsIOPERAND arrayIndexIOperand[1];
                            gctREG_INDEX arrayIndex = slNewTempRegs(Compiler, 1);

                            slsIOPERAND_Initialize(arrayIndexIOperand,
                                                   gcSHADER_INTEGER_X1,
                                                   gcSHADER_PRECISION_MEDIUM,
                                                   arrayIndex);

                            offsetConstantValue.intValue = offset;
                            slsROPERAND_InitializeConstant(constantROperand,
                                                           gcSHADER_INTEGER_X1,
                                                           gcSHADER_PRECISION_MEDIUM,
                                                           1,
                                                           &offsetConstantValue);

                            slsROPERAND_InitializeTempReg(arrayIndexROperand,
                                                          slvSTORAGE_QUALIFIER_NONE,
                                                          gcSHADER_INTEGER_X1,
                                                          gcSHADER_PRECISION_MEDIUM,
                                                          LeftParameters->lOperands[i].arrayIndex.u.indexRegIndex);

                            status = slGenArithmeticExprCode(Compiler,
                                                             BinaryExpr->exprBase.base.lineNo,
                                                             BinaryExpr->exprBase.base.stringNo,
                                                             slvOPCODE_ADD,
                                                             arrayIndexIOperand,
                                                             constantROperand,
                                                             arrayIndexROperand);

                            if (gcmIS_ERROR(status)) { return status; }

                            Parameters->lOperands[i].arrayIndex.mode = slvINDEX_REG;
                            Parameters->lOperands[i].arrayIndex.u.indexRegIndex = arrayIndex;
                        }
                    }
                    else
                    {
                        Parameters->lOperands[i] = LeftParameters->lOperands[offset + i];
                    }
                }
            }

            if (Parameters->needROperand)
            {
                for (i = 0; i < Parameters->operandCount; i++)
                {
                    if (LeftParameters->rOperands[i].vertexIndex.mode != slvINDEX_NONE)
                    {
                        if (!slsDATA_TYPE_IsUnderlyingStruct(((BinaryExpr)->leftOperand)->dataType))
                        {
                            offset = index;
                        }

                        Parameters->rOperands[i] = LeftParameters->rOperands[i];

                        if (LeftParameters->rOperands[i].arrayIndex.mode == slvINDEX_CONSTANT ||
                            LeftParameters->rOperands[i].arrayIndex.mode == slvINDEX_NONE)
                        {
                            Parameters->rOperands[i].arrayIndex.mode = slvINDEX_CONSTANT;
                            Parameters->rOperands[i].arrayIndex.u.constant += offset;
                        }
                        else
                        {
                            sluCONSTANT_VALUE offsetConstantValue;
                            slsROPERAND constantROperand[1];
                            slsROPERAND arrayIndexROperand[1];
                            slsIOPERAND arrayIndexIOperand[1];
                            gctREG_INDEX arrayIndex = slNewTempRegs(Compiler, 1);

                            slsIOPERAND_Initialize(arrayIndexIOperand,
                                                   gcSHADER_INTEGER_X1,
                                                   gcSHADER_PRECISION_MEDIUM,
                                                   arrayIndex);

                            offsetConstantValue.intValue = offset;
                            slsROPERAND_InitializeConstant(constantROperand,
                                                           gcSHADER_INTEGER_X1,
                                                           gcSHADER_PRECISION_MEDIUM,
                                                           1,
                                                           &offsetConstantValue);

                            slsROPERAND_InitializeTempReg(arrayIndexROperand,
                                                          slvSTORAGE_QUALIFIER_NONE,
                                                          gcSHADER_INTEGER_X1,
                                                          gcSHADER_PRECISION_MEDIUM,
                                                          LeftParameters->rOperands[i].arrayIndex.u.indexRegIndex);

                            status = slGenArithmeticExprCode(Compiler,
                                                             BinaryExpr->exprBase.base.lineNo,
                                                             BinaryExpr->exprBase.base.stringNo,
                                                             slvOPCODE_ADD,
                                                             arrayIndexIOperand,
                                                             constantROperand,
                                                             arrayIndexROperand);

                            if (gcmIS_ERROR(status)) { return status; }

                            Parameters->rOperands[i].arrayIndex.mode = slvINDEX_REG;
                            Parameters->rOperands[i].arrayIndex.u.indexRegIndex = arrayIndex;
                        }
                    }
                    else
                    {
                        Parameters->rOperands[i] = LeftParameters->rOperands[offset + i];
                    }
                }
            }
        }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenIndexAssignCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN gctREG_INDEX IndexRegIndex,
    IN slsROPERAND * ROperand
    )
{
    slsLOPERAND lOperand;

    gcmASSERT(gcIsScalarDataType(ROperand->dataType) &&
              gcIsIntegerDataType(ROperand->dataType));

    slsLOPERAND_InitializeTempReg(&lOperand,
                                  slvSTORAGE_QUALIFIER_NONE,
                                  ROperand->dataType,
                                  gcSHADER_PRECISION_MEDIUM,
                                  IndexRegIndex);

    return slGenAssignCode(Compiler,
                        LineNo,
                        StringNo,
                        &lOperand,
                        ROperand);
}

static gceSTATUS
_GenIndexAddCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN gctREG_INDEX TargetIndexRegIndex,
    IN gctREG_INDEX SourceIndexRegIndex,
    IN slsROPERAND * ROperand,
    IN sleINDEX_MODE IndexMode
    )
{
    slsIOPERAND iOperand;
    slsROPERAND rOperand;

    slsIOPERAND_Initialize(&iOperand,
                           gcSHADER_INTEGER_X1,
                           ROperand->u.reg.precision,
                           TargetIndexRegIndex);

    if (IndexMode == slvINDEX_REG)
    {
        slsROPERAND_InitializeTempReg(&rOperand,
                                      slvSTORAGE_QUALIFIER_NONE,
                                      gcSHADER_INTEGER_X1,
                                      ROperand->u.reg.precision,
                                      SourceIndexRegIndex);
    }
    else
    {
        gctREG_INDEX index = 0;

        switch (IndexMode)
        {
        case slvINDEX_REG_Y:
            index = 1;
            break;
        case slvINDEX_REG_Z:
            index = 2;
            break;
        case slvINDEX_REG_W:
            index = 3;
            break;
        default:
            gcmASSERT(0);
        }

        slsROPERAND_InitializeTempReg(&rOperand,
                                      slvSTORAGE_QUALIFIER_NONE,
                                      gcSHADER_INTEGER_X4,
                                      ROperand->u.reg.precision,
                                      SourceIndexRegIndex);
        rOperand.dataType = gcSHADER_INTEGER_X1;
        rOperand.vectorIndex.mode = slvINDEX_CONSTANT;
        rOperand.vectorIndex.u.indexRegIndex = index;
    }

    return slGenArithmeticExprCode(
                                Compiler,
                                LineNo,
                                StringNo,
                                slvOPCODE_ADD,
                                &iOperand,
                                ROperand,
                                &rOperand);
}

static gceSTATUS
_GenIndexScaleCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN gctREG_INDEX IndexRegIndex,
    IN slsROPERAND * ROperand,
    IN gctINT32 ElementDataTypeSize,
    IN gctINT32 offset,
    IN gctREG_INDEX IndexRegIndexInParent,
    IN sleINDEX_MODE IndexRegIndexMode
    )
{
    gceSTATUS           status;
    slsIOPERAND         iOperand, tmpIOperand = {0};
    slsROPERAND         rOperand, tmpROperand;
    sluCONSTANT_VALUE   constantValue;
    gctREG_INDEX tmpRegIndex;
    gctBOOL hasParentIndexReg = (IndexRegIndexInParent != (gctREG_INDEX)~0);

    if (hasParentIndexReg)
    {
        tmpRegIndex = slNewTempRegs(Compiler, 1);
        slsIOPERAND_Initialize(&tmpIOperand,
                               gcSHADER_INTEGER_X1,
                               ROperand->u.reg.precision,
                               tmpRegIndex);
    }

    slsIOPERAND_Initialize(&iOperand,
                           ROperand->dataType,
                           ROperand->u.reg.precision,
                           IndexRegIndex);

    constantValue.intValue = ElementDataTypeSize;

    slsROPERAND_InitializeConstant(&rOperand,
                                   ROperand->dataType,
                                   ROperand->u.reg.precision,
                                   1,
                                   &constantValue);

    if (offset == 0)
    {
        status = slGenArithmeticExprCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    slvOPCODE_MUL,
                                    (hasParentIndexReg) ? &tmpIOperand : &iOperand,
                                    ROperand,
                                    &rOperand);
    }
    else
    {
        slsIOPERAND offsetIOperand;
        slsROPERAND offsetROperand;
        sluCONSTANT_VALUE   offsetConstantValue;
        gctREG_INDEX offsetRegIndex = slNewTempRegs(Compiler, 1);

        slsIOPERAND_Initialize(&offsetIOperand,
                               gcSHADER_INTEGER_X1,
                               ROperand->u.reg.precision,
                               offsetRegIndex);

        status = slGenArithmeticExprCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    slvOPCODE_MUL,
                                    &offsetIOperand,
                                    ROperand,
                                    &rOperand);

        if (gcmIS_ERROR(status)) { return status; }

        offsetConstantValue.intValue = offset;
        slsROPERAND_InitializeConstant(&rOperand,
                                       gcSHADER_INTEGER_X1,
                                       gcSHADER_PRECISION_MEDIUM,
                                       1,
                                       &offsetConstantValue);

        slsROPERAND_InitializeUsingIOperand(&offsetROperand, &offsetIOperand);

        status = slGenArithmeticExprCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    slvOPCODE_ADD,
                                    (hasParentIndexReg) ? &tmpIOperand : &iOperand,
                                    &offsetROperand,
                                    &rOperand);
    }

    if (gcmIS_ERROR(status)) { return status; }

    if (hasParentIndexReg)
    {
        slsROPERAND parentIndexROperand;
        slsIOPERAND parentIndexIOperand;
        slsCOMPONENT_SELECTION componentSelection = ComponentSelection_X;

        if (IndexRegIndexMode == slvINDEX_REG)
        {
            slsIOPERAND_Initialize(&parentIndexIOperand,
                                   gcSHADER_INTEGER_X1,
                                   ROperand->u.reg.precision,
                                   IndexRegIndexInParent);
        }
        else
        {
            switch (IndexRegIndexMode)
            {
            case slvINDEX_REG_Y:
                componentSelection = ComponentSelection_Y;
                break;
            case slvINDEX_REG_Z:
                componentSelection = ComponentSelection_Z;
                break;
            case slvINDEX_REG_W:
                componentSelection = ComponentSelection_W;
                break;
            default:
                gcmASSERT(0);
            }

            slsIOPERAND_Initialize(&parentIndexIOperand,
                                   gcSHADER_INTEGER_X4,
                                   ROperand->u.reg.precision,
                                   IndexRegIndexInParent);
        }

        slsROPERAND_InitializeUsingIOperand(&tmpROperand, &tmpIOperand);
        slsROPERAND_InitializeUsingIOperand(&parentIndexROperand, &parentIndexIOperand);

        if (IndexRegIndexMode != slvINDEX_REG)
        {
            parentIndexROperand.u.reg.componentSelection = componentSelection;
        }

        status = slGenArithmeticExprCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    slvOPCODE_ADD,
                                    &iOperand,
                                    &tmpROperand,
                                    &parentIndexROperand);
    }

    return status;
}

#define _slmGenIndexAssignCode(Compiler, LineNo, StringNo, Index, TempIndex, VectorIndexing, Status)  \
    do { \
        if((Index)->isReg && _IsTempRegQualifier((Index)->u.reg.qualifier) && \
           (Index)->arrayIndex.mode == slvINDEX_NONE && \
           (Index)->matrixIndex.mode == slvINDEX_NONE && \
           (Index)->vectorIndex.mode == slvINDEX_CONSTANT) { \
            (TempIndex) = (Index)->u.reg.regIndex; \
            (VectorIndexing) = &((Index)->vectorIndex); \
            (Status) = gcvSTATUS_OK; \
        } \
        else { \
            (TempIndex) = slNewTempRegs((Compiler), 1); \
            (Status) = _GenIndexAssignCode((Compiler), \
                                           (LineNo), \
                                           (StringNo), \
                                           (TempIndex), \
                                           (Index)); \
        } \
    } while (gcvFALSE)

gceSTATUS
_GetIOElementStride(
    IN sloCOMPILER Compiler,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN slsGEN_CODE_PARAMETERS * LeftParameters,
    IN slsGEN_CODE_PARAMETERS * Parameters,
    OUT gctINT32 * ElementStride
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctINT32 elementStride = 1;

    if (slsDATA_TYPE_IsInheritFromUnsizedDataType(BinaryExpr->leftOperand->dataType))
    {
        if (Parameters->needLOperand)
        {
            gcmASSERT(_IsLOperandStorageBlockMember(Compiler, &LeftParameters->lOperands[0]));
            elementStride = _GetUnderlyingVariableArrayStride(Compiler,
                                                            BinaryExpr->leftOperand->dataType,
                                                            &LeftParameters->lOperands[0].reg);

            if(elementStride == -1)
            {
                gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                BinaryExpr->exprBase.base.lineNo,
                                                BinaryExpr->exprBase.base.stringNo,
                                                slvREPORT_ERROR,
                                                "unknown array stride"));
                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }
        }

        if (Parameters->needROperand)
        {
            gcmASSERT(_IsROperandStorageBlockMember(Compiler, &LeftParameters->rOperands[0]));
            elementStride = _GetUnderlyingVariableArrayStride(Compiler,
                                                            BinaryExpr->leftOperand->dataType,
                                                            &LeftParameters->rOperands[0].u.reg);
            if(elementStride == -1)
            {
                gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                BinaryExpr->exprBase.base.lineNo,
                                                BinaryExpr->exprBase.base.stringNo,
                                                slvREPORT_ERROR,
                                                "unknown array stride"));
                return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            }
        }
    }
    else
    {
        gcmASSERT(LeftParameters->operandCount >= Parameters->operandCount);

        if (Parameters->needROperand)
        {
            if (_IsROperandStorageBlockMember(Compiler, &LeftParameters->rOperands[0]))
            {
                if (LeftParameters->rOperands[0].u.reg.u.variable->arraySize == 1 &&
                    LeftParameters->rOperands[0].u.reg.u.variable->arrayLengthCount > 0)
                {
                    elementStride = LeftParameters->rOperands[0].u.reg.u.variable->arrayStride;
                }
                else
                {
                    slsROPERAND operand = LeftParameters->rOperands[Parameters->operandCount];
                    elementStride = operand.u.reg.u.variable->offset - LeftParameters->rOperands[0].u.reg.u.variable->offset;

                    if (elementStride == 0)
                    {
                        elementStride = operand.u.reg.u.variable->arrayStride;
                    }
                }
            }
            else
            {
                if (LeftParameters->rOperands[0].u.reg.u.uniform->arraySize == 1 &&
                    LeftParameters->rOperands[0].u.reg.u.uniform->arrayLengthCount > 0)
                {
                    elementStride = LeftParameters->rOperands[0].u.reg.u.uniform->arrayStride;
                }
                else
                {
                    slsROPERAND operand = LeftParameters->rOperands[Parameters->operandCount];
                    elementStride = operand.u.reg.u.uniform->offset - LeftParameters->rOperands[0].u.reg.u.uniform->offset;

                    if (elementStride == 0)
                    {
                        elementStride = operand.u.reg.u.uniform->arrayStride;
                    }
                }
            }
        }

        if (Parameters->needLOperand)
        {
            if (_IsLOperandStorageBlockMember(Compiler, &LeftParameters->lOperands[0]))
            {
                if (LeftParameters->lOperands[0].reg.u.variable->arraySize == 1 &&
                    LeftParameters->lOperands[0].reg.u.variable->arrayLengthCount > 0)
                {
                    elementStride = LeftParameters->lOperands[0].reg.u.variable->arrayStride;
                }
                else
                {
                    slsLOPERAND operand = LeftParameters->lOperands[Parameters->operandCount];
                    elementStride = operand.reg.u.variable->offset - LeftParameters->lOperands[0].reg.u.variable->offset;

                    if (elementStride == 0)
                    {
                        elementStride = operand.reg.u.variable->arrayStride;
                    }
                }
            }
            else
            {
                if (LeftParameters->lOperands[0].reg.u.uniform->arraySize == 1 &&
                    LeftParameters->lOperands[0].reg.u.uniform->arrayLengthCount > 0)
                {
                    elementStride = LeftParameters->lOperands[0].reg.u.uniform->arrayStride;
                }
                else
                {
                    slsLOPERAND operand = LeftParameters->lOperands[Parameters->operandCount];
                    elementStride = operand.reg.u.uniform->offset - LeftParameters->lOperands[0].reg.u.uniform->offset;

                    if (elementStride == 0)
                    {
                        elementStride = operand.reg.u.uniform->arrayStride;
                    }
                }
            }
        }
    }

    elementStride = (elementStride == 0) ? 1 : elementStride;

    if (ElementStride)
    {
        *ElementStride = elementStride;
    }
    return status;
}

gceSTATUS
_GetVertexOrPatchIndexSubScriptCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN slsGEN_CODE_PARAMETERS * LeftParameters,
    IN slsGEN_CODE_PARAMETERS * RightParameters,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS           status = gcvSTATUS_OK;
    gctINT32            index;
    gctUINT             i;
    gctREG_INDEX        indexRegIndex;
    slsIOPERAND         iOperand[1];
    slsLOPERAND         lOperand[1];

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(LeftParameters);
    gcmASSERT(RightParameters);
    gcmASSERT(Parameters);

    if (!RightParameters->rOperands[0].isReg)
    {
        index = RightParameters->rOperands[0].u.constant.values[0].intValue;

        if (Parameters->needLOperand)
        {
            for (i = 0; i < Parameters->operandCount; i++)
            {
                Parameters->lOperands[i] = LeftParameters->lOperands[i];
                Parameters->lOperands[i].dataType = LeftParameters->dataTypes[i];
                Parameters->lOperands[i].vertexIndex.mode = slvINDEX_CONSTANT;
                Parameters->lOperands[i].vertexIndex.u.constant = (gctREG_INDEX) index;
            }
        }

        if (Parameters->needROperand)
        {
            for (i = 0; i < Parameters->operandCount; i++)
            {
                Parameters->rOperands[i] = LeftParameters->rOperands[i];
                Parameters->rOperands[i].dataType = LeftParameters->dataTypes[i];
                Parameters->rOperands[i].vertexIndex.mode = slvINDEX_CONSTANT;
                Parameters->rOperands[i].vertexIndex.u.constant = (gctREG_INDEX) index;
            }
        }
    }
    else
    {
        indexRegIndex = slNewTempRegs(Compiler, 1);
        slsIOPERAND_Initialize(iOperand,
                               gcSHADER_INTEGER_X1,
                               RightParameters->rOperands[0].u.reg.precision,
                               indexRegIndex);

        slsLOPERAND_InitializeUsingIOperand(lOperand, iOperand);

        gcmONERROR(slGenAssignCode(Compiler,
                                   0,
                                   0,
                                   lOperand,
                                   &RightParameters->rOperands[0]));

        if (Parameters->needLOperand)
        {
            for (i = 0; i < Parameters->operandCount; i++)
            {
                Parameters->lOperands[i] = LeftParameters->lOperands[i];
                Parameters->lOperands[i].dataType = LeftParameters->dataTypes[i];
                Parameters->lOperands[i].vertexIndex.mode = slvINDEX_REG;
                Parameters->lOperands[i].vertexIndex.u.indexRegIndex = indexRegIndex;
            }
        }

        if (Parameters->needROperand)
        {
            for (i = 0; i < Parameters->operandCount; i++)
            {
                Parameters->rOperands[i] = LeftParameters->rOperands[i];
                Parameters->rOperands[i].dataType = LeftParameters->dataTypes[i];
                Parameters->rOperands[i].vertexIndex.mode = slvINDEX_REG;
                Parameters->rOperands[i].vertexIndex.u.constant = indexRegIndex;
            }
        }
    }

OnError:
    gcmFOOTER_NO();
    return status;
}

sleINDEX_LEVEL
_UpdateIndexLevel(
    IN slsDATA_TYPE * DataType,
    IN sleINDEX_LEVEL IndexLevel
    )
{
    sleINDEX_LEVEL indexLevel = IndexLevel;

    if (DataType->elementType == slvTYPE_STRUCT)
    {
        indexLevel = slvINDEX_LEVEL_NODE;
    }
    else
    {
        if (IndexLevel == slvINDEX_LEVEL_NONE)
        {
            indexLevel = slvINDEX_LEVEL_LEAF;
        }
        else if (IndexLevel == slvINDEX_LEVEL_NODE)
        {
            indexLevel = slvINDEX_LEVEL_LEAF_AND_NODE;
        }
    }

    return indexLevel;
}

gceSTATUS
_GetNonConstantSubscriptCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN slsGEN_CODE_PARAMETERS * LeftParameters,
    IN slsGEN_CODE_PARAMETERS * RightParameters,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS       status;
    gctREG_INDEX    indexRegIndex, IndexRegIndexInParent, rIndexRegIndex, lIndexRegIndex;
    sleINDEX_MODE   IndexRegIndexMode = slvINDEX_NONE;
    gctUINT         i;
    gctINT32        elementDataTypeSize;
    slsINDEX * vectorIndexing = gcvNULL;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(LeftParameters);
    gcmASSERT(RightParameters);
    gcmASSERT(Parameters);

    gcmASSERT(RightParameters->operandCount == 1);
    gcmASSERT(RightParameters->rOperands != gcvNULL && RightParameters->rOperands[0].isReg);

    if (LeftParameters->needLOperand)
    {
        IndexRegIndexInParent = ((LeftParameters->lOperands[0].arrayIndex.mode != slvINDEX_NONE &&
                                              LeftParameters->lOperands[0].arrayIndex.mode != slvINDEX_CONSTANT)?
                                 LeftParameters->lOperands[0].arrayIndex.u.indexRegIndex : (gctREG_INDEX) -1);
        IndexRegIndexMode = LeftParameters->lOperands[0].arrayIndex.mode;
    }
    else if (LeftParameters->needROperand)
    {
        IndexRegIndexInParent = ((LeftParameters->rOperands[0].arrayIndex.mode != slvINDEX_NONE &&
                                              LeftParameters->rOperands[0].arrayIndex.mode != slvINDEX_CONSTANT) ?
                                 LeftParameters->rOperands[0].arrayIndex.u.indexRegIndex : (gctREG_INDEX) -1);
        IndexRegIndexMode = LeftParameters->rOperands[0].arrayIndex.mode;
    }
    else
    {
        IndexRegIndexInParent = (gctREG_INDEX)~0;
    }

    if (slsDATA_TYPE_IsBVecOrIVecOrVec(BinaryExpr->leftOperand->dataType))
    {
        if ((Parameters->needROperand && _IsROperandStorageBlockMember(Compiler, &LeftParameters->rOperands[0])) ||
            (Parameters->needLOperand && _IsLOperandStorageBlockMember(Compiler, &LeftParameters->lOperands[0])))

        {
            _GetDataTypeByteOffset(0,
                                   gcGetComponentDataType(_ConvElementDataType(BinaryExpr->leftOperand->dataType)),
                                   gcvFALSE,
                                   gcvINTERFACE_BLOCK_NONE,
                                   gcvFALSE,
                                   gcvNULL,
                                   &elementDataTypeSize,
                                   gcvNULL);

            indexRegIndex = slNewTempRegs(Compiler, 1);

            status = _GenIndexScaleCode(Compiler,
                                        BinaryExpr->rightOperand->base.lineNo,
                                        BinaryExpr->rightOperand->base.stringNo,
                                        indexRegIndex,
                                        &RightParameters->rOperands[0],
                                        elementDataTypeSize,
                                        0, /* (BinaryExpr->leftOperand->dataType->fieldSpace) ? LeftParameters->offsetInParent : 0, */
                                        IndexRegIndexInParent,
                                        IndexRegIndexMode);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            gcmASSERT(Parameters->operandCount == 1);
            if (Parameters->needLOperand)
            {
                for (i = 0; i < Parameters->operandCount; i++)
                {
                    Parameters->lOperands[i] = LeftParameters->lOperands[i];
                    Parameters->lOperands[i].matrixIndex.mode = slvINDEX_NONE;

                    Parameters->lOperands[i].dataType = Parameters->dataTypes[i];
                    Parameters->lOperands[i].arrayIndex.u.indexRegIndex = indexRegIndex;

                    Parameters->lOperands[i].arrayIndex.mode = slvINDEX_REG;
                }
            }

            if (Parameters->needROperand)
            {
                for (i = 0; i < Parameters->operandCount; i++)
                {
                    Parameters->rOperands[i] = LeftParameters->rOperands[i];
                    Parameters->rOperands[i].matrixIndex.mode = slvINDEX_NONE;

                    Parameters->rOperands[i].dataType = Parameters->dataTypes[i];
                    Parameters->rOperands[i].arrayIndex.u.indexRegIndex = indexRegIndex;

                    Parameters->rOperands[i].arrayIndex.mode = slvINDEX_REG;
                }
            }
        }
        else
        {
            /*
               Vector components are dynamic indexed, so scalar array with vector size
               will be generated, any dynamic indexing on vector component will be
               replaced with scalar array. Vector will be restored from scalar array at
               other proper place.
            */

            slsNAME                     *scalarArrayName;
            slsDATA_TYPE                *arrayDataType;
            slsIOPERAND                 intermIOperand;
            slsLOPERAND                 intermLOperand;
            slsROPERAND                 intermROperand;
            gcSHADER_TYPE               binaryDataType;
            gcSHADER_PRECISION          binaryPrecision;
            gctREG_INDEX                tempRegIndex;

            /* Create scalar array data type */
            status = sloCOMPILER_CreateArrayDataType(
                                                    Compiler,
                                                    BinaryExpr->leftOperand->dataType,
                                                    slmDATA_TYPE_vectorSize_GET(BinaryExpr->leftOperand->dataType),
                                                    &arrayDataType);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slmDATA_TYPE_vectorSize_SET(arrayDataType, 0);
            arrayDataType->qualifiers.storage = slvSTORAGE_QUALIFIER_NONE;

            /* Create a symbol for auxiliary scalar array */
            status = sloCOMPILER_CreateAuxiliaryName(Compiler,
                                                     (BinaryExpr->leftOperand->base.vptr->type == slvIR_VARIABLE) ?
                                                     ((sloIR_VARIABLE)BinaryExpr->leftOperand)->name : gcvNULL,
                                                     BinaryExpr->exprBase.base.lineNo,
                                                     BinaryExpr->exprBase.base.stringNo,
                                                     arrayDataType, &scalarArrayName);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Alloc register for auxiliary symbol */
            status = slsNAME_AllocLogicalRegs(Compiler, CodeGenerator, scalarArrayName);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Initialize scalar array with vec component */
            if (LeftParameters->needLOperand)
                slsROPERAND_InitializeWithLOPERAND(&intermROperand, LeftParameters->lOperands);
            if (LeftParameters->needROperand)
                intermROperand = LeftParameters->rOperands[0];

            status = _ConvertVecToAuxiScalarArray(Compiler, CodeGenerator, &intermROperand, scalarArrayName);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Indexed access on scalar array */
            binaryDataType      = scalarArrayName->context.logicalRegs->dataType;
            binaryPrecision     = scalarArrayName->context.logicalRegs->precision;
            tempRegIndex = scalarArrayName->context.logicalRegs->regIndex;
            if (RightParameters->rOperands[0].arrayIndex.mode != slvINDEX_NONE
                || RightParameters->rOperands[0].matrixIndex.mode != slvINDEX_NONE
                || RightParameters->rOperands[0].vectorIndex.mode != slvINDEX_NONE
                || !_IsTempRegQualifier(RightParameters->rOperands[0].u.reg.qualifier))
            {
                _slmGenIndexAssignCode(Compiler,
                                       BinaryExpr->rightOperand->base.lineNo,
                                       BinaryExpr->rightOperand->base.stringNo,
                                       &RightParameters->rOperands[0],
                                       indexRegIndex,
                                       vectorIndexing,
                                       status);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
            else
            {
                indexRegIndex = RightParameters->rOperands[0].u.reg.regIndex;
            }

            if (Parameters->needLOperand)
            {
                for (i = 0; i < Parameters->operandCount; i++)
                {
                    slsIOPERAND_Initialize(&intermIOperand, binaryDataType, binaryPrecision, tempRegIndex);
                    slsLOPERAND_InitializeUsingIOperand(&intermLOperand, &intermIOperand);

                    Parameters->lOperands[i] = intermLOperand;

                    Parameters->lOperands[i].arrayIndex.u.indexRegIndex = indexRegIndex;
                    if(vectorIndexing) {
                        Parameters->lOperands[i].arrayIndex.mode = _ConvVectorIndexToIndexMode(vectorIndexing->u.constant);
                    }
                    else {
                        Parameters->lOperands[i].arrayIndex.mode = slvINDEX_REG;
                    }
                }
            }

            if (Parameters->needROperand)
            {
                for (i = 0; i < Parameters->operandCount; i++)
                {
                    slsIOPERAND_Initialize(&intermIOperand, binaryDataType, binaryPrecision, tempRegIndex);
                    slsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);

                    Parameters->rOperands[i] = intermROperand;

                    Parameters->rOperands[i].arrayIndex.u.indexRegIndex = indexRegIndex;
                    if(vectorIndexing) {
                        Parameters->rOperands[i].arrayIndex.mode = _ConvVectorIndexToIndexMode(vectorIndexing->u.constant);
                    }
                    else {
                        Parameters->rOperands[i].arrayIndex.mode = slvINDEX_REG;
                    }
                }
            }

            /* If vector is going to be written, we should record this vec->array */
            /* transformation, so we can trans them reversely later */
            if (LeftParameters->needLOperand)
            {
                gctPOINTER                  pointer = gcvNULL;

                status = sloCOMPILER_Allocate(
                                            Compiler,
                                            (gctSIZE_T)sizeof(slsVEC2ARRAY),
                                            &pointer);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                BinaryExpr->u.vec2Array = pointer;

                BinaryExpr->u.vec2Array->scalarArrayName = scalarArrayName;
                BinaryExpr->u.vec2Array->vecOperand = LeftParameters->lOperands[0];
            }
        }
    }
    else if (slsDATA_TYPE_IsMat(BinaryExpr->leftOperand->dataType))
    {
        gctBOOL isPerVertexIndex = gcvFALSE;

        gcmASSERT(Parameters->operandCount == 1);

        if ((Parameters->needLOperand && Parameters->lOperands[0].vertexIndex.mode != slvINDEX_NONE) ||
            (Parameters->needROperand && Parameters->rOperands[0].vertexIndex.mode != slvINDEX_NONE))
        {
            isPerVertexIndex = gcvTRUE;
        }
        if (isPerVertexIndex)
        {
            slsNAME                     *scalarArrayName;
            slsDATA_TYPE                *arrayDataType;
            slsIOPERAND                 intermIOperand;
            slsLOPERAND                 intermLOperand;
            slsROPERAND                 intermROperand;
            gcSHADER_TYPE               binaryDataType;
            gcSHADER_PRECISION          binaryPrecision;
            gctREG_INDEX                tempRegIndex;
            slsINDEX *                  vectorIndexing = gcvNULL;

            /* Create scalar array data type */
            status = sloCOMPILER_CreateArrayDataType(
                                                    Compiler,
                                                    BinaryExpr->leftOperand->dataType,
                                                    slmDATA_TYPE_matrixColumnCount_GET(BinaryExpr->leftOperand->dataType),
                                                    &arrayDataType);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slmDATA_TYPE_matrixColumnCount_SET(arrayDataType, 0);
            arrayDataType->qualifiers.storage = slvSTORAGE_QUALIFIER_NONE;

            /* Create a symbol for auxiliary scalar array */
            status = sloCOMPILER_CreateAuxiliaryName(Compiler,
                                                        (BinaryExpr->leftOperand->base.vptr->type == slvIR_VARIABLE) ?
                                                        ((sloIR_VARIABLE)BinaryExpr->leftOperand)->name : gcvNULL,
                                                        BinaryExpr->exprBase.base.lineNo,
                                                        BinaryExpr->exprBase.base.stringNo,
                                                        arrayDataType, &scalarArrayName);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Alloc register for auxiliary symbol */
            status = slsNAME_AllocLogicalRegs(Compiler, CodeGenerator, scalarArrayName);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Initialize scalar array with vec component */
            if (LeftParameters->needLOperand)
                slsROPERAND_InitializeWithLOPERAND(&intermROperand, LeftParameters->lOperands);
            if (LeftParameters->needROperand)
                intermROperand = LeftParameters->rOperands[0];

            status = _ConvertMatrixToAuxiVecArray(Compiler, CodeGenerator, &intermROperand, scalarArrayName, BinaryExpr->leftOperand->dataType);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Indexed access on scalar array */
            binaryDataType      = scalarArrayName->context.logicalRegs->dataType;
            binaryPrecision     = scalarArrayName->context.logicalRegs->precision;
            tempRegIndex = scalarArrayName->context.logicalRegs->regIndex;
            if (RightParameters->rOperands[0].arrayIndex.mode != slvINDEX_NONE
                || RightParameters->rOperands[0].matrixIndex.mode != slvINDEX_NONE
                || RightParameters->rOperands[0].vectorIndex.mode != slvINDEX_NONE
                || !_IsTempRegQualifier(RightParameters->rOperands[0].u.reg.qualifier))
            {
                _slmGenIndexAssignCode(Compiler,
                                        BinaryExpr->rightOperand->base.lineNo,
                                        BinaryExpr->rightOperand->base.stringNo,
                                        &RightParameters->rOperands[0],
                                        indexRegIndex,
                                        vectorIndexing,
                                        status);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
            else
            {
                indexRegIndex = RightParameters->rOperands[0].u.reg.regIndex;
            }

            if (Parameters->needLOperand)
            {
                for (i = 0; i < Parameters->operandCount; i++)
                {
                    slsIOPERAND_Initialize(&intermIOperand, binaryDataType, binaryPrecision, tempRegIndex);
                    slsLOPERAND_InitializeUsingIOperand(&intermLOperand, &intermIOperand);

                    Parameters->lOperands[i] = intermLOperand;

                    Parameters->lOperands[i].arrayIndex.u.indexRegIndex = indexRegIndex;
                    if(vectorIndexing) {
                        Parameters->lOperands[i].arrayIndex.mode = _ConvVectorIndexToIndexMode(vectorIndexing->u.constant);
                    }
                    else {
                        Parameters->lOperands[i].arrayIndex.mode = slvINDEX_REG;
                    }
                }
            }

            if (Parameters->needROperand)
            {
                for (i = 0; i < Parameters->operandCount; i++)
                {
                    slsIOPERAND_Initialize(&intermIOperand, binaryDataType, binaryPrecision, tempRegIndex);
                    slsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);

                    Parameters->rOperands[i] = intermROperand;

                    Parameters->rOperands[i].arrayIndex.u.indexRegIndex = indexRegIndex;
                    if(vectorIndexing) {
                        Parameters->rOperands[i].arrayIndex.mode = _ConvVectorIndexToIndexMode(vectorIndexing->u.constant);
                    }
                    else {
                        Parameters->rOperands[i].arrayIndex.mode = slvINDEX_REG;
                    }
                }
            }

            /* If vector is going to be written, we should record this vec->array */
            /* transformation, so we can trans them reversely later */
            if (LeftParameters->needLOperand)
            {
                gctPOINTER                  pointer = gcvNULL;

                status = sloCOMPILER_Allocate(
                                            Compiler,
                                            (gctSIZE_T)sizeof(slsVEC2ARRAY),
                                            &pointer);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                BinaryExpr->u.mat2Array = pointer;

                BinaryExpr->u.mat2Array->scalarArrayName = scalarArrayName;
                BinaryExpr->u.mat2Array->vecOperand = LeftParameters->lOperands[0];
            }

            gcmFOOTER();
            return status;
        }
        else if (LeftParameters->rOperands &&
            (LeftParameters->rOperands[0].arrayIndex.mode == slvINDEX_REG ||
             LeftParameters->rOperands[0].arrayIndex.mode == slvINDEX_REG_Y ||
             LeftParameters->rOperands[0].arrayIndex.mode == slvINDEX_REG_Z ||
             LeftParameters->rOperands[0].arrayIndex.mode == slvINDEX_REG_W))
        {
            indexRegIndex = slNewTempRegs(Compiler, 1);

            status = _GenIndexAddCode(
                                    Compiler,
                                    BinaryExpr->rightOperand->base.lineNo,
                                    BinaryExpr->rightOperand->base.stringNo,
                                    indexRegIndex,
                                    LeftParameters->rOperands[0].arrayIndex.u.indexRegIndex,
                                    &RightParameters->rOperands[0],
                                    LeftParameters->rOperands[0].arrayIndex.mode);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /*LeftParameters->rOperands[0].arrayIndex.mode = slvINDEX_NONE;*/
        }
        else if (RightParameters->rOperands[0].arrayIndex.mode != slvINDEX_NONE
                    || RightParameters->rOperands[0].matrixIndex.mode != slvINDEX_NONE
                    || RightParameters->rOperands[0].vectorIndex.mode != slvINDEX_NONE
                    || !_IsTempRegQualifier(RightParameters->rOperands[0].u.reg.qualifier))
        {

            if ((Parameters->needROperand && _IsROperandStorageBlockMember(Compiler, &LeftParameters->rOperands[0])) ||
                (Parameters->needLOperand && _IsLOperandStorageBlockMember(Compiler, &LeftParameters->lOperands[0])))

            {
                slsLOGICAL_REG *blockMemberReg;

                if(Parameters->needROperand)
                {
                    blockMemberReg = &LeftParameters->rOperands[0].u.reg;
                }
                else
                {
                    blockMemberReg = &LeftParameters->lOperands[0].reg;
                }
                elementDataTypeSize = GetVariableMatrixStride(blockMemberReg->u.variable);
                gcmASSERT(elementDataTypeSize != -1);

                indexRegIndex = slNewTempRegs(Compiler, 1);

                status = _GenIndexScaleCode(Compiler,
                                            BinaryExpr->rightOperand->base.lineNo,
                                            BinaryExpr->rightOperand->base.stringNo,
                                            indexRegIndex,
                                            &RightParameters->rOperands[0],
                                            elementDataTypeSize,
                                            0, /* (BinaryExpr->leftOperand->dataType->fieldSpace) ? LeftParameters->offsetInParent : 0, */
                                            IndexRegIndexInParent,
                                            IndexRegIndexMode);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                gcmASSERT(Parameters->operandCount == 1);
                if (Parameters->needLOperand)
                {
                    for (i = 0; i < Parameters->operandCount; i++)
                    {
                        Parameters->lOperands[i] = LeftParameters->lOperands[i];
                        Parameters->lOperands[i].matrixIndex.mode = slvINDEX_NONE;

                        Parameters->lOperands[i].dataType =
                        Parameters->lOperands[i].reg.dataType = Parameters->dataTypes[i];
                        Parameters->lOperands[i].arrayIndex.u.indexRegIndex = indexRegIndex;

                        Parameters->lOperands[i].arrayIndex.mode = slvINDEX_REG;
                    }
                }

                if (Parameters->needROperand)
                {
                    for (i = 0; i < Parameters->operandCount; i++)
                    {
                        Parameters->rOperands[i] = LeftParameters->rOperands[i];
                        Parameters->rOperands[i].matrixIndex.mode = slvINDEX_NONE;

                        Parameters->rOperands[i].dataType =
                        Parameters->rOperands[i].u.reg.dataType = Parameters->dataTypes[i];
                        Parameters->rOperands[i].arrayIndex.u.indexRegIndex = indexRegIndex;

                        Parameters->rOperands[i].arrayIndex.mode = slvINDEX_REG;
                    }
                }
                gcmFOOTER_NO();
                return gcvSTATUS_OK;
            }
            else
            {
                _slmGenIndexAssignCode(Compiler,
                                       BinaryExpr->rightOperand->base.lineNo,
                                       BinaryExpr->rightOperand->base.stringNo,
                                       &RightParameters->rOperands[0],
                                       indexRegIndex,
                                       vectorIndexing,
                                       status);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
        }
        else
        {
            indexRegIndex = RightParameters->rOperands[0].u.reg.regIndex;
        }

        if (Parameters->needLOperand)
        {
            Parameters->lOperands[0] = LeftParameters->lOperands[0];

            Parameters->lOperands[0].dataType =
                            gcGetMatrixColumnDataType(LeftParameters->lOperands[0].dataType);

            Parameters->lOperands[0].matrixIndex.u.indexRegIndex = indexRegIndex;
            if(vectorIndexing) {
                Parameters->lOperands[0].matrixIndex.mode = _ConvVectorIndexToIndexMode(vectorIndexing->u.constant);
            }
            else {
                Parameters->lOperands[0].matrixIndex.mode = slvINDEX_REG;
            }
        }

        if (Parameters->needROperand)
        {
            Parameters->rOperands[0] = LeftParameters->rOperands[0];

            Parameters->rOperands[0].dataType =
                            gcGetMatrixColumnDataType(LeftParameters->rOperands[0].dataType);

            Parameters->rOperands[0].matrixIndex.u.indexRegIndex = indexRegIndex;
            if(vectorIndexing) {
                Parameters->rOperands[0].matrixIndex.mode = _ConvVectorIndexToIndexMode(vectorIndexing->u.constant);
            }
            else {
                Parameters->rOperands[0].matrixIndex.mode = slvINDEX_REG;
            }
        }
    }
    else
    {
        gcmASSERT(slsDATA_TYPE_IsArray(BinaryExpr->leftOperand->dataType));

        if (Parameters->operandCount > 1 || slsDATA_TYPE_IsMat(BinaryExpr->exprBase.dataType) ||
            (RightParameters->rOperands[0].arrayIndex.mode != slvINDEX_NONE ||
             RightParameters->rOperands[0].matrixIndex.mode != slvINDEX_NONE ||
             RightParameters->rOperands[0].vectorIndex.mode != slvINDEX_NONE ||
             !_IsTempRegQualifier(RightParameters->rOperands[0].u.reg.qualifier)) ||
             IndexRegIndexInParent != (gctREG_INDEX)~0
             ||
             ((Parameters->needROperand && _IsROperandInterfaceBlockMember(Compiler, &LeftParameters->rOperands[0])) ||
              (Parameters->needLOperand && _IsLOperandInterfaceBlockMember(Compiler, &LeftParameters->lOperands[0])))
            )
        {
            indexRegIndex = 0;

            if ((Parameters->needROperand && _IsROperandInterfaceBlockMember(Compiler, &LeftParameters->rOperands[0])) ||
                (Parameters->needLOperand && _IsLOperandInterfaceBlockMember(Compiler, &LeftParameters->lOperands[0])))

            {
                _GetIOElementStride(Compiler, BinaryExpr, LeftParameters, Parameters, &elementDataTypeSize);
            }
            else
            {
                for (i = 0, elementDataTypeSize = 0; i < Parameters->operandCount; i++)
                {
                    elementDataTypeSize += gcGetDataTypeSize(Parameters->dataTypes[i]);
                }
            }

            if(IndexRegIndexInParent == (gctREG_INDEX)~0  &&
                elementDataTypeSize == 1) {
                _slmGenIndexAssignCode(Compiler,
                                        BinaryExpr->rightOperand->base.lineNo,
                                        BinaryExpr->rightOperand->base.stringNo,
                                        &RightParameters->rOperands[0],
                                        indexRegIndex,
                                        vectorIndexing,
                                        status);
            }
            else {
                indexRegIndex = slNewTempRegs(Compiler, 1);

                status = _GenIndexScaleCode(Compiler,
                                            BinaryExpr->rightOperand->base.lineNo,
                                            BinaryExpr->rightOperand->base.stringNo,
                                            indexRegIndex,
                                            &RightParameters->rOperands[0],
                                            elementDataTypeSize,
                                            0, /* (BinaryExpr->leftOperand->dataType->fieldSpace) ? LeftParameters->offsetInParent : 0, */
                                            IndexRegIndexInParent,
                                            IndexRegIndexMode);
            }

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else
        {
            indexRegIndex = RightParameters->rOperands[0].u.reg.regIndex;
        }

        /* check for situation with an array of constant vectors being indexed into */
        if (LeftParameters->constantVariable && Parameters->needROperand) {
            slsLOGICAL_REG *logicalRegs;

            if (LeftParameters->constantVariable->context.logicalRegCount == 0) {
                 slsROPERAND constantROperand[1];
                 slsIOPERAND intermIOperand[1];
                 slsLOPERAND intermLOperand[1];
                 slsDATA_TYPE *newDataType;
                 slsDATA_TYPE *savedDataType;

                 status = sloCOMPILER_CloneDataType(Compiler,
                                                    slvSTORAGE_QUALIFIER_NONE,
                                                    LeftParameters->constantVariable->dataType->qualifiers.precision,
                                                    LeftParameters->constantVariable->dataType,
                                                    &newDataType);
                 if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                 savedDataType = LeftParameters->constantVariable->dataType;
                 LeftParameters->constantVariable->dataType = newDataType;

                 status = slsNAME_AllocLogicalRegs(Compiler,
                                                   CodeGenerator,
                                                   LeftParameters->constantVariable);
                 if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                 gcmASSERT(LeftParameters->constantVariable->context.logicalRegs &&
                           LeftParameters->constantVariable->context.logicalRegCount == LeftParameters->operandCount);

                 LeftParameters->constantVariable->dataType = savedDataType;

                 for (i = 0, logicalRegs = LeftParameters->constantVariable->context.logicalRegs;
                          i < LeftParameters->operandCount; i++, logicalRegs++) {

                     /*load constant into a temp */
                     slsROPERAND_InitializeConstant(constantROperand,
                                                    logicalRegs->dataType,
                                                    logicalRegs->precision,
                                                    LeftParameters->rOperands[i].u.constant.valueCount,
                                                    LeftParameters->rOperands[i].u.constant.values);

                     slsIOPERAND_Initialize(intermIOperand,
                                            logicalRegs->dataType,
                                            logicalRegs->precision,
                                            logicalRegs->regIndex);

                     slsLOPERAND_InitializeUsingIOperand(intermLOperand, intermIOperand);

                     status = slGenAssignCode(Compiler,
                                              BinaryExpr->rightOperand->base.lineNo,
                                              BinaryExpr->rightOperand->base.stringNo,
                                              intermLOperand,
                                              constantROperand);
                     if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
            }

            gcmASSERT (LeftParameters->constantVariable->context.logicalRegs);
            for (i = 0, logicalRegs = LeftParameters->constantVariable->context.logicalRegs;
                 i < LeftParameters->operandCount; i++, logicalRegs++) {
                LeftParameters->rOperands[i].isReg = gcvTRUE;
                LeftParameters->rOperands[i].u.reg = *logicalRegs;
            }
        }

        lIndexRegIndex = rIndexRegIndex = indexRegIndex;
        /* If there is already an array index existed, we need to add this array index. */
        if (Parameters->needLOperand && LeftParameters->lOperands[0].arrayIndex.mode == slvINDEX_CONSTANT)
        {
            slsIOPERAND intermIOperand[1];
            slsROPERAND intermROperand[2];

            slsIOPERAND_New(Compiler,
                            intermIOperand,
                            gcSHADER_INTEGER_X1,
                            gcSHADER_PRECISION_DEFAULT);
            slsROPERAND_InitializeIntOrIVecConstant(&intermROperand[0],
                                                    gcSHADER_INTEGER_X1,
                                                    gcSHADER_PRECISION_DEFAULT,
                                                    LeftParameters->lOperands[0].arrayIndex.u.constant);
            slsROPERAND_InitializeTempReg(&intermROperand[1],
                                          slvSTORAGE_QUALIFIER_NONE,
                                          gcSHADER_INTEGER_X1,
                                          gcSHADER_PRECISION_MEDIUM,
                                          lIndexRegIndex);

            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_ADD,
                                             intermIOperand,
                                             &intermROperand[0],
                                             &intermROperand[1]);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            lIndexRegIndex = intermIOperand->tempRegIndex;
        }

        if (Parameters->needROperand && LeftParameters->rOperands[0].arrayIndex.mode == slvINDEX_CONSTANT)
        {
            slsIOPERAND intermIOperand[1];
            slsROPERAND intermROperand[2];

            slsIOPERAND_New(Compiler,
                            intermIOperand,
                            gcSHADER_INTEGER_X1,
                            gcSHADER_PRECISION_DEFAULT);

            slsROPERAND_InitializeIntOrIVecConstant(&intermROperand[0],
                                                    gcSHADER_INTEGER_X1,
                                                    gcSHADER_PRECISION_DEFAULT,
                                                    LeftParameters->rOperands[0].arrayIndex.u.constant);
            slsROPERAND_InitializeTempReg(&intermROperand[1],
                                          slvSTORAGE_QUALIFIER_NONE,
                                          gcSHADER_INTEGER_X1,
                                          gcSHADER_PRECISION_MEDIUM,
                                          lIndexRegIndex);

            status = slGenArithmeticExprCode(Compiler,
                                             0,
                                             0,
                                             slvOPCODE_ADD,
                                             intermIOperand,
                                             &intermROperand[0],
                                             &intermROperand[1]);
            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            rIndexRegIndex = intermIOperand->tempRegIndex;
        }

        if (Parameters->needLOperand)
        {
            for (i = 0; i < Parameters->operandCount; i++)
            {
                gcmASSERT(LeftParameters->lOperands[i].matrixIndex.mode == slvINDEX_NONE);

                Parameters->lOperands[i] = LeftParameters->lOperands[i];

                Parameters->lOperands[i].arrayIndex.u.indexRegIndex = lIndexRegIndex;

                if (vectorIndexing)
                {
                    Parameters->lOperands[i].arrayIndex.mode = _ConvVectorIndexToIndexMode(vectorIndexing->u.constant);
                }
                else
                {
                    Parameters->lOperands[i].arrayIndex.mode = slvINDEX_REG;
                }

                Parameters->lOperands[i].indexLevel =
                    _UpdateIndexLevel(BinaryExpr->leftOperand->dataType,
                                      Parameters->lOperands[i].indexLevel);
            }
        }

        if (Parameters->needROperand)
        {
            for (i = 0; i < Parameters->operandCount; i++)
            {
                gcmASSERT(LeftParameters->rOperands[i].matrixIndex.mode == slvINDEX_NONE);

                Parameters->rOperands[i] = LeftParameters->rOperands[i];

                Parameters->rOperands[i].arrayIndex.u.indexRegIndex = rIndexRegIndex;

                if (vectorIndexing)
                {
                    Parameters->rOperands[i].arrayIndex.mode = _ConvVectorIndexToIndexMode(vectorIndexing->u.constant);
                }
                else
                {
                    Parameters->rOperands[i].arrayIndex.mode = slvINDEX_REG;
                }

                Parameters->rOperands[i].indexLevel =
                    _UpdateIndexLevel(BinaryExpr->leftOperand->dataType,
                                      Parameters->rOperands[i].indexLevel);
            }
        }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenSubscriptCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  leftParameters, rightParameters;
    gctBOOL                 isPerVertexIndex = gcvFALSE;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &leftParameters,
                                    Parameters->needLOperand,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->leftOperand->base,
                                &CodeGenerator->visitor,
                                &leftParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &rightParameters,
                                    gcvFALSE,
                                    Parameters->needLOperand || Parameters->needROperand);

    rightParameters.hint = slvGEN_INDEX_CODE;

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->rightOperand->base,
                                &CodeGenerator->visitor,
                                &rightParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the subscripting code */
    if (Parameters->needLOperand || Parameters->needROperand)
    {
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        BinaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmASSERT(rightParameters.operandCount == 1);
        gcmASSERT(rightParameters.rOperands != gcvNULL);

        status = _IsExprPerVertexPatchArray(Compiler,
                                            BinaryExpr->leftOperand,
                                            &isPerVertexIndex);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Check if the left ooperand is per-vertex indexed. */
        if (isPerVertexIndex)
        {
            if (slsDATA_TYPE_IsUnderlyingIOBlock(BinaryExpr->leftOperand->dataType))
                slsDATA_TYPE_SetPerVertexArray(BinaryExpr->exprBase.dataType, gcvTRUE);
            /*
            ** If a per-vertex output variable is used as an l-value,
            ** it is a compile-time error if the expression
            ** indicating the vertex index is not the identifier gl_InvocationID.
            */
            if (Parameters->needLOperand)
            {
                sloIR_VARIABLE variable;
                gctBOOL hasError = gcvFALSE;

                if (sloIR_OBJECT_GetType(&BinaryExpr->rightOperand->base) != slvIR_VARIABLE)
                {
                    hasError = gcvTRUE;
                }

                if (!hasError)
                {
                    variable  = (sloIR_VARIABLE)(&BinaryExpr->rightOperand->base);
                    if (variable->name == gcvNULL || variable->name->symbol == gcvNULL ||
                        !gcmIS_SUCCESS(gcoOS_StrCmp(variable->name->symbol, "gl_InvocationID")))
                    {
                        hasError = gcvTRUE;
                    }
                }

                if (hasError)
                {
                    gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                                    BinaryExpr->exprBase.base.lineNo,
                                                    BinaryExpr->exprBase.base.stringNo,
                                                    slvREPORT_ERROR,
                                                    "Must use identifier gl_InvocationID as the vertex index "
                                                    "when writing value to a per-vertex output variable."
                                                    ));
                    status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                    gcmFOOTER();
                    return status;
                }
            }

            status = _GetVertexOrPatchIndexSubScriptCode(Compiler,
                                                         CodeGenerator,
                                                         BinaryExpr,
                                                         &leftParameters,
                                                         &rightParameters,
                                                         Parameters);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else
        {
            if (!rightParameters.rOperands[0].isReg)
            {
                status = _GetConstantSubscriptCode(Compiler,
                                                   CodeGenerator,
                                                   BinaryExpr,
                                                   &leftParameters,
                                                   &rightParameters,
                                                   Parameters);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
            else
            {
                status = _GetNonConstantSubscriptCode(Compiler,
                                                      CodeGenerator,
                                                      BinaryExpr,
                                                      &leftParameters,
                                                      &rightParameters,
                                                      Parameters);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
        }
    }

    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenArithmeticCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  leftParameters, rightParameters;
    gctUINT                 i;
    slsIOPERAND             iOperand;
    sleOPCODE               opcode;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &leftParameters,
                                    gcvFALSE,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->leftOperand->base,
                                &CodeGenerator->visitor,
                                &leftParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &rightParameters,
                                    gcvFALSE,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->rightOperand->base,
                                &CodeGenerator->visitor,
                                &rightParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the arithmetic code */
    if (Parameters->needROperand)
    {
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        BinaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        for (i = 0; i < Parameters->operandCount; i++)
        {
            slsIOPERAND_New(Compiler,
                            &iOperand,
                            Parameters->dataTypes[i],
                            GetHigherPrecison(rightParameters.rOperands[0].u.reg.precision,
                                              Parameters->rOperands[0].u.reg.precision));

            switch (BinaryExpr->type)
            {
            case slvBINARY_ADD: opcode = slvOPCODE_ADD; break;
            case slvBINARY_SUB: opcode = slvOPCODE_SUB; break;
            case slvBINARY_MUL: opcode = slvOPCODE_MUL; break;
            case slvBINARY_MOD: opcode = slvOPCODE_MOD; break;
            case slvBINARY_DIV:
                 opcode = slvOPCODE_DIV;
                 if (sloCOMPILER_IsHaltiVersion(Compiler) &&
                     slmDATA_TYPE_IsIntegerType(BinaryExpr->exprBase.dataType)) {
                     opcode = slvOPCODE_IDIV;
                 }
                 break;

            default:
                gcmASSERT(0);
                status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                gcmFOOTER();
                return status;
            }

            status = slGenArithmeticExprCode(
                                            Compiler,
                                            BinaryExpr->exprBase.base.lineNo,
                                            BinaryExpr->exprBase.base.stringNo,
                                            opcode,
                                            &iOperand,
                                            leftParameters.rOperands + i,
                                            rightParameters.rOperands + i);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slsROPERAND_InitializeUsingIOperand(Parameters->rOperands + i, &iOperand);
        }
    }

    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenRelationalCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  leftParameters, rightParameters;
    slsIOPERAND             intermIOperand;
    sleOPCODE               opcode;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &leftParameters,
                                    gcvFALSE,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->leftOperand->base,
                                &CodeGenerator->visitor,
                                &leftParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &rightParameters,
                                    gcvFALSE,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->rightOperand->base,
                                &CodeGenerator->visitor,
                                &rightParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        gcmASSERT(leftParameters.operandCount == 1);
        gcmASSERT(rightParameters.operandCount == 1);

        switch (BinaryExpr->type)
        {
        case slvBINARY_LESS_THAN:           opcode = slvOPCODE_LESS_THAN;           break;
        case slvBINARY_LESS_THAN_EQUAL:     opcode = slvOPCODE_LESS_THAN_EQUAL;     break;
        case slvBINARY_GREATER_THAN:        opcode = slvOPCODE_GREATER_THAN;        break;
        case slvBINARY_GREATER_THAN_EQUAL:  opcode = slvOPCODE_GREATER_THAN_EQUAL;  break;

        default:
            gcmASSERT(0);
            status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            gcmFOOTER();
            return status;
        }

        /* less-than/less-than-equal/greater-than/greater-than-equal t0, operand */
        slsIOPERAND_New(Compiler, &intermIOperand, gcSHADER_BOOLEAN_X1, gcSHADER_PRECISION_MEDIUM);

        status = slGenGenericCode2(
                                Compiler,
                                BinaryExpr->exprBase.base.lineNo,
                                BinaryExpr->exprBase.base.stringNo,
                                opcode,
                                &intermIOperand,
                                &leftParameters.rOperands[0],
                                &rightParameters.rOperands[0]);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Return t0 */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        BinaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &intermIOperand);
    }

    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenEqualityCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  leftParameters, rightParameters;
    slsIOPERAND             intermIOperand;
    slsLOPERAND             intermLOperand;
    slsROPERAND             constROperand;
    sleOPCODE               opcode;
    sleCONDITION            condition;
    slsSELECTION_CONTEXT    selectionContext;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &leftParameters,
                                    gcvFALSE,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->leftOperand->base,
                                &CodeGenerator->visitor,
                                &leftParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &rightParameters,
                                    gcvFALSE,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->rightOperand->base,
                                &CodeGenerator->visitor,
                                &rightParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        slsIOPERAND_New(Compiler, &intermIOperand, gcSHADER_BOOLEAN_X1, gcSHADER_PRECISION_MEDIUM);

        if (slsDATA_TYPE_IsScalar(BinaryExpr->leftOperand->dataType))
        {
            /* Get the opcode */
            switch (BinaryExpr->type)
            {
            case slvBINARY_EQUAL:       opcode = slvOPCODE_EQUAL;       break;
            case slvBINARY_NOT_EQUAL:
            case slvBINARY_XOR:         opcode = slvOPCODE_NOT_EQUAL;   break;

            default:
                gcmASSERT(0);
                status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                gcmFOOTER();
                return status;
            }

            /* equal/not-equal t0, operand */
            status = slGenGenericCode2(
                                    Compiler,
                                    BinaryExpr->exprBase.base.lineNo,
                                    BinaryExpr->exprBase.base.stringNo,
                                    opcode,
                                    &intermIOperand,
                                    &leftParameters.rOperands[0],
                                    &rightParameters.rOperands[0]);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else
        {
            gcmASSERT(leftParameters.operandCount == rightParameters.operandCount);

            slsLOPERAND_InitializeUsingIOperand(&intermLOperand, &intermIOperand);

            /* Get the condition code */
            switch (BinaryExpr->type)
            {
            case slvBINARY_EQUAL:
                condition = slvCONDITION_EQUAL;
                break;

            case slvBINARY_NOT_EQUAL:
            case slvBINARY_XOR:
                condition = slvCONDITION_NOT_EQUAL;
                break;

            default:
                gcmASSERT(0);
                status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                gcmFOOTER();
                return status;
            }

            /* Selection Begin */
            status = slDefineSelectionBegin(
                                            Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectionContext);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Generate the code of the condition expression */
            status = _GenMultiplyEqualityConditionCode(
                                                        Compiler,
                                                        CodeGenerator,
                                                        BinaryExpr->exprBase.base.lineNo,
                                                        BinaryExpr->exprBase.base.stringNo,
                                                        _GetSelectionConditionLabel(&selectionContext),
                                                        gcvFALSE,
                                                        condition,
                                                        leftParameters.operandCount,
                                                        leftParameters.dataTypes,
                                                        leftParameters.rOperands,
                                                        rightParameters.rOperands);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Generate the code of the true operand */
            status = slDefineSelectionTrueOperandBegin(
                                                    Compiler,
                                                    CodeGenerator,
                                                    &selectionContext);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slsROPERAND_InitializeBoolOrBVecConstant(&constROperand,
                                                     gcSHADER_BOOLEAN_X1,
                                                     gcSHADER_PRECISION_MEDIUM,
                                                     gcvTRUE);

            status = slGenAssignCode(
                                    Compiler,
                                    BinaryExpr->exprBase.base.lineNo,
                                    BinaryExpr->exprBase.base.stringNo,
                                    &intermLOperand,
                                    &constROperand);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = slDefineSelectionTrueOperandEnd(
                                                    Compiler,
                                                    CodeGenerator,
                                                    &selectionContext,
                                                    gcvFALSE);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Generate the code of the false operand */
            status = slDefineSelectionFalseOperandBegin(
                                                    Compiler,
                                                    CodeGenerator,
                                                    &selectionContext);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slsROPERAND_InitializeBoolOrBVecConstant(&constROperand,
                                                     gcSHADER_BOOLEAN_X1,
                                                     gcSHADER_PRECISION_MEDIUM,
                                                     gcvFALSE);

            status = slGenAssignCode(
                                    Compiler,
                                    BinaryExpr->exprBase.base.lineNo,
                                    BinaryExpr->exprBase.base.stringNo,
                                    &intermLOperand,
                                    &constROperand);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            status = slDefineSelectionFalseOperandEnd(
                                                    Compiler,
                                                    CodeGenerator,
                                                    &selectionContext);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            /* Selection End */
            status = slDefineSelectionEnd(
                                        Compiler,
                                        CodeGenerator,
                                        &selectionContext);

        }

        /* Return t0 */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        BinaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &intermIOperand);
    }

    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenAndCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsSELECTION_CONTEXT    selectionContext = {0};
    slsGEN_CODE_PARAMETERS  rightParameters;
    slsIOPERAND             intermIOperand;
    slsLOPERAND             intermLOperand;
    slsROPERAND             constROperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(BinaryExpr->leftOperand);
    gcmASSERT(BinaryExpr->rightOperand);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    if (Parameters->needROperand)
    {
        gcmASSERT(BinaryExpr->exprBase.dataType);

        /* Allocate the operand(s) */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        BinaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmASSERT(Parameters->operandCount == 1);

        slsIOPERAND_New(Compiler,
                        &intermIOperand,
                        Parameters->dataTypes[0],
                        Parameters->rOperands[0].u.reg.precision);
        slsLOPERAND_InitializeUsingIOperand(&intermLOperand, &intermIOperand);
        slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &intermIOperand);
    }

    /* Selection Begin */
    status = slDefineSelectionBegin(
                                    Compiler,
                                    CodeGenerator,
                                    Parameters->needROperand,
                                    &selectionContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the condition expression */
    status = _GenConditionCode(
                            Compiler,
                            CodeGenerator,
                            BinaryExpr->leftOperand,
                            _GetSelectionConditionLabel(&selectionContext),
                            gcvFALSE);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the true operand */
    status = slDefineSelectionTrueOperandBegin(
                                            Compiler,
                                            CodeGenerator,
                                            &selectionContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &rightParameters,
                                    gcvFALSE,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->rightOperand->base,
                                &CodeGenerator->visitor,
                                &rightParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        status = slGenAssignCode(
                                Compiler,
                                BinaryExpr->exprBase.base.lineNo,
                                BinaryExpr->exprBase.base.stringNo,
                                &intermLOperand,
                                &rightParameters.rOperands[0]);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    status = slDefineSelectionTrueOperandEnd(
                                            Compiler,
                                            CodeGenerator,
                                            &selectionContext,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the false operand */
    if (Parameters->needROperand)
    {
        status = slDefineSelectionFalseOperandBegin(
                                                Compiler,
                                                CodeGenerator,
                                                &selectionContext);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsROPERAND_InitializeBoolOrBVecConstant(&constROperand,
                                                 gcSHADER_BOOLEAN_X1,
                                                 gcSHADER_PRECISION_MEDIUM,
                                                 gcvFALSE);

        status = slGenAssignCode(
                                Compiler,
                                BinaryExpr->exprBase.base.lineNo,
                                BinaryExpr->exprBase.base.stringNo,
                                &intermLOperand,
                                &constROperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        status = slDefineSelectionFalseOperandEnd(
                                                Compiler,
                                                CodeGenerator,
                                                &selectionContext);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    /* Selection End */
    status = slDefineSelectionEnd(
                                Compiler,
                                CodeGenerator,
                               &selectionContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenOrCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsSELECTION_CONTEXT    selectionContext = {0};
    slsGEN_CODE_PARAMETERS  rightParameters;
    slsIOPERAND             intermIOperand;
    slsLOPERAND             intermLOperand;
    slsROPERAND             constROperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(BinaryExpr->leftOperand);
    gcmASSERT(BinaryExpr->rightOperand);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    if (Parameters->needROperand)
    {
        gcmASSERT(BinaryExpr->exprBase.dataType);

        /* Allocate the operand(s) */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        BinaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmASSERT(Parameters->operandCount == 1);

        slsIOPERAND_New(Compiler,
                        &intermIOperand,
                        Parameters->dataTypes[0],
                        Parameters->rOperands[0].u.reg.precision);
        slsLOPERAND_InitializeUsingIOperand(&intermLOperand, &intermIOperand);
        slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &intermIOperand);
    }

    /* Selection Begin */
    status = slDefineSelectionBegin(
                                    Compiler,
                                    CodeGenerator,
                                    Parameters->needROperand,
                                    &selectionContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the condition expression */
    status = _GenConditionCode(
                            Compiler,
                            CodeGenerator,
                            BinaryExpr->leftOperand,
                            _GetSelectionConditionLabel(&selectionContext),
                            gcvTRUE);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the true operand */
    status = slDefineSelectionTrueOperandBegin(
                                            Compiler,
                                            CodeGenerator,
                                            &selectionContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &rightParameters,
                                    gcvFALSE,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->rightOperand->base,
                                &CodeGenerator->visitor,
                                &rightParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        status = slGenAssignCode(
                                Compiler,
                                BinaryExpr->exprBase.base.lineNo,
                                BinaryExpr->exprBase.base.stringNo,
                                &intermLOperand,
                                &rightParameters.rOperands[0]);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    status = slDefineSelectionTrueOperandEnd(
                                            Compiler,
                                            CodeGenerator,
                                            &selectionContext,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the false operand */
    if (Parameters->needROperand)
    {
        status = slDefineSelectionFalseOperandBegin(
                                                Compiler,
                                                CodeGenerator,
                                                &selectionContext);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsROPERAND_InitializeBoolOrBVecConstant(&constROperand,
                                                 gcSHADER_BOOLEAN_X1,
                                                 gcSHADER_PRECISION_MEDIUM,
                                                 gcvTRUE);

        status = slGenAssignCode(
                                Compiler,
                                BinaryExpr->exprBase.base.lineNo,
                                BinaryExpr->exprBase.base.stringNo,
                                &intermLOperand,
                                &constROperand);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        status = slDefineSelectionFalseOperandEnd(
                                                Compiler,
                                                CodeGenerator,
                                                &selectionContext);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    /* Selection End */
    status = slDefineSelectionEnd(
                                Compiler,
                                CodeGenerator,
                                &selectionContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenBitwiseCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS    status;
    slsGEN_CODE_PARAMETERS    leftParameters, rightParameters;
    gctUINT        i;
    slsIOPERAND    iOperand;
    sleOPCODE    opcode;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(&leftParameters,
                      gcvFALSE,
                      Parameters->needROperand);

    status = sloIR_OBJECT_Accept(Compiler,
                     &BinaryExpr->leftOperand->base,
                     &CodeGenerator->visitor,
                     &leftParameters);

    if (gcmIS_ERROR(status)) return status;

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    slsGEN_CODE_PARAMETERS_Initialize(&rightParameters,
                      gcvFALSE,
                      Parameters->needROperand);

    status = sloIR_OBJECT_Accept(Compiler,
                     &BinaryExpr->rightOperand->base,
                     &CodeGenerator->visitor,
                     &rightParameters);
    if (gcmIS_ERROR(status)) return status;

    /* Generate the bit-wise code */
    if (Parameters->needROperand)
    {
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(Compiler,
                                 Parameters,
                                 BinaryExpr->exprBase.dataType);
        if (gcmIS_ERROR(status)) {gcmFOOTER(); return status;}

        for (i = 0; i < Parameters->operandCount; i++)
        {
                        slsIOPERAND_New(Compiler,
                                        &iOperand,
                                        Parameters->dataTypes[i],
                                        Parameters->rOperands[i].u.reg.precision);

            switch (BinaryExpr->type)
            {
            case slvBINARY_BITWISE_AND:    opcode = slvOPCODE_BITWISE_AND; break;
            case slvBINARY_BITWISE_OR:    opcode = slvOPCODE_BITWISE_OR; break;
            case slvBINARY_BITWISE_XOR:    opcode = slvOPCODE_BITWISE_XOR; break;

            default:
                gcmASSERT(0);
                                status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                                gcmFOOTER();
                                return status;
            }

            status = slGenGenericCode2(Compiler,
                           BinaryExpr->exprBase.base.lineNo,
                           BinaryExpr->exprBase.base.stringNo,
                           opcode,
                           &iOperand,
                           leftParameters.rOperands + i,
                           rightParameters.rOperands + i);
                if (gcmIS_ERROR(status)) {gcmFOOTER(); return status;}

            slsROPERAND_InitializeUsingIOperand(Parameters->rOperands + i, &iOperand);
        }
    }

    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenShiftCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS    status;
    slsGEN_CODE_PARAMETERS operandsParameters[2];
    slsIOPERAND    iOperand;
    sleOPCODE    opcode;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(&operandsParameters[0],
                      gcvFALSE,
                      Parameters->needROperand);

    status = sloIR_OBJECT_Accept(Compiler,
                     &BinaryExpr->leftOperand->base,
                     &CodeGenerator->visitor,
                     &operandsParameters[0]);
    if (gcmIS_ERROR(status)) {gcmFOOTER(); return status;}

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    slsGEN_CODE_PARAMETERS_Initialize(&operandsParameters[1],
                      gcvFALSE,
                      Parameters->needROperand);

    status = sloIR_OBJECT_Accept(Compiler,
                     &BinaryExpr->rightOperand->base,
                     &CodeGenerator->visitor,
                     &operandsParameters[1]);
    if (gcmIS_ERROR(status)) {
       slsGEN_CODE_PARAMETERS_Finalize(&operandsParameters[0]);
       gcmFOOTER();
       return status;
    }

    /* Generate the shift code */
    if (Parameters->needROperand) {
        gcmONERROR(slsGEN_CODE_PARAMETERS_AllocateOperands(Compiler,
                                   Parameters,
                                   BinaryExpr->exprBase.dataType));

        gcmASSERT(Parameters->operandCount == 1);
                slsIOPERAND_New(Compiler,
                                &iOperand,
                                Parameters->dataTypes[0],
                                Parameters->rOperands[0].u.reg.precision);

        switch (BinaryExpr->type) {
        case slvBINARY_RSHIFT:
           opcode = slvOPCODE_RSHIFT;
           break;

        case slvBINARY_LSHIFT:
           opcode = slvOPCODE_LSHIFT;
           break;

        default:
           gcmASSERT(0);
           status = gcvSTATUS_INVALID_ARGUMENT;
               gcmFOOTER();
               return status;
        }

                gcmONERROR(slGenGenericCode2(Compiler,
                                             BinaryExpr->exprBase.base.lineNo,
                                             BinaryExpr->exprBase.base.stringNo,
                                             opcode,
                                             &iOperand,
                                             operandsParameters[0].rOperands,
                                             operandsParameters[1].rOperands));

        slsROPERAND_InitializeUsingIOperand(Parameters->rOperands, &iOperand);
    }

OnError:
    slsGEN_CODE_PARAMETERS_Finalize(&operandsParameters[0]);
    slsGEN_CODE_PARAMETERS_Finalize(&operandsParameters[1]);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenSequenceCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  leftParameters, rightParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &leftParameters,
                                    gcvFALSE,
                                    gcvFALSE);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->leftOperand->base,
                                &CodeGenerator->visitor,
                                &leftParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    slsGEN_CODE_PARAMETERS_Initialize(
                                    &rightParameters,
                                    gcvFALSE,
                                    Parameters->needROperand);

    status = sloIR_OBJECT_Accept(
                                Compiler,
                                &BinaryExpr->rightOperand->base,
                                &CodeGenerator->visitor,
                                &rightParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        slsGEN_CODE_PARAMETERS_MoveOperands(Parameters, &rightParameters);
    }

    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_BINARY_EXPR_GenAssignCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status = gcvSTATUS_OK;
    slsGEN_CODE_PARAMETERS  leftParameters, rightParameters;
    gctUINT                 i;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(&leftParameters, gcvTRUE, Parameters->needROperand);
    slsGEN_CODE_PARAMETERS_Initialize(&rightParameters, gcvFALSE, gcvTRUE);

    gcmONERROR(sloIR_OBJECT_Accept(Compiler,
                                &BinaryExpr->leftOperand->base,
                                &CodeGenerator->visitor,
                                &leftParameters));

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    gcmONERROR(sloIR_OBJECT_Accept(Compiler,
                                   &BinaryExpr->rightOperand->base,
                                   &CodeGenerator->visitor,
                                   &rightParameters));

    /* Generate the assign code */
    gcmASSERT(leftParameters.operandCount == rightParameters.operandCount);

    for (i = 0; i < leftParameters.operandCount; i++)
    {
        gcmONERROR(slGenAssignCode(Compiler,
                                BinaryExpr->exprBase.base.lineNo,
                                BinaryExpr->exprBase.base.stringNo,
                                leftParameters.lOperands + i,
                                rightParameters.rOperands + i));
    }

    if (Parameters->needROperand)
    {
        slsGEN_CODE_PARAMETERS_MoveOperands(Parameters, &leftParameters);
    }

OnError:
    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_BINARY_EXPR_GenArithmeticAssignCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status = gcvSTATUS_OK;
    slsGEN_CODE_PARAMETERS  leftParameters, rightParameters;
    gctUINT                 i;
    slsIOPERAND             intermIOperand;
    slsROPERAND             intermROperand;
    sleOPCODE               opcode;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(&leftParameters, gcvTRUE, gcvTRUE);
    slsGEN_CODE_PARAMETERS_Initialize(&rightParameters, gcvFALSE, gcvTRUE);

    gcmONERROR(sloIR_OBJECT_Accept(Compiler,
                                &BinaryExpr->leftOperand->base,
                                &CodeGenerator->visitor,
                                &leftParameters));

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    gcmONERROR(sloIR_OBJECT_Accept(Compiler,
                                &BinaryExpr->rightOperand->base,
                                &CodeGenerator->visitor,
                                &rightParameters));

    /* Generate the arithmetic assign code */
    gcmASSERT(leftParameters.operandCount == rightParameters.operandCount);

    for (i = 0; i < leftParameters.operandCount; i++)
    {
        /* Generate the arithmetic code */
        slsIOPERAND_New(Compiler,
                        &intermIOperand,
                        leftParameters.dataTypes[i],
                        leftParameters.rOperands[i].u.reg.precision);

        switch (BinaryExpr->type)
        {
        case slvBINARY_ADD_ASSIGN: opcode = slvOPCODE_ADD; break;
        case slvBINARY_SUB_ASSIGN: opcode = slvOPCODE_SUB; break;
        case slvBINARY_MUL_ASSIGN: opcode = slvOPCODE_MUL; break;
        case slvBINARY_MOD_ASSIGN: opcode = slvOPCODE_MOD; break;
        case slvBINARY_DIV_ASSIGN:
             opcode = slvOPCODE_DIV;
             if (sloCOMPILER_IsHaltiVersion(Compiler) &&
                  slmDATA_TYPE_IsIntegerType(BinaryExpr->exprBase.dataType)) {
                  opcode = slvOPCODE_IDIV;
             }
             break;

        default:
            gcmASSERT(0);
            status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            goto OnError;
        }

        gcmONERROR(slGenArithmeticExprCode(Compiler,
                                        BinaryExpr->exprBase.base.lineNo,
                                        BinaryExpr->exprBase.base.stringNo,
                                        opcode,
                                        &intermIOperand,
                                        leftParameters.rOperands + i,
                                        rightParameters.rOperands + i));

        slsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);

        /* Generate the assign code */
        gcmONERROR(slGenAssignCode(Compiler,
                                BinaryExpr->exprBase.base.lineNo,
                                BinaryExpr->exprBase.base.stringNo,
                                leftParameters.lOperands + i,
                                &intermROperand));
    }

    if (Parameters->needROperand)
    {
        slsGEN_CODE_PARAMETERS_MoveOperands(Parameters, &leftParameters);
    }

OnError:
    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_BINARY_EXPR_GenShiftAssignCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    slsGEN_CODE_PARAMETERS leftParameters, rightParameters;
    gctUINT    i;
    slsIOPERAND intermIOperand[1];
    slsROPERAND intermROperand[1];
    sleOPCODE opcode;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(&leftParameters, gcvTRUE, gcvTRUE);
    slsGEN_CODE_PARAMETERS_Initialize(&rightParameters, gcvFALSE, gcvTRUE);

    gcmONERROR(sloIR_OBJECT_Accept(Compiler,
                       &BinaryExpr->leftOperand->base,
                       &CodeGenerator->visitor,
                       &leftParameters));

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    gcmONERROR(sloIR_OBJECT_Accept(Compiler,
                       &BinaryExpr->rightOperand->base,
                       &CodeGenerator->visitor,
                       &rightParameters));

    /* Generate the shift assign code */
    gcmASSERT(leftParameters.operandCount == rightParameters.operandCount);

    switch (BinaryExpr->type) {
    case slvBINARY_LEFT_ASSIGN:
       opcode = slvOPCODE_LSHIFT;
       break;

    case slvBINARY_RIGHT_ASSIGN:
       opcode = slvOPCODE_RSHIFT;
       break;

    default:
          gcmASSERT(0);
          status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
          goto OnError;
    }

    if(Parameters->needROperand) {
            gcmONERROR(slsGEN_CODE_PARAMETERS_AllocateOperands(Compiler,
                                                               Parameters,
                                                               BinaryExpr->exprBase.dataType));
    }

    for (i = 0; i < leftParameters.operandCount; i++) {
          /* Generate the shift code */
              slsIOPERAND_New(Compiler,
                              intermIOperand,
                              leftParameters.dataTypes[i],
                              leftParameters.rOperands[i].u.reg.precision);

          gcmONERROR(slGenGenericCode2(Compiler,
                          BinaryExpr->exprBase.base.lineNo,
                          BinaryExpr->exprBase.base.stringNo,
                          opcode,
                          intermIOperand,
                          leftParameters.rOperands + i,
                          rightParameters.rOperands + i));

              slsROPERAND_InitializeUsingIOperand(intermROperand, intermIOperand);

              /* Generate the assign code */
              gcmONERROR(slGenAssignCode(Compiler,
                                         BinaryExpr->exprBase.base.lineNo,
                                         BinaryExpr->exprBase.base.stringNo,
                                         leftParameters.lOperands + i,
                                         intermROperand));

          if (Parameters->needROperand) {
          Parameters->rOperands[i] = *intermROperand;
          }
    }

OnError:
    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_BINARY_EXPR_GenBitwiseAssignCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    slsGEN_CODE_PARAMETERS    leftParameters, rightParameters;
    gctUINT    i;
    slsIOPERAND intermIOperand[1];
    slsROPERAND intermROperand[1];
    sleOPCODE opcode;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of the left operand */
    gcmASSERT(BinaryExpr->leftOperand);

    slsGEN_CODE_PARAMETERS_Initialize(&leftParameters, gcvTRUE, gcvTRUE);
    slsGEN_CODE_PARAMETERS_Initialize(&rightParameters, gcvFALSE, gcvTRUE);

    gcmONERROR(sloIR_OBJECT_Accept(Compiler,
                       &BinaryExpr->leftOperand->base,
                       &CodeGenerator->visitor,
                       &leftParameters));

    /* Generate the code of the right operand */
    gcmASSERT(BinaryExpr->rightOperand);

    gcmONERROR(sloIR_OBJECT_Accept(Compiler,
                       &BinaryExpr->rightOperand->base,
                       &CodeGenerator->visitor,
                       &rightParameters));

    /* Generate the bit-wise assign code */
    gcmASSERT(leftParameters.operandCount == rightParameters.operandCount);

    switch (BinaryExpr->type) {
    case slvBINARY_AND_ASSIGN: opcode = slvOPCODE_BITWISE_AND; break;
    case slvBINARY_XOR_ASSIGN: opcode = slvOPCODE_BITWISE_XOR; break;
    case slvBINARY_OR_ASSIGN: opcode = slvOPCODE_BITWISE_OR; break;

    default:
            gcmASSERT(0);
            status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            goto OnError;
    }

    if(Parameters->needROperand) {
            gcmONERROR(slsGEN_CODE_PARAMETERS_AllocateOperands(Compiler,
                                                               Parameters,
                                                               BinaryExpr->exprBase.dataType));
    }

        for (i = 0; i < leftParameters.operandCount; i++) {
          /* Generate the bit-wise assign code */
              slsIOPERAND_New(Compiler,
                              intermIOperand,
                              leftParameters.dataTypes[i],
                              leftParameters.rOperands[i].u.reg.precision);

          gcmONERROR(slGenGenericCode2(Compiler,
                          BinaryExpr->exprBase.base.lineNo,
                          BinaryExpr->exprBase.base.stringNo,
                          opcode,
                          intermIOperand,
                          leftParameters.rOperands + i,
                          rightParameters.rOperands + i));

          slsROPERAND_InitializeUsingIOperand(intermROperand, intermIOperand);

              /* Generate the assign code */
              gcmONERROR(slGenAssignCode(Compiler,
                        BinaryExpr->exprBase.base.lineNo,
                        BinaryExpr->exprBase.base.stringNo,
                        leftParameters.lOperands + i,
                        intermROperand));

          if (Parameters->needROperand) {
          Parameters->rOperands[i] = *intermROperand;
          }
    }

OnError:
    slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_BINARY_EXPR_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_BINARY_EXPR BinaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    slsGEN_CODE_PARAMETERS  leftParameters, rightParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(BinaryExpr, slvIR_BINARY_EXPR);
    gcmASSERT(Parameters);

    /* Try to evaluate the operands */
    if (!Parameters->needLOperand && Parameters->needROperand)
    {
        /* Try to evaluate the left operand */
        gcmASSERT(BinaryExpr->leftOperand);

        slsGEN_CODE_PARAMETERS_Initialize(
                                        &leftParameters,
                                        gcvFALSE,
                                        gcvTRUE);

        leftParameters.hint = slvEVALUATE_ONLY;

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    &BinaryExpr->leftOperand->base,
                                    &CodeGenerator->visitor,
                                    &leftParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Try to evaluate the right operand */
        gcmASSERT(BinaryExpr->rightOperand);

        slsGEN_CODE_PARAMETERS_Initialize(
                                        &rightParameters,
                                        gcvFALSE,
                                        gcvTRUE);

        rightParameters.hint = slvEVALUATE_ONLY;

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    &BinaryExpr->rightOperand->base,
                                    &CodeGenerator->visitor,
                                    &rightParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (leftParameters.constant != gcvNULL && rightParameters.constant != gcvNULL)
        {
            status = sloIR_BINARY_EXPR_Evaluate(
                                                Compiler,
                                                BinaryExpr->type,
                                                leftParameters.constant,
                                                rightParameters.constant,
                                                &Parameters->constant);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            leftParameters.constant     = gcvNULL;
            rightParameters.constant    = gcvNULL;
        }

        slsGEN_CODE_PARAMETERS_Finalize(&leftParameters);
        slsGEN_CODE_PARAMETERS_Finalize(&rightParameters);

        if (Parameters->hint == slvEVALUATE_ONLY)
        {
            gcmFOOTER_NO();
            return gcvSTATUS_OK;
        }

        if (Parameters->constant != gcvNULL)
        {
            status = sloIR_CONSTANT_GenCode(
                                        Compiler,
                                        CodeGenerator,
                                        Parameters->constant,
                                        Parameters);

            gcmFOOTER();
            return status;
        }
    }

    switch (BinaryExpr->type)
    {
    case slvBINARY_SUBSCRIPT:
        status = sloIR_BINARY_EXPR_GenSubscriptCode(
                                                Compiler,
                                                CodeGenerator,
                                                BinaryExpr,
                                                Parameters);

        break;

    case slvBINARY_ADD:
    case slvBINARY_SUB:
    case slvBINARY_MUL:
    case slvBINARY_DIV:
    case slvBINARY_MOD:
        status = sloIR_BINARY_EXPR_GenArithmeticCode(
                                                Compiler,
                                                CodeGenerator,
                                                BinaryExpr,
                                                Parameters);

        break;

    case slvBINARY_GREATER_THAN:
    case slvBINARY_LESS_THAN:
    case slvBINARY_GREATER_THAN_EQUAL:
    case slvBINARY_LESS_THAN_EQUAL:
        status = sloIR_BINARY_EXPR_GenRelationalCode(
                                                Compiler,
                                                CodeGenerator,
                                                BinaryExpr,
                                                Parameters);

        break;

    case slvBINARY_EQUAL:
    case slvBINARY_NOT_EQUAL:
    case slvBINARY_XOR:
        status = sloIR_BINARY_EXPR_GenEqualityCode(
                                                Compiler,
                                                CodeGenerator,
                                                BinaryExpr,
                                                Parameters);

        break;

    case slvBINARY_AND:
        status = sloIR_BINARY_EXPR_GenAndCode(
                                            Compiler,
                                            CodeGenerator,
                                            BinaryExpr,
                                            Parameters);

        break;

    case slvBINARY_OR:
        status = sloIR_BINARY_EXPR_GenOrCode(
                                            Compiler,
                                            CodeGenerator,
                                            BinaryExpr,
                                            Parameters);

        break;

    case slvBINARY_BITWISE_AND:
    case slvBINARY_BITWISE_OR:
    case slvBINARY_BITWISE_XOR:
        status = sloIR_BINARY_EXPR_GenBitwiseCode(Compiler,
                                                  CodeGenerator,
                                                  BinaryExpr,
                                                  Parameters);
        break;

    case slvBINARY_LSHIFT:
    case slvBINARY_RSHIFT:
        status = sloIR_BINARY_EXPR_GenShiftCode(Compiler,
                                                CodeGenerator,
                                                BinaryExpr,
                                                Parameters);
        break;


    case slvBINARY_SEQUENCE:
        status = sloIR_BINARY_EXPR_GenSequenceCode(
                                                Compiler,
                                                CodeGenerator,
                                                BinaryExpr,
                                                Parameters);

        break;

    case slvBINARY_ASSIGN:
        status = sloIR_BINARY_EXPR_GenAssignCode(
                                            Compiler,
                                            CodeGenerator,
                                            BinaryExpr,
                                            Parameters);

        break;


    case slvBINARY_LEFT_ASSIGN:
    case slvBINARY_RIGHT_ASSIGN:
         status =  sloIR_BINARY_EXPR_GenShiftAssignCode(Compiler,
                                                        CodeGenerator,
                                                        BinaryExpr,
                                                        Parameters);
         break;

    case slvBINARY_AND_ASSIGN:
    case slvBINARY_XOR_ASSIGN:
    case slvBINARY_OR_ASSIGN:
         status = sloIR_BINARY_EXPR_GenBitwiseAssignCode(Compiler,
                                                         CodeGenerator,
                                                         BinaryExpr,
                                                         Parameters);
         break;

    case slvBINARY_MUL_ASSIGN:
    case slvBINARY_DIV_ASSIGN:
    case slvBINARY_ADD_ASSIGN:
    case slvBINARY_SUB_ASSIGN:
    case slvBINARY_MOD_ASSIGN:
        status = sloIR_BINARY_EXPR_GenArithmeticAssignCode(Compiler,
                                                           CodeGenerator,
                                                           BinaryExpr,
                                                           Parameters);
        break;

    default:
        gcmASSERT(0);
        status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        gcmFOOTER();
        return status;
    }

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Restore vec from scalar array if vect is component indexing. */
    if (BinaryExpr->type != slvBINARY_SUBSCRIPT)
    {
        status = _ConvertAuxiScalarArray(Compiler,
                                         CodeGenerator,
                                         BinaryExpr);
        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
slGenSelectExprCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsIOPERAND * IOperand,
    IN slsROPERAND * Cond,
    IN slsROPERAND * ROperand0,
    IN slsROPERAND * ROperand1
)
{
    gceSTATUS status;
    gcsTARGET target;
    gcsSOURCE cond;
    gcsSOURCE source0;
    gcsSOURCE source1;
    gcSHADER_TYPE copyCondType;
    gcSHADER_TYPE copyType0;
    gcSHADER_TYPE copyType1;
    gcSHADER_TYPE copyIOperandType;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(IOperand);
    gcmASSERT(Cond);
    gcmASSERT(ROperand0);
    gcmASSERT(ROperand1);

    gcmVERIFY_OK(sloCOMPILER_Dump(Compiler,
                                  slvDUMP_CODE_GENERATOR,
                                  "<OPERATION line=\"%d\" string=\"%d\" type=\"%s\">",
                                  LineNo,
                                  StringNo,
                                  "select"));

    gcmVERIFY_OK(slsIOPERAND_Dump(Compiler, IOperand));
    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, Cond));
    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand0));
    gcmVERIFY_OK(slsROPERAND_Dump(Compiler, ROperand1));


    gcmASSERT(gcGetComponentDataType(Cond->dataType) == gcSHADER_BOOLEAN_X1);

    copyCondType = Cond->dataType;
    Cond->dataType =
        gcConvScalarToVectorDataType(gcSHADER_INTEGER_X1,
                             gcGetDataTypeComponentCount(Cond->dataType));

    copyType0 = ROperand0->dataType;
    if(gcGetComponentDataType(ROperand0->dataType) == gcSHADER_FLOAT_X1) {
        ROperand0->dataType =
            gcConvScalarToVectorDataType(gcSHADER_INTEGER_X1,
                                 gcGetDataTypeComponentCount(ROperand0->dataType));
    }
    copyType1 = ROperand1->dataType;
    if(gcGetComponentDataType(ROperand1->dataType) == gcSHADER_FLOAT_X1) {
        ROperand1->dataType =
            gcConvScalarToVectorDataType(gcSHADER_INTEGER_X1,
                                 gcGetDataTypeComponentCount(ROperand1->dataType));
    }
    copyIOperandType = IOperand->dataType;
    if(gcGetComponentDataType(IOperand->dataType) == gcSHADER_FLOAT_X1) {
        IOperand->dataType =
            gcConvScalarToVectorDataType(gcSHADER_INTEGER_X1,
                                  gcGetDataTypeComponentCount(IOperand->dataType));
    }
    gcmVERIFY_OK(_ConvIOperandToTarget(Compiler,
                                       IOperand,
                                       &target));

    gcmONERROR(_ConvNormalROperandToSource(Compiler,
                                           LineNo,
                                           StringNo,
                                           Cond,
                                           &cond));

    gcmONERROR(_ConvNormalROperandToSource(Compiler,
                                           LineNo,
                                           StringNo,
                                           ROperand0,
                                           &source0));

    gcmONERROR(_ConvNormalROperandToSource(Compiler,
                                           LineNo,
                                           StringNo,
                                           ROperand1,
                                           &source1));

    gcmONERROR(slEmitSelectCode(Compiler,
                                LineNo,
                                StringNo,
                                &target,
                                &cond,
                                &source0,
                                &source1));

   gcmVERIFY_OK(sloCOMPILER_Dump(Compiler,
                                 slvDUMP_CODE_GENERATOR,
                                 "</OPERATION>"));

OnError:
   Cond->dataType = copyCondType;
   ROperand0->dataType = copyType0;
   ROperand1->dataType = copyType1;
   IOperand->dataType = copyIOperandType;
   gcmFOOTER();
   return status;
}

gceSTATUS
sloIR_SELECTION_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_SELECTION Selection,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    gctBOOL                 emptySelection;
    slsGEN_CODE_PARAMETERS  condParameters, trueParameters, falseParameters;
    slsSELECTION_CONTEXT    selectionContext = {0};
    gctBOOL                 trueOperandHasReturn;
    slsIOPERAND             iOperand;
    slsLOPERAND             lOperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(Selection, slvIR_SELECTION);
    gcmASSERT(Selection->condExpr);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    gcoOS_ZeroMemory(&trueParameters, gcmSIZEOF(trueParameters));
    gcoOS_ZeroMemory(&falseParameters, gcmSIZEOF(falseParameters));

    if (Parameters->hint == slvEVALUATE_ONLY)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    emptySelection = (Selection->trueOperand == gcvNULL && Selection->falseOperand == gcvNULL);

    if (emptySelection)
    {
        gcmASSERT(!Parameters->needROperand);

        /* Only generate the code of the condition expression */
        slsGEN_CODE_PARAMETERS_Initialize(&condParameters, gcvFALSE, gcvFALSE);

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    &Selection->condExpr->base,
                                    &CodeGenerator->visitor,
                                    &condParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsGEN_CODE_PARAMETERS_Finalize(&condParameters);

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    /* Selection Begin */
    status = slDefineSelectionBegin(
                                    Compiler,
                                    CodeGenerator,
                                    (Selection->falseOperand != gcvNULL),
                                    &selectionContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        gcmASSERT(Selection->exprBase.dataType);

        /* Allocate the operand(s) */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        Selection->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmASSERT(Parameters->operandCount == 1);

        slsIOPERAND_New(Compiler,
                        &iOperand,
                        Parameters->dataTypes[0],
                        Parameters->rOperands[0].u.reg.precision);
        slsLOPERAND_InitializeUsingIOperand(&lOperand, &iOperand);
        slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &iOperand);
    }

    /* Generate the code of the condition expression */
    status = _GenConditionCode(
                            Compiler,
                            CodeGenerator,
                            Selection->condExpr,
                            _GetSelectionConditionLabel(&selectionContext),
                            gcvFALSE);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the true operand */
    status = slDefineSelectionTrueOperandBegin(
                                            Compiler,
                                            CodeGenerator,
                                            &selectionContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Selection->trueOperand != gcvNULL)
    {
        slsGEN_CODE_PARAMETERS_Initialize(&trueParameters, gcvFALSE, Parameters->needROperand);

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    Selection->trueOperand,
                                    &CodeGenerator->visitor,
                                    &trueParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (Parameters->needROperand)
        {
            status = slGenAssignCode(
                                    Compiler,
                                    Selection->trueOperand->lineNo,
                                    Selection->trueOperand->stringNo,
                                    &lOperand,
                                    &trueParameters.rOperands[0]);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
    }

    trueOperandHasReturn = (Selection->trueOperand != gcvNULL
                            && sloIR_BASE_HasReturn(Compiler, Selection->trueOperand));

    status = slDefineSelectionTrueOperandEnd(
                                            Compiler,
                                            CodeGenerator,
                                            &selectionContext,
                                            trueOperandHasReturn);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of the false operand */
    if (Selection->falseOperand != gcvNULL)
    {
        status = slDefineSelectionFalseOperandBegin(
                                                Compiler,
                                                CodeGenerator,
                                                &selectionContext);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        slsGEN_CODE_PARAMETERS_Initialize(&falseParameters, gcvFALSE, Parameters->needROperand);

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    Selection->falseOperand,
                                    &CodeGenerator->visitor,
                                    &falseParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (Parameters->needROperand)
        {
            status = slGenAssignCode(
                                    Compiler,
                                    Selection->falseOperand->lineNo,
                                    Selection->falseOperand->stringNo,
                                    &lOperand,
                                    &falseParameters.rOperands[0]);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }

        status = slDefineSelectionFalseOperandEnd(
                                                Compiler,
                                                CodeGenerator,
                                                &selectionContext);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    /* Selection End */
    status = slDefineSelectionEnd(
                                Compiler,
                                CodeGenerator,
                                &selectionContext);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Selection->trueOperand != gcvNULL)  slsGEN_CODE_PARAMETERS_Finalize(&trueParameters);
    if (Selection->falseOperand != gcvNULL) slsGEN_CODE_PARAMETERS_Finalize(&falseParameters);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_SWITCH_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_SWITCH Selection,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS  status;
    sloIR_LABEL cases;
    slsITERATION_CONTEXT switchContext[1];
    slsGEN_CODE_PARAMETERS  condParameters, switchBodyParameters;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(Selection, slvIR_SWITCH);
    gcmASSERT(Selection->condExpr);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    gcoOS_ZeroMemory(&switchBodyParameters, gcmSIZEOF(switchBodyParameters));

    if (Parameters->hint == slvEVALUATE_ONLY) {
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    /* Only generate the code of the condition expression */
    slsGEN_CODE_PARAMETERS_Initialize(&condParameters,
                                      gcvFALSE,
                                      gcvTRUE);

    status = sloIR_OBJECT_Accept(Compiler,
                                 &Selection->condExpr->base,
                                 &CodeGenerator->visitor,
                                 &condParameters);
    if (gcmIS_ERROR(status)) {
        gcmFOOTER();
        return status;
    }

    gcmASSERT(condParameters.operandCount == 1);

    if(Selection->switchBody == gcvNULL) {
        gcmASSERT(!Parameters->needROperand);

        slsGEN_CODE_PARAMETERS_Finalize(&condParameters);
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    slsGEN_CODE_PARAMETERS_Initialize(&switchBodyParameters, gcvFALSE, gcvFALSE);

    cases = Selection->cases;

    status = _CloneIterationContextForSwitch(Compiler, CodeGenerator, switchContext);
    if (gcmIS_ERROR(status)) {
         gcmFOOTER();
         return status;
    }

    while(cases) {
    cases->programCounter = slNewLabel(Compiler);
    /* Generate the code of the condition expression */
    switch(cases->type) {
    case slvCASE:
            gcmONERROR(_GenSplitOperandConditionCode(Compiler,
                                                     CodeGenerator,
                                                     slvCONDITION_EQUAL,
                                                     condParameters.rOperands,
                                                     &cases->caseValue->exprBase,
                                                     cases->programCounter,
                                                     gcvTRUE));
        break;

    case slvDEFAULT:
            gcmONERROR(slEmitAlwaysBranchCode(Compiler,
                                              Selection->exprBase.base.lineNo,
                                              Selection->exprBase.base.stringNo,
                                              slvOPCODE_JUMP,
                                              cases->programCounter));
            gcmASSERT(!cases->nextCase);
            break;

        default:
            gcmASSERT(0);
            break;
        }
        cases = cases->nextCase;
    }

    gcmONERROR(sloIR_OBJECT_Accept(Compiler,
                                   Selection->switchBody,
                                   &CodeGenerator->visitor,
                                   &switchBodyParameters));

    gcmONERROR(_DefineSwitchEnd(Compiler, CodeGenerator));

OnError:
    slsGEN_CODE_PARAMETERS_Finalize(&switchBodyParameters);
    slsGEN_CODE_PARAMETERS_Finalize(&condParameters);

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_POLYNARY_EXPR_FinalizeOperandsParameters(
    IN sloCOMPILER Compiler,
    IN gctUINT OperandCount,
    IN slsGEN_CODE_PARAMETERS * OperandsParameters
    )
{
    gctUINT     i;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);

    if (OperandCount == 0)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    gcmASSERT(OperandsParameters);

    for (i = 0; i < OperandCount; i++)
    {
        slsGEN_CODE_PARAMETERS_Finalize(&OperandsParameters[i]);
    }

    gcmVERIFY_OK(sloCOMPILER_Free(Compiler, OperandsParameters));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenOperandsCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctBOOL NeedROperand,
    OUT gctUINT * OperandCount,
    OUT slsGEN_CODE_PARAMETERS * * OperandsParameters
    )
{
    gceSTATUS                   status;
    gctUINT                     operandCount;
    slsGEN_CODE_PARAMETERS *    operandsParameters;
    sloIR_EXPR                  operand;
    gctUINT                     i = 0;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount);
    gcmASSERT(OperandsParameters);

    if (PolynaryExpr->operands == gcvNULL)
    {
        *OperandCount       = 0;
        *OperandsParameters = gcvNULL;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    do
    {
        gctPOINTER pointer = gcvNULL;

        gcmVERIFY_OK(sloIR_SET_GetMemberCount(
                                            Compiler,
                                            PolynaryExpr->operands,
                                            &operandCount));

        gcmASSERT(operandCount > 0);

        status = sloCOMPILER_Allocate(
                                    Compiler,
                                    (gctSIZE_T)sizeof(slsGEN_CODE_PARAMETERS) * operandCount,
                                    &pointer);

        if (gcmIS_ERROR(status)) break;

        operandsParameters = pointer;

        FOR_EACH_DLINK_NODE(&PolynaryExpr->operands->members, struct _sloIR_EXPR, operand)
        {
            slsGEN_CODE_PARAMETERS_Initialize(&operandsParameters[i], gcvFALSE, NeedROperand);

            status = sloIR_OBJECT_Accept(
                                        Compiler,
                                        &operand->base,
                                        &CodeGenerator->visitor,
                                        &operandsParameters[i]);

            if (gcmIS_ERROR(status)) break;

            i++;
        }

        if (gcmIS_ERROR(status)) break;

        *OperandCount       = operandCount;
        *OperandsParameters = operandsParameters;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    *OperandCount       = 0;
    *OperandsParameters = gcvNULL;

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenOperandsCodeForFuncCall(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    OUT gctUINT * OperandCount,
    OUT slsGEN_CODE_PARAMETERS * * OperandsParameters
    )
{
    gceSTATUS                   status;
    gctUINT                     operandCount;
    slsGEN_CODE_PARAMETERS *    operandsParameters;
    slsGEN_CODE_PARAMETERS *    tempOperandsParameters;
    sloIR_EXPR                  operand;
    slsLOPERAND                 lOperand;
    gctUINT                     i = 0, j;
    slsNAME *                   paramName;
    gctBOOL                     needLOperand, needROperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount);
    gcmASSERT(OperandsParameters);

    if (PolynaryExpr->operands == gcvNULL)
    {
        *OperandCount       = 0;
        *OperandsParameters = gcvNULL;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    do
    {
        /*
        ** To make sure that the evaluation of an in parameter won't change the value of previous parameter,
        ** we allocate a temp operand array, once we finish evaluating an parameter,
        ** we assign the evaluation value into this temp operand. Then use this temp operand array to call function.
        */
        gctPOINTER pointer = gcvNULL;

        gcmVERIFY_OK(sloIR_SET_GetMemberCount(Compiler,
                                              PolynaryExpr->operands,
                                              &operandCount));

        gcmASSERT(operandCount > 0);

        /* Allocate the temp operands. */
        status = sloCOMPILER_Allocate(Compiler,
                                      (gctSIZE_T)sizeof(slsGEN_CODE_PARAMETERS) * operandCount,
                                      &pointer);

        if (gcmIS_ERROR(status)) break;
        tempOperandsParameters = (slsGEN_CODE_PARAMETERS *)pointer;

        /* Allocate the evaluation operands. */
        status = sloCOMPILER_Allocate(Compiler,
                                      (gctSIZE_T)sizeof(slsGEN_CODE_PARAMETERS) * operandCount,
                                      &pointer);

        if (gcmIS_ERROR(status)) break;
        operandsParameters = (slsGEN_CODE_PARAMETERS *)pointer;

        /* Evaluate all parameters. */
        for (paramName = slsDLINK_LIST_First(
                                &PolynaryExpr->funcName->u.funcInfo.localSpace->names, slsNAME),
                operand = slsDLINK_LIST_First(
                                &PolynaryExpr->operands->members, struct _sloIR_EXPR);
            (slsDLINK_NODE *)paramName != &PolynaryExpr->funcName->u.funcInfo.localSpace->names;
            paramName = slsDLINK_NODE_Next(&paramName->node, slsNAME),
                operand = slsDLINK_NODE_Next(&operand->base.node, struct _sloIR_EXPR))
        {
            slsLOGICAL_REG * logicalRegs = gcvNULL;
            gctREG_INDEX tempRegIndex;
            gctBOOL replaceROperand = gcvTRUE;

            if (paramName->type != slvPARAMETER_NAME) break;

            gcmASSERT((slsDLINK_NODE *)operand != &PolynaryExpr->operands->members);

            switch (paramName->dataType->qualifiers.storage)
            {
            case slvSTORAGE_QUALIFIER_CONST_IN:
            case slvSTORAGE_QUALIFIER_IN:
                needLOperand = gcvFALSE;
                needROperand = gcvTRUE;
                break;

            case slvSTORAGE_QUALIFIER_OUT:
                needLOperand = gcvTRUE;
                needROperand = gcvFALSE;
                break;

            case slvSTORAGE_QUALIFIER_INOUT:
                needLOperand = gcvTRUE;
                needROperand = gcvTRUE;
                break;

            default:
                gcmASSERT(0);
                status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                gcmFOOTER();
                return status;
            }

            if(i >= operandCount)
            {
                *OperandCount       = 0;
                *OperandsParameters = gcvNULL;
                gcmASSERT(0);

                status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
                gcmFOOTER();
                return status;
            }

            slsGEN_CODE_PARAMETERS_Initialize(&operandsParameters[i], needLOperand, needROperand);

            status = sloIR_OBJECT_Accept(Compiler,
                                         &operand->base,
                                         &CodeGenerator->visitor,
                                         &operandsParameters[i]);
            if (gcmIS_ERROR(status)) break;

            /* Assign the evaluation of a parameter into a temp operand. */
            tempOperandsParameters[i] = operandsParameters[i];

            switch (paramName->dataType->qualifiers.storage)
            {
            case slvSTORAGE_QUALIFIER_CONST_IN:
            case slvSTORAGE_QUALIFIER_IN:
            case slvSTORAGE_QUALIFIER_INOUT:
                gcmASSERT(operandsParameters[i].needROperand);

                /* Allocate a temp logical register. */
                status = sloCOMPILER_Allocate(Compiler,
                                              (gctSIZE_T)sizeof(slsLOGICAL_REG) * operandsParameters[i].operandCount,
                                              &pointer);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsLOGICAL_REG) * operandsParameters[i].operandCount);
                logicalRegs = (slsLOGICAL_REG *)pointer;

                /* Allocate the rOperands. */
                status = sloCOMPILER_Allocate(Compiler,
                                             (gctSIZE_T)sizeof(slsROPERAND) * operandsParameters[i].operandCount,
                                             &pointer);
                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                gcoOS_ZeroMemory(pointer, (gctSIZE_T)sizeof(slsROPERAND) * operandsParameters[i].operandCount);
                tempOperandsParameters[i].rOperands = (slsROPERAND *)pointer;

                for (j = 0; j < operandsParameters[i].operandCount; j++)
                {
                    tempRegIndex = slNewTempRegs(Compiler, gcGetDataTypeSize(paramName->context.logicalRegs[j].dataType));
                    slsLOGICAL_REG_InitializeTemp(logicalRegs + j,
                                                  paramName->context.logicalRegs[j].qualifier,
                                                  paramName->context.logicalRegs[j].dataType,
                                                  paramName->context.logicalRegs[j].precision,
                                                  tempRegIndex);
                }

                /* Assign the evaluation of the parameter into the temp operand. */
                for (j = 0; j < operandsParameters[i].operandCount; j++)
                {
                    slsLOPERAND_Initialize(&lOperand, logicalRegs + j);

                    /* Just change assignment for a temp register. */
                    if (operandsParameters[i].rOperands[j].isReg &&
                        operandsParameters[i].rOperands[j].u.reg.u.pointer != gcvNULL &&
                        (*((gceOBJECT_TYPE *)operandsParameters[i].rOperands[j].u.reg.u.pointer) != gcvOBJ_OUTPUT ||
                         *((gceOBJECT_TYPE *)operandsParameters[i].rOperands[j].u.reg.u.pointer) != gcvOBJ_VARIABLE))
                    {
                        replaceROperand = gcvFALSE;
                    }
                    else if (operandsParameters[i].rOperands[j].u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM ||
                             operandsParameters[i].rOperands[j].u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER ||
                             gcIsSamplerDataType(lOperand.dataType) ||
                             gcIsImageDataType(lOperand.dataType) ||
                             gcIsSamplerArrayDataType(lOperand.dataType) ||
                             gcIsImageArrayDataType(lOperand.dataType) ||
                             gcIsAtomicDataType(lOperand.dataType))
                    {
                        replaceROperand = gcvFALSE;
                    }
                    else
                    {
                        status = slGenAssignCode(Compiler,
                                                 PolynaryExpr->exprBase.base.lineNo,
                                                 PolynaryExpr->exprBase.base.stringNo,
                                                 &lOperand,
                                                 operandsParameters[i].rOperands + j);

                        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                    }

                    /* Convert the LOperand to ROperand. */
                    if (replaceROperand)
                    {
                        slsROPERAND_InitializeWithLOPERAND(&tempOperandsParameters[i].rOperands[j],
                                                           &lOperand);
                    }
                    else
                    {
                        gcoOS_MemCopy(&tempOperandsParameters[i].rOperands[j],
                                      &operandsParameters[i].rOperands[j],
                                      gcmSIZEOF(slsROPERAND));
                    }
                }
                /* clean up operandsParameters[i]. */
                operandsParameters[i].constant = gcvNULL;
                operandsParameters[i].dataTypes = gcvNULL;
                operandsParameters[i].lOperands = gcvNULL;
                operandsParameters[i].constantVariable = gcvNULL;

                /* Free logical registers. */
                gcmVERIFY_OK(sloCOMPILER_Free(Compiler, logicalRegs));
                break;

            default:
                /* clean up operandsParameters[i]. */
                operandsParameters[i].constant = gcvNULL;
                operandsParameters[i].dataTypes = gcvNULL;
                operandsParameters[i].rOperands = gcvNULL;
                operandsParameters[i].lOperands = gcvNULL;
                operandsParameters[i].constantVariable = gcvNULL;
                break;
            }
            i++;
        }

        /* Delete operandsParameters. */
        gcmVERIFY_OK(sloIR_POLYNARY_EXPR_FinalizeOperandsParameters(Compiler,
                                                                    operandCount,
                                                                    operandsParameters));

        if (gcmIS_ERROR(status)) break;

        *OperandCount       = operandCount;
        *OperandsParameters = tempOperandsParameters;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    *OperandCount       = 0;
    *OperandsParameters = gcvNULL;

    gcmFOOTER();
    return status;
}

static slsCOMPONENT_SELECTION
_GetComponentSelectionSlice(
    IN slsCOMPONENT_SELECTION ComponentSelection,
    IN gctUINT8 StartComponent,
    IN gctUINT8 SliceComponentCount
    )
{
    slsCOMPONENT_SELECTION resultComponentSelection = { 0 };

    gcmASSERT((StartComponent + SliceComponentCount) <= ComponentSelection.components);

    resultComponentSelection.components = SliceComponentCount;

    switch (StartComponent)
    {
    case 0:
        resultComponentSelection.x = ComponentSelection.x;
        if (SliceComponentCount > 1) resultComponentSelection.y = ComponentSelection.y;
        if (SliceComponentCount > 2) resultComponentSelection.z = ComponentSelection.z;
        if (SliceComponentCount > 3) resultComponentSelection.w = ComponentSelection.w;
        break;

    case 1:
        resultComponentSelection.x = ComponentSelection.y;
        if (SliceComponentCount > 1) resultComponentSelection.y = ComponentSelection.z;
        if (SliceComponentCount > 2) resultComponentSelection.z = ComponentSelection.w;
        break;

    case 2:
        resultComponentSelection.x = ComponentSelection.z;
        if (SliceComponentCount > 1) resultComponentSelection.y = ComponentSelection.w;
        break;

    case 3:
        resultComponentSelection.x = ComponentSelection.w;
        break;

    default:
        gcmASSERT(0);
    }

    return resultComponentSelection;
}

static void
_GetOperandConstantSlice(
    IN slsOPERAND_CONSTANT * OperandConstant,
    IN gctUINT8 StartComponent,
    IN gctUINT8 SliceComponentCount,
    IN gcSHADER_TYPE SliceDataType,
    OUT slsOPERAND_CONSTANT * ResultOperandConstant
    )
{
    gctUINT     i;

    /* Verify the arguments. */
    gcmASSERT(OperandConstant);
    gcmASSERT(ResultOperandConstant);
    gcmASSERT((StartComponent + SliceComponentCount) <= (gctUINT8)OperandConstant->valueCount);

    ResultOperandConstant->dataType     = SliceDataType;
    ResultOperandConstant->valueCount   = SliceComponentCount;

    for (i = 0; i < SliceComponentCount; i++)
    {
        ResultOperandConstant->values[i]    = OperandConstant->values[StartComponent + i];
    }
}

void
slGetVectorROperandSlice(
    IN slsROPERAND * ROperand,
    IN gctUINT8 StartComponent,
    IN gctUINT8 SliceComponentCount,
    OUT slsROPERAND * ROperandSlice
    )
{
    gcSHADER_TYPE sliceDataType;

    /* Verify the arguments. */
    gcmASSERT(ROperand);
    gcmASSERT(ROperandSlice);
    gcmASSERT(SliceComponentCount);

    sliceDataType = gcGetVectorSliceDataType(ROperand->dataType, SliceComponentCount);

    if (ROperandSlice != ROperand)
    {
        *ROperandSlice = *ROperand;
    }
    ROperandSlice->dataType = sliceDataType;

    if (SliceComponentCount == 1)
    {
        gcmASSERT(ROperandSlice->vectorIndex.mode == slvINDEX_NONE);

        ROperandSlice->vectorIndex.mode         = slvINDEX_CONSTANT;
        ROperandSlice->vectorIndex.u.constant   = (gctREG_INDEX)StartComponent;
    }
    else
    {
        if (ROperandSlice->isReg)
        {
            ROperandSlice->u.reg.componentSelection =
                        _GetComponentSelectionSlice(ROperand->u.reg.componentSelection,
                                                    StartComponent,
                                                    SliceComponentCount);
        }
        else
        {
            _GetOperandConstantSlice(&ROperand->u.constant,
                                     StartComponent,
                                     SliceComponentCount,
                                     sliceDataType,
                                     &ROperandSlice->u.constant);
        }
    }
}

static void
_GetVectorROperandSlice(
    IN slsROPERAND * ROperand,
    IN gctUINT8 StartComponent,
    IN gctUINT8 RequiredComponentCount,
    OUT slsROPERAND * ROperandSlice,
    OUT gctUINT8 * SliceComponentCount
    )
{
    gctUINT8        sliceComponentCount;

    /* Verify the arguments. */
    gcmASSERT(ROperand);
    gcmASSERT(gcIsVectorDataType(ROperand->dataType));
    gcmASSERT(ROperandSlice);
    gcmASSERT(SliceComponentCount);

    sliceComponentCount = gcGetVectorDataTypeComponentCount(ROperand->dataType) - StartComponent;

    if (sliceComponentCount > RequiredComponentCount)
    {
        sliceComponentCount = RequiredComponentCount;
    }

    slGetVectorROperandSlice(ROperand,
                             StartComponent,
                             sliceComponentCount,
                             ROperandSlice);
    *SliceComponentCount = sliceComponentCount;
}

static gctBOOL
_GetROperandSlice(
    IN slsROPERAND * ROperand,
    IN OUT gctUINT8 * StartComponent,
    IN OUT gctUINT8 * RequiredComponentCount,
    OUT slsROPERAND * ROperandSlice,
    OUT gctUINT8 * SliceComponentCount
    )
{
    gctUINT8        componentCount, sliceComponentCount;
    gctUINT         matrixColumnCount, matrixRowCount, matrixIndex;
    slsROPERAND     matrixColumnROperand;

    /* Verify the arguments. */
    gcmASSERT(ROperand);
    gcmASSERT(StartComponent);
    gcmASSERT(RequiredComponentCount);
    gcmASSERT(*RequiredComponentCount > 0);
    gcmASSERT(ROperandSlice);

    if (gcIsScalarDataType(ROperand->dataType))
    {
        if (*StartComponent > 0) return gcvFALSE;

        *ROperandSlice = *ROperand;

        sliceComponentCount = 1;
    }
    else if (gcIsVectorDataType(ROperand->dataType))
    {
        componentCount = gcGetVectorDataTypeComponentCount(ROperand->dataType);

        if (*StartComponent > componentCount - 1) return gcvFALSE;

        _GetVectorROperandSlice(
                                ROperand,
                                *StartComponent,
                                *RequiredComponentCount,
                                ROperandSlice,
                                &sliceComponentCount);
    }
    else
    {
        gcmASSERT(gcIsMatrixDataType(ROperand->dataType));

        matrixColumnCount = gcGetMatrixDataTypeColumnCount(ROperand->dataType);
        matrixRowCount    = gcGetMatrixDataTypeRowCount(ROperand->dataType);

        if (*StartComponent > matrixColumnCount * matrixRowCount - 1) return gcvFALSE;

        matrixIndex = *StartComponent / matrixRowCount;

        slsROPERAND_InitializeAsMatrixColumn(
                                            &matrixColumnROperand,
                                            ROperand,
                                            matrixIndex);

        _GetVectorROperandSlice(
                                &matrixColumnROperand,
                                *StartComponent - (gctUINT8) (matrixIndex * matrixRowCount),
                                *RequiredComponentCount,
                                ROperandSlice,
                                &sliceComponentCount);
    }

    (*StartComponent)           += sliceComponentCount;
    (*RequiredComponentCount)   -= sliceComponentCount;

    if (SliceComponentCount != gcvNULL) *SliceComponentCount = sliceComponentCount;

    return gcvTRUE;
}

void
slGetVectorLOperandSlice(
    IN slsLOPERAND * LOperand,
    IN gctUINT8 StartComponent,
    IN gctUINT8 SliceComponentCount,
    OUT slsLOPERAND * LOperandSlice
    )
{
    gcSHADER_TYPE   sliceDataType;

    /* Verify the arguments. */
    gcmASSERT(LOperand);
    gcmASSERT(gcIsVectorDataType(LOperand->dataType));
    gcmASSERT(SliceComponentCount > 0);
    gcmASSERT(LOperandSlice);

    sliceDataType = gcGetVectorSliceDataType(LOperand->dataType, SliceComponentCount);

    *LOperandSlice          = *LOperand;
    LOperandSlice->dataType = sliceDataType;

    if (SliceComponentCount == 1)
    {
        gcmASSERT(LOperandSlice->vectorIndex.mode == slvINDEX_NONE);

        LOperandSlice->vectorIndex.mode         = slvINDEX_CONSTANT;
        LOperandSlice->vectorIndex.u.constant   = (gctREG_INDEX)StartComponent;
    }
    else
    {
        LOperandSlice->reg.componentSelection   =
                    _GetComponentSelectionSlice(LOperand->reg.componentSelection,
                                                StartComponent,
                                                SliceComponentCount);
    }
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenConstructScalarCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS                       status;
    gctUINT                         operandCount;
    slsGEN_CODE_PARAMETERS *        operandsParameters;
    gctBOOL                         treatFloatAsInt;
    gctUINT8                        startComponent = 0;
    gctUINT8                        requiredComponentCount = 1;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    status = sloIR_POLYNARY_EXPR_GenOperandsCode(
                                                Compiler,
                                                CodeGenerator,
                                                PolynaryExpr,
                                                Parameters->needROperand,
                                                &operandCount,
                                                &operandsParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmASSERT(operandCount == 1);

    treatFloatAsInt = operandsParameters[0].treatFloatAsInt;

    if (Parameters->needROperand)
    {
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        PolynaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmASSERT(Parameters->operandCount == 1);

        _GetROperandSlice(
                        &operandsParameters[0].rOperands[0],
                        &startComponent,
                        &requiredComponentCount,
                        &Parameters->rOperands[0],
                        gcvNULL);

        status = slsROPERAND_ChangeDataTypeFamily(
                                                Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                treatFloatAsInt,
                                                Parameters->dataTypes[0],
                                                &Parameters->rOperands[0]);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmVERIFY_OK(sloIR_POLYNARY_EXPR_FinalizeOperandsParameters(
                                                                Compiler,
                                                                operandCount,
                                                                operandsParameters));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenConstructArrayCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctUINT    operandCount;
    slsGEN_CODE_PARAMETERS *operandsParameters;

    gcmHEADER();
    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    status = sloIR_POLYNARY_EXPR_GenOperandsCode(Compiler,
                             CodeGenerator,
                             PolynaryExpr,
                             Parameters->needROperand,
                             &operandCount,
                             &operandsParameters);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if (Parameters->needROperand)
    {
        gctUINT i, j, k;

        /* Allocate the operand(s) */
        gcmONERROR(slsGEN_CODE_PARAMETERS_AllocateOperands(Compiler,
                                   Parameters,
                                   PolynaryExpr->exprBase.dataType));

        k = 0;
        for(i = 0; i < operandCount; i++) {
           for(j = 0; j < operandsParameters[i].operandCount; j++) {
                       Parameters->rOperands[k] = operandsParameters[i].rOperands[j];
                       status = slsROPERAND_ChangeDataTypeFamily(Compiler,
                                                                 PolynaryExpr->exprBase.base.lineNo,
                                                                 PolynaryExpr->exprBase.base.stringNo,
                                                                 gcvFALSE,
                                                                 Parameters->dataTypes[k],
                                                                 &Parameters->rOperands[k]);
                       if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                       k++;
           }
        }
        gcmASSERT(Parameters->operandCount == k);
    }

OnError:
    gcmVERIFY_OK(sloIR_POLYNARY_EXPR_FinalizeOperandsParameters(Compiler,
                                    operandCount,
                                    operandsParameters));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

typedef struct _slsOPERANDS_LOCATION
{
    gctUINT         currentOperand;

    gctUINT8        startComponent;
}
slsOPERANDS_LOCATION;

#define slsOPERANDS_LOCATION_Initialize(location) \
    do \
    { \
        (location)->currentOperand  = 0; \
        (location)->startComponent  = 0; \
    } \
    while (gcvFALSE)

gceSTATUS
sloIR_POLYNARY_EXPR_GenVectorComponentAssignCode(
    IN sloCOMPILER Compiler,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN slsGEN_CODE_PARAMETERS * OperandsParameters,
    IN slsIOPERAND * IOperand,
    IN OUT slsOPERANDS_LOCATION * Location
    )
{
    gceSTATUS       status;
    gctUINT8        lOperandStartComponent = 0;
    gctUINT8        requiredComponentCount;
    slsROPERAND     rOperandSlice;
    gctUINT8        sliceComponentCount;
    slsLOPERAND     lOperand, lOperandSlice;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount > 0);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);
    gcmASSERT(gcIsVectorDataType(IOperand->dataType));
    gcmASSERT(Location);

    requiredComponentCount = gcGetVectorDataTypeComponentCount(IOperand->dataType);

    slsLOPERAND_InitializeUsingIOperand(&lOperand, IOperand);

    while (requiredComponentCount > 0)
    {
        gcmASSERT(Location->currentOperand < OperandCount);
        gcmASSERT(OperandsParameters[Location->currentOperand].operandCount == 1);

        if (!_GetROperandSlice(
                            &OperandsParameters[Location->currentOperand].rOperands[0],
                            &Location->startComponent,
                            &requiredComponentCount,
                            &rOperandSlice,
                            &sliceComponentCount))
        {
            Location->currentOperand++;
            Location->startComponent = 0;
            continue;
        }

        slGetVectorLOperandSlice(&lOperand,
                                 lOperandStartComponent,
                                 sliceComponentCount,
                                 &lOperandSlice);

        lOperandStartComponent += sliceComponentCount;

        status = slsROPERAND_ChangeDataTypeFamily(
                                                Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                OperandsParameters[
                                                    Location->currentOperand].treatFloatAsInt,
                                                lOperandSlice.dataType,
                                                &rOperandSlice);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        status = slGenAssignCode(
                                Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                &lOperandSlice,
                                &rOperandSlice);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenMatrixComponentAssignCode(
    IN sloCOMPILER Compiler,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN slsGEN_CODE_PARAMETERS * OperandsParameters,
    IN slsIOPERAND * IOperand
    )
{
    gceSTATUS               status;
    gctUINT                 matrixColumnCount, i;
    slsOPERANDS_LOCATION    location;
    slsIOPERAND             matrixColumnIOperand[1];

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount > 0);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);
    gcmASSERT(gcIsMatrixDataType(IOperand->dataType));

    matrixColumnCount = gcGetMatrixDataTypeColumnCount(IOperand->dataType);

    slsOPERANDS_LOCATION_Initialize(&location);

    for (i = 0; i < matrixColumnCount; i++)
    {
        slsIOPERAND_InitializeAsMatrixColumn(matrixColumnIOperand, IOperand, i);

        status = sloIR_POLYNARY_EXPR_GenVectorComponentAssignCode(
                                                                Compiler,
                                                                PolynaryExpr,
                                                                OperandCount,
                                                                OperandsParameters,
                                                                matrixColumnIOperand,
                                                                &location);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenScalarToVectorAssignCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN gctBOOL TreatFloatAsInt,
    IN slsROPERAND * ScalarROperand,
    IN slsIOPERAND * VectorIOperand,
    OUT slsROPERAND * VectorROperand
    )
{
    gceSTATUS       status;
    slsROPERAND     scalarROperand;
    slsLOPERAND     vectorLOperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ScalarROperand);
    gcmASSERT(VectorIOperand);
    gcmASSERT(VectorROperand);

    scalarROperand = *ScalarROperand;

    status = slsROPERAND_ChangeDataTypeFamily(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            TreatFloatAsInt,
                                            gcGetVectorComponentDataType(VectorIOperand->dataType),
                                            &scalarROperand);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slsLOPERAND_InitializeTempReg(&vectorLOperand,
                                  slvSTORAGE_QUALIFIER_NONE,
                                  scalarROperand.dataType,
                                  scalarROperand.u.reg.precision,
                                  VectorIOperand->tempRegIndex);

    status = slGenAssignCode(
                            Compiler,
                            LineNo,
                            StringNo,
                            &vectorLOperand,
                            &scalarROperand);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slsROPERAND_InitializeUsingIOperand(VectorROperand, VectorIOperand);

    VectorROperand->u.reg.componentSelection.w =
        VectorROperand->u.reg.componentSelection.z =
        VectorROperand->u.reg.componentSelection.y =
            VectorROperand->u.reg.componentSelection.x;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenConstructVectorCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS                       status;
    gctUINT                         operandCount;
    slsGEN_CODE_PARAMETERS *        operandsParameters;
    slsIOPERAND                     iOperand;
    slsOPERANDS_LOCATION            location;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    status = sloIR_POLYNARY_EXPR_GenOperandsCode(
                                                Compiler,
                                                CodeGenerator,
                                                PolynaryExpr,
                                                Parameters->needROperand,
                                                &operandCount,
                                                &operandsParameters);

    gcmASSERT(operandCount > 0);

    if (gcmIS_ERROR(status))
    {
        gcmFOOTER();
        return status;
    }

    gcmASSERT(operandsParameters);
    if (operandsParameters == gcvNULL)
    {
        status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        gcmFOOTER();
        return status;
    }

    if (Parameters->needROperand)
    {
        /* Allocate the operand(s) */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        PolynaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmASSERT(Parameters->operandCount == 1);

        if (operandCount == 1 && operandsParameters[0].operandCount == 1
            && gcIsScalarDataType(operandsParameters[0].dataTypes[0]))
        {
            if (!operandsParameters[0].rOperands[0].isReg)
            {
                /* Convert the scalar constant to the vector constant */
                Parameters->rOperands[0] = operandsParameters[0].rOperands[0];

                slsROPERAND_CONSTANT_ConvScalarToVector(
                                                    Compiler,
                                                    Parameters->dataTypes[0],
                                                    &Parameters->rOperands[0]);
            }
            else
            {
                /* Generate the special assignment */
                slsIOPERAND_New(Compiler,
                                &iOperand,
                                Parameters->dataTypes[0],
                                Parameters->rOperands[0].u.reg.precision);

                slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &iOperand);

                status = _GenScalarToVectorAssignCode(
                                                    Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    operandsParameters[0].treatFloatAsInt,
                                                    &operandsParameters[0].rOperands[0],
                                                    &iOperand,
                                                    &Parameters->rOperands[0]);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
        }
        else
        {
            /* Generate the assignment(s) */
            slsIOPERAND_New(Compiler,
                            &iOperand,
                            Parameters->dataTypes[0],
                            Parameters->rOperands[0].u.reg.precision);

            slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &iOperand);

            slsOPERANDS_LOCATION_Initialize(&location);

            status = sloIR_POLYNARY_EXPR_GenVectorComponentAssignCode(
                                                                    Compiler,
                                                                    PolynaryExpr,
                                                                    operandCount,
                                                                    operandsParameters,
                                                                    &iOperand,
                                                                    &location);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
    }

    gcmVERIFY_OK(sloIR_POLYNARY_EXPR_FinalizeOperandsParameters(
                                                                Compiler,
                                                                operandCount,
                                                                operandsParameters));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenScalarToMatrixAssignCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsROPERAND * ScalarROperand,
    IN slsIOPERAND * MatrixIOperand
    )
{
    gceSTATUS       status;
    gctUINT         i, j;
    slsROPERAND     scalarROperand;
    slsLOPERAND     matrixLOperand, componentLOperand;
    slsROPERAND     zeroROperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(ScalarROperand);
    gcmASSERT(MatrixIOperand);

    scalarROperand = *ScalarROperand;

    status = slsROPERAND_ChangeDataTypeFamily(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            gcvFALSE,
                                            gcSHADER_FLOAT_X1,
                                            &scalarROperand);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    slsLOPERAND_InitializeUsingIOperand(&matrixLOperand, MatrixIOperand);
    slsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                                                  gcSHADER_FLOAT_X1,
                                                  gcSHADER_PRECISION_MEDIUM,
                                                  (gctFLOAT)0.0);

    for (i = 0; i < gcGetMatrixDataTypeColumnCount(MatrixIOperand->dataType); i++)
    {
        for (j = 0; j < gcGetMatrixDataTypeRowCount(MatrixIOperand->dataType); j++)
        {
            slsLOPERAND_InitializeAsMatrixComponent(&componentLOperand, &matrixLOperand, i, j);

            if (i == j)
            {
                status = slGenAssignCode(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        &componentLOperand,
                                        &scalarROperand);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
            else
            {
                status = slGenAssignCode(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        &componentLOperand,
                                        &zeroROperand);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }
        }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenMatrixToMatrixAssignCode(
    IN sloCOMPILER Compiler,
    IN gctUINT LineNo,
    IN gctUINT StringNo,
    IN slsROPERAND * MatrixROperand,
    IN slsIOPERAND * MatrixIOperand
    )
{
    gceSTATUS       status;
    gctUINT         targetMatrixColumnCount, targetMatrixRowCount, sourceMatrixColumnCount, sourceMatrixRowCount;
    gctUINT         i, j;
    slsLOPERAND     matrixLOperand, columnLOperand, columnSliceLOperand, componentLOperand;
    slsROPERAND     columnROperand, columnSliceROperand, oneROperand, zeroROperand;
    gctUINT8        sliceComponentCount;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(MatrixROperand);
    gcmASSERT(MatrixIOperand);

    sourceMatrixColumnCount = gcGetMatrixDataTypeColumnCount(MatrixROperand->dataType);
    sourceMatrixRowCount = gcGetMatrixDataTypeRowCount(MatrixROperand->dataType);
    targetMatrixColumnCount = gcGetMatrixDataTypeColumnCount(MatrixIOperand->dataType);
    targetMatrixRowCount = gcGetMatrixDataTypeRowCount(MatrixIOperand->dataType);

    slsLOPERAND_InitializeUsingIOperand(&matrixLOperand, MatrixIOperand);
    slsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                                                  gcSHADER_FLOAT_X1,
                                                  gcSHADER_PRECISION_MEDIUM,
                                                  (gctFLOAT)1.0);
    slsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                                                  gcSHADER_FLOAT_X1,
                                                  gcSHADER_PRECISION_MEDIUM,
                                                  (gctFLOAT)0.0);

    for (i = 0; i < targetMatrixColumnCount; i++)
    {
        slsLOPERAND_InitializeAsMatrixColumn(&columnLOperand, &matrixLOperand, i);
        slsROPERAND_InitializeAsMatrixColumn(&columnROperand, MatrixROperand, i);

        if (targetMatrixRowCount == sourceMatrixRowCount && i < sourceMatrixColumnCount)
        {
            status = slGenAssignCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    &columnLOperand,
                                    &columnROperand);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else if ((targetMatrixRowCount < sourceMatrixRowCount) && i < sourceMatrixColumnCount)
        {
            _GetVectorROperandSlice(
                                    &columnROperand,
                                    0,
                                    (gctUINT8) targetMatrixRowCount,
                                    &columnSliceROperand,
                                    &sliceComponentCount);

            gcmASSERT(sliceComponentCount == targetMatrixRowCount);

            status = slGenAssignCode(
                                    Compiler,
                                    LineNo,
                                    StringNo,
                                    &columnLOperand,
                                    &columnSliceROperand);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else
        {
            if (targetMatrixRowCount > sourceMatrixRowCount && i < sourceMatrixColumnCount)
            {
                slGetVectorLOperandSlice(&columnLOperand,
                                         0,
                                         (gctUINT8) sourceMatrixRowCount,
                                         &columnSliceLOperand);

                status = slGenAssignCode(
                                        Compiler,
                                        LineNo,
                                        StringNo,
                                        &columnSliceLOperand,
                                        &columnROperand);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

                j = sourceMatrixRowCount;
            }
            else
            {
                j = 0;
            }

            for (; j < targetMatrixRowCount; j++)
            {
                slsLOPERAND_InitializeAsMatrixComponent(&componentLOperand, &matrixLOperand, i, j);

                if (i == j)
                {
                    status = slGenAssignCode(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            &componentLOperand,
                                            &oneROperand);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
                else
                {
                    status = slGenAssignCode(
                                            Compiler,
                                            LineNo,
                                            StringNo,
                                            &componentLOperand,
                                            &zeroROperand);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
            }   /* for */
        }   /* if */
    }   /* for */

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenConstructMatrixCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS                       status;
    gctUINT                         operandCount;
    slsGEN_CODE_PARAMETERS *        operandsParameters;
    slsIOPERAND                     iOperand;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    status = sloIR_POLYNARY_EXPR_GenOperandsCode(
                                                Compiler,
                                                CodeGenerator,
                                                PolynaryExpr,
                                                Parameters->needROperand,
                                                &operandCount,
                                                &operandsParameters);

    gcmASSERT(operandCount > 0);

    if (gcmIS_ERROR(status))
    {
        gcmFOOTER();
        return status;
    }

    gcmASSERT(operandsParameters);
    if (operandsParameters == gcvNULL)
    {
        status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        gcmFOOTER();
        return status;
    }

    if (Parameters->needROperand)
    {
        /* Allocate the register(s) */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        PolynaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmASSERT(Parameters->operandCount == 1);

        slsIOPERAND_New(Compiler,
                        &iOperand,
                        Parameters->dataTypes[0],
                        Parameters->rOperands[0].u.reg.precision);

        slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], &iOperand);

        /* Generate the assignment(s) */
        if (operandCount == 1 && operandsParameters[0].operandCount == 1
            && gcIsScalarDataType(operandsParameters[0].dataTypes[0]))
        {
            status = _GenScalarToMatrixAssignCode(
                                                Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                &operandsParameters[0].rOperands[0],
                                                &iOperand);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else if (operandCount == 1 && operandsParameters[0].operandCount == 1
            && gcIsMatrixDataType(operandsParameters[0].dataTypes[0]))
        {
            status = _GenMatrixToMatrixAssignCode(
                                                Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                &operandsParameters[0].rOperands[0],
                                                &iOperand);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
        else
        {
            status = sloIR_POLYNARY_EXPR_GenMatrixComponentAssignCode(
                                                                    Compiler,
                                                                    PolynaryExpr,
                                                                    operandCount,
                                                                    operandsParameters,
                                                                    &iOperand);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
        }
    }

    gcmVERIFY_OK(sloIR_POLYNARY_EXPR_FinalizeOperandsParameters(
                                                                Compiler,
                                                                operandCount,
                                                                operandsParameters));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenConstructStructCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS                       status;
    gctUINT                         operandCount;
    slsGEN_CODE_PARAMETERS *        operandsParameters;
    gctUINT                         i, j, k;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    status = sloIR_POLYNARY_EXPR_GenOperandsCode(
                                                Compiler,
                                                CodeGenerator,
                                                PolynaryExpr,
                                                Parameters->needROperand,
                                                &operandCount,
                                                &operandsParameters);

    gcmASSERT(operandCount > 0);

    if (gcmIS_ERROR(status))
    {
        gcmFOOTER();
        return status;
    }

    gcmASSERT(operandsParameters);
    if (operandsParameters == gcvNULL)
    {
        status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        gcmFOOTER();
        return status;
    }

    if (Parameters->needROperand)
    {
        /* Allocate the register(s) */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(
                                                        Compiler,
                                                        Parameters,
                                                        PolynaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        /* Copy all operands */
        for (i = 0, j = 0, k = 0; i < Parameters->operandCount; i++, k++)
        {
            if (k == operandsParameters[j].operandCount)
            {
                k = 0;
                j++;
            }

            gcmASSERT(j < operandCount);
            gcmASSERT(k < operandsParameters[j].operandCount);
            Parameters->rOperands[i] = operandsParameters[j].rOperands[k];
        }
    }

    gcmVERIFY_OK(sloIR_POLYNARY_EXPR_FinalizeOperandsParameters(
                                                                Compiler,
                                                                operandCount,
                                                                operandsParameters));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenBuiltInCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS                       status;
    gctUINT                         operandCount;
    slsGEN_CODE_PARAMETERS *        operandsParameters;
    slsIOPERAND                     iOperandBuf[1];
    slsIOPERAND                     *iOperand = gcvNULL;
    gcSHADER_PRECISION              precision;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Force it to generate code when the function return value is not used */
    Parameters->needROperand = gcvTRUE;

    /* Generate the code of all operands */
    status = sloIR_POLYNARY_EXPR_GenOperandsCode(Compiler,
                                                 CodeGenerator,
                                                 PolynaryExpr,
                                                 Parameters->needROperand,
                                                 &operandCount,
                                                 &operandsParameters);

    if (Parameters->needROperand && !slsDATA_TYPE_IsVoid(PolynaryExpr->exprBase.dataType))
    {
        /* Allocate the register(s) */
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(Compiler,
                                                         Parameters,
                                                         PolynaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        gcmASSERT(Parameters->operandCount == 1);

        if (operandCount == 0)
        {
            precision = Parameters->rOperands[0].u.reg.precision;
        }
        else
        {
            gcmASSERT(operandsParameters);
            precision = GetHigherPrecison(operandsParameters->rOperands[0].u.reg.precision,
                                          Parameters->rOperands[0].u.reg.precision);
        }
        slsIOPERAND_New(Compiler,
                        iOperandBuf,
                        Parameters->dataTypes[0],
                        precision);

        iOperand = iOperandBuf;
        slsROPERAND_InitializeUsingIOperand(&Parameters->rOperands[0], iOperand);
    }

    /* Generate the built-in code */
    status = slGenBuiltInFunctionCode(Compiler,
                                      CodeGenerator,
                                      PolynaryExpr,
                                      operandCount,
                                      operandsParameters,
                                      iOperand,
                                      Parameters);

    if (Parameters->needROperand && !slsDATA_TYPE_IsVoid(PolynaryExpr->exprBase.dataType))
    {
        Parameters->rOperands[0].u.reg.precision = iOperand->precision;
    }

    if (gcmIS_ERROR(status)) {
        gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            slvREPORT_ERROR,
            "invalid builtin function '%s'", PolynaryExpr->funcSymbol));

       gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
       return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    gcmVERIFY_OK(sloIR_POLYNARY_EXPR_FinalizeOperandsParameters(Compiler,
                                                                operandCount,
                                                                operandsParameters));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenFuncCallCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctBOOL  intrinsicCall,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS                   status;
    gctUINT                     operandCount, i, j;
    slsGEN_CODE_PARAMETERS *    operandsParameters;
    slsNAME *                   paramName;
    slsLOPERAND                 lOperand;
    slsROPERAND                 rOperand;
    slsIOPERAND                 intermIOperand;
    slsLOPERAND                 intermLOperand;
    slsROPERAND                 intermROperand;
    gctLABEL                    funcLabel;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    if (!PolynaryExpr->funcName->isBuiltIn && !intrinsicCall &&
        !PolynaryExpr->funcName->u.funcInfo.isFuncDef)
    {
        gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        slvREPORT_ERROR,
                                        "function \'%s\' has not been defined",
                                        PolynaryExpr->funcName->symbol));
        gcmFOOTER_NO();
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    /* Allocate the function resources */
    status = _AllocateFuncResources(Compiler,
                                    CodeGenerator,
                                    PolynaryExpr->funcName,
                                    intrinsicCall);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Generate the code of all operands */
    status = sloIR_POLYNARY_EXPR_GenOperandsCodeForFuncCall(Compiler,
                                                            CodeGenerator,
                                                            PolynaryExpr,
                                                            &operandCount,
                                                            &operandsParameters);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Set all 'in' arguments */
    i = 0;
    FOR_EACH_DLINK_NODE(&PolynaryExpr->funcName->u.funcInfo.localSpace->names, slsNAME, paramName)
    {
        if (paramName->type != slvPARAMETER_NAME) break;

        gcmASSERT(i < operandCount);

        switch (paramName->dataType->qualifiers.storage)
        {
        case slvSTORAGE_QUALIFIER_CONST_IN:
        case slvSTORAGE_QUALIFIER_IN:
        case slvSTORAGE_QUALIFIER_INOUT:
            gcmASSERT(operandsParameters[i].needROperand);

            for (j = 0; j < operandsParameters[i].operandCount; j++)
            {
                slsLOPERAND_Initialize(&lOperand,
                                       paramName->context.logicalRegs + j);

                /* set lOperand's precision */
                lOperand.reg.precision = paramName->dataType->qualifiers.precision;

                if (gcIsSamplerDataType(lOperand.dataType))
                {
                    status = slGenAssignSamplerCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    &lOperand,
                                                    operandsParameters[i].rOperands + j);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
                else if(gcIsImageDataType(lOperand.dataType))
                {
                    status = slGenAssignCode(Compiler,
                                             PolynaryExpr->exprBase.base.lineNo,
                                             PolynaryExpr->exprBase.base.stringNo,
                                             &lOperand,
                                             operandsParameters[i].rOperands + j);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
                else
                {
                    status = slGenAssignCode(Compiler,
                                             PolynaryExpr->exprBase.base.lineNo,
                                             PolynaryExpr->exprBase.base.stringNo,
                                             &lOperand,
                                             operandsParameters[i].rOperands + j);

                    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
                }
            }

            break;

        default:
            break;
        }

        i++;
    }

    /* Generate the call code */
    status = slGetFunctionLabel(Compiler,
                                PolynaryExpr->funcName->context.function,
                                &funcLabel);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    status = slEmitAlwaysBranchCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    slvOPCODE_CALL,
                                    funcLabel);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Get all 'out' arguments */
    i = 0;
    FOR_EACH_DLINK_NODE(&PolynaryExpr->funcName->u.funcInfo.localSpace->names, slsNAME, paramName)
    {
        if (paramName->type != slvPARAMETER_NAME) break;

        gcmASSERT(i < operandCount);

        switch (paramName->dataType->qualifiers.storage)
        {
        case slvSTORAGE_QUALIFIER_OUT:
        case slvSTORAGE_QUALIFIER_INOUT:
            gcmASSERT(operandsParameters[i].needLOperand);

            for (j = 0; j < operandsParameters[i].operandCount; j++)
            {
                slsROPERAND_InitializeReg(&rOperand,
                                          paramName->context.logicalRegs + j);

                status = slGenAssignCode(Compiler,
                                         PolynaryExpr->exprBase.base.lineNo,
                                         PolynaryExpr->exprBase.base.stringNo,
                                         operandsParameters[i].lOperands + j,
                                         &rOperand);

                if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
            }

            break;
        }

        i++;
    }

    /* Get the return value */
    if (Parameters->needROperand)
    {
        status = slsGEN_CODE_PARAMETERS_AllocateOperands(Compiler,
                                                         Parameters,
                                                         PolynaryExpr->exprBase.dataType);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        for (i = 0; i < Parameters->operandCount; i++)
        {
            /* Returned value needs to be stored to a temp register, optimizer will optimize this MOV if */
            /* it is redundant truely */
            slsIOPERAND_New(Compiler,
                            &intermIOperand,
                            (PolynaryExpr->funcName->context.logicalRegs + i)->dataType,
                            (PolynaryExpr->funcName->context.logicalRegs + i)->precision);
            slsLOPERAND_InitializeUsingIOperand(&intermLOperand, &intermIOperand);
            slsROPERAND_InitializeReg(&intermROperand,
                                      PolynaryExpr->funcName->context.logicalRegs + i);

            status = slGenAssignCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    &intermLOperand,
                                    &intermROperand);

            if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

            slsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);
            *(Parameters->rOperands + i) = intermROperand;
        }
    }

    gcmVERIFY_OK(sloIR_POLYNARY_EXPR_FinalizeOperandsParameters(Compiler,
                                                                operandCount,
                                                                operandsParameters));

    PolynaryExpr->funcName->context.function->intrinsicsKind = gceINTRIN_NONE;

    if (intrinsicCall)
    {
        gcSHADER    shader;
        gcSHADER_LABEL  shaderLabel;

        gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &shader));

        /* set shader has the intrinsic builtin */
        SetShaderHasIntrinsicBuiltin(shader, gcvTRUE);

        /* set function call's intrinsic kind */
        PolynaryExpr->funcName->context.function->intrinsicsKind = PolynaryExpr->funcName->u.funcInfo.intrinsicKind;

        /* set intrinsic function label's function, these labels
           needs to be patched later after compiling the library*/
        if (gcSHADER_FindLabel(shader, funcLabel, &shaderLabel))
        {
            shaderLabel->function = PolynaryExpr->funcName->context.function;
        }
        else
        {
            gcmASSERT(gcvFALSE);
        }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_POLYNARY_EXPR_TryToEvaluate(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS               status;
    sloIR_POLYNARY_EXPR     newPolynaryExpr;
    sloIR_EXPR              operand;
    slsGEN_CODE_PARAMETERS  operandParameters;
    sloIR_CONSTANT          operandConstant;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(Parameters);

    if (PolynaryExpr->type == slvPOLYNARY_FUNC_CALL && !PolynaryExpr->funcName->isBuiltIn)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    /* Create a new polynary expression */
    status = sloIR_POLYNARY_EXPR_Construct(
                                        Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        PolynaryExpr->type,
                                        PolynaryExpr->exprBase.dataType,
                                        PolynaryExpr->funcSymbol,
                                        &newPolynaryExpr);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    if(PolynaryExpr->operands == gcvNULL) { gcmFOOTER(); return status; }

    status = sloIR_SET_Construct(
                                Compiler,
                                PolynaryExpr->operands->base.lineNo,
                                PolynaryExpr->operands->base.stringNo,
                                PolynaryExpr->operands->type,
                                &newPolynaryExpr->operands);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    /* Try to evaluate all operands */
    FOR_EACH_DLINK_NODE(&PolynaryExpr->operands->members, struct _sloIR_EXPR, operand)
    {
        /* Try to evaluate the operand */
        slsGEN_CODE_PARAMETERS_Initialize(
                                        &operandParameters,
                                        gcvFALSE,
                                        gcvTRUE);

        operandParameters.hint = slvEVALUATE_ONLY;

        status = sloIR_OBJECT_Accept(
                                    Compiler,
                                    &operand->base,
                                    &CodeGenerator->visitor,
                                    &operandParameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        operandConstant             = operandParameters.constant;
        operandParameters.constant  = gcvNULL;

        slsGEN_CODE_PARAMETERS_Finalize(&operandParameters);

        if (operandConstant == gcvNULL) goto Exit;

        /* Add to the new polynary expression */
        gcmVERIFY_OK(sloIR_SET_AddMember(
                                        Compiler,
                                        newPolynaryExpr->operands,
                                        &operandConstant->exprBase.base));
    }

    if (newPolynaryExpr->type == slvPOLYNARY_FUNC_CALL)
    {
        status = sloCOMPILER_BindFuncCall(Compiler, newPolynaryExpr);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    /* Try to evaluate the new polynary expression */
    status = sloIR_POLYNARY_EXPR_Evaluate(
                                        Compiler,
                                        newPolynaryExpr,
                                        &Parameters->constant);

    if (gcmIS_SUCCESS(status) && Parameters->constant != gcvNULL)
    {
        newPolynaryExpr = gcvNULL;
    }

Exit:
    if (newPolynaryExpr != gcvNULL)
    {
        gcmVERIFY_OK(sloIR_OBJECT_Destroy(Compiler, &newPolynaryExpr->exprBase.base));
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloIR_POLYNARY_EXPR_GenCode(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN sloIR_POLYNARY_EXPR PolynaryExpr,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS       status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(PolynaryExpr, slvIR_POLYNARY_EXPR);
    gcmASSERT(Parameters);

    /* Try to evaluate the polynary expression */
    if (!Parameters->needLOperand && Parameters->needROperand)
    {
        status = sloIR_POLYNARY_EXPR_TryToEvaluate(
                                                Compiler,
                                                CodeGenerator,
                                                PolynaryExpr,
                                                Parameters);

        if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

        if (Parameters->hint == slvEVALUATE_ONLY)
        {
            gcmFOOTER_KILL();
            return gcvSTATUS_OK;
        }

        if (Parameters->constant != gcvNULL)
        {
            status = sloIR_CONSTANT_GenCode(
                                        Compiler,
                                        CodeGenerator,
                                        Parameters->constant,
                                        Parameters);
            gcmFOOTER();
            return status;
        }
    }

    switch (PolynaryExpr->type)
    {
    case slvPOLYNARY_CONSTRUCT_FLOAT:
    case slvPOLYNARY_CONSTRUCT_INT:
    case slvPOLYNARY_CONSTRUCT_BOOL:
    case slvPOLYNARY_CONSTRUCT_UINT:
        status = sloIR_POLYNARY_EXPR_GenConstructScalarCode(
                                                        Compiler,
                                                        CodeGenerator,
                                                        PolynaryExpr,
                                                        Parameters);

        gcmFOOTER();
        return status;

    case slvPOLYNARY_CONSTRUCT_ARRAY:
    case slvPOLYNARY_CONSTRUCT_ARRAYS_OF_ARRAYS:
    status = sloIR_POLYNARY_EXPR_GenConstructArrayCode(Compiler,
                                                           CodeGenerator,
                                                           PolynaryExpr,
                                                           Parameters);
        gcmFOOTER();
        return status;

    case slvPOLYNARY_CONSTRUCT_VEC2:
    case slvPOLYNARY_CONSTRUCT_VEC3:
    case slvPOLYNARY_CONSTRUCT_VEC4:
    case slvPOLYNARY_CONSTRUCT_BVEC2:
    case slvPOLYNARY_CONSTRUCT_BVEC3:
    case slvPOLYNARY_CONSTRUCT_BVEC4:
    case slvPOLYNARY_CONSTRUCT_IVEC2:
    case slvPOLYNARY_CONSTRUCT_IVEC3:
    case slvPOLYNARY_CONSTRUCT_IVEC4:
    case slvPOLYNARY_CONSTRUCT_UVEC2:
    case slvPOLYNARY_CONSTRUCT_UVEC3:
    case slvPOLYNARY_CONSTRUCT_UVEC4:
        status = sloIR_POLYNARY_EXPR_GenConstructVectorCode(
                                                        Compiler,
                                                        CodeGenerator,
                                                        PolynaryExpr,
                                                        Parameters);

        gcmFOOTER();
        return status;

    case slvPOLYNARY_CONSTRUCT_MAT2:
    case slvPOLYNARY_CONSTRUCT_MAT2X3:
    case slvPOLYNARY_CONSTRUCT_MAT2X4:
    case slvPOLYNARY_CONSTRUCT_MAT3:
    case slvPOLYNARY_CONSTRUCT_MAT3X2:
    case slvPOLYNARY_CONSTRUCT_MAT3X4:
    case slvPOLYNARY_CONSTRUCT_MAT4:
    case slvPOLYNARY_CONSTRUCT_MAT4X2:
    case slvPOLYNARY_CONSTRUCT_MAT4X3:
        status = sloIR_POLYNARY_EXPR_GenConstructMatrixCode(
                                                        Compiler,
                                                        CodeGenerator,
                                                        PolynaryExpr,
                                                        Parameters);

        gcmFOOTER();
        return status;

    case slvPOLYNARY_CONSTRUCT_STRUCT:
        status = sloIR_POLYNARY_EXPR_GenConstructStructCode(
                                                        Compiler,
                                                        CodeGenerator,
                                                        PolynaryExpr,
                                                        Parameters);

        gcmFOOTER();
        return status;

    case slvPOLYNARY_FUNC_CALL:
        gcmASSERT(PolynaryExpr->funcName);

        /* generate a normal function call for intrinsic builtin functions */
        if (PolynaryExpr->funcName->u.funcInfo.isIntrinsicCall)
        {
            status = sloIR_POLYNARY_EXPR_GenFuncCallCode(
                                                    Compiler,
                                                    CodeGenerator,
                                                    PolynaryExpr,
                                                    gcvTRUE,
                                                    Parameters);

        }
        else if (PolynaryExpr->funcName->isBuiltIn)
        {
            status = sloIR_POLYNARY_EXPR_GenBuiltInCode(
                                                    Compiler,
                                                    CodeGenerator,
                                                    PolynaryExpr,
                                                    Parameters);
        }
        else
        {
            status = sloIR_POLYNARY_EXPR_GenFuncCallCode(
                                                    Compiler,
                                                    CodeGenerator,
                                                    PolynaryExpr,
                                                    gcvFALSE,
                                                    Parameters);
        }
        gcmFOOTER();
        return status;
    default:
        gcmASSERT(0);
        status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
        gcmFOOTER();
        return status;
    }
}

gceSTATUS
sloIR_VIV_Asm_GenOperandsCode(
    IN sloCOMPILER          Compiler,
    IN sloCODE_GENERATOR    CodeGenerator,
    IN sloIR_VIV_ASM        VivASM,
    IN gctBOOL              NeedROperand,
    OUT gctUINT *           OperandCount,
    OUT slsGEN_CODE_PARAMETERS * * OperandsParameters
    )
{
    gceSTATUS                   status;
    gctUINT                     operandCount;
    slsGEN_CODE_PARAMETERS *    operandsParameters;
    sloIR_EXPR                  operand;
    gctUINT                     i = 0;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(VivASM, slvIR_VIV_ASM);
    gcmASSERT(OperandCount);
    gcmASSERT(OperandsParameters);

    if (VivASM->operands == gcvNULL)
    {
        *OperandCount       = 0;
        *OperandsParameters = gcvNULL;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    do
    {
        gctPOINTER pointer = gcvNULL;

        gcmVERIFY_OK(sloIR_SET_GetMemberCount(
                                            Compiler,
                                            VivASM->operands,
                                            &operandCount));

        gcmASSERT(operandCount > 0);

        status = sloCOMPILER_Allocate(
                                    Compiler,
                                    (gctSIZE_T)sizeof(slsGEN_CODE_PARAMETERS) * operandCount,
                                    &pointer);

        if (gcmIS_ERROR(status)) break;

        operandsParameters = pointer;

        status = sloCOMPILER_Allocate(
                                    Compiler,
                                    (gctSIZE_T)sizeof(slsASM_MODIFIERS) * operandCount,
                                    &pointer);

        if (gcmIS_ERROR(status)) break;

        VivASM->opndMods = pointer;

        FOR_EACH_DLINK_NODE(&VivASM->operands->members, struct _sloIR_EXPR, operand)
        {
            slsGEN_CODE_PARAMETERS_Initialize(&operandsParameters[i], gcvFALSE, NeedROperand);

            status = sloIR_OBJECT_Accept(
                                        Compiler,
                                        &operand->base,
                                        &CodeGenerator->visitor,
                                        &operandsParameters[i]);

            if (gcmIS_ERROR(status)) break;

            VivASM->opndMods[i] = gcvNULL;

            if (operand->asmMods != gcvNULL)
            {
                status = sloCOMPILER_Allocate(
                                        Compiler,
                                        (gctSIZE_T)sizeof(slsASM_MODIFIERS),
                                        &pointer);
                if (gcmIS_ERROR(status)) break;

                VivASM->opndMods[i]    = pointer;
                *(VivASM->opndMods[i]) = *operand->asmMods;
            }

            i++;
        }

        if (gcmIS_ERROR(status)) break;

        *OperandCount       = operandCount;
        *OperandsParameters = operandsParameters;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    *OperandCount       = 0;
    *OperandsParameters = gcvNULL;

    gcmFOOTER();
    return status;
}

gceSTATUS
sloIR_VIV_ASM_GenCode(
    IN sloCOMPILER                  Compiler,
    IN sloCODE_GENERATOR            CodeGenerator,
    IN sloIR_VIV_ASM                VivAsm,
    IN OUT slsGEN_CODE_PARAMETERS * Parameters
    )
{
    gceSTATUS                       status;
    gctUINT                         operandCount;
    slsGEN_CODE_PARAMETERS *        operandsParameters;
    slsIOPERAND                     iOperand;
    gcSL_OPCODE                     opcode;
    gctUINT                         i;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);
    slmVERIFY_IR_OBJECT(VivAsm, slvIR_VIV_ASM);
    gcmASSERT(Parameters);
    gcmASSERT(!Parameters->needLOperand);

    /* Generate the code of all operands */
    status = sloIR_VIV_Asm_GenOperandsCode(Compiler,
                                            CodeGenerator,
                                            VivAsm,
                                            gcvTRUE,
                                            &operandCount,
                                            &operandsParameters);

    if(!operandsParameters[0].rOperands[0].isReg ||
        operandsParameters[0].rOperands[0].u.reg.qualifier == slvSTORAGE_QUALIFIER_CONST ||
        operandsParameters[0].rOperands[0].u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM ||
        operandsParameters[0].rOperands[0].u.reg.qualifier == slvSTORAGE_QUALIFIER_UNIFORM_BLOCK_MEMBER ||
        operandsParameters[0].rOperands[0].u.reg.qualifier == slvSTORAGE_QUALIFIER_CONST_IN ||
        operandsParameters[0].rOperands[0].u.reg.qualifier == slvSTORAGE_QUALIFIER_INSTANCE_ID ||
        operandsParameters[0].rOperands[0].u.reg.qualifier == slvSTORAGE_QUALIFIER_VERTEX_ID)
    {
        gcmFOOTER();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    for (i = 0; i < operandCount; ++i)
    {
        if (gcIsMatrixDataType(operandsParameters[i].rOperands[0].dataType))
        {
            gcmFOOTER();
            return gcvSTATUS_INVALID_ARGUMENT;
        }
    }

    opcode = (gcSL_OPCODE)VivAsm->opcode.opcode;

    if (operandCount > 0)
    {
        slsIOPERAND_Initialize(&iOperand,
                                operandsParameters[0].rOperands[0].dataType,
                                operandsParameters[0].rOperands[0].u.reg.precision,
                                operandsParameters[0].rOperands[0].u.reg.regIndex);
    }

    gcmONERROR( slGenBuiltinVivAsmCode(
        Compiler,
        VivAsm,
        VivAsm->base.lineNo,
        VivAsm->base.stringNo,
        opcode,
        operandCount > 0 ? &iOperand : gcvNULL,
        operandCount > 1 ? operandsParameters[1].rOperands : gcvNULL,
        operandCount > 2 ? operandsParameters[2].rOperands : gcvNULL,
        operandCount > 3 ? operandsParameters[3].rOperands : gcvNULL));

    gcmVERIFY_OK(sloIR_POLYNARY_EXPR_FinalizeOperandsParameters(Compiler,
                                                                operandCount,
                                                                operandsParameters));


    gcmFOOTER();
    return status;

OnError:
    gcmVERIFY_OK(sloCOMPILER_Report(Compiler,
        VivAsm->base.lineNo,
        VivAsm->base.stringNo,
        slvREPORT_ERROR,
        "invalid builtin asm '%s'", VivAsm->opcode.opcode));

    gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
    return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
}

gceSTATUS
sloIR_AllocObjectPointerArrays(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gcSHADER  shader;
    gceSTATUS status;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(CodeGenerator);
    gcmVERIFY_OK(sloCOMPILER_GetBinary(Compiler, &shader));

    if(CodeGenerator->attributeCount) {
      status = gcSHADER_ReallocateAttributes(shader, (gctSIZE_T)CodeGenerator->attributeCount);
          if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    if(CodeGenerator->uniformCount) {
      status = gcSHADER_ReallocateUniforms(shader, (gctSIZE_T)CodeGenerator->uniformCount);
          if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    if(CodeGenerator->variableCount) {
      status = gcSHADER_ReallocateVariables(shader, (gctSIZE_T)CodeGenerator->variableCount);
          if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    if(CodeGenerator->outputCount) {
      status = gcSHADER_ReallocateOutputs(shader, (gctSIZE_T)CodeGenerator->outputCount);
          if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }
    if(CodeGenerator->functionCount) {
      status = gcSHADER_ReallocateFunctions(shader, (gctSIZE_T)CodeGenerator->functionCount);
          if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
sloCODE_GENERATOR_Construct(
    IN sloCOMPILER Compiler,
    OUT sloCODE_GENERATOR * CodeGenerator
    )
{
    gceSTATUS           status;
    sloCODE_GENERATOR   codeGenerator;
    gctBOOL             isCreateDefaultUBO = gcvFALSE;
    sleSHADER_TYPE      shaderType;
    sleCOMPILER_FLAGS   flag;

    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    gcmASSERT(CodeGenerator);

    do
    {
        gctPOINTER pointer = gcvNULL;

        gcmVERIFY_OK(sloCOMPILER_GetCompilerFlag(Compiler, &flag));

        status = sloCOMPILER_Allocate(
                                    Compiler,
                                    (gctSIZE_T)sizeof(struct _sloCODE_GENERATOR),
                                    &pointer);

        if (gcmIS_ERROR(status)) break;

        codeGenerator = pointer;

        /* Initialize the visitor */
        codeGenerator->visitor.object.type          = slvOBJ_CODE_GENERATOR;

        codeGenerator->visitor.visitSet             =
                        (sltVISIT_SET_FUNC_PTR)sloIR_SET_GenCode;

        codeGenerator->visitor.visitIteration       =
                        (sltVISIT_ITERATION_FUNC_PTR)sloIR_ITERATION_GenCode;

        codeGenerator->visitor.visitJump            =
                        (sltVISIT_JUMP_FUNC_PTR)sloIR_JUMP_GenCode;


        codeGenerator->visitor.visitLabel =
                        (sltVISIT_LABEL_FUNC_PTR)sloIR_LABEL_GenCode;

        codeGenerator->visitor.visitVariable        =
                        (sltVISIT_VARIABLE_FUNC_PTR)sloIR_VARIABLE_GenCode;

        codeGenerator->visitor.visitConstant        =
                        (sltVISIT_CONSTANT_FUNC_PTR)sloIR_CONSTANT_GenCode;

        codeGenerator->visitor.visitUnaryExpr       =
                        (sltVISIT_UNARY_EXPR_FUNC_PTR)sloIR_UNARY_EXPR_GenCode;

        codeGenerator->visitor.visitBinaryExpr      =
                        (sltVISIT_BINARY_EXPR_FUNC_PTR)sloIR_BINARY_EXPR_GenCode;

        codeGenerator->visitor.visitSelection       =
                        (sltVISIT_SELECTION_FUNC_PTR)sloIR_SELECTION_GenCode;

        codeGenerator->visitor.visitSwitch =
                        (sltVISIT_SWITCH_FUNC_PTR)sloIR_SWITCH_GenCode;

        codeGenerator->visitor.visitPolynaryExpr    =
                        (sltVISIT_POLYNARY_EXPR_FUNC_PTR)sloIR_POLYNARY_EXPR_GenCode;

        codeGenerator->visitor.visitVivAsm          =
                        (sltVISIT_VIV_ASM_FUNC_PTR)sloIR_VIV_ASM_GenCode;

        /* Initialize other data members */
        codeGenerator->currentIterationContext      = gcvNULL;

        if(slsCOMPILER_HasUnspecifiedLocation(flag)) {
            codeGenerator->layoutLocation = 0;
        }
        else {
            codeGenerator->layoutLocation = -1;
        }

        if(slsCOMPILER_HasUnspecifiedUniformLocation(flag)) {
            codeGenerator->layoutUniformLocation = 0;
        }
        else {
            codeGenerator->layoutUniformLocation = -1;
        }

        sloCOMPILER_IsCreateDefaultUBO(Compiler, &isCreateDefaultUBO);
        sloCOMPILER_GetShaderType(Compiler, &shaderType);
        if (((isCreateDefaultUBO && (gcmOPT_CreateDefaultUBO() != 0))
             || (shaderType != slvSHADER_TYPE_COMPUTE && gcmOPT_CreateDefaultUBO())) &&
            gcoHAL_IsFeatureAvailable1(gcvNULL, gcvFEATURE_HALTI1))
        {
            codeGenerator->createDefaultUBO = gcvTRUE;
        }
        else codeGenerator->createDefaultUBO = gcvFALSE;

        *CodeGenerator = codeGenerator;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }
    while (gcvFALSE);

    *CodeGenerator = gcvNULL;

    gcmFOOTER();
    return status;
}

gceSTATUS
sloCODE_GENERATOR_Destroy(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator
    )
{
    gcmHEADER();

    /* Verify the arguments. */
    slmVERIFY_OBJECT(Compiler, slvOBJ_COMPILER);
    slmVERIFY_OBJECT(CodeGenerator, slvOBJ_CODE_GENERATOR);;

    gcmVERIFY_OK(sloCOMPILER_Free(Compiler, CodeGenerator));

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
slAddUnusedOutputPatch(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME_SPACE* globalNameSpace
    )
{
    slsNAME* globalName;
    gceSTATUS status = gcvSTATUS_OK;

    gcmHEADER();

    FOR_EACH_DLINK_NODE(&globalNameSpace->names, slsNAME, globalName)
    {
        if ((globalName->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_VARYING_OUT) ||
            (globalName->type == slvVARIABLE_NAME &&
             globalName->u.variableInfo.interfaceBlock &&
             slsDATA_TYPE_IsUnderlyingIOBlock(globalName->u.variableInfo.interfaceBlock->dataType)))
        {
            status = slsNAME_AllocLogicalRegs(Compiler,
                                              CodeGenerator,
                                              globalName);
            if (gcmIS_ERROR(status)) { gcmFOOTER_NO(); return status; }

            if (globalName->u.variableInfo.isReferenced)
            {
                slsNAME_SetStaticallyUsed(Compiler,
                                          globalName,
                                          globalName->context.logicalRegs,
                                          globalName->context.logicalRegCount);
            }
        }
    }

    gcmFOOTER_NO();
    return status;
}

gceSTATUS
slAddUnusedInputPatch(
    IN sloCOMPILER Compiler,
    IN sloCODE_GENERATOR CodeGenerator,
    IN slsNAME_SPACE* globalNameSpace
    )
{
    slsNAME* globalName;
    gceSTATUS status = gcvSTATUS_OK;

    gcmHEADER();

    FOR_EACH_DLINK_NODE(&globalNameSpace->names, slsNAME, globalName)
    {
        if ((globalName->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_VARYING_IN) ||
            (globalName->type == slvVARIABLE_NAME &&
             globalName->u.variableInfo.interfaceBlock &&
             slsDATA_TYPE_IsUnderlyingIOBlock(globalName->u.variableInfo.interfaceBlock->dataType)))
        {
            status = slsNAME_AllocLogicalRegs(Compiler,
                                              CodeGenerator,
                                              globalName);
            if (gcmIS_ERROR(status)) { gcmFOOTER_NO(); return status; }

            if (globalName->u.variableInfo.isReferenced)
            {
                slsNAME_SetStaticallyUsed(Compiler,
                                          globalName,
                                          globalName->context.logicalRegs,
                                          globalName->context.logicalRegCount);
            }
        }
    }

    gcmFOOTER_NO();
    return status;
}

gceSTATUS
slPackSSBOWithSharedOrStd140OrStd430(
    IN sloCOMPILER Compiler,
    IN slsNAME_SPACE* globalNameSpace
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    slsNAME* globalName, *ssbo;

    gcmHEADER();

    FOR_EACH_DLINK_NODE(&globalNameSpace->names, slsNAME, globalName)
    {
        if (globalName->type == slvVARIABLE_NAME &&
            globalName->u.variableInfo.interfaceBlock &&
            slsDATA_TYPE_IsUnderlyingStorageBlock(globalName->u.variableInfo.interfaceBlock->dataType))
        {
            ssbo = globalName->u.variableInfo.interfaceBlock;

            gcmASSERT(slsDATA_TYPE_IsUnderlyingStorageBlock(ssbo->dataType));
            gcmASSERT(globalName->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_NONE ||
                      globalName->dataType->qualifiers.storage == slvSTORAGE_QUALIFIER_STORAGE_BLOCK_MEMBER);

            if ((ssbo->dataType->qualifiers.layout.id & slvLAYOUT_SHARED) ||
                (ssbo->dataType->qualifiers.layout.id & slvLAYOUT_STD140) ||
                (ssbo->dataType->qualifiers.layout.id & slvLAYOUT_STD430))
            {
                if (ssbo->u.interfaceBlockContent.u.storageBlock == gcvNULL)
                    gcmONERROR(_AllocLogicalRegForInterfaceBlock(Compiler, sloCOMPILER_GetCodeGenerator(Compiler), globalName));
            }
        }
    }

    gcmFOOTER_NO();
    return status;

OnError:
    gcmFOOTER_NO();
    return status;
}
