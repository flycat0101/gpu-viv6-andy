/****************************************************************************
*
*    Copyright (c) 2005 - 2018 by Vivante Corp.  All rights reserved.
*
*    The material in this file is confidential and contains trade secrets
*    of Vivante Corporation. This is proprietary information owned by
*    Vivante Corporation. No part of this work may be disclosed,
*    reproduced, copied, transmitted, or used in any way for any purpose,
*    without the express written permission of Vivante Corporation.
*
*****************************************************************************/


#ifndef __gc_cl_built_ins_math_h_
#define __gc_cl_built_ins_math_h_

#define FULL_PROFILE_TEST   1

clsBUILTIN_FUNCTION    MathBuiltinFunctions[] =
{
    {clvEXTENSION_NONE,     "half_sin",            T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_sin",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "sin",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "half_cos",            T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_cos",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "cos",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "sincos",              T_F_GENTYPE,       2, {T_F_GENTYPE, T_F_GENTYPE}, {0, 1}, {1, 0}, 0},
    {clvEXTENSION_NONE,     "half_tan",            T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_tan",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "tan",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "asin",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "acos",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "atan",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "half_divide",         T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "native_divide",       T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "sinh",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "cosh",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "tanh",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "asinh",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "acosh",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "atanh",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "sinpi",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "cospi",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "tanpi",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "tgamma",              T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "erfc",                   T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "erf",                   T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "asinpi",              T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "acospi",              T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "atanpi",              T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "atan2",               T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "atan2pi",             T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "cbrt",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "hypot",               T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    /* Exponential Functions */
    {clvEXTENSION_NONE,     "pow",                 T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "half_powr",           T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "native_powr",         T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "powr",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "pown",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_I_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "rootn",               T_F_GENTYPE,    2, {T_F_GENTYPE, T_I_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "half_exp",            T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_exp",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "exp",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "half_exp10",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_exp10",        T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "exp10",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "expm1",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "half_log",            T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_log",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "log",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "half_exp2",           T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_exp2",         T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "exp2",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "half_log2",           T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_log2",         T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "log2",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "half_log10",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_log10",        T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "log10",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "log1p",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "half_sqrt",           T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_sqrt",         T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "sqrt",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "half_recip",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_recip",        T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "reciprocal",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "half_rsqrt",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native_rsqrt",        T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "rsqrt",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    /* Common Functions */
    {clvEXTENSION_NONE,     "fabs",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "sign",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "floor",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "rint",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "ceil",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,        "fract",             T_F_GENTYPE,  2, {T_F_GENTYPE, T_F_GENTYPE}, {0, 1}, {1, 0}, 1},

    {clvEXTENSION_NONE,     "modf",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0, 1}, {1, 0}, 1},

    {clvEXTENSION_NONE,     "frexp",               T_F_GENTYPE,    2, {T_F_GENTYPE, T_I_GENTYPE}, {0, 1}, {1, 0}, 1},

    {clvEXTENSION_NONE,     "fmod",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "nextafter",           T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "remainder",           T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "remquo",              T_F_GENTYPE,    3, {T_F_GENTYPE, T_F_GENTYPE, T_I_GENTYPE}, {0, 0, 1}, {1, 1, 0}, 1},
    {clvEXTENSION_NONE,     "ilogb",               T_I_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "logb",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "nan",                 T_F_GENTYPE,    1, {T_U_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "ldexp",               T_F_GENTYPE,    2, {T_F_GENTYPE, T_I_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "round",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "trunc",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "copysign",            T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "fmin",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "fmin",                T_FLOAT2,       2, {T_FLOAT2,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "fmin",                T_FLOAT3,       2, {T_FLOAT3,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "fmin",                T_FLOAT4,       2, {T_FLOAT4,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "fmin",                T_FLOAT8,       2, {T_FLOAT8,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "fmin",                T_FLOAT16,      2, {T_FLOAT16,   T_FLOAT},     {0}, {0}, 1},

    {clvEXTENSION_NONE,     "fmax",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "fmax",                T_FLOAT2,       2, {T_FLOAT2,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "fmax",                T_FLOAT3,       2, {T_FLOAT3,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "fmax",                T_FLOAT4,       2, {T_FLOAT4,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "fmax",                T_FLOAT8,       2, {T_FLOAT8,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "fmax",                T_FLOAT16,      2, {T_FLOAT16,   T_FLOAT},     {0}, {0}, 1},


    {clvEXTENSION_NONE,     "fdim",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "fmix",                T_F_GENTYPE,    3, {T_F_GENTYPE, T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1, 1}, 1},
    {clvEXTENSION_NONE,     "fma",                 T_F_GENTYPE,    3, {T_F_GENTYPE, T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1, 1}, 0},
    {clvEXTENSION_NONE,     "fast_fma",            T_F_GENTYPE,    3, {T_F_GENTYPE, T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1, 1}, 0},
    {clvEXTENSION_NONE,     "mad",                 T_F_GENTYPE,    3, {T_F_GENTYPE, T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1, 1}, 1},


    {clvEXTENSION_NONE,     "maxmag",              T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "minmag",              T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "viv_half_sin",            T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_sin",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_sin",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_half_cos",            T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_cos",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_cos",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_sincos",              T_F_GENTYPE,       2, {T_F_GENTYPE, T_F_GENTYPE}, {0, 1}, {1, 0}, 0},
    {clvEXTENSION_NONE,     "viv_half_tan",            T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_tan",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_tan",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native#asin",             T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_asin",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native#acos",             T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_acos",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "native#atan",             T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_atan",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_half_divide",         T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_native_divide",       T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_sinh",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_cosh",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_tanh",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_asinh",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_acosh",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_atanh",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_sinpi",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_cospi",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_tanpi",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_tgamma",              T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_erfc",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_erf",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_asinpi",              T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_acospi",              T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_atanpi",              T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_atan2",               T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "viv_atan2pi",             T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "viv_cbrt",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_hypot",               T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    /* Vivante Primitive Exponential Functions */
    {clvEXTENSION_NONE,     "viv_pow",                 T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "viv_half_powr",           T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_native_powr",         T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_powr",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_pown",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_I_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "viv_rootn",               T_F_GENTYPE,    2, {T_F_GENTYPE, T_I_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "viv_half_exp",            T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_exp",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_exp",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_half_exp10",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_exp10",        T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_exp10",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_expm1",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_half_log",            T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_log",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_log",                 T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_half_exp2",           T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_exp2",         T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_exp2",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_half_log2",           T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_log2",         T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_log2",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_half_log10",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_log10",        T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_log10",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_log1p",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_half_sqrt",           T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_sqrt",         T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_sqrt",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_half_recip",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_recip",        T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_reciprocal",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "add#",                    T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {0}, 1},
    {clvEXTENSION_NONE,     "sub#",                    T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {0}, 1},
    {clvEXTENSION_NONE,     "mul#",                    T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {0}, 1},
    {clvEXTENSION_NONE,     "divide#",                 T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {0}, 1},
    {clvEXTENSION_NONE,     "divide_int#",             T_IU_GENTYPE,   2, {T_IU_GENTYPE, T_IU_GENTYPE}, {0}, {0}, 1},

    {clvEXTENSION_NONE,     "viv_half_rsqrt",          T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_native_rsqrt",        T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_rsqrt",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    /* Vivante Primitive Common Functions */
    {clvEXTENSION_NONE,     "viv_fabs",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_sign",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_floor",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_rint",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,     "viv_ceil",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},

    {clvEXTENSION_NONE,        "viv_fract",             T_F_GENTYPE,  2, {T_F_GENTYPE, T_F_GENTYPE}, {0, 1}, {1, 0}, 1},

    {clvEXTENSION_NONE,     "viv_modf",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0, 1}, {1, 0}, 1},

    {clvEXTENSION_NONE,     "viv_frexp",               T_F_GENTYPE,    2, {T_F_GENTYPE, T_I_GENTYPE}, {0, 1}, {1, 0}, 1},

    {clvEXTENSION_NONE,     "viv_fmod",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "viv_nextafter",           T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "viv_remainder",           T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "viv_remquo",              T_F_GENTYPE,    3, {T_F_GENTYPE, T_F_GENTYPE, T_I_GENTYPE}, {0, 0, 1}, {1, 1, 0}, 1},
    {clvEXTENSION_NONE,     "viv_ilogb",               T_I_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_logb",                T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_nan",                 T_F_GENTYPE,    1, {T_U_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_ldexp",               T_F_GENTYPE,    2, {T_F_GENTYPE, T_I_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_round",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_trunc",               T_F_GENTYPE,    1, {T_F_GENTYPE}, {0}, {1}, 1},
    {clvEXTENSION_NONE,     "viv_copysign",            T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "mod#",                    T_IU_GENTYPE,    2, {T_IU_GENTYPE, T_IU_GENTYPE}, {0}, {0}, 1},

    {clvEXTENSION_NONE,     "viv_fmin",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_fmin",                T_FLOAT2,       2, {T_FLOAT2,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_fmin",                T_FLOAT3,       2, {T_FLOAT3,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_fmin",                T_FLOAT4,       2, {T_FLOAT4,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_fmin",                T_FLOAT8,       2, {T_FLOAT8,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_fmin",                T_FLOAT16,      2, {T_FLOAT16,   T_FLOAT},     {0}, {0}, 1},

    {clvEXTENSION_NONE,     "viv_fmax",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_fmax",                T_FLOAT2,       2, {T_FLOAT2,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_fmax",                T_FLOAT3,       2, {T_FLOAT3,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_fmax",                T_FLOAT4,       2, {T_FLOAT4,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_fmax",                T_FLOAT8,       2, {T_FLOAT8,    T_FLOAT},     {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_fmax",                T_FLOAT16,      2, {T_FLOAT16,   T_FLOAT},     {0}, {0}, 1},


    {clvEXTENSION_NONE,     "viv_fdim",                T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_fmix",                T_F_GENTYPE,    3, {T_F_GENTYPE, T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_fma",                 T_F_GENTYPE,    3, {T_F_GENTYPE, T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1, 1}, 0},
    {clvEXTENSION_NONE,     "fma#",                    T_F_GENTYPE,    3, {T_F_GENTYPE, T_F_GENTYPE, T_F_GENTYPE}, {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_mad",                 T_F_GENTYPE,    3, {T_F_GENTYPE, T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1, 1}, 1},


    {clvEXTENSION_NONE,     "viv_maxmag",              T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},
    {clvEXTENSION_NONE,     "viv_minmag",              T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {1, 1}, 1},

    {clvEXTENSION_NONE,     "viv_add_lo",          T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_mul_lo",          T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_add_rtz",         T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_sub_rtz",         T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {0}, 1},
    {clvEXTENSION_NONE,     "viv_mul_rtz",         T_F_GENTYPE,    2, {T_F_GENTYPE, T_F_GENTYPE}, {0}, {0}, 1},
};

#define _cldMathBuiltinFunctionCount (sizeof(MathBuiltinFunctions) / sizeof(clsBUILTIN_FUNCTION))

/*Those function are for full profile, actually good for simple profile, but need gc4000 */
#if FULL_PROFILE_TEST
static gceSTATUS
_GenFullProfileRootnCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    clsROPERAND zeroROperand, nanROperand, unsignROperand, signROperand, oddROperand, infROperand, halfInfROperand;
    clsROPERAND oneROperand, mantissaROperand, twenty3ROperand, int127ROperand, thirty1ROperand, int255ROperand, intNeg255ROperand;

    clsIOPERAND        intermIOperands[15];
    clsROPERAND        intermROperands[15];
    gceSTATUS                    status;
    int i;
    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7fC00000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x80000000);
    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&halfInfROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 0x3fc00000);

    clsROPERAND_InitializeIntOrIVecConstant(&oddROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x1);

    clsROPERAND_InitializeIntOrIVecConstant(&twenty3ROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 23);
    clsROPERAND_InitializeIntOrIVecConstant(&thirty1ROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 31);

    clsROPERAND_InitializeIntOrIVecConstant(&int127ROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 127);
    clsROPERAND_InitializeIntOrIVecConstant(&mantissaROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x007fffff);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                          clmGenCodeDataType(T_FLOAT),
                          (gctFLOAT) 1.0f);


    clsROPERAND_InitializeIntOrIVecConstant(&int255ROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 255);

    clsROPERAND_InitializeIntOrIVecConstant(&intNeg255ROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) (-255));

    for(i = 0; i<15; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    intermIOperands[0].dataType.elementType = clvTYPE_INT;



    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INT_TO_FLOAT,
                &intermIOperands[0],
                &OperandsParameters[1].rOperands[0]);

    intermIOperands[0].dataType.elementType = clvTYPE_FLOAT;



        /* r3 = y&0x01 */
        /* r4 = sign(x) */
        intermIOperands[3].dataType.elementType = clvTYPE_INT;
        intermROperands[3].dataType.elementType = clvTYPE_INT;

        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[3],
            &OperandsParameters[1].rOperands[0],
            &oddROperand);

        /* r5 = abs(x)*/
        status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ABS,
                            &intermIOperands[4],
                            &OperandsParameters[0].rOperands[0]);

        intermIOperands[5].dataType.elementType = clvTYPE_INT;
        intermIOperands[4].dataType.elementType = clvTYPE_INT;
        intermROperands[4].dataType.elementType = clvTYPE_INT;
        /*Clean the sign bit. |-0| = -0 */
        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[5],
            &intermROperands[4],
            &unsignROperand);

        intermIOperands[5].dataType.elementType = clvTYPE_FLOAT;
        intermIOperands[14].dataType.elementType = clvTYPE_INT;
        status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            &intermIOperands[13],
            &zeroROperand);
        /* r0: float(Y), r3: oddY, r4: sign(x), r5: abs(x), r14: 0,normal case  */

        /* If y == 0 */
    clmGEN_CODE_IF(Compiler, /*IF_0 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &OperandsParameters[1].rOperands[0],
                 clvCONDITION_EQUAL,
                 &zeroROperand);
    /*return to Nan */
    status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            IOperand,
            &nanROperand);
   clmGEN_CODE_ELSE(Compiler,  /*IF_0 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
    /*Now y != 0 */

   /*Check x == Nan?  */
    clmGEN_CODE_IF(Compiler, /*IF_10 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[5],
                 clvCONDITION_GREATER_THAN,
                 &infROperand);
    /*return to Nan */
    status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            IOperand,
            &nanROperand);
   clmGEN_CODE_ELSE(Compiler,  /*IF_10 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /* check if Y is Odd */
    clmGEN_CODE_IF(Compiler, /*IF_2 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[3],
                 clvCONDITION_EQUAL,
                 &zeroROperand);

    /*Check if x < 0.0, beware -0.0 = 0x80000000 is 0, Very strange, the test takes 0x80000001<0.0f  */
    OperandsParameters[0].rOperands[0].dataType.elementType = clvTYPE_UINT;
    clmGEN_CODE_IF(Compiler, /*IF_1 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &OperandsParameters[0].rOperands[0],
                 clvCONDITION_GREATER_THAN,
                 &signROperand);
    OperandsParameters[0].rOperands[0].dataType.elementType = clvTYPE_FLOAT;


    /*Now X < 0, Y is even, return to Nan, assign Nan to r13, add r13 to the end */
    status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            &intermIOperands[13],
            &nanROperand);

   clmGEN_CODE_ELSE(Compiler,  /*IF_1 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /*x >= 0, but y Even, same as normal case Do Nothing, r13 = 0 */
    /*The final sign */
     status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            &intermIOperands[4],
            &zeroROperand);


   clmGEN_CODE_ENDIF(Compiler, /*IF_1 */
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ELSE(Compiler,  /*IF_2 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /*y is odd */
   /*The final sign of result*/
        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[4],
            &OperandsParameters[0].rOperands[0],
            &signROperand);

   clmGEN_CODE_ENDIF(Compiler, /*IF_1 */
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

   /*x != Nan case */

   /* |r5 - halfInf| == halfInf? */
    intermIOperands[6].dataType.elementType = clvTYPE_INT;
    intermROperands[6].dataType.elementType = clvTYPE_INT;

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTNE,
                                &intermIOperands[6],
                                &halfInfROperand,
                                &intermROperands[5]);

    status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ABS,
                            &intermIOperands[14],
                            &intermROperands[6]);

    /*Check X == 0 or X == Inf ? */
    clmGEN_CODE_IF(Compiler, /*IF_3 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[14],
                 clvCONDITION_EQUAL,
                 &halfInfROperand);
    /*Now Yes */

    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_XOR_BITWISE,
            &intermIOperands[3],
            &intermROperands[6],
            &OperandsParameters[1].rOperands[0]);

    /*PosInf/2 or NegInf/2  XOr Y, Get sign, sign = 0, return 0, else return inf */

    status = clGenShiftExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_RSHIFT,
                        &intermIOperands[3],
                        &intermROperands[3],
                        &thirty1ROperand);

    /*r3 = (inf/2 - x) ^ y < 0 ? inf : 0, under condition |x-inf/2| = inf/2 */
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[3],
            &intermROperands[3],
            &infROperand);


   clmGEN_CODE_ELSE(Compiler,  /*IF_3 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /*Now normal case. x != 0, x != Inf, x != Nan, (y > 0), x > 0 || (x<0 && y Odd) */

    /* r7 = 1/r0, precise enough*/
        intermROperands[0].dataType.elementType = clvTYPE_FLOAT;
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INVERSE,
                &intermIOperands[7],
                &intermROperands[0]);


        /*Now, r7 is well approximation of 1/n. We have to x = 2^p*Man, pow(x, 1/y) = 2^(p/y)*2 ^ Log(Man)/y */
        {
            intermIOperands[8].dataType.elementType = clvTYPE_SHORT; /*Doesn't do Saturation, we will use it later */
            intermIOperands[8].dataType.elementType = clvTYPE_INT;   /*Temp use, SW saturation */
            intermROperands[8].dataType.elementType = clvTYPE_INT;
            intermIOperands[9].dataType.elementType = clvTYPE_INT;
            intermROperands[9].dataType.elementType = clvTYPE_INT;
            intermIOperands[10].dataType.elementType = clvTYPE_INT;
            intermROperands[10].dataType.elementType = clvTYPE_INT;
            /*Float to Short, saturation atomatically*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_FLOAT_TO_INT,
                        &intermIOperands[8],
                        &intermROperands[0]);

            /*No clipping necessary  for GC5200, but GC5200 Cmodel with old driver (GC2100), we have to do */
        status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MIN,
                    &intermIOperands[9],
                    &intermROperands[8],
                    &int255ROperand);

        /*No clipping necessary  for GC5200, but GC5200 Cmodel with old driver (GC2100), we have to do */
        status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MAX,
                    &intermIOperands[8],
                    &intermROperands[9],
                    &intNeg255ROperand);

            /*Get exp part of x*/
            status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[9],
                &OperandsParameters[0].rOperands[0],
                &infROperand);


            /*Shift x component to low bits*/
            status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &intermIOperands[10],
                                &intermROperands[9],
                                &twenty3ROperand);


            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTNE,
                        &intermIOperands[9],
                        &intermROperands[10],
                        &int127ROperand);

            intermROperands[8].dataType.elementType = clvTYPE_SHORT;
            intermROperands[9].dataType.elementType = clvTYPE_SHORT;
            intermIOperands[10].dataType.elementType = clvTYPE_SHORT;

            /*Get exponent(x)/n, short calculation */
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_DIV,
                        &intermIOperands[10],
                        &intermROperands[9],
                        &intermROperands[8]);

            intermROperands[8].dataType.elementType = clvTYPE_INT;
            intermROperands[9].dataType.elementType = clvTYPE_INT;
            intermIOperands[10].dataType.elementType = clvTYPE_INT;

            /* (exponent(x)/n) * n */
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTNE,
                        &intermIOperands[9],
                        &intermROperands[10],
                        &intermROperands[8]);

            /* Put in the exponent position. */
            status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[8],
                                &intermROperands[9],
                                &twenty3ROperand);

            /*Integer sub, similar to remove part of exponent part exponent(x)/n*n, r5 = |x| */
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTNE,
                        &intermIOperands[9],
                        &intermROperands[5],
                        &intermROperands[8]);

            /* 2^(exponent(x)/n) in float: (i+127)<<23 */
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTNE,
                        &intermIOperands[8],
                        &intermROperands[10],
                        &int127ROperand);
            /*r10 = 2^(exponent(x)/n)*/
            status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[10],
                                &intermROperands[8],
                                &twenty3ROperand);

            /*Now floating calculation*/
            intermIOperands[8].dataType.elementType = clvTYPE_FLOAT;
            intermIOperands[9].dataType.elementType = clvTYPE_FLOAT;
            intermIOperands[10].dataType.elementType = clvTYPE_FLOAT;

            intermROperands[8].dataType.elementType = clvTYPE_FLOAT;
            intermROperands[9].dataType.elementType = clvTYPE_FLOAT;
            intermROperands[10].dataType.elementType = clvTYPE_FLOAT;

            /*Exp2(Log2(r9)*1/n)*r10*/
            status = clGenGenericCode1(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_LOG2,
                                    &intermIOperands[8],
                                    &intermROperands[9]);

            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTNE,
                        &intermIOperands[9],
                        &intermROperands[7],
                        &intermROperands[8]);

            status = clGenGenericCode1(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_EXP2,
                                    &intermIOperands[8],
                                    &intermROperands[9]);


            /*The r3 is the final result, not sign yet*/
            intermIOperands[3].dataType.elementType = clvTYPE_FLOAT;
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTNE,
                        &intermIOperands[3],
                        &intermROperands[10],
                        &intermROperands[8]);

    }
   clmGEN_CODE_ENDIF(Compiler, /*IF_3 */
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

   intermIOperands[3].dataType.elementType = clvTYPE_INT;

    /*Add back the sign of X */
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_OR_BITWISE,
            &intermIOperands[3],
            &intermROperands[4],
            &intermROperands[3]);

    /*Add Nan or Zero, since (-Inf)^(1/8) also go through here */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTNE,
                IOperand,
                &intermROperands[13],
                &intermROperands[3]);

   clmGEN_CODE_ENDIF(Compiler, /*IF_10 */
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler, /*IF_0 */
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

    return gcvSTATUS_OK;
OnError:
   return status;
}

static gceSTATUS
_GenFullProfileSinCosPiCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    strstr(PolynaryExpr->funcName->symbol, "sin")? clvOPCODE_SINPI : clvOPCODE_COSPI,
                    IOperand,
                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenFullProfileTanPiCode(
    IN cloCOMPILER Compiler,

    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_TANPI,
                    IOperand,
                    &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenFullProfileExpE_10Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand,
    IN gctINT    baseIndex /*1: 87: E^(x)/(x>87?:2:1)*/
    )
{

    gceSTATUS        status;
    clsROPERAND        oneROperand, logEROperand, logTwoROperand, logTwoLowROperand, zeroROperand;
    clsIOPERAND        intermIOperands[9];
    clsROPERAND        intermROperands[9], oneIntROperand;
    int i;

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              1.0f);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                              clmGenCodeDataType(T_FLOAT),
                              0.0f);

    clsROPERAND_InitializeIntOrIVecConstant(&oneIntROperand,
                                            clmGenCodeDataType(T_UINT),
                                            1);


    if(strstr(PolynaryExpr->funcName->symbol, "10") == NULL){ /*10 Not in function name,  */
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&logEROperand,
                                  clmGenCodeDataType(T_FLOAT),
                                  (gctFLOAT) _LOGE_2);

        clsROPERAND_InitializeFloatOrVecOrMatConstant(&logTwoROperand,
                                  clmGenCodeDataType(T_FLOAT),
                                  ( _LOG2_E_high ) );

        clsROPERAND_InitializeFloatOrVecOrMatConstant(&logTwoLowROperand,
                                  clmGenCodeDataType(T_FLOAT),
                                  ( _LOG2_E_low ));
    }
    else{ /*Log10(x) */
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&logEROperand,
                                  clmGenCodeDataType(T_FLOAT),
                                  (gctFLOAT) _LOG10_2);

        clsROPERAND_InitializeFloatOrVecOrMatConstant(&logTwoROperand,
                                  clmGenCodeDataType(T_FLOAT),
                                  ( _LOG2_10_high ) );

        clsROPERAND_InitializeFloatOrVecOrMatConstant(&logTwoLowROperand,
                                  clmGenCodeDataType(T_FLOAT),
                                  ( _LOG2_10_low ));
    }

    /* mul x, _LOG2_E */
    for(i = 0; i<6; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    /*Beware, this multiply should use round to zero!, otherwise, not meaning of MULLO_RTZw */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0],
                                    &logTwoROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MULLO_RTZ,
                                    &intermIOperands[1],
                                    &OperandsParameters[0].rOperands[0],
                                    &logTwoROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTNE,
                                    &intermIOperands[2],
                                    &OperandsParameters[0].rOperands[0],
                                    &logTwoLowROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTNE,
                                    &intermIOperands[3],
                                    &intermROperands[1],
                                    &intermROperands[2]);
    if (gcmIS_ERROR(status)) return status;

    status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_FLOOR,
                            &intermIOperands[1],
                            &intermROperands[0]);
    if (gcmIS_ERROR(status)) return status;
    if(baseIndex == 87){
        clsROPERAND        float87ROperand;
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&float87ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              87.0f);

        clmGEN_CODE_IF(Compiler, /*IF 00 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_GREATER_THAN,
             &float87ROperand);
        /*Integer part sub 1, 2^(x) divided by 2 */
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTNE,
                                    &intermIOperands[1],
                                    &intermROperands[1],
                                    &oneROperand);

        clmGEN_CODE_ELSE(Compiler, /*IF 00 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
        clmGEN_CODE_ENDIF(Compiler, /*IF 00 */
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

    }

/*Get FRACTION part */
    status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_FRACT_RTZ,
                            &intermIOperands[2],
                            &intermROperands[0]);
    if (gcmIS_ERROR(status)) return status;

/* Fractional + residue */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTNE,
                                    &intermIOperands[0],
                                    &intermROperands[2],
                                    &intermROperands[3]);
    if (gcmIS_ERROR(status)) return status;

    status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_EXP2,
                            &intermIOperands[2],
                            &intermROperands[0]);

    status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_EXP2,
                            &intermIOperands[3],
                            &intermROperands[1]);

    if(baseIndex != -1){ /*Normally */
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTNE,
                                        IOperand,
                                        &intermROperands[3],
                                        &intermROperands[2]);
    }
    else{ /*Exp(x) - 1.0*/
        float coefExpm1[ ] = {
         1.000000000000000000000000f,
         0.500000417232513430000000f,
         0.166666850447654720000000f,
         0.041660461574792862000000f,
         0.008331260643899440800000f,
         0.001412113895639777200000f,
         0.000203609248274005950000f,
        };
        clsROPERAND dot7ROperand, expm1CoefROperand[7], twoROperand, neg2ROperand, outRangeROperand;

        clsROPERAND_InitializeFloatOrVecOrMatConstant(&dot7ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              0.7f);

        clsROPERAND_InitializeIntOrIVecConstant(&twoROperand,
                                            clmGenCodeDataType(T_INT),
                                            2);

        clsROPERAND_InitializeIntOrIVecConstant(&neg2ROperand,
                                            clmGenCodeDataType(T_INT),
                                            -2);
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&outRangeROperand,
                          clmGenCodeDataType(T_FLOAT),
                          (float)80.0f);

        for(i = 0; i<7; i++){
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&expm1CoefROperand[i],
                              clmGenCodeDataType(T_FLOAT),
                              coefExpm1[i]);
        }
        status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ABS,
                                &intermIOperands[4],
                                &OperandsParameters[0].rOperands[0]);

        clmGEN_CODE_IF(Compiler, /*IF 01 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &intermROperands[4],
             clvCONDITION_GREATER_THAN,
             &dot7ROperand);
        /*|x| > 0.70, e^x - 1: get rough result, then adjusted to fit 3.0 ULP */
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTNE,
                                        &intermIOperands[5],
                                        &intermROperands[3],
                                        &intermROperands[2]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTNE,
                                        &intermIOperands[1],
                                        &intermROperands[5],
                                        &oneROperand);

        OperandsParameters[0].rOperands[0].dataType.elementType = clvTYPE_UINT;
        outRangeROperand.dataType.elementType = clvTYPE_UINT;
        /*Uint compare, big number and Neg value doesn't need to adjusted */
        clmGEN_CODE_IF(Compiler, /*IF 02 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_GREATER_THAN_EQUAL,
             &outRangeROperand);

        OperandsParameters[0].rOperands[0].dataType.elementType = clvTYPE_FLOAT;
        /*When E^|x| very big, or x<0.0 */
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &intermROperands[1]);

        clmGEN_CODE_ELSE(Compiler, /*IF 02 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

        /*Since 2^(frac(x)) may not be accurate enough, frac(x) - log(2^frac(x)) to adjust */
        status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LOG2,
                            &intermIOperands[4],
                            &intermROperands[2]);

        intermROperands[4].dataType.elementType = clvTYPE_INT;
        intermROperands[0].dataType.elementType = clvTYPE_INT;
        intermIOperands[4].dataType.elementType = clvTYPE_INT;
        intermIOperands[0].dataType.elementType = clvTYPE_INT;

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB,
                                        &intermIOperands[4],
                                        &intermROperands[0],
                                        &intermROperands[4]);
       /* Clamp the difference to [-2,2]*/
        status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MIN,
                    &intermIOperands[0],
                    &intermROperands[4],
                    &twoROperand);
        status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MAX,
                    &intermIOperands[4],
                    &intermROperands[0],
                    &neg2ROperand);

        IOperand->dataType.elementType = clvTYPE_INT;
        /*Add back the adjustment */
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD,
                                        IOperand,
                                        &intermROperands[4],
                                        &intermROperands[1]);
        /*put the data type back */
        IOperand->dataType.elementType = clvTYPE_FLOAT;
        intermROperands[4].dataType.elementType = clvTYPE_FLOAT;
        intermROperands[0].dataType.elementType = clvTYPE_FLOAT;
        intermIOperands[4].dataType.elementType = clvTYPE_FLOAT;
        intermIOperands[0].dataType.elementType = clvTYPE_FLOAT;

        clmGEN_CODE_ENDIF(Compiler, /*IF 02 */
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

        clmGEN_CODE_ELSE(Compiler, /*IF 01 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
        /*Get expm1 have to use polynomial approximation for |x| < 0.70*/
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTNE,
                                        &intermIOperands[0],
                                        &OperandsParameters[0].rOperands[0],
                                        &expm1CoefROperand[6]);
        for(i = 5; i>=0; i--){
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTNE,
                                        &intermIOperands[1],
                                        &intermROperands[0],
                                        &expm1CoefROperand[i]);
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTNE,
                                        i == 0? IOperand : &intermIOperands[0],
                                        &OperandsParameters[0].rOperands[0],
                                        &intermROperands[1]);
        }


        clmGEN_CODE_ENDIF(Compiler, /*IF 01 */
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);
    }
    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;
OnError:
    return status;
}

static gceSTATUS
_GenFullProfileLogCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    clsIOPERAND        intermIOperands[4];
    clsROPERAND        intermROperands[4];

    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_LOG2,
                    &intermIOperands[3],
                    &OperandsParameters[0].rOperands[0]);


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&intermROperands[2],
                              clmGenCodeDataType(T_FLOAT),
                              _RCP_OF_LOG2_E
                              );

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTNE,
                                    IOperand,
                                    &intermROperands[3],
                                    &intermROperands[2]
                                    );


    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;

}


static gceSTATUS
_GenFullProfileLog10Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    clsIOPERAND        intermIOperands[4];
    clsROPERAND        intermROperands[4];

    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_LOG2,
                    &intermIOperands[3],
                    &OperandsParameters[0].rOperands[0]);


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&intermROperands[2],
                              clmGenCodeDataType(T_FLOAT),
                              _LOG10_2
                              );

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTNE,
                                    IOperand,
                                    &intermROperands[3],
                                    &intermROperands[2]
                                    );


    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenFullProfileLog2Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_LOG2,
                    IOperand,
                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenFullProfileLog1pCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    int i;
    clsIOPERAND        intermIOperands[14];
    clsROPERAND        intermROperands[14];
    clsROPERAND        coefROperands[11], dot5ROperand, negDot25002ROperand;
    clsROPERAND        int23ROperand, int22ROperand, neg1ROperand, nanROperand, bigNumROperand;
    clsROPERAND        int1ROperand, int7fROperand,float127ROperand,logE2ROperand, zeroROperand;
    clsROPERAND        float2ROperand, float1ROperand,negDot625ROperand, expROperand, msbMatROperand;
    float log1pTable[ ] = {
                 1.0000000f,
                -0.499999970197677610000000f,
                 0.333333313465118410000000f,
                -0.250004529953002930000000f,
                 0.200008183717727660000000f,
                -0.166490644216537480000000f,
                 0.142377927899360660000000f,
                -0.127252116799354550000000f,
                 0.120216220617294310000000f,
                -0.098022490739822388000000f,
                 0.042104966938495636000000f,
            };
    for(i = 0; i<11; i++){
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&coefROperands[i],
                              clmGenCodeDataType(T_FLOAT),
                              log1pTable[i]);
    }
    for(i = 0; i<14; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i],  (i & 1) == 0 ?
            (clmGenCodeDataType(T_UINT)) : (clmGenCodeDataType(T_FLOAT)) );
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&dot5ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              0.5f);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&neg1ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              -1.0f);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&expROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&int7fROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7f000000);

    clsROPERAND_InitializeIntOrIVecConstant(&msbMatROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x00400000);


    clsROPERAND_InitializeIntOrIVecConstant(&int1ROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x1);

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x0000000);

    clsROPERAND_InitializeIntOrIVecConstant(&int23ROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 23);
    clsROPERAND_InitializeIntOrIVecConstant(&int22ROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 22);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&float1ROperand,
                          clmGenCodeDataType(T_FLOAT),
                          1.0f);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&float2ROperand,
                          clmGenCodeDataType(T_FLOAT),
                          2.0f);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&bigNumROperand,
                          clmGenCodeDataType(T_FLOAT),
                          1073741824.0f);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&float127ROperand,
                          clmGenCodeDataType(T_FLOAT),
                          127.0f);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logE2ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        0.69314718055994530941723212145818f );

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&negDot25002ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        -0.250002f );
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&negDot625ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              -.6250f);

    /* Get 1+x */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTNE,
                                    &intermIOperands[1],
                                    &coefROperands[0],
                                    &OperandsParameters[0].rOperands[0]
                                    );


    clmGEN_CODE_IF(Compiler, /*IF 00 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_LESS_THAN_EQUAL,
             &neg1ROperand);

    /*if x<=-1, return Nan */
    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_LOG2,
                    IOperand,
                    &intermROperands[1]);

    clmGEN_CODE_ELSE(Compiler, /*IF 00 */
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    clmGEN_CODE_IF(Compiler, /*IF 01 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_GREATER_THAN,
             &bigNumROperand);

    /*if x very big, call log(x) = log(1+x) */
    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_LOG2,
                    &intermIOperands[3],
                    &intermROperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTNE,
                                    IOperand,
                                    &intermROperands[3],
                                    &logE2ROperand
                                    );


    /*Now we use polynomial approximation, seperate exp and Mantissa  */
    clmGEN_CODE_ELSE(Compiler, /*IF 01 */
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    /*Get expnential */
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[0],
                        &expROperand,
                        &intermROperands[1]);

    /*msb of Mantissa, large than 0.5 or not */
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[2],
                        &msbMatROperand,
                        &intermROperands[1]);


    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[4],
                                &intermROperands[2],
                                &int1ROperand);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD,
                                    &intermIOperands[6],
                                    &intermROperands[0],
                                    &intermROperands[4]
                                    );


    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB,
                                    &intermIOperands[8],
                                    &int7fROperand,
                                    &intermROperands[6]
                                    );
    /*Scale back to 0.5~1.0, exponent part are gone */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTNE,
                                    &intermIOperands[3],
                                    &intermROperands[1],
                                    &intermROperands[8]
                                    );

    /*Go back to x = (1+x) - 1, prepare for polynomial approximation */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTNE,
                                    &intermIOperands[1],
                                    &intermROperands[3],
                                    &coefROperands[0]
                                    );

    /*Exponent part*/
    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &intermIOperands[10],
                                &intermROperands[6],
                                &int23ROperand);
    /*Go back to float point */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INT_TO_FLOAT,
                &intermIOperands[5],
                &intermROperands[10]);

    /*Normalize, take away 127 */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTNE,
                                    &intermIOperands[7],
                                    &intermROperands[5],
                                    &float127ROperand
                                    );

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTNE,
                                    &intermIOperands[3],
                                    &intermROperands[7],
                                    &logE2ROperand
                                    );

    /*Zero means current r3 is OK */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[0],
                &zeroROperand);

    /*Some special interval 0.5<=x<1.0 */
    clmGEN_CODE_IF(Compiler, /*If 02 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_GREATER_THAN_EQUAL,
             &dot5ROperand);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[0],
                &nanROperand);

    clmGEN_CODE_IF(Compiler, /*If 03 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_LESS_THAN_EQUAL,
             &float1ROperand);

    /*when 0.5<=x<1.0, we use polynomial of (x-1)/2   */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTNE,
                                    &intermIOperands[5],
                                    &OperandsParameters[0].rOperands[0],
                                    &coefROperands[0]
                                    );

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTNE,
                                    &intermIOperands[1],
                                    &dot5ROperand,
                                    &intermROperands[5]
                                    );
    clmGEN_CODE_ELSE(Compiler, /*IF 03 */
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);
    clmGEN_CODE_ENDIF(Compiler, /*IF 03 */
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);




    clmGEN_CODE_ELSE(Compiler, /*IF 02 */
           CodeGenerator,
           PolynaryExpr->exprBase.base.lineNo,
           PolynaryExpr->exprBase.base.stringNo);

    clmGEN_CODE_ENDIF(Compiler, /*IF 02 */
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);


    /*Some special interval -0.25002f > x> -0.625f*/
    clmGEN_CODE_IF(Compiler, /*If 04 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_LESS_THAN,
             &negDot25002ROperand);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[0],
                &nanROperand);

    clmGEN_CODE_IF(Compiler, /*If 05 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_GREATER_THAN,
             &negDot625ROperand);

    /*when -0.625<x<-.250, we use polynomial of (2x+1)   */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTNE,
                                    &intermIOperands[5],
                                    &float2ROperand,
                                    &OperandsParameters[0].rOperands[0]
                                    );

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTNE,
                                    &intermIOperands[1],
                                    &coefROperands[0],
                                    &intermROperands[5]
                                    );
    clmGEN_CODE_ELSE(Compiler, /*IF 04 */
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);
    clmGEN_CODE_ENDIF(Compiler, /*IF 04 */
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);




    clmGEN_CODE_ELSE(Compiler, /*IF 05 */
           CodeGenerator,
           PolynaryExpr->exprBase.base.lineNo,
           PolynaryExpr->exprBase.base.stringNo);

    clmGEN_CODE_ENDIF(Compiler, /*IF 05 */
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

    /*In the case -0.250002=<x<0.5 */
    clmGEN_CODE_IF(Compiler, /*If 06 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &intermROperands[0],
             clvCONDITION_EQUAL,
             &zeroROperand);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[1],
                &OperandsParameters[0].rOperands[0]);


    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[3],
                &zeroROperand);
    clmGEN_CODE_ELSE(Compiler, /*IF 06 */
           CodeGenerator,
           PolynaryExpr->exprBase.base.lineNo,
           PolynaryExpr->exprBase.base.stringNo);

    clmGEN_CODE_ENDIF(Compiler, /*IF 06 */
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

    /*Now process the polynomial approximation */

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTNE,
                                    &intermIOperands[5],
                                    &coefROperands[10],
                                    &intermROperands[1]
                                    );
    for(i = 9; i>=0; i--){
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTNE,
                                    &intermIOperands[7],
                                    &coefROperands[i],
                                    &intermROperands[5]
                                    );
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTNE,
                                    &intermIOperands[5],
                                    &intermROperands[7],
                                    &intermROperands[1]
                                    );
    }

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTNE,
                                IOperand,
                                &intermROperands[3],
                                &intermROperands[5]
                                );
    clmGEN_CODE_ENDIF(Compiler, /*IF 01 */
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);


    clmGEN_CODE_ENDIF(Compiler, /*IF 00 */
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;
OnError:
    return status;
}


#endif /* #ifdef FULL_PROFILE_TEST  */

static gceSTATUS
_GenSinCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    gctREG_INDEX    tempRegIndex;
    gctREG_INDEX    wordRegIndex, wordRegTwoIndex, wordRegThreeIndex, wordRegFourIndex;

    clsSELECTION_CONTEXT    selectionContext6, selectionContext7,
                            selectionContext8, selectionContext9, selectionContext10, selectionContext11, selectionContext12, selectionContext13;

    clsIOPERAND wordStartIOperand, wordStartTwoIOperand, wordStartThreeIOperand, wordStartFourIOperand, bitStartIOperand, bitStartThreeIOperand, finalIOperand, regionIOperand, leadZeroIOperand[2], leadZeroTwoIOperand[2];
    clsROPERAND bitStartROperand, bitStartThreeROperand, regROperand, regTwoROperand, regThreeROperand, regFourROperand, reducedROperand, finalROperand, regionROperand, leadZeroROperand[2];
    clsIOPERAND intermIOperands[46];
    clsROPERAND intermROperands[46];
    clsIOPERAND negIOperand, negTwoIOperand;

    clsIOPERAND bitsIOperands[4], bitsTwoIOperands[4];
    clsIOPERAND reducedIOperand;
    clsROPERAND bitsROperands[4], bitsTwoROperands[4];
    clsIOPERAND notIOperands[6];
    clsROPERAND notROperands[6];
    clsIOPERAND compareThreeIOperands[1], compareFourIOperands[1], compareFiveIOperands[1];
    clsROPERAND compareThreeROperands[1], compareFourROperands[1], compareFiveROperands[1];
    clsROPERAND firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand;
    clsIOPERAND    firstCoefIOperand, secondCoefIOperand, thirdCoefIOperand, fourthCoefIOperand;
    clsROPERAND piROperand, piHalvedROperand, piThreeHalvedROperand, negOneROperand, oneROperand, oneShortROperand, twoShortROperand, twoPiROperand, twoPiLoROperand, twoROperand, zeroIntROperand, oneIntROperand, twoIntROperand,
                threeIntROperand, fourROperand, fourIntROperand, fiveIntROperand, nineIntROperand, elevenIntROperand, twentyNineIntROperand, thirtyOneHexROperand, thirtyTwoIntROperand,
                fullHexROperand, roundingROperand, twentyThreeShortROperand, addROperand, negROperand, negTwoROperand;
    clsROPERAND maskROperand, maskTwoROperand, maskThreeROperand, expMaskROperand, nanROperand;
    clsROPERAND invrsTwoPiROperand[6];

    clsIOPERAND offsetIOperand, switchIOperand;
    clsROPERAND offsetROperand, switchROperand;

    clsROPERAND    firstCosROperand, secondCosROperand, thirdCosROperand, fourthCosROperand,
                firstSinROperand, secondSinROperand, thirdSinROperand, fourthSinROperand;

    clsIOPERAND expIOperands[2];
    clsROPERAND expROperands[2];

    clsROPERAND cosineROperand;

    clsROPERAND testIntROperand;
    int i;


    clsROPERAND_InitializeIntOrIVecConstant(&testIntROperand,
                              clmGenCodeDataType(T_INT),
                              (gctUINT) 3);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_constant);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_halved);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piThreeHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_threeHalved);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoPiROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) two_pi);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoPiLoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) two_pi_lo);
    clsROPERAND_InitializeIntOrIVecConstant(&zeroIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0);
    clsROPERAND_InitializeIntOrIVecConstant(&oneIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 1);
    clsROPERAND_InitializeIntOrIVecConstant(&oneShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctINT16) 1);
    clsROPERAND_InitializeIntOrIVecConstant(&twoShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctINT16) 2);
    clsROPERAND_InitializeIntOrIVecConstant(&twoIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 2);
    clsROPERAND_InitializeIntOrIVecConstant(&threeIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 3);
    clsROPERAND_InitializeIntOrIVecConstant(&fourIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 4);
    clsROPERAND_InitializeIntOrIVecConstant(&fiveIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 5);
    clsROPERAND_InitializeIntOrIVecConstant(&nineIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 9);
    clsROPERAND_InitializeIntOrIVecConstant(&elevenIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 11);
    clsROPERAND_InitializeIntOrIVecConstant(&twentyThreeShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctUINT16) 23);
    clsROPERAND_InitializeIntOrIVecConstant(&twentyNineIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 29);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyTwoIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 32);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneHexROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x0000001f);
    clsROPERAND_InitializeIntOrIVecConstant(&fullHexROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0xffffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&roundingROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x00000080);
    clsROPERAND_InitializeIntOrIVecConstant(&cosineROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x3f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7fc00000);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&negOneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) -1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 4.0);

    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[0],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x28be60db);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[1],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x9391054a);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[2],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7f09d5f4);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[3],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7d4d3770);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[4],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x36d8a566);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[5],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x4f10e407);

    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x007fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&maskTwoROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x00800000);
    clsROPERAND_InitializeIntOrIVecConstant(&maskThreeROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0xffff0000);


    clsROPERAND_InitializeIntOrIVecConstant(&expMaskROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7F800000);

    clsROPERAND_InitializeIntOrIVecConstant(&addROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 127);

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* getexp x, start by masking */
    clsIOPERAND_New(Compiler, &expIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&expROperands[0], &expIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &expIOperands[0],
                        &expMaskROperand,
                        &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* shift right by 23 */
    clsIOPERAND_New(Compiler, &expIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&expROperands[1], &expIOperands[1]);


    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &expIOperands[1],
                                &expROperands[0],
                                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &expROperands[1],
                 clvCONDITION_LESS_THAN,
                 &addROperand);

    {/* |x| < 1.0, approximation directly */

        float sinCoefXLess1[] = {
                1.000000000000000000000000f,
                -0.166665986180305480000000f,
                0.008329850621521472900000f,
                -0.000192914783838205040000f
        };
        for(i = 0; i<4; i++){
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&intermROperands[i],
                              clmGenCodeDataType(T_FLOAT),
                              sinCoefXLess1[i]);
            clsIOPERAND_New(Compiler, &intermIOperands[10+i], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[10+i], &intermIOperands[10+i]);
        }

        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[10],
                &OperandsParameters[0].rOperands[0],
                &OperandsParameters[0].rOperands[0]);

        for(i = 3; i>=0; i--){
            if(i == 3){
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &intermIOperands[12],
                            &intermROperands[i]);
            }
            else{
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[12],
                        &intermROperands[11],
                        &intermROperands[i]);
            }
            if(i > 0)
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[11],
                        &intermROperands[12],
                        &intermROperands[10]);
        }

        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                IOperand,
                &intermROperands[12],
                &OperandsParameters[0].rOperands[0]);

    }

    clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    /* Check Infinity or Nan*/
    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &expROperands[0],
                 clvCONDITION_EQUAL,
                 &expMaskROperand);

    /* Return to Nan for X = Inf or Nan */
    status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            IOperand,
            &nanROperand);

    clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    /* sub from result */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));


    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                &intermIOperands[0],
                                &expROperands[1],
                                &addROperand);

    if (gcmIS_ERROR(status)) return status;



    /* get mant x */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &intermIOperands[1],
                                &maskROperand,
                                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* get hidden bit */
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &intermIOperands[2],
                                &maskTwoROperand,
                                &intermROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* mullo 1/2pi part one (integer mul is automatically mullo in hardware instruction) */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    for(i = 0; i<6; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[2*i + 3], clmGenCodeDataType(T_UINT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[2*i+3], &intermIOperands[2*i+3]);
        clsIOPERAND_New(Compiler, &intermIOperands[2*i + 4], clmGenCodeDataType(T_UINT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[2*i+4], &intermIOperands[2*i+4]);


        status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[2*i+3],
                            &intermROperands[2],
                            &invrsTwoPiROperand[i]);
        if (gcmIS_ERROR(status)) return status;


        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MULHI,
                                &intermIOperands[2*i+4],
                                &intermROperands[2],
                                &invrsTwoPiROperand[i]);
        if (gcmIS_ERROR(status)) return status;
    }

    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);
    clsIOPERAND_New(Compiler, &notIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&notROperands[0], &notIOperands[0]);

    /* allocate registers for the 192 bit, six segment array */
    tempRegIndex = clNewTempRegs(Compiler, 7, clvTYPE_UINT);
    status = clNewVariable(Compiler,
                       0,
                       0,
                       "sinPrecisionArray",
                       clvQUALIFIER_NONE,
                       clvQUALIFIER_NONE,
                       clvSTORAGE_QUALIFIER_NONE,
                       clmGenCodeDataType(T_UINT),
                       7,
                       gcvTRUE,
                       tempRegIndex,
                       gcvNULL);
    for(i = 0; i<7; i++){
        clsIOPERAND_Initialize(Compiler, &intermIOperands[20+i], clmGenCodeDataType(T_UINT), tempRegIndex + (gctREG_INDEX)i);
    }
    for(i = 5; i>=1; i--){
        /* Not (MulHi)*/
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_NOT_BITWISE,
                    &notIOperands[0],
                    &intermROperands[2*i+4]);
        if (gcmIS_ERROR(status)) return status;
        /* ( MulLo > ~(MulHi) ? regroup needed) */
        clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[2*i+1],
                 clvCONDITION_GREATER_THAN,
                 &notROperands[0]);

        /*Add the overflow bit */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[2*i+2],
                                &oneIntROperand,
                                &intermROperands[2*i+2]);
        if (gcmIS_ERROR(status)) return status;

        clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

        /*else, do nothing */

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

        /*Hi + PreviousLo */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[20+i],
                                &intermROperands[2*i+1],
                                &intermROperands[2*i+4]);
        if (gcmIS_ERROR(status)) return status;
    }

    /* assign part one */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[20],
                &intermROperands[4]);
    /* assign the last 4-bytes*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[26],
                &intermROperands[13]);

    if (gcmIS_ERROR(status)) return status;

    /* add 9 to exponent */
    clsIOPERAND_New(Compiler, &intermIOperands[26], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[26],
                                &intermROperands[0],
                                &nineIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift 9 + exponent by 5 bits (i.e. divide by 32), gets word index */
    clsIOPERAND_New(Compiler, &wordStartIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[26]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &wordStartIOperand,
                                &intermROperands[26],
                                &fiveIntROperand);

    if (gcmIS_ERROR(status)) return status;


    /* mod 9 + exponent by 32, gets bit position */
    clsIOPERAND_New(Compiler, &bitStartIOperand, clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &bitStartIOperand,
                                &intermROperands[26],
                                &thirtyOneHexROperand);

    if (gcmIS_ERROR(status)) return status;




    /* get index */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegIndex = wordStartIOperand.tempRegIndex;
    regROperand.arrayIndex.mode = clvINDEX_REG;
    regROperand.arrayIndex.u.indexRegIndex = wordRegIndex;



    /* shift the target word of the six segments */
    clsIOPERAND_New(Compiler, &intermIOperands[27], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartROperand, &bitStartIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[27],
                                &regROperand,
                                &bitStartROperand);

    if (gcmIS_ERROR(status)) return status;





    /* this will hold the reduced x */
    clsIOPERAND_New(Compiler, &reducedIOperand, clmGenCodeDataType(T_UINT));


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: startBits > 0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext6,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &bitStartROperand,
                                                &zeroIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for startBits > 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* sub from 32 start bits */
    clsIOPERAND_New(Compiler, &bitsIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartROperand, &bitStartIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &bitsIOperands[0],
                                &thirtyTwoIntROperand,
                                &bitStartROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add one to target reg, denoting the next word */
    clsIOPERAND_New(Compiler, &wordStartTwoIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[0], &wordStartIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &wordStartTwoIOperand,
                                &bitsROperands[0],
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift the next word of the six segments */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regTwoROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);


    wordRegTwoIndex = wordStartTwoIOperand.tempRegIndex;
    regTwoROperand.arrayIndex.mode = clvINDEX_REG;
    regTwoROperand.arrayIndex.u.indexRegIndex = wordRegTwoIndex;

    clsIOPERAND_New(Compiler, &bitsIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[1], &bitsIOperands[0]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &bitsIOperands[1],
                                &regTwoROperand,
                                &bitsROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* get enough bits from next word for 32 bit precision */
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[3], &intermIOperands[27]);
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[2], &bitsIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &reducedIOperand,
                                &bitsROperands[3],
                                &bitsROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext6,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part where startBits = 0, so nothing is done besides assigning */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* assign the unaltered word */
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[3], &intermIOperands[27]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &reducedIOperand,
                &bitsROperands[3]);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext6);

    if (gcmIS_ERROR(status)) return status;




    /* get the region */
    clsIOPERAND_New(Compiler, &regionIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &regionIOperand,
                                &reducedROperand,
                                &twentyNineIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* clean the reducedROperand */
    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &reducedIOperand,
                                &reducedROperand,
                                &twoIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* and region with 0x01 */
    clsIOPERAND_New(Compiler, &compareThreeIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&regionROperand, &regionIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &compareThreeIOperands[0],
                                &regionROperand,
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;




    clsIOPERAND_New(Compiler, &leadZeroIOperand[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareThreeROperands[0], &compareThreeIOperands[0]);
    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region & 0x01 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext7,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &compareThreeROperands[0],
                                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* not the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_NOT_BITWISE,
                &leadZeroIOperand[0],
                &reducedROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext7,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &leadZeroIOperand[0],
                &reducedROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext7);

    if (gcmIS_ERROR(status)) return status;




    /* grab leading zero */
    clsIOPERAND_New(Compiler, &leadZeroIOperand[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&leadZeroROperand[0], &leadZeroIOperand[0]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LEADZERO,
                &leadZeroIOperand[1],
                &leadZeroROperand[0]);

    if (gcmIS_ERROR(status)) return status;



    /* add eleven to leading zero */
    clsIOPERAND_New(Compiler, &intermIOperands[28], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &leadZeroIOperand[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[28],
                                &intermROperands[16],
                                &elevenIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add exponent to result */
    clsIOPERAND_New(Compiler, &intermIOperands[29], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[28]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[29],
                                &intermROperands[17],
                                &intermROperands[14]);

    if (gcmIS_ERROR(status)) return status;









    /* shift 11 + exponent + leading zero position by 5 bits (i.e. divide by 32), gets word index */
    clsIOPERAND_New(Compiler, &wordStartThreeIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[29]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &wordStartThreeIOperand,
                                &intermROperands[18],
                                &fiveIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mod 11 + exponent + leading zero position by 32, gets bit position */
    clsIOPERAND_New(Compiler, &bitStartThreeIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[29]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &bitStartThreeIOperand,
                                &intermROperands[18],
                                &thirtyOneHexROperand);

    if (gcmIS_ERROR(status)) return status;




    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    /* get index */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regThreeROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegThreeIndex = wordStartThreeIOperand.tempRegIndex;
    regThreeROperand.arrayIndex.mode = clvINDEX_REG;
    regThreeROperand.arrayIndex.u.indexRegIndex = wordRegThreeIndex;



    /* shift the target word of the six segments */
    clsIOPERAND_New(Compiler, &intermIOperands[30], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartThreeROperand, &bitStartThreeIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[30],
                                &regThreeROperand,
                                &bitStartThreeROperand);

    if (gcmIS_ERROR(status)) return status;




    /* used to hold the final word value */
    clsIOPERAND_New(Compiler, &finalIOperand, clmGenCodeDataType(T_UINT));


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: startBits > 0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext8,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &bitStartThreeROperand,
                                                &zeroIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for startBits > 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* sub from 32 start bits */
    clsIOPERAND_New(Compiler, &bitsTwoIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartThreeROperand, &bitStartThreeIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &bitsTwoIOperands[0],
                                &thirtyTwoIntROperand,
                                &bitStartThreeROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add one to target reg, denoting the next word */
    clsIOPERAND_New(Compiler, &wordStartFourIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[0], &wordStartThreeIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &wordStartFourIOperand,
                                &bitsTwoROperands[0],
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift the next word of the six segments */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regFourROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegFourIndex = wordStartFourIOperand.tempRegIndex;
    regFourROperand.arrayIndex.mode = clvINDEX_REG;
    regFourROperand.arrayIndex.u.indexRegIndex = wordRegFourIndex;

    clsIOPERAND_New(Compiler, &bitsTwoIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[1], &bitsTwoIOperands[0]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &bitsTwoIOperands[1],
                                &regFourROperand,
                                &bitsTwoROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* get enough bits from next word for 32 bit precision */
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[3], &intermIOperands[30]);
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[2], &bitsTwoIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &finalIOperand,
                                &bitsTwoROperands[3],
                                &bitsTwoROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext8,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part where startBits = 0, so nothing is done besides assigning */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* assign the unaltered word */
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[3], &intermIOperands[30]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &finalIOperand,
                &bitsTwoROperands[3]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext8);

    if (gcmIS_ERROR(status)) return status;




    clsIOPERAND_New(Compiler, &leadZeroTwoIOperand[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareThreeROperands[0], &compareThreeIOperands[0]);
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region & 0x01 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext9,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &compareThreeROperands[0],
                                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* xor the word */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_XOR_BITWISE,
                &finalIOperand,
                &finalROperand,
                &fullHexROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext9,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &finalIOperand,
                &finalROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext9);

    if (gcmIS_ERROR(status)) return status;




    /* and with 0xffff0000 */
    clsIOPERAND_New(Compiler, &compareFourIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &compareFourIOperands[0],
                                &finalROperand,
                                &maskThreeROperand);

    if (gcmIS_ERROR(status)) return status;









    /* rounding starts */
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);
    clsROPERAND_InitializeUsingIOperand(&compareFourROperands[0], &compareFourIOperands[0]);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region & 0x01 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext10,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_NOT_EQUAL,
                                                &compareFourROperands[0],
                                                &maskThreeROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* add the word with rounding */
    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &finalIOperand,
                                &finalROperand,
                                &roundingROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext10,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* do nothing */

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext10);

    if (gcmIS_ERROR(status)) return status;









    /* convert the int to a float */
    clsIOPERAND_New(Compiler, &intermIOperands[31], clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_UINT_TO_FLOAT,
                &intermIOperands[31],
                &finalROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift 32 by 23 */
    clsIOPERAND_New(Compiler, &intermIOperands[32], clmGenCodeDataType(T_UINT));

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[32],
                &thirtyTwoIntROperand,
                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    /* subtract from the word the above result */
    clsIOPERAND_New(Compiler, &intermIOperands[33], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[32]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[31]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[33],
                                &intermROperands[19],
                                &intermROperands[20]);

    if (gcmIS_ERROR(status)) return status;

    /* shift 32 by 23 */
    clsIOPERAND_New(Compiler, &intermIOperands[34], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &leadZeroIOperand[1]);

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[34],
                &intermROperands[16],
                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    /* subtract from the word the above result */
    clsIOPERAND_New(Compiler, &intermIOperands[35], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[22], &intermIOperands[33]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[21], &intermIOperands[34]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[35],
                                &intermROperands[22],
                                &intermROperands[21]);

    if (gcmIS_ERROR(status)) return status;

    /* mod exponent of region */
    clsIOPERAND_New(Compiler, &compareFiveIOperands[0], clmGenCodeDataType(T_USHORT));
    clsROPERAND_InitializeUsingIOperand(&regionROperand, &regionIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_AND_BITWISE,
                                    &compareFiveIOperands[0],
                                    &regionROperand,
                                    &threeIntROperand);

    if (gcmIS_ERROR(status)) return status;


    /* get the correct coefficients */
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(1.2337005499793097000000 + 0.0000000001879654780980));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(-0.2536694772145465800000 -0.0000000069740527374221));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(0.0208629252575471480000 -0.0000004950582152116484));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(-0.0009161912571036650800 + 0.0000071557551705439561));

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) 1.5707963219692149000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -0.6459634788598108700000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) 0.0796802306857143090000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -0.0046021839812099832000);


    clsIOPERAND_New(Compiler, &fourthCoefIOperand, clmGenCodeDataType(T_FLOAT));
    clsIOPERAND_New(Compiler, &thirdCoefIOperand, clmGenCodeDataType(T_FLOAT));
    clsIOPERAND_New(Compiler, &secondCoefIOperand, clmGenCodeDataType(T_FLOAT));
    clsIOPERAND_New(Compiler, &firstCoefIOperand, clmGenCodeDataType(T_FLOAT));


    clsIOPERAND_New(Compiler, &offsetIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareFiveROperands[0], &compareFiveIOperands[0]);

    /* The selection begins for region % 4 = 1 */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region % 4 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext10,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &compareFiveROperands[0],
                                                &oneShortROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &fourthCoefIOperand,
                &fourthCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &thirdCoefIOperand,
                &thirdCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &secondCoefIOperand,
                &secondCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &firstCoefIOperand,
                &firstCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign the offset */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &offsetIOperand,
                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext10,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

                /* The selection begins for region % 4 = 2*/
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectionContext11);

            if (gcmIS_ERROR(status)) return status;

            /* The condition part: region % 4 = 2 */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext11,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &compareFiveROperands[0],
                                                            &twoShortROperand);

            if (gcmIS_ERROR(status)) return status;

            /* The true part */
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext11);

            if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &fourthCoefIOperand,
                            &fourthCosROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &thirdCoefIOperand,
                            &thirdCosROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &secondCoefIOperand,
                            &secondCosROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &firstCoefIOperand,
                            &firstCosROperand);

                if (gcmIS_ERROR(status)) return status;


                /* assign the offset */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &offsetIOperand,
                            &oneIntROperand);

                if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectionContext11,
                                                    gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            /* The false part */
            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext11);

            if (gcmIS_ERROR(status)) return status;


                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &fourthCoefIOperand,
                            &fourthSinROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &thirdCoefIOperand,
                            &thirdSinROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &secondCoefIOperand,
                            &secondSinROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &firstCoefIOperand,
                            &firstSinROperand);

                if (gcmIS_ERROR(status)) return status;


                /* assign the offset */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &offsetIOperand,
                            &zeroIntROperand);

                if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext11);

            if (gcmIS_ERROR(status)) return status;

            /* The selection end */
            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContext11);

            if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext10);

    if (gcmIS_ERROR(status)) return status;


    clsROPERAND_InitializeUsingIOperand(&fourthCoefROperand, &fourthCoefIOperand);
    clsROPERAND_InitializeUsingIOperand(&thirdCoefROperand, &thirdCoefIOperand);
    clsROPERAND_InitializeUsingIOperand(&secondCoefROperand, &secondCoefIOperand);
    clsROPERAND_InitializeUsingIOperand(&firstCoefROperand, &firstCoefIOperand);


    /* determine if negative */
    clsIOPERAND_New(Compiler, &negIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&regionROperand, &regionIOperand);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region > 3 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext12,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &regionROperand,
                                                &threeIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &negIOperand,
                &negOneROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext12,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &negIOperand,
                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext12);

    if (gcmIS_ERROR(status)) return status;




    /* mul */
    clsIOPERAND_New(Compiler, &intermIOperands[37], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[35]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[37],
                                &intermROperands[24],
                                &intermROperands[24]);

    if (gcmIS_ERROR(status)) return status;

    /* mul coef1 with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[38], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[38],
                                &firstCoefROperand,
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add coef2 to result */
    clsIOPERAND_New(Compiler, &intermIOperands[39], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[38]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[39],
                                &secondCoefROperand,
                                &intermROperands[26]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[40], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[27], &intermIOperands[39]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[40],
                                &intermROperands[27],
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add coef3 to result */
    clsIOPERAND_New(Compiler, &intermIOperands[41], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[28], &intermIOperands[40]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[41],
                                &thirdCoefROperand,
                                &intermROperands[28]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[42], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[29], &intermIOperands[41]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[42],
                                &intermROperands[29],
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add coef4 to result */
    clsIOPERAND_New(Compiler, &intermIOperands[43], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[30], &intermIOperands[42]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[43],
                                &fourthCoefROperand,
                                &intermROperands[30]);

    if (gcmIS_ERROR(status)) return status;




    /* switch */
    clsIOPERAND_New(Compiler, &switchIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&offsetROperand, &offsetIOperand);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: offset = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext12,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &offsetROperand,
                                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[44], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[31], &intermIOperands[43]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[44],
                                &intermROperands[31],
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add result with (x')^2 */

    clsROPERAND_InitializeUsingIOperand(&intermROperands[34], &intermIOperands[44]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &switchIOperand,
                                &cosineROperand,
                                &intermROperands[34]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext12,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with (x')^2 */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[31], &intermIOperands[43]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[35], &intermIOperands[35]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &switchIOperand,
                                &intermROperands[31],
                                &intermROperands[35]);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext12);

    if (gcmIS_ERROR(status)) return status;






    clsIOPERAND_New(Compiler, &negTwoIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&negTwoROperand, &negTwoIOperand);


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext13);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: is argument negative?*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext13,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &OperandsParameters[0].rOperands[0],
                                                &zeroIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part: argument >= 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext13);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &negTwoIOperand,
                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext13,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part: argument < 0 */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext13);

    if (gcmIS_ERROR(status)) return status;



    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &negTwoIOperand,
                &negOneROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext13);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext13);

    if (gcmIS_ERROR(status)) return status;



    clsIOPERAND_New(Compiler, &intermIOperands[45], clmGenCodeDataType(T_FLOAT));

    /* mul result with negative or unity */
    clsROPERAND_InitializeUsingIOperand(&switchROperand, &switchIOperand);
    clsROPERAND_InitializeUsingIOperand(&negROperand, &negIOperand);



    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[45],
                                &negROperand,
                                &switchROperand);

    if (gcmIS_ERROR(status)) return status;


    /* mul result with negative or unity */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[36], &intermIOperands[45]);
    clsROPERAND_InitializeUsingIOperand(&negTwoROperand, &negTwoIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                IOperand,
                                &negTwoROperand,
                                &intermROperands[36]);

    if (gcmIS_ERROR(status)) return status;

   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);
OnError:
   return status;
}

static gceSTATUS
_GenNativeSinCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(Compiler,
                               PolynaryExpr->exprBase.base.lineNo,
                               PolynaryExpr->exprBase.base.stringNo,
                               clvOPCODE_SIN,
                               IOperand,
                               &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenCosCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    gctREG_INDEX    tempRegIndex;
    gctREG_INDEX    wordRegIndex, wordRegTwoIndex, wordRegThreeIndex, wordRegFourIndex;

    clsSELECTION_CONTEXT    selectionContext6, selectionContext7,
                            selectionContext8, selectionContext9, selectionContext10, selectionContext11, selectionContext12;

    clsIOPERAND wordStartIOperand, wordStartTwoIOperand, wordStartThreeIOperand, wordStartFourIOperand, bitStartIOperand, bitStartThreeIOperand, finalIOperand, regionIOperand, leadZeroIOperand[2], leadZeroTwoIOperand[2];
    clsROPERAND bitStartROperand, bitStartThreeROperand, regROperand, regTwoROperand, regThreeROperand, regFourROperand, reducedROperand, finalROperand, regionROperand, leadZeroROperand[2];
    clsIOPERAND intermIOperands[46];
    clsROPERAND intermROperands[46];
    clsIOPERAND negIOperand;

    clsIOPERAND bitsIOperands[4], bitsTwoIOperands[4];
    clsIOPERAND reducedIOperand;
    clsROPERAND bitsROperands[4], bitsTwoROperands[4];
    clsIOPERAND notIOperands[6];
    clsROPERAND notROperands[6];
    clsIOPERAND compareThreeIOperands[1], compareFourIOperands[1], compareFiveIOperands[1];
    clsROPERAND compareThreeROperands[1], compareFourROperands[1], compareFiveROperands[1];
    clsROPERAND firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand;
    clsIOPERAND    firstCoefIOperand, secondCoefIOperand, thirdCoefIOperand, fourthCoefIOperand;
    clsROPERAND piROperand, piHalvedROperand, piThreeHalvedROperand, negOneROperand, oneROperand, oneShortROperand, twoShortROperand, twoPiROperand, twoPiLoROperand, twoROperand, zeroIntROperand, oneIntROperand, twoIntROperand,
                threeIntROperand, fourROperand, fourIntROperand, fiveIntROperand, nineIntROperand, elevenIntROperand, twentyNineIntROperand, thirtyOneHexROperand, thirtyTwoIntROperand,
                fullHexROperand, roundingROperand, twentyThreeShortROperand, addROperand, negROperand;
    clsROPERAND maskROperand, maskTwoROperand, maskThreeROperand, expMaskROperand, nanROperand;
    clsROPERAND invrsTwoPiROperand[6];


    clsIOPERAND offsetIOperand, switchIOperand;
    clsROPERAND offsetROperand, switchROperand;

    clsROPERAND    firstCosROperand, secondCosROperand, thirdCosROperand, fourthCosROperand,
                firstSinROperand, secondSinROperand, thirdSinROperand, fourthSinROperand;

    clsIOPERAND expIOperands[2];
    clsROPERAND expROperands[2];

    clsROPERAND cosineROperand;

    clsROPERAND testIntROperand;
    int i;

    clsROPERAND_InitializeIntOrIVecConstant(&testIntROperand,
                              clmGenCodeDataType(T_INT),
                              (gctUINT) 3);



    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_constant);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_halved);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piThreeHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_threeHalved);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoPiROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) two_pi);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoPiLoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) two_pi_lo);
    clsROPERAND_InitializeIntOrIVecConstant(&zeroIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0);
    clsROPERAND_InitializeIntOrIVecConstant(&oneIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 1);
    clsROPERAND_InitializeIntOrIVecConstant(&oneShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctINT16) 1);
    clsROPERAND_InitializeIntOrIVecConstant(&twoShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctINT16) 2);
    clsROPERAND_InitializeIntOrIVecConstant(&twoIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 2);
    clsROPERAND_InitializeIntOrIVecConstant(&threeIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 3);
    clsROPERAND_InitializeIntOrIVecConstant(&fourIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 4);
    clsROPERAND_InitializeIntOrIVecConstant(&fiveIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 5);
    clsROPERAND_InitializeIntOrIVecConstant(&nineIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 9);
    clsROPERAND_InitializeIntOrIVecConstant(&elevenIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 11);
    clsROPERAND_InitializeIntOrIVecConstant(&twentyThreeShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctUINT16) 23);
    clsROPERAND_InitializeIntOrIVecConstant(&twentyNineIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 29);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyTwoIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 32);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneHexROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x0000001f);
    clsROPERAND_InitializeIntOrIVecConstant(&fullHexROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0xffffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&roundingROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x00000080);
    clsROPERAND_InitializeIntOrIVecConstant(&cosineROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x3f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7fc00000);





    clsROPERAND_InitializeFloatOrVecOrMatConstant(&negOneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) -1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 4.0);


    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[0],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x28be60db);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[1],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x9391054a);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[2],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7f09d5f4);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[3],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7d4d3770);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[4],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x36d8a566);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[5],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x4f10e407);

    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x007fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&maskTwoROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x00800000);
    clsROPERAND_InitializeIntOrIVecConstant(&maskThreeROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0xffff0000);


    clsROPERAND_InitializeIntOrIVecConstant(&expMaskROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7F800000);



    clsROPERAND_InitializeIntOrIVecConstant(&addROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 127);



    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);




    /* getexp x, start by masking */
    clsIOPERAND_New(Compiler, &expIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&expROperands[0], &expIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &expIOperands[0],
                        &expMaskROperand,
                        &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* shift right by 23 */
    clsIOPERAND_New(Compiler, &expIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&expROperands[1], &expIOperands[1]);


    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &expIOperands[1],
                                &expROperands[0],
                                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &expROperands[1],
                 clvCONDITION_LESS_THAN,
                 &addROperand);

    {/* |x| < 1.0, approximation directly, with polynomial x^2 */
        float cosCoefXLess1[] = {   1.000000000000000000000000f,
                                     -0.499999970197677610000000f,
                                      0.041666429489850998000000f,
                                     -0.001388253993354737800000f,
                                      0.000024100709197227843000f,};
        for(i = 0; i<5; i++){
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&intermROperands[i],
                              clmGenCodeDataType(T_FLOAT),
                              cosCoefXLess1[i]);
            clsIOPERAND_New(Compiler, &intermIOperands[10+i], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[10+i], &intermIOperands[10+i]);
        }

        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[10],
                &OperandsParameters[0].rOperands[0],
                &OperandsParameters[0].rOperands[0]);

        for(i = 4; i>=0; i--){
            if(i == 4){
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &intermIOperands[12],
                            &intermROperands[i]);
            }
            else{
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        i > 0? &intermIOperands[12] : IOperand,
                        &intermROperands[11],
                        &intermROperands[i]);
            }
            if(i > 0)
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[11],
                        &intermROperands[12],
                        &intermROperands[10]);
        }
    }

    clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    /* Check Infinity or Nan*/
    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &expROperands[0],
                 clvCONDITION_EQUAL,
                 &expMaskROperand);

    /* Return to Nan for X = Inf or Nan */
    status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            IOperand,
            &nanROperand);

    clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    /* sub from result */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));


    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                &intermIOperands[0],
                                &expROperands[1],
                                &addROperand);

    if (gcmIS_ERROR(status)) return status;



    /* get mant x */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &intermIOperands[1],
                                &maskROperand,
                                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* get hidden bit */
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &intermIOperands[2],
                                &maskTwoROperand,
                                &intermROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* mullo 1/2pi part one (integer mul is automatically mullo in hardware instruction) */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    for(i = 0; i<6; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[2*i + 3], clmGenCodeDataType(T_UINT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[2*i+3], &intermIOperands[2*i+3]);
        clsIOPERAND_New(Compiler, &intermIOperands[2*i + 4], clmGenCodeDataType(T_UINT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[2*i+4], &intermIOperands[2*i+4]);


        status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[2*i+3],
                            &intermROperands[2],
                            &invrsTwoPiROperand[i]);
        if (gcmIS_ERROR(status)) return status;


        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MULHI,
                                &intermIOperands[2*i+4],
                                &intermROperands[2],
                                &invrsTwoPiROperand[i]);
        if (gcmIS_ERROR(status)) return status;
    }

    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);
    clsIOPERAND_New(Compiler, &notIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&notROperands[0], &notIOperands[0]);

    /* allocate registers for the 192 bit, six segment array */
    tempRegIndex = clNewTempRegs(Compiler, 7, clvTYPE_UINT);
    status = clNewVariable(Compiler,
                       0,
                       0,
                       "sinPrecisionArray",
                       clvQUALIFIER_NONE,
                       clvQUALIFIER_NONE,
                       clvSTORAGE_QUALIFIER_NONE,
                       clmGenCodeDataType(T_UINT),
                       7,
                       gcvTRUE,
                       tempRegIndex,
                       gcvNULL);
    for(i = 0; i<7; i++){
        clsIOPERAND_Initialize(Compiler, &intermIOperands[20+i], clmGenCodeDataType(T_UINT), tempRegIndex + (gctREG_INDEX)i);
    }
    for(i = 5; i>=1; i--){
        /* Not (MulHi)*/
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_NOT_BITWISE,
                    &notIOperands[0],
                    &intermROperands[2*i+4]);
        if (gcmIS_ERROR(status)) return status;
        /* ( MulLo > ~(MulHi) ? regroup needed) */
        clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[2*i+1],
                 clvCONDITION_GREATER_THAN,
                 &notROperands[0]);

        /*Add the overflow bit */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[2*i+2],
                                &oneIntROperand,
                                &intermROperands[2*i+2]);
        if (gcmIS_ERROR(status)) return status;

        clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

        /*else, do nothing */

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

        /*Hi + PreviousLo */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[20+i],
                                &intermROperands[2*i+1],
                                &intermROperands[2*i+4]);
        if (gcmIS_ERROR(status)) return status;
    }

    /* assign part one */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[20],
                &intermROperands[4]);
    /* assign the last 4-bytes*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[26],
                &intermROperands[13]);

    if (gcmIS_ERROR(status)) return status;

    /* add 9 to exponent */
    clsIOPERAND_New(Compiler, &intermIOperands[26], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[26],
                                &intermROperands[0],
                                &nineIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift 9 + exponent by 5 bits (i.e. divide by 32), gets word index */
    clsIOPERAND_New(Compiler, &wordStartIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[26]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &wordStartIOperand,
                                &intermROperands[26],
                                &fiveIntROperand);

    if (gcmIS_ERROR(status)) return status;


    /* mod 9 + exponent by 32, gets bit position */
    clsIOPERAND_New(Compiler, &bitStartIOperand, clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &bitStartIOperand,
                                &intermROperands[26],
                                &thirtyOneHexROperand);

    if (gcmIS_ERROR(status)) return status;




    /* get index */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegIndex = wordStartIOperand.tempRegIndex;
    regROperand.arrayIndex.mode = clvINDEX_REG;
    regROperand.arrayIndex.u.indexRegIndex = wordRegIndex;



    /* shift the target word of the six segments */
    clsIOPERAND_New(Compiler, &intermIOperands[27], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartROperand, &bitStartIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[27],
                                &regROperand,
                                &bitStartROperand);

    if (gcmIS_ERROR(status)) return status;





    /* this will hold the reduced x */
    clsIOPERAND_New(Compiler, &reducedIOperand, clmGenCodeDataType(T_UINT));


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: startBits > 0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext6,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &bitStartROperand,
                                                &zeroIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for startBits > 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* sub from 32 start bits */
    clsIOPERAND_New(Compiler, &bitsIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartROperand, &bitStartIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &bitsIOperands[0],
                                &thirtyTwoIntROperand,
                                &bitStartROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add one to target reg, denoting the next word */
    clsIOPERAND_New(Compiler, &wordStartTwoIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[0], &wordStartIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &wordStartTwoIOperand,
                                &bitsROperands[0],
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift the next word of the six segments */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regTwoROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);


    wordRegTwoIndex = wordStartTwoIOperand.tempRegIndex;
    regTwoROperand.arrayIndex.mode = clvINDEX_REG;
    regTwoROperand.arrayIndex.u.indexRegIndex = wordRegTwoIndex;

    clsIOPERAND_New(Compiler, &bitsIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[1], &bitsIOperands[0]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &bitsIOperands[1],
                                &regTwoROperand,
                                &bitsROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* get enough bits from next word for 32 bit precision */
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[3], &intermIOperands[27]);
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[2], &bitsIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &reducedIOperand,
                                &bitsROperands[3],
                                &bitsROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext6,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part where startBits = 0, so nothing is done besides assigning */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* assign the unaltered word */
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[3], &intermIOperands[27]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &reducedIOperand,
                &bitsROperands[3]);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext6);

    if (gcmIS_ERROR(status)) return status;




    /* get the region */
    clsIOPERAND_New(Compiler, &regionIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);
    {
        /*Cos(x) = Sin(x+Pi/2), so the regionCalculation same as SinRegion+2, then calculate Sin(x) */
        clsROPERAND cosRegionROperand;
        clsROPERAND_InitializeIntOrIVecConstant(&cosRegionROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) (2<<29));
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &reducedIOperand,
                                &reducedROperand,
                                &cosRegionROperand);

        clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[20]);
        status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &regionIOperand,
                                &reducedROperand,
                                &twentyNineIntROperand);

        if (gcmIS_ERROR(status)) return status;
    }
    /* clean the reducedROperand, integer part */

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &reducedIOperand,
                                &reducedROperand,
                                &twoIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* and region with 0x01 */
    clsIOPERAND_New(Compiler, &compareThreeIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&regionROperand, &regionIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &compareThreeIOperands[0],
                                &regionROperand,
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;




    clsIOPERAND_New(Compiler, &leadZeroIOperand[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareThreeROperands[0], &compareThreeIOperands[0]);
    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region & 0x01 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext7,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &compareThreeROperands[0],
                                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* not the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_NOT_BITWISE,
                &leadZeroIOperand[0],
                &reducedROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext7,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &leadZeroIOperand[0],
                &reducedROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext7);

    if (gcmIS_ERROR(status)) return status;




    /* grab leading zero */
    clsIOPERAND_New(Compiler, &leadZeroIOperand[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&leadZeroROperand[0], &leadZeroIOperand[0]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LEADZERO,
                &leadZeroIOperand[1],
                &leadZeroROperand[0]);

    if (gcmIS_ERROR(status)) return status;



    /* add eleven to leading zero */
    clsIOPERAND_New(Compiler, &intermIOperands[28], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &leadZeroIOperand[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[28],
                                &intermROperands[16],
                                &elevenIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add exponent to result */
    clsIOPERAND_New(Compiler, &intermIOperands[29], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[28]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[29],
                                &intermROperands[17],
                                &intermROperands[14]);

    if (gcmIS_ERROR(status)) return status;









    /* shift 11 + exponent + leading zero position by 5 bits (i.e. divide by 32), gets word index */
    clsIOPERAND_New(Compiler, &wordStartThreeIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[29]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &wordStartThreeIOperand,
                                &intermROperands[18],
                                &fiveIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mod 11 + exponent + leading zero position by 32, gets bit position */
    clsIOPERAND_New(Compiler, &bitStartThreeIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[29]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &bitStartThreeIOperand,
                                &intermROperands[18],
                                &thirtyOneHexROperand);

    if (gcmIS_ERROR(status)) return status;




    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    /* get index */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regThreeROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegThreeIndex = wordStartThreeIOperand.tempRegIndex;
    regThreeROperand.arrayIndex.mode = clvINDEX_REG;
    regThreeROperand.arrayIndex.u.indexRegIndex = wordRegThreeIndex;



    /* shift the target word of the six segments */
    clsIOPERAND_New(Compiler, &intermIOperands[30], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartThreeROperand, &bitStartThreeIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[30],
                                &regThreeROperand,
                                &bitStartThreeROperand);

    if (gcmIS_ERROR(status)) return status;




    /* used to hold the final word value */
    clsIOPERAND_New(Compiler, &finalIOperand, clmGenCodeDataType(T_UINT));


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: startBits > 0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext8,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &bitStartThreeROperand,
                                                &zeroIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for startBits > 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* sub from 32 start bits */
    clsIOPERAND_New(Compiler, &bitsTwoIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartThreeROperand, &bitStartThreeIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &bitsTwoIOperands[0],
                                &thirtyTwoIntROperand,
                                &bitStartThreeROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add one to target reg, denoting the next word */
    clsIOPERAND_New(Compiler, &wordStartFourIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[0], &wordStartThreeIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &wordStartFourIOperand,
                                &bitsTwoROperands[0],
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift the next word of the six segments */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regFourROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegFourIndex = wordStartFourIOperand.tempRegIndex;
    regFourROperand.arrayIndex.mode = clvINDEX_REG;
    regFourROperand.arrayIndex.u.indexRegIndex = wordRegFourIndex;

    clsIOPERAND_New(Compiler, &bitsTwoIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[1], &bitsTwoIOperands[0]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &bitsTwoIOperands[1],
                                &regFourROperand,
                                &bitsTwoROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* get enough bits from next word for 32 bit precision */
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[3], &intermIOperands[30]);
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[2], &bitsTwoIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &finalIOperand,
                                &bitsTwoROperands[3],
                                &bitsTwoROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext8,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part where startBits = 0, so nothing is done besides assigning */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* assign the unaltered word */
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[3], &intermIOperands[30]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &finalIOperand,
                &bitsTwoROperands[3]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext8);

    if (gcmIS_ERROR(status)) return status;




    clsIOPERAND_New(Compiler, &leadZeroTwoIOperand[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareThreeROperands[0], &compareThreeIOperands[0]);
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext9);
    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region & 0x01 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext9,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &compareThreeROperands[0],
                                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* xor the word */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_XOR_BITWISE,
                &finalIOperand,
                &finalROperand,
                &fullHexROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext9,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &finalIOperand,
                &finalROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext9);

    if (gcmIS_ERROR(status)) return status;




    /* and with 0xffff0000 */
    clsIOPERAND_New(Compiler, &compareFourIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &compareFourIOperands[0],
                                &finalROperand,
                                &maskThreeROperand);

    if (gcmIS_ERROR(status)) return status;









    /* rounding starts */
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);
    clsROPERAND_InitializeUsingIOperand(&compareFourROperands[0], &compareFourIOperands[0]);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region & 0x01 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext10,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_NOT_EQUAL,
                                                &compareFourROperands[0],
                                                &maskThreeROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* add the word with rounding */
    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &finalIOperand,
                                &finalROperand,
                                &roundingROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext10,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* do nothing */

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext10);

    if (gcmIS_ERROR(status)) return status;









    /* convert the int to a float */
    clsIOPERAND_New(Compiler, &intermIOperands[31], clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_UINT_TO_FLOAT,
                &intermIOperands[31],
                &finalROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift 32 by 23 */
    clsIOPERAND_New(Compiler, &intermIOperands[32], clmGenCodeDataType(T_UINT));

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[32],
                &thirtyTwoIntROperand,
                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    /* subtract from the word the above result */
    clsIOPERAND_New(Compiler, &intermIOperands[33], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[32]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[31]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[33],
                                &intermROperands[19],
                                &intermROperands[20]);

    if (gcmIS_ERROR(status)) return status;

    /* shift 32 by 23 */
    clsIOPERAND_New(Compiler, &intermIOperands[34], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &leadZeroIOperand[1]);

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[34],
                &intermROperands[16],
                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    /* subtract from the word the above result */
    clsIOPERAND_New(Compiler, &intermIOperands[35], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[22], &intermIOperands[33]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[21], &intermIOperands[34]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[35],
                                &intermROperands[22],
                                &intermROperands[21]);

    if (gcmIS_ERROR(status)) return status;

    /* mod exponent of region */
    clsIOPERAND_New(Compiler, &compareFiveIOperands[0], clmGenCodeDataType(T_USHORT));
    clsROPERAND_InitializeUsingIOperand(&regionROperand, &regionIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_AND_BITWISE,
                                    &compareFiveIOperands[0],
                                    &regionROperand,
                                    &threeIntROperand);

    if (gcmIS_ERROR(status)) return status;


    /* get the correct coefficients */
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(1.2337005499793097000000 + 0.0000000001879654780980));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(-0.2536694772145465800000 -0.0000000069740527374221));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(0.0208629252575471480000 -0.0000004950582152116484));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(-0.0009161912571036650800 + 0.0000071557551705439561));

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) 1.5707963219692149000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -0.6459634788598108700000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) 0.0796802306857143090000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -0.0046021839812099832000);


    clsIOPERAND_New(Compiler, &fourthCoefIOperand, clmGenCodeDataType(T_FLOAT));
    clsIOPERAND_New(Compiler, &thirdCoefIOperand, clmGenCodeDataType(T_FLOAT));
    clsIOPERAND_New(Compiler, &secondCoefIOperand, clmGenCodeDataType(T_FLOAT));
    clsIOPERAND_New(Compiler, &firstCoefIOperand, clmGenCodeDataType(T_FLOAT));


    clsIOPERAND_New(Compiler, &offsetIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareFiveROperands[0], &compareFiveIOperands[0]);

    /* The selection begins for region % 4 = 1 */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region % 4 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext10,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &compareFiveROperands[0],
                                                &oneShortROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &fourthCoefIOperand,
                &fourthCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &thirdCoefIOperand,
                &thirdCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &secondCoefIOperand,
                &secondCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &firstCoefIOperand,
                &firstCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign the offset */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &offsetIOperand,
                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext10,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

                /* The selection begins for region % 4 = 2*/
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectionContext11);

            if (gcmIS_ERROR(status)) return status;

            /* The condition part: region % 4 = 2 */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext11,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &compareFiveROperands[0],
                                                            &twoShortROperand);

            if (gcmIS_ERROR(status)) return status;

            /* The true part */
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext11);

            if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &fourthCoefIOperand,
                            &fourthCosROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &thirdCoefIOperand,
                            &thirdCosROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &secondCoefIOperand,
                            &secondCosROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &firstCoefIOperand,
                            &firstCosROperand);

                if (gcmIS_ERROR(status)) return status;


                /* assign the offset */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &offsetIOperand,
                            &oneIntROperand);

                if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectionContext11,
                                                    gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            /* The false part */
            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext11);

            if (gcmIS_ERROR(status)) return status;


                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &fourthCoefIOperand,
                            &fourthSinROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &thirdCoefIOperand,
                            &thirdSinROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &secondCoefIOperand,
                            &secondSinROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &firstCoefIOperand,
                            &firstSinROperand);

                if (gcmIS_ERROR(status)) return status;


                /* assign the offset */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &offsetIOperand,
                            &zeroIntROperand);

                if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext11);

            if (gcmIS_ERROR(status)) return status;

            /* The selection end */
            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContext11);

            if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext10);

    if (gcmIS_ERROR(status)) return status;


    clsROPERAND_InitializeUsingIOperand(&fourthCoefROperand, &fourthCoefIOperand);
    clsROPERAND_InitializeUsingIOperand(&thirdCoefROperand, &thirdCoefIOperand);
    clsROPERAND_InitializeUsingIOperand(&secondCoefROperand, &secondCoefIOperand);
    clsROPERAND_InitializeUsingIOperand(&firstCoefROperand, &firstCoefIOperand);


    /* determine if negative */
    clsIOPERAND_New(Compiler, &negIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&regionROperand, &regionIOperand);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region > 3 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext12,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &regionROperand,
                                                &threeIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &negIOperand,
                &negOneROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext12,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &negIOperand,
                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext12);

    if (gcmIS_ERROR(status)) return status;




    /* mul */
    clsIOPERAND_New(Compiler, &intermIOperands[37], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[35]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[37],
                                &intermROperands[24],
                                &intermROperands[24]);

    if (gcmIS_ERROR(status)) return status;

    /* mul coef1 with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[38], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[38],
                                &firstCoefROperand,
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add coef2 to result */
    clsIOPERAND_New(Compiler, &intermIOperands[39], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[38]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[39],
                                &secondCoefROperand,
                                &intermROperands[26]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[40], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[27], &intermIOperands[39]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[40],
                                &intermROperands[27],
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add coef3 to result */
    clsIOPERAND_New(Compiler, &intermIOperands[41], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[28], &intermIOperands[40]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[41],
                                &thirdCoefROperand,
                                &intermROperands[28]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[42], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[29], &intermIOperands[41]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[42],
                                &intermROperands[29],
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add coef4 to result */
    clsIOPERAND_New(Compiler, &intermIOperands[43], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[30], &intermIOperands[42]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[43],
                                &fourthCoefROperand,
                                &intermROperands[30]);

    if (gcmIS_ERROR(status)) return status;




    /* switch */
    clsIOPERAND_New(Compiler, &switchIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&offsetROperand, &offsetIOperand);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: offset = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext12,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &offsetROperand,
                                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[44], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[31], &intermIOperands[43]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[44],
                                &intermROperands[31],
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add result with (x')^2 */

    clsROPERAND_InitializeUsingIOperand(&intermROperands[34], &intermIOperands[44]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &switchIOperand,
                                &cosineROperand,
                                &intermROperands[34]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext12,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with (x')^2 */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[31], &intermIOperands[43]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[35], &intermIOperands[35]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &switchIOperand,
                                &intermROperands[31],
                                &intermROperands[35]);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext12);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with negative or unity */
    clsROPERAND_InitializeUsingIOperand(&switchROperand, &switchIOperand);
    clsROPERAND_InitializeUsingIOperand(&negROperand, &negIOperand);



    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                IOperand,
                                &negROperand,
                                &switchROperand);

    if (gcmIS_ERROR(status)) return status;


   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);
OnError:
   return status;
}

static gceSTATUS
_GenNativeCosCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(Compiler,
                               PolynaryExpr->exprBase.base.lineNo,
                               PolynaryExpr->exprBase.base.stringNo,
                               clvOPCODE_COS,
                               IOperand,
                               &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenSinCosCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    gctREG_INDEX    tempRegIndex;
    gctREG_INDEX    wordRegIndex, wordRegTwoIndex, wordRegThreeIndex, wordRegFourIndex;

    clsSELECTION_CONTEXT    selectionContext6, selectionContext7;

    clsIOPERAND wordStartIOperand, wordStartTwoIOperand, wordStartThreeIOperand, wordStartFourIOperand, bitStartIOperand, bitStartThreeIOperand, finalIOperand, regionIOperand[2], leadZeroIOperand[2], leadZeroTwoIOperand[2];
    clsROPERAND bitStartROperand, bitStartThreeROperand, regROperand, regTwoROperand, regThreeROperand, regFourROperand, reducedROperand, finalROperand, regionROperand[2], leadZeroROperand[2];
    clsIOPERAND intermIOperands[46];
    clsROPERAND intermROperands[46];
    clsIOPERAND negIOperand;

    clsIOPERAND bitsIOperands[4], bitsTwoIOperands[4];
    clsIOPERAND reducedIOperand;
    clsROPERAND bitsROperands[4], bitsTwoROperands[4];
    clsIOPERAND notIOperands[6];
    clsROPERAND notROperands[6];
    clsIOPERAND compareThreeIOperands[1], compareFourIOperands[1], compareFiveIOperands[1];
    clsROPERAND compareThreeROperands[1], compareFourROperands[1], compareFiveROperands[1];
    clsROPERAND firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand;
    clsIOPERAND    firstCoefIOperand, secondCoefIOperand, thirdCoefIOperand, fourthCoefIOperand;
    clsROPERAND piROperand, piHalvedROperand, piThreeHalvedROperand, negOneROperand, oneROperand, oneShortROperand, twoShortROperand, twoPiROperand, twoPiLoROperand, twoROperand, zeroIntROperand, oneIntROperand, twoIntROperand,
                threeIntROperand, fourROperand, fourIntROperand, fiveIntROperand, nineIntROperand, elevenIntROperand, twentyNineIntROperand, thirtyOneHexROperand, thirtyTwoIntROperand,
                fullHexROperand, roundingROperand, twentyThreeShortROperand, addROperand, negROperand;
    clsROPERAND maskROperand, maskTwoROperand, maskThreeROperand, expMaskROperand, nanROperand;
    clsROPERAND invrsTwoPiROperand[6];

    clsIOPERAND offsetIOperand, switchIOperand;
    clsROPERAND offsetROperand, switchROperand;

    clsROPERAND    firstCosROperand, secondCosROperand, thirdCosROperand, fourthCosROperand,
                firstSinROperand, secondSinROperand, thirdSinROperand, fourthSinROperand;

    clsIOPERAND expIOperands[2];
    clsROPERAND expROperands[2];

    clsROPERAND cosineROperand;

    clsROPERAND testIntROperand;
    int i;

    clsROPERAND_InitializeIntOrIVecConstant(&testIntROperand,
                              clmGenCodeDataType(T_INT),
                              (gctUINT) 3);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_constant);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_halved);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piThreeHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_threeHalved);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoPiROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) two_pi);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoPiLoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) two_pi_lo);
    clsROPERAND_InitializeIntOrIVecConstant(&zeroIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0);
    clsROPERAND_InitializeIntOrIVecConstant(&oneIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 1);
    clsROPERAND_InitializeIntOrIVecConstant(&oneShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctINT16) 1);
    clsROPERAND_InitializeIntOrIVecConstant(&twoShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctINT16) 2);
    clsROPERAND_InitializeIntOrIVecConstant(&twoIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 2);
    clsROPERAND_InitializeIntOrIVecConstant(&threeIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 3);
    clsROPERAND_InitializeIntOrIVecConstant(&fourIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 4);
    clsROPERAND_InitializeIntOrIVecConstant(&fiveIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 5);
    clsROPERAND_InitializeIntOrIVecConstant(&nineIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 9);
    clsROPERAND_InitializeIntOrIVecConstant(&elevenIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 11);
    clsROPERAND_InitializeIntOrIVecConstant(&twentyThreeShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctUINT16) 23);
    clsROPERAND_InitializeIntOrIVecConstant(&twentyNineIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 29);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyTwoIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 32);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneHexROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x0000001f);
    clsROPERAND_InitializeIntOrIVecConstant(&fullHexROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0xffffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&roundingROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x00000080);
    clsROPERAND_InitializeIntOrIVecConstant(&cosineROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x3f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7fc00000);





    clsROPERAND_InitializeFloatOrVecOrMatConstant(&negOneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) -1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 4.0);


    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[0],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x28be60db);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[1],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x9391054a);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[2],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7f09d5f4);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[3],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7d4d3770);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[4],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x36d8a566);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[5],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x4f10e407);

    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x007fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&maskTwoROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x00800000);
    clsROPERAND_InitializeIntOrIVecConstant(&maskThreeROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0xffff0000);


    clsROPERAND_InitializeIntOrIVecConstant(&expMaskROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7F800000);



    clsROPERAND_InitializeIntOrIVecConstant(&addROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 127);



    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);




    /* getexp x, start by masking */
    clsIOPERAND_New(Compiler, &expIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&expROperands[0], &expIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &expIOperands[0],
                        &expMaskROperand,
                        &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* shift right by 23 */
    clsIOPERAND_New(Compiler, &expIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&expROperands[1], &expIOperands[1]);


    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &expIOperands[1],
                                &expROperands[0],
                                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &expROperands[1],
                 clvCONDITION_LESS_THAN,
                 &addROperand);

    {/* |x| < 1.0, approximation directly, with polynomial x^2 */
        float cosCoefXLess1[] = {   1.000000000000000000000000f,
                                     -0.499999970197677610000000f,
                                      0.041666429489850998000000f,
                                     -0.001388253993354737800000f,
                                      0.000024100709197227843000f,};
        for(i = 0; i<5; i++){
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&intermROperands[i],
                              clmGenCodeDataType(T_FLOAT),
                              cosCoefXLess1[i]);
            clsIOPERAND_New(Compiler, &intermIOperands[10+i], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[10+i], &intermIOperands[10+i]);
        }

        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[10],
                &OperandsParameters[0].rOperands[0],
                &OperandsParameters[0].rOperands[0]);

        for(i = 4; i>=0; i--){
            if(i == 4){
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &intermIOperands[12],
                            &intermROperands[i]);
            }
            else{
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[12],
                        &intermROperands[11],
                        &intermROperands[i]);
            }
            if(i > 0)
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[11],
                        &intermROperands[12],
                        &intermROperands[10]);
        }
        { /* Save out the r12*/
            clsLOPERAND lOperand[1];
            clsROPERAND zeroROperand;

            clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                                clmGenCodeDataType(T_INT),
                                                0x0);

            clsLOPERAND_InitializeUsingROperand(lOperand, &OperandsParameters[1].rOperands[0]);
            status = clGenStoreCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        &intermROperands[12],
                                        lOperand,
                                        OperandsParameters[1].rOperands[0].dataType,
                                        &zeroROperand);
                if (gcmIS_ERROR(status)) return status;
        } /*End of Save out */



    }
    {/* |x| < 1.0, approximation directly */

        float sinCoefXLess1[] = {
                1.000000000000000000000000f,
                -0.166665986180305480000000f,
                0.008329850621521472900000f,
                -0.000192914783838205040000f
        };
        for(i = 0; i<4; i++){
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&intermROperands[i],
                              clmGenCodeDataType(T_FLOAT),
                              sinCoefXLess1[i]);
            clsIOPERAND_New(Compiler, &intermIOperands[10+i], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[10+i], &intermIOperands[10+i]);
        }

        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[10],
                &OperandsParameters[0].rOperands[0],
                &OperandsParameters[0].rOperands[0]);

        for(i = 3; i>=0; i--){
            if(i == 3){
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &intermIOperands[12],
                            &intermROperands[i]);
            }
            else{
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[12],
                        &intermROperands[11],
                        &intermROperands[i]);
            }
            if(i > 0)
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[11],
                        &intermROperands[12],
                        &intermROperands[10]);
        }

        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                IOperand,
                &intermROperands[12],
                &OperandsParameters[0].rOperands[0]);

    }

    clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    /* Check Infinity or Nan*/
    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &expROperands[0],
                 clvCONDITION_EQUAL,
                 &expMaskROperand);

    /* Return to Nan for X = Inf or Nan */
    status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            IOperand,
            &nanROperand);
        { /* Save out the Nan*/
            clsLOPERAND lOperand[1];
            clsROPERAND zeroROperand;

            clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                                clmGenCodeDataType(T_INT),
                                                0x0);

            clsLOPERAND_InitializeUsingROperand(lOperand, &OperandsParameters[1].rOperands[0]);
            status = clGenStoreCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        &nanROperand,
                                        lOperand,
                                        OperandsParameters[1].rOperands[0].dataType,
                                        &zeroROperand);
                if (gcmIS_ERROR(status)) return status;
        } /*End of Save out */


    clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    /* sub from result */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));


    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                &intermIOperands[0],
                                &expROperands[1],
                                &addROperand);

    if (gcmIS_ERROR(status)) return status;



    /* get mant x */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &intermIOperands[1],
                                &maskROperand,
                                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* get hidden bit */
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &intermIOperands[2],
                                &maskTwoROperand,
                                &intermROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* mullo 1/2pi part one (integer mul is automatically mullo in hardware instruction) */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    for(i = 0; i<6; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[2*i + 3], clmGenCodeDataType(T_UINT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[2*i+3], &intermIOperands[2*i+3]);
        clsIOPERAND_New(Compiler, &intermIOperands[2*i + 4], clmGenCodeDataType(T_UINT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[2*i+4], &intermIOperands[2*i+4]);


        status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[2*i+3],
                            &intermROperands[2],
                            &invrsTwoPiROperand[i]);
        if (gcmIS_ERROR(status)) return status;


        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MULHI,
                                &intermIOperands[2*i+4],
                                &intermROperands[2],
                                &invrsTwoPiROperand[i]);
        if (gcmIS_ERROR(status)) return status;
    }

    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);
    clsIOPERAND_New(Compiler, &notIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&notROperands[0], &notIOperands[0]);

    /* allocate registers for the 192 bit, six segment array */
    tempRegIndex = clNewTempRegs(Compiler, 7, clvTYPE_UINT);
    status = clNewVariable(Compiler,
                       0,
                       0,
                       "sinPrecisionArray",
                       clvQUALIFIER_NONE,
                       clvQUALIFIER_NONE,
                       clvSTORAGE_QUALIFIER_NONE,
                       clmGenCodeDataType(T_UINT),
                       7,
                       gcvTRUE,
                       tempRegIndex,
                       gcvNULL);
    for(i = 0; i<7; i++){
        clsIOPERAND_Initialize(Compiler, &intermIOperands[20+i], clmGenCodeDataType(T_UINT), tempRegIndex + (gctREG_INDEX)i);
    }
    for(i = 5; i>=1; i--){
        /* Not (MulHi)*/
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_NOT_BITWISE,
                    &notIOperands[0],
                    &intermROperands[2*i+4]);
        if (gcmIS_ERROR(status)) return status;
        /* ( MulLo > ~(MulHi) ? regroup needed) */
        clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[2*i+1],
                 clvCONDITION_GREATER_THAN,
                 &notROperands[0]);

        /*Add the overflow bit */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[2*i+2],
                                &oneIntROperand,
                                &intermROperands[2*i+2]);
        if (gcmIS_ERROR(status)) return status;

        clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

        /*else, do nothing */

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

        /*Hi + PreviousLo */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[20+i],
                                &intermROperands[2*i+1],
                                &intermROperands[2*i+4]);
        if (gcmIS_ERROR(status)) return status;
    }

    /* assign part one */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[20],
                &intermROperands[4]);
    /* assign the last 4-bytes*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[26],
                &intermROperands[13]);

    if (gcmIS_ERROR(status)) return status;

    /* add 9 to exponent */
    clsIOPERAND_New(Compiler, &intermIOperands[26], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[26],
                                &intermROperands[0],
                                &nineIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift 9 + exponent by 5 bits (i.e. divide by 32), gets word index */
    clsIOPERAND_New(Compiler, &wordStartIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[26]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &wordStartIOperand,
                                &intermROperands[26],
                                &fiveIntROperand);

    if (gcmIS_ERROR(status)) return status;


    /* mod 9 + exponent by 32, gets bit position */
    clsIOPERAND_New(Compiler, &bitStartIOperand, clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &bitStartIOperand,
                                &intermROperands[26],
                                &thirtyOneHexROperand);

    if (gcmIS_ERROR(status)) return status;




    /* get index */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegIndex = wordStartIOperand.tempRegIndex;
    regROperand.arrayIndex.mode = clvINDEX_REG;
    regROperand.arrayIndex.u.indexRegIndex = wordRegIndex;



    /* shift the target word of the six segments */
    clsIOPERAND_New(Compiler, &intermIOperands[27], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartROperand, &bitStartIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[27],
                                &regROperand,
                                &bitStartROperand);

    if (gcmIS_ERROR(status)) return status;





    /* this will hold the reduced x */
    clsIOPERAND_New(Compiler, &reducedIOperand, clmGenCodeDataType(T_UINT));


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: startBits > 0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext6,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &bitStartROperand,
                                                &zeroIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for startBits > 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* sub from 32 start bits */
    clsIOPERAND_New(Compiler, &bitsIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartROperand, &bitStartIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &bitsIOperands[0],
                                &thirtyTwoIntROperand,
                                &bitStartROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add one to target reg, denoting the next word */
    clsIOPERAND_New(Compiler, &wordStartTwoIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[0], &wordStartIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &wordStartTwoIOperand,
                                &bitsROperands[0],
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift the next word of the six segments */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regTwoROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);


    wordRegTwoIndex = wordStartTwoIOperand.tempRegIndex;
    regTwoROperand.arrayIndex.mode = clvINDEX_REG;
    regTwoROperand.arrayIndex.u.indexRegIndex = wordRegTwoIndex;

    clsIOPERAND_New(Compiler, &bitsIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[1], &bitsIOperands[0]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &bitsIOperands[1],
                                &regTwoROperand,
                                &bitsROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* get enough bits from next word for 32 bit precision */
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[3], &intermIOperands[27]);
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[2], &bitsIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &reducedIOperand,
                                &bitsROperands[3],
                                &bitsROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext6,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part where startBits = 0, so nothing is done besides assigning */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* assign the unaltered word */
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[3], &intermIOperands[27]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &reducedIOperand,
                &bitsROperands[3]);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext6);

    if (gcmIS_ERROR(status)) return status;




    /* get the region */
    clsIOPERAND_New(Compiler, &regionIOperand[0], clmGenCodeDataType(T_UINT));
    clsIOPERAND_New(Compiler, &regionIOperand[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&regionROperand[0], &regionIOperand[0]);
    clsROPERAND_InitializeUsingIOperand(&regionROperand[1], &regionIOperand[1]);

    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    for(i = 0; i<2; i++)
    {
        /*Cos(x) = Sin(x+Pi/2), so the regionCalculation same as SinRegion+2, then calculate Sin(x) */
        if(i){
            clsROPERAND cosRegionROperand;
            clsROPERAND_InitializeIntOrIVecConstant(&cosRegionROperand,
                                  clmGenCodeDataType(T_UINT),
                                  (gctUINT) (2<<29));
            status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &reducedIOperand,
                                    &reducedROperand,
                                    &cosRegionROperand);
        }
        status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &regionIOperand[i],
                                &reducedROperand,
                                &twentyNineIntROperand);

        if (gcmIS_ERROR(status)) return status;
    }
    /* clean the reducedROperand, integer part */

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &reducedIOperand,
                                &reducedROperand,
                                &twoIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* and region with 0x01 */
    clsIOPERAND_New(Compiler, &compareThreeIOperands[0], clmGenCodeDataType(T_UINT));

    for(i = 0; i<2; i++){ /* Loop, i = 0 for sine, i = 1 for cos*/
    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &compareThreeIOperands[0],
                                &regionROperand[i],
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;




    clsIOPERAND_New(Compiler, &leadZeroIOperand[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareThreeROperands[0], &compareThreeIOperands[0]);
    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region & 0x01 = 1 */
    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &compareThreeROperands[0],
                 clvCONDITION_EQUAL,
                 &oneIntROperand);


    /* The true part */
    /* not the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_NOT_BITWISE,
                &leadZeroIOperand[0],
                &reducedROperand);

    if (gcmIS_ERROR(status)) return status;

    clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &leadZeroIOperand[0],
                &reducedROperand);

    clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);




    /* grab leading zero */
    clsIOPERAND_New(Compiler, &leadZeroIOperand[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&leadZeroROperand[0], &leadZeroIOperand[0]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LEADZERO,
                &leadZeroIOperand[1],
                &leadZeroROperand[0]);

    if (gcmIS_ERROR(status)) return status;



    /* add eleven to leading zero */
    clsIOPERAND_New(Compiler, &intermIOperands[28], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &leadZeroIOperand[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[28],
                                &intermROperands[16],
                                &elevenIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add exponent to result */
    clsIOPERAND_New(Compiler, &intermIOperands[29], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[28]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[29],
                                &intermROperands[17],
                                &intermROperands[14]);

    if (gcmIS_ERROR(status)) return status;









    /* shift 11 + exponent + leading zero position by 5 bits (i.e. divide by 32), gets word index */
    clsIOPERAND_New(Compiler, &wordStartThreeIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[29]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &wordStartThreeIOperand,
                                &intermROperands[18],
                                &fiveIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mod 11 + exponent + leading zero position by 32, gets bit position */
    clsIOPERAND_New(Compiler, &bitStartThreeIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[29]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &bitStartThreeIOperand,
                                &intermROperands[18],
                                &thirtyOneHexROperand);

    if (gcmIS_ERROR(status)) return status;




    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    /* get index */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regThreeROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegThreeIndex = wordStartThreeIOperand.tempRegIndex;
    regThreeROperand.arrayIndex.mode = clvINDEX_REG;
    regThreeROperand.arrayIndex.u.indexRegIndex = wordRegThreeIndex;



    /* shift the target word of the six segments */
    clsIOPERAND_New(Compiler, &intermIOperands[30], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartThreeROperand, &bitStartThreeIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[30],
                                &regThreeROperand,
                                &bitStartThreeROperand);

    if (gcmIS_ERROR(status)) return status;




    /* used to hold the final word value */
    clsIOPERAND_New(Compiler, &finalIOperand, clmGenCodeDataType(T_UINT));


    /* The condition part: startBits > 0 */
    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &bitStartThreeROperand,
                 clvCONDITION_GREATER_THAN,
                 &zeroIntROperand);

    /* sub from 32 start bits */
    clsIOPERAND_New(Compiler, &bitsTwoIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartThreeROperand, &bitStartThreeIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &bitsTwoIOperands[0],
                                &thirtyTwoIntROperand,
                                &bitStartThreeROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add one to target reg, denoting the next word */
    clsIOPERAND_New(Compiler, &wordStartFourIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[0], &wordStartThreeIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &wordStartFourIOperand,
                                &bitsTwoROperands[0],
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift the next word of the six segments */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regFourROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegFourIndex = wordStartFourIOperand.tempRegIndex;
    regFourROperand.arrayIndex.mode = clvINDEX_REG;
    regFourROperand.arrayIndex.u.indexRegIndex = wordRegFourIndex;

    clsIOPERAND_New(Compiler, &bitsTwoIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[1], &bitsTwoIOperands[0]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &bitsTwoIOperands[1],
                                &regFourROperand,
                                &bitsTwoROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* get enough bits from next word for 32 bit precision */
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[3], &intermIOperands[30]);
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[2], &bitsTwoIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &finalIOperand,
                                &bitsTwoROperands[3],
                                &bitsTwoROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    clmGEN_CODE_ELSE(Compiler,
                       CodeGenerator,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo);





    /* assign the unaltered word */
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[3], &intermIOperands[30]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &finalIOperand,
                &bitsTwoROperands[3]);

    if (gcmIS_ERROR(status)) return status;

    clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);




    clsIOPERAND_New(Compiler, &leadZeroTwoIOperand[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareThreeROperands[0], &compareThreeIOperands[0]);
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);


    /* The condition part: region & 0x01 = 1 */

    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &compareThreeROperands[0],
                 clvCONDITION_EQUAL,
                 &oneIntROperand);


    if (gcmIS_ERROR(status)) return status;

    /* xor the word */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_XOR_BITWISE,
                &finalIOperand,
                &finalROperand,
                &fullHexROperand);

    if (gcmIS_ERROR(status)) return status;

    clmGEN_CODE_ELSE(Compiler,
                       CodeGenerator,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo);
    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &finalIOperand,
                &finalROperand);

    if (gcmIS_ERROR(status)) return status;

    clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);


    /* and with 0xffff0000 */
    clsIOPERAND_New(Compiler, &compareFourIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &compareFourIOperands[0],
                                &finalROperand,
                                &maskThreeROperand);

    if (gcmIS_ERROR(status)) return status;









    /* rounding starts */
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);
    clsROPERAND_InitializeUsingIOperand(&compareFourROperands[0], &compareFourIOperands[0]);



    /* The condition part: region & 0x01 = 1 */
    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &compareFourROperands[0],
                 clvCONDITION_NOT_EQUAL,
                 &maskThreeROperand);

    /* add the word with rounding */
    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &finalIOperand,
                                &finalROperand,
                                &roundingROperand);

    if (gcmIS_ERROR(status)) return status;

   clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);


        /*else, do nothing */

   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);









    /* convert the int to a float */
    clsIOPERAND_New(Compiler, &intermIOperands[31], clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_UINT_TO_FLOAT,
                &intermIOperands[31],
                &finalROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift 32 by 23 */
    clsIOPERAND_New(Compiler, &intermIOperands[32], clmGenCodeDataType(T_UINT));

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[32],
                &thirtyTwoIntROperand,
                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    /* subtract from the word the above result */
    clsIOPERAND_New(Compiler, &intermIOperands[33], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[32]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[31]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[33],
                                &intermROperands[19],
                                &intermROperands[20]);

    if (gcmIS_ERROR(status)) return status;

    /* shift 32 by 23 */
    clsIOPERAND_New(Compiler, &intermIOperands[34], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &leadZeroIOperand[1]);

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[34],
                &intermROperands[16],
                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    /* subtract from the word the above result */
    clsIOPERAND_New(Compiler, &intermIOperands[35], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[22], &intermIOperands[33]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[21], &intermIOperands[34]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[35],
                                &intermROperands[22],
                                &intermROperands[21]);

    if (gcmIS_ERROR(status)) return status;

    /* mod exponent of region */
    clsIOPERAND_New(Compiler, &compareFiveIOperands[0], clmGenCodeDataType(T_USHORT));

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_AND_BITWISE,
                                    &compareFiveIOperands[0],
                                    &regionROperand[i],
                                    &threeIntROperand);

    if (gcmIS_ERROR(status)) return status;


    /* get the correct coefficients */
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(1.2337005499793097000000 + 0.0000000001879654780980));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(-0.2536694772145465800000 -0.0000000069740527374221));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(0.0208629252575471480000 -0.0000004950582152116484));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCosROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -(-0.0009161912571036650800 + 0.0000071557551705439561));

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) 1.5707963219692149000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -0.6459634788598108700000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) 0.0796802306857143090000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstSinROperand,
                      clmGenCodeDataType(T_FLOAT),
                      (gctFLOAT) -0.0046021839812099832000);


    clsIOPERAND_New(Compiler, &fourthCoefIOperand, clmGenCodeDataType(T_FLOAT));
    clsIOPERAND_New(Compiler, &thirdCoefIOperand, clmGenCodeDataType(T_FLOAT));
    clsIOPERAND_New(Compiler, &secondCoefIOperand, clmGenCodeDataType(T_FLOAT));
    clsIOPERAND_New(Compiler, &firstCoefIOperand, clmGenCodeDataType(T_FLOAT));


    clsIOPERAND_New(Compiler, &offsetIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareFiveROperands[0], &compareFiveIOperands[0]);


    /* The condition part: region % 4 = 1 */
    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &compareFiveROperands[0],
                 clvCONDITION_EQUAL,
                 &oneShortROperand);


    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &fourthCoefIOperand,
                &fourthCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &thirdCoefIOperand,
                &thirdCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &secondCoefIOperand,
                &secondCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &firstCoefIOperand,
                &firstCosROperand);

    if (gcmIS_ERROR(status)) return status;

    /* assign the offset */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &offsetIOperand,
                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

  clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);
  {




            /* The condition part: region % 4 = 2 */
          clmGEN_CODE_IF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo,
                     &compareFiveROperands[0],
                     clvCONDITION_EQUAL,
                     &twoShortROperand);

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &fourthCoefIOperand,
                            &fourthCosROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &thirdCoefIOperand,
                            &thirdCosROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &secondCoefIOperand,
                            &secondCosROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &firstCoefIOperand,
                            &firstCosROperand);

                if (gcmIS_ERROR(status)) return status;


                /* assign the offset */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &offsetIOperand,
                            &oneIntROperand);

                if (gcmIS_ERROR(status)) return status;
                /* else*/
              clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &fourthCoefIOperand,
                            &fourthSinROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &thirdCoefIOperand,
                            &thirdSinROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &secondCoefIOperand,
                            &secondSinROperand);

                if (gcmIS_ERROR(status)) return status;

                /* assign */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &firstCoefIOperand,
                            &firstSinROperand);

                if (gcmIS_ERROR(status)) return status;


                /* assign the offset */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &offsetIOperand,
                            &zeroIntROperand);

                if (gcmIS_ERROR(status)) return status;

            clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);


    }

   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);


    clsROPERAND_InitializeUsingIOperand(&fourthCoefROperand, &fourthCoefIOperand);
    clsROPERAND_InitializeUsingIOperand(&thirdCoefROperand, &thirdCoefIOperand);
    clsROPERAND_InitializeUsingIOperand(&secondCoefROperand, &secondCoefIOperand);
    clsROPERAND_InitializeUsingIOperand(&firstCoefROperand, &firstCoefIOperand);


    /* determine if negative */
    clsIOPERAND_New(Compiler, &negIOperand, clmGenCodeDataType(T_UINT));



    /* The condition part: region > 3 */
    clmGEN_CODE_IF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo,
                     &regionROperand[i],
                     clvCONDITION_GREATER_THAN,
                     &threeIntROperand);

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &negIOperand,
                &negOneROperand);

    if (gcmIS_ERROR(status)) return status;

        /* else*/
      clmGEN_CODE_ELSE(Compiler,
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &negIOperand,
                &oneROperand);

    if (gcmIS_ERROR(status)) return status;


   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

    /* mul */
    clsIOPERAND_New(Compiler, &intermIOperands[37], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[35]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[37],
                                &intermROperands[24],
                                &intermROperands[24]);

    if (gcmIS_ERROR(status)) return status;

    /* mul coef1 with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[38], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[38],
                                &firstCoefROperand,
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add coef2 to result */
    clsIOPERAND_New(Compiler, &intermIOperands[39], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[38]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[39],
                                &secondCoefROperand,
                                &intermROperands[26]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[40], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[27], &intermIOperands[39]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[40],
                                &intermROperands[27],
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add coef3 to result */
    clsIOPERAND_New(Compiler, &intermIOperands[41], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[28], &intermIOperands[40]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[41],
                                &thirdCoefROperand,
                                &intermROperands[28]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[42], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[29], &intermIOperands[41]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[42],
                                &intermROperands[29],
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add coef4 to result */
    clsIOPERAND_New(Compiler, &intermIOperands[43], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[30], &intermIOperands[42]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[43],
                                &fourthCoefROperand,
                                &intermROperands[30]);

    if (gcmIS_ERROR(status)) return status;




    /* switch */
    clsIOPERAND_New(Compiler, &switchIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&offsetROperand, &offsetIOperand);



    /* The condition part: offset = 1 */
      clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &offsetROperand,
                 clvCONDITION_EQUAL,
                 &oneIntROperand);

    /* mul result with (x')^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[44], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[31], &intermIOperands[43]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[37]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[44],
                                &intermROperands[31],
                                &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;

    /* add result with (x')^2 */

    clsROPERAND_InitializeUsingIOperand(&intermROperands[34], &intermIOperands[44]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &switchIOperand,
                                &cosineROperand,
                                &intermROperands[34]);

    if (gcmIS_ERROR(status)) return status;

    /* else*/
  clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);


    /* mul result with (x')^2 */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[31], &intermIOperands[43]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[35], &intermIOperands[35]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &switchIOperand,
                                &intermROperands[31],
                                &intermROperands[35]);

    if (gcmIS_ERROR(status)) return status;


    clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);


    /* mul result with negative or unity */
    clsROPERAND_InitializeUsingIOperand(&switchROperand, &switchIOperand);
    clsROPERAND_InitializeUsingIOperand(&negROperand, &negIOperand);

    if(i){
        intermIOperands[12].dataType.elementType = clvTYPE_FLOAT;
    }
    else{ /*i == 0, for sin(x), get the sign of the x */
      negIOperand.dataType.elementType = clvTYPE_FLOAT;
      clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &OperandsParameters[0].rOperands[0],
                 clvCONDITION_LESS_THAN,
                 &zeroIntROperand);

          status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &negIOperand,
                                &negROperand,
                                &negOneROperand);
    /* else*/
      clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

      clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);
      negIOperand.dataType.elementType = clvTYPE_UINT;
    }

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                i == 0? IOperand : &intermIOperands[12],
                                &negROperand,
                                &switchROperand);
    if(i){ /* Save out the r12, cos(x)*/
            clsLOPERAND lOperand[1];
            clsROPERAND zeroROperand;

            clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                                clmGenCodeDataType(T_INT),
                                                0x0);

            clsLOPERAND_InitializeUsingROperand(lOperand, &OperandsParameters[1].rOperands[0]);
            status = clGenStoreCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        &intermROperands[12],
                                        lOperand,
                                        OperandsParameters[1].rOperands[0].dataType,
                                        &zeroROperand);
                if (gcmIS_ERROR(status)) return status;
    } /*End of Save out */

    if (gcmIS_ERROR(status)) return status;
    } /* Loop, i = 0 for sine, i = 1 for cos*/

   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);
OnError:
   return status;
}

static gceSTATUS
_GenTanCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    gctREG_INDEX    tempRegIndex;
    gctREG_INDEX    wordRegIndex, wordRegTwoIndex, wordRegThreeIndex, wordRegFourIndex;

    clsSELECTION_CONTEXT    selectionContext6, selectionContext7,
                            selectionContext8, selectionContext9, selectionContext10;

    clsIOPERAND wordStartIOperand, wordStartTwoIOperand, wordStartThreeIOperand, wordStartFourIOperand, bitStartIOperand, bitStartThreeIOperand, finalIOperand, regionIOperand, leadZeroIOperand[2], leadZeroTwoIOperand[2];
    clsROPERAND bitStartROperand, bitStartThreeROperand, regROperand, regTwoROperand, regThreeROperand, regFourROperand, reducedROperand, finalROperand, regionROperand, leadZeroROperand[2];
    clsIOPERAND intermIOperands[46];
    clsROPERAND intermROperands[46];

    clsIOPERAND bitsIOperands[4], bitsTwoIOperands[4];
    clsIOPERAND reducedIOperand;
    clsROPERAND bitsROperands[4], bitsTwoROperands[4];
    clsIOPERAND notIOperands[6];
    clsROPERAND notROperands[6];
    clsIOPERAND compareThreeIOperands[1], compareFourIOperands[1];
    clsROPERAND compareThreeROperands[1], compareFourROperands[1];
    clsROPERAND piROperand, piHalvedROperand, piThreeHalvedROperand, negOneROperand, oneROperand, oneShortROperand, twoShortROperand, twoPiROperand, twoPiLoROperand, twoROperand, zeroIntROperand, oneIntROperand, twoIntROperand,
                threeIntROperand, fourROperand, fourIntROperand, fiveIntROperand, nineIntROperand, elevenIntROperand, twentyNineIntROperand, thirtyOneHexROperand, thirtyTwoIntROperand,
                fullHexROperand, roundingROperand, twentyThreeShortROperand, addROperand;
    clsROPERAND maskROperand, maskTwoROperand, maskThreeROperand, expMaskROperand, nanROperand;
    clsROPERAND invrsTwoPiROperand[6];

    clsIOPERAND expIOperands[2];
    clsROPERAND expROperands[2];

    clsROPERAND cosineROperand;

    clsROPERAND testIntROperand;
    int i;

    clsROPERAND_InitializeIntOrIVecConstant(&testIntROperand,
                              clmGenCodeDataType(T_INT),
                              (gctUINT) 3);



    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_constant);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_halved);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piThreeHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_threeHalved);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoPiROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) two_pi);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoPiLoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) two_pi_lo);
    clsROPERAND_InitializeIntOrIVecConstant(&zeroIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0);
    clsROPERAND_InitializeIntOrIVecConstant(&oneIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 1);
    clsROPERAND_InitializeIntOrIVecConstant(&oneShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctINT16) 1);
    clsROPERAND_InitializeIntOrIVecConstant(&twoShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctINT16) 2);
    clsROPERAND_InitializeIntOrIVecConstant(&twoIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 2);
    clsROPERAND_InitializeIntOrIVecConstant(&threeIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 3);
    clsROPERAND_InitializeIntOrIVecConstant(&fourIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 4);
    clsROPERAND_InitializeIntOrIVecConstant(&fiveIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 5);
    clsROPERAND_InitializeIntOrIVecConstant(&nineIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 9);
    clsROPERAND_InitializeIntOrIVecConstant(&elevenIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 11);
    clsROPERAND_InitializeIntOrIVecConstant(&twentyThreeShortROperand,
                              clmGenCodeDataType(T_SHORT),
                              (gctUINT16) 23);
    clsROPERAND_InitializeIntOrIVecConstant(&twentyNineIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 29);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyTwoIntROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 32);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneHexROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x0000001f);
    clsROPERAND_InitializeIntOrIVecConstant(&fullHexROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0xffffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&roundingROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x00000080);
    clsROPERAND_InitializeIntOrIVecConstant(&cosineROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x3f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7fc00000);





    clsROPERAND_InitializeFloatOrVecOrMatConstant(&negOneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) -1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 4.0);


    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[0],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x28be60db);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[1],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x9391054a);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[2],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7f09d5f4);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[3],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7d4d3770);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[4],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x36d8a566);
    clsROPERAND_InitializeIntOrIVecConstant(&invrsTwoPiROperand[5],
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x4f10e407);

    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x007fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&maskTwoROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x00800000);
    clsROPERAND_InitializeIntOrIVecConstant(&maskThreeROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0xffff0000);


    clsROPERAND_InitializeIntOrIVecConstant(&expMaskROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7F800000);



    clsROPERAND_InitializeIntOrIVecConstant(&addROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 127);



    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);




    /* getexp x, start by masking */
    clsIOPERAND_New(Compiler, &expIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&expROperands[0], &expIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &expIOperands[0],
                        &expMaskROperand,
                        &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* shift right by 23 */
    clsIOPERAND_New(Compiler, &expIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&expROperands[1], &expIOperands[1]);


    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &expIOperands[1],
                                &expROperands[0],
                                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &expROperands[1],
                 clvCONDITION_LESS_THAN,
                 &addROperand);

    {/* |x| < 1.0, approximation directly */
        float tanCoefXLess1[] = {
        1.000000000000000000000000f,
        0.333330631256103520000000f,
        0.133404493331909180000000f,
        0.053259164094924927000000f,
        0.025360789149999619000000f,
        -0.000597973237745463850000f,
        0.018156010657548904000000f,
        -0.010787991806864738000000f,
        0.005282592494040727600000f};
        for(i = 0; i<9; i++){
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&intermROperands[i],
                              clmGenCodeDataType(T_FLOAT),
                              tanCoefXLess1[i]);
            clsIOPERAND_New(Compiler, &intermIOperands[10+i], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[10+i], &intermIOperands[10+i]);
        }

        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[10],
                &OperandsParameters[0].rOperands[0],
                &OperandsParameters[0].rOperands[0]);

        for(i = 8; i>=0; i--){
            if(i == 8){
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &intermIOperands[12],
                            &intermROperands[i]);
            }
            else{
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[12],
                        &intermROperands[11],
                        &intermROperands[i]);
            }
            if(i > 0)
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[11],
                        &intermROperands[12],
                        &intermROperands[10]);
        }

        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                IOperand,
                &intermROperands[12],
                &OperandsParameters[0].rOperands[0]);

    }

    clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    /* Check Infinity or Nan*/
    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &expROperands[0],
                 clvCONDITION_EQUAL,
                 &expMaskROperand);

    /* Return to Nan for X = Inf or Nan */
    status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            IOperand,
            &nanROperand);

    clmGEN_CODE_ELSE(Compiler,
               CodeGenerator,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo);

    /* sub from result */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));


    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                &intermIOperands[0],
                                &expROperands[1],
                                &addROperand);

    if (gcmIS_ERROR(status)) return status;



    /* get mant x */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &intermIOperands[1],
                                &maskROperand,
                                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* get hidden bit */
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &intermIOperands[2],
                                &maskTwoROperand,
                                &intermROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* mullo 1/2pi part one (integer mul is automatically mullo in hardware instruction) */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    for(i = 0; i<6; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[2*i + 3], clmGenCodeDataType(T_UINT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[2*i+3], &intermIOperands[2*i+3]);
        clsIOPERAND_New(Compiler, &intermIOperands[2*i + 4], clmGenCodeDataType(T_UINT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[2*i+4], &intermIOperands[2*i+4]);


        status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[2*i+3],
                            &intermROperands[2],
                            &invrsTwoPiROperand[i]);
        if (gcmIS_ERROR(status)) return status;


        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MULHI,
                                &intermIOperands[2*i+4],
                                &intermROperands[2],
                                &invrsTwoPiROperand[i]);
        if (gcmIS_ERROR(status)) return status;
    }

    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);
    clsIOPERAND_New(Compiler, &notIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&notROperands[0], &notIOperands[0]);

    /* allocate registers for the 192 bit, six segment array */
    tempRegIndex = clNewTempRegs(Compiler, 7, clvTYPE_UINT);
    status = clNewVariable(Compiler,
                       0,
                       0,
                       "sinPrecisionArray",
                       clvQUALIFIER_NONE,
                       clvQUALIFIER_NONE,
                       clvSTORAGE_QUALIFIER_NONE,
                       clmGenCodeDataType(T_UINT),
                       7,
                       gcvTRUE,
                       tempRegIndex,
                       gcvNULL);
    for(i = 0; i<7; i++){
        clsIOPERAND_Initialize(Compiler, &intermIOperands[20+i], clmGenCodeDataType(T_UINT), tempRegIndex + (gctREG_INDEX)i);
    }
    for(i = 5; i>=1; i--){
        /* Not (MulHi)*/
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_NOT_BITWISE,
                    &notIOperands[0],
                    &intermROperands[2*i+4]);
        if (gcmIS_ERROR(status)) return status;
        /* ( MulLo > ~(MulHi) ? regroup needed) */
        clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[2*i+1],
                 clvCONDITION_GREATER_THAN,
                 &notROperands[0]);

        /*Add the overflow bit */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[2*i+2],
                                &oneIntROperand,
                                &intermROperands[2*i+2]);
        if (gcmIS_ERROR(status)) return status;

        clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

        /*else, do nothing */

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

        /*Hi + PreviousLo */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[20+i],
                                &intermROperands[2*i+1],
                                &intermROperands[2*i+4]);
        if (gcmIS_ERROR(status)) return status;
    }

    /* assign part one */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[20],
                &intermROperands[4]);
    /* assign the last 4-bytes*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[26],
                &intermROperands[13]);

    if (gcmIS_ERROR(status)) return status;

    /* add 9 to exponent */
    clsIOPERAND_New(Compiler, &intermIOperands[26], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[26],
                                &intermROperands[0],
                                &nineIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift 9 + exponent by 5 bits (i.e. divide by 32), gets word index */
    clsIOPERAND_New(Compiler, &wordStartIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[26]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &wordStartIOperand,
                                &intermROperands[26],
                                &fiveIntROperand);

    if (gcmIS_ERROR(status)) return status;


    /* mod 9 + exponent by 32, gets bit position */
    clsIOPERAND_New(Compiler, &bitStartIOperand, clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &bitStartIOperand,
                                &intermROperands[26],
                                &thirtyOneHexROperand);

    if (gcmIS_ERROR(status)) return status;




    /* get index */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegIndex = wordStartIOperand.tempRegIndex;
    regROperand.arrayIndex.mode = clvINDEX_REG;
    regROperand.arrayIndex.u.indexRegIndex = wordRegIndex;



    /* shift the target word of the six segments */
    clsIOPERAND_New(Compiler, &intermIOperands[27], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartROperand, &bitStartIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[27],
                                &regROperand,
                                &bitStartROperand);

    if (gcmIS_ERROR(status)) return status;





    /* this will hold the reduced x */
    clsIOPERAND_New(Compiler, &reducedIOperand, clmGenCodeDataType(T_UINT));


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: startBits > 0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext6,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &bitStartROperand,
                                                &zeroIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for startBits > 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* sub from 32 start bits */
    clsIOPERAND_New(Compiler, &bitsIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartROperand, &bitStartIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &bitsIOperands[0],
                                &thirtyTwoIntROperand,
                                &bitStartROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add one to target reg, denoting the next word */
    clsIOPERAND_New(Compiler, &wordStartTwoIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[0], &wordStartIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &wordStartTwoIOperand,
                                &bitsROperands[0],
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift the next word of the six segments */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regTwoROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);


    wordRegTwoIndex = wordStartTwoIOperand.tempRegIndex;
    regTwoROperand.arrayIndex.mode = clvINDEX_REG;
    regTwoROperand.arrayIndex.u.indexRegIndex = wordRegTwoIndex;

    clsIOPERAND_New(Compiler, &bitsIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[1], &bitsIOperands[0]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &bitsIOperands[1],
                                &regTwoROperand,
                                &bitsROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* get enough bits from next word for 32 bit precision */
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[3], &intermIOperands[27]);
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[2], &bitsIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &reducedIOperand,
                                &bitsROperands[3],
                                &bitsROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext6,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part where startBits = 0, so nothing is done besides assigning */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* assign the unaltered word */
    clsROPERAND_InitializeUsingIOperand(&bitsROperands[3], &intermIOperands[27]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &reducedIOperand,
                &bitsROperands[3]);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext6);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext6);

    if (gcmIS_ERROR(status)) return status;




    /* get the region */
    clsIOPERAND_New(Compiler, &regionIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &regionIOperand,
                                &reducedROperand,
                                &twentyNineIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* clean the reducedROperand */
    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &reducedIOperand,
                                &reducedROperand,
                                &twoIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* and region with 0x01 */
    clsIOPERAND_New(Compiler, &compareThreeIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&regionROperand, &regionIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &compareThreeIOperands[0],
                                &regionROperand,
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;




    clsIOPERAND_New(Compiler, &leadZeroIOperand[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareThreeROperands[0], &compareThreeIOperands[0]);
    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region & 0x01 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext7,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &compareThreeROperands[0],
                                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* not the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_NOT_BITWISE,
                &leadZeroIOperand[0],
                &reducedROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext7,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &leadZeroIOperand[0],
                &reducedROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext7);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext7);

    if (gcmIS_ERROR(status)) return status;




    /* grab leading zero */
    clsIOPERAND_New(Compiler, &leadZeroIOperand[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&leadZeroROperand[0], &leadZeroIOperand[0]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LEADZERO,
                &leadZeroIOperand[1],
                &leadZeroROperand[0]);

    if (gcmIS_ERROR(status)) return status;



    /* add eleven to leading zero */
    clsIOPERAND_New(Compiler, &intermIOperands[28], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &leadZeroIOperand[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[28],
                                &intermROperands[16],
                                &elevenIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add exponent to result */
    clsIOPERAND_New(Compiler, &intermIOperands[29], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[28]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[29],
                                &intermROperands[17],
                                &intermROperands[14]);

    if (gcmIS_ERROR(status)) return status;









    /* shift 11 + exponent + leading zero position by 5 bits (i.e. divide by 32), gets word index */
    clsIOPERAND_New(Compiler, &wordStartThreeIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[29]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &wordStartThreeIOperand,
                                &intermROperands[18],
                                &fiveIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mod 11 + exponent + leading zero position by 32, gets bit position */
    clsIOPERAND_New(Compiler, &bitStartThreeIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[29]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &bitStartThreeIOperand,
                                &intermROperands[18],
                                &thirtyOneHexROperand);

    if (gcmIS_ERROR(status)) return status;




    clsROPERAND_InitializeUsingIOperand(&reducedROperand, &reducedIOperand);

    /* get index */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regThreeROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegThreeIndex = wordStartThreeIOperand.tempRegIndex;
    regThreeROperand.arrayIndex.mode = clvINDEX_REG;
    regThreeROperand.arrayIndex.u.indexRegIndex = wordRegThreeIndex;



    /* shift the target word of the six segments */
    clsIOPERAND_New(Compiler, &intermIOperands[30], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartThreeROperand, &bitStartThreeIOperand);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[30],
                                &regThreeROperand,
                                &bitStartThreeROperand);

    if (gcmIS_ERROR(status)) return status;




    /* used to hold the final word value */
    clsIOPERAND_New(Compiler, &finalIOperand, clmGenCodeDataType(T_UINT));


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: startBits > 0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext8,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &bitStartThreeROperand,
                                                &zeroIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for startBits > 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* sub from 32 start bits */
    clsIOPERAND_New(Compiler, &bitsTwoIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitStartThreeROperand, &bitStartThreeIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &bitsTwoIOperands[0],
                                &thirtyTwoIntROperand,
                                &bitStartThreeROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add one to target reg, denoting the next word */
    clsIOPERAND_New(Compiler, &wordStartFourIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[0], &wordStartThreeIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &wordStartFourIOperand,
                                &bitsTwoROperands[0],
                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift the next word of the six segments */
    clsROPERAND_InitializeTempReg(Compiler,
                                  &regFourROperand,
                                  clvQUALIFIER_NONE,
                                  clmGenCodeDataType(T_UINT),
                                  tempRegIndex);

    wordRegFourIndex = wordStartFourIOperand.tempRegIndex;
    regFourROperand.arrayIndex.mode = clvINDEX_REG;
    regFourROperand.arrayIndex.u.indexRegIndex = wordRegFourIndex;

    clsIOPERAND_New(Compiler, &bitsTwoIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[1], &bitsTwoIOperands[0]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &bitsTwoIOperands[1],
                                &regFourROperand,
                                &bitsTwoROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* get enough bits from next word for 32 bit precision */
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[3], &intermIOperands[30]);
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[2], &bitsTwoIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &finalIOperand,
                                &bitsTwoROperands[3],
                                &bitsTwoROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext8,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part where startBits = 0, so nothing is done besides assigning */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* assign the unaltered word */
    clsROPERAND_InitializeUsingIOperand(&bitsTwoROperands[3], &intermIOperands[30]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &finalIOperand,
                &bitsTwoROperands[3]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext8);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext8);

    if (gcmIS_ERROR(status)) return status;




    clsIOPERAND_New(Compiler, &leadZeroTwoIOperand[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&compareThreeROperands[0], &compareThreeIOperands[0]);
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region & 0x01 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext9,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &compareThreeROperands[0],
                                                &oneIntROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* xor the word */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_XOR_BITWISE,
                &finalIOperand,
                &finalROperand,
                &fullHexROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext9,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* assign the word */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &finalIOperand,
                &finalROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext9);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext9);

    if (gcmIS_ERROR(status)) return status;




    /* and with 0xffff0000 */
    clsIOPERAND_New(Compiler, &compareFourIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &compareFourIOperands[0],
                                &finalROperand,
                                &maskThreeROperand);

    if (gcmIS_ERROR(status)) return status;









    /* rounding starts */
    clsROPERAND_InitializeUsingIOperand(&finalROperand, &finalIOperand);
    clsROPERAND_InitializeUsingIOperand(&compareFourROperands[0], &compareFourIOperands[0]);

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: region & 0x01 = 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext10,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_NOT_EQUAL,
                                                &compareFourROperands[0],
                                                &maskThreeROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* add the word with rounding */
    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &finalIOperand,
                                &finalROperand,
                                &roundingROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext10,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* do nothing */

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext10);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext10);

    if (gcmIS_ERROR(status)) return status;









    /* convert the int to a float */
    clsIOPERAND_New(Compiler, &intermIOperands[31], clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_UINT_TO_FLOAT,
                &intermIOperands[31],
                &finalROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift 32 by 23 */
    clsIOPERAND_New(Compiler, &intermIOperands[32], clmGenCodeDataType(T_UINT));

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[32],
                &thirtyTwoIntROperand,
                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    /* subtract from the word the above result */
    clsIOPERAND_New(Compiler, &intermIOperands[33], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[32]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[31]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[33],
                                &intermROperands[19],
                                &intermROperands[20]);

    if (gcmIS_ERROR(status)) return status;

    /* shift 32 by 23 */
    clsIOPERAND_New(Compiler, &intermIOperands[34], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &leadZeroIOperand[1]);

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[34],
                &intermROperands[16],
                &twentyThreeShortROperand);

    if (gcmIS_ERROR(status)) return status;

    /* subtract from the word the above result */
    clsIOPERAND_New(Compiler, &intermIOperands[35], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[33], &intermIOperands[33]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[34], &intermIOperands[34]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[35],
                                &intermROperands[33],
                                &intermROperands[34]);

    if (gcmIS_ERROR(status)) return status;

    if (gcmIS_ERROR(status)) return status;

    {
        float tanCoef[] ={
                            1.5707965f,
                            1.2919173f,
                            1.2757556f,
                            1.2580330f,
                            1.4384425f,
                            0.39402980f,
                            3.3960443f};
        for(i = 0; i<7; i++){
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&intermROperands[i],
                              clmGenCodeDataType(T_FLOAT),
                              tanCoef[i]);
            clsIOPERAND_New(Compiler, &intermIOperands[10+i], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[10+i], &intermIOperands[10+i]);
        }
        clsROPERAND_InitializeUsingIOperand(&intermROperands[35], &intermIOperands[35]);
        intermROperands[35].dataType.elementType = clvTYPE_FLOAT;

        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[10],
                &intermROperands[35],
                &intermROperands[35]);

        for(i = 6; i>=0; i--){
            if(i == 6){
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &intermIOperands[12],
                            &intermROperands[i]);
            }
            else{
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[12],
                        &intermROperands[11],
                        &intermROperands[i]);
            }
            if(i > 0)
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[11],
                        &intermROperands[12],
                        &intermROperands[10]);
        }

        /*Now r10 is the |tan(x)| or 1/|tan(x)| */
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[10],
                &intermROperands[12],
                &intermROperands[35]);

    }
    {
        /* ((Region + 1)& 0x03)>1? reciprocal:normal */
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &compareThreeIOperands[0],
                &regionROperand,
                &oneIntROperand);

        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &compareThreeIOperands[0],
                                &compareThreeROperands[0],
                                &threeIntROperand);

        clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &compareThreeROperands[0],
                 clvCONDITION_GREATER_THAN,
                 &oneIntROperand);

        /*region = 1, 2, 5, 6, calculate reciprocal */
        intermROperands[10].dataType.elementType = clvTYPE_FLOAT;
        status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_INVERSE,
                        &intermIOperands[11],
                        &intermROperands[10]);

        /*N-R iteration, not exceptional case, 0, very small values are excluded */
        status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[12],
                                            &intermROperands[10],
                                            &intermROperands[11]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[13],
                                        &oneROperand,
                                        &intermROperands[12]);

        /*go further, N-R, more accuracy */
        status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MULLO_RTZ,
                                            &intermIOperands[12],
                                            &intermROperands[10],
                                            &intermROperands[11]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[13],
                                        &intermROperands[13],
                                        &intermROperands[12]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[12],
                                        &intermROperands[13],
                                        &intermROperands[11]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[10],
                                        &intermROperands[11],
                                        &intermROperands[12]);

        clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

        /*else, do nothing for region 0, 3, 4, 7 */

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

    }
    {
        clsROPERAND thirtyROperand, signROperand;
        clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x80000000);
        clsROPERAND_InitializeIntOrIVecConstant(&thirtyROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 30);

        /*Add the sign */
        status = clGenShiftExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_LSHIFT,
                    &intermIOperands[34],
                    &regionROperand,
                    &thirtyROperand);

        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &intermIOperands[35],
                                &intermROperands[34],
                                &signROperand);
        /*Get the original input sign */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &intermIOperands[34],
                                &OperandsParameters[0].rOperands[0],
                                &signROperand);

        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_XOR_BITWISE,
                                &intermIOperands[33],
                                &intermROperands[34],
                                &intermROperands[35]);


        /* add the sign bit */
        IOperand->dataType.elementType = clvTYPE_INT;
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    IOperand,
                    &intermROperands[33],
                    &intermROperands[10]);
        IOperand->dataType.elementType = clvTYPE_FLOAT;

        if (gcmIS_ERROR(status)) return status;


    }

   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);
OnError:
   return status;
}

static gceSTATUS
_GenNativeTanCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(Compiler,
                               PolynaryExpr->exprBase.base.lineNo,
                               PolynaryExpr->exprBase.base.stringNo,
                               clvOPCODE_TAN,
                               IOperand,
                               &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenAsinCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsLOPERAND firstLOperand[1], secondLOperand[1], thirdLOperand[1];
    clsROPERAND zeroROperand, firstROperand, oneNegativeROperand, oneROperand, twoROperand, piHalvedROperand;
    clsIOPERAND intermIOperands[32];
    clsROPERAND intermROperands[32];
    clsIOPERAND switchIOperand[1], switchTwoIOperand[1];
    clsROPERAND switchROperand[1], switchTwoROperand[1];
    clsIOPERAND conditionIOperand;
    clsROPERAND conditionROperand;
    clsROPERAND unsignROperand;

    clsSELECTION_CONTEXT    selectionContext1,  selectionContext3, selectionContext4, selectionContext5;
    clsROPERAND        firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand, fifthCoefROperand, sixthCoefROperand,
                    seventhCoefROperand;
    clsROPERAND        firstACosCoefROperand, secondACosCoefROperand, thirdACosCoefROperand, fourthACosCoefROperand, fifthACosCoefROperand;

    clsIOPERAND_New(Compiler, switchIOperand, clmGenCodeDataType(T_FLOAT));
    clsLOPERAND_InitializeUsingIOperand(firstLOperand, switchIOperand);

    clsIOPERAND_New(Compiler, switchTwoIOperand, clmGenCodeDataType(T_FLOAT));
    clsLOPERAND_InitializeUsingIOperand(secondLOperand, switchTwoIOperand);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.7072);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneNegativeROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) -1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_halved);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x7fffffff);




    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);


    clsIOPERAND_New(Compiler, &conditionIOperand, clmGenCodeDataType(T_INT));

    /*Get the Abs(x) */
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &conditionIOperand,
                    &unsignROperand,
                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    clsROPERAND_InitializeUsingIOperand(&conditionROperand, &conditionIOperand);


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: |x| > 1.0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &conditionROperand,
                                                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for |x|>1.0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /*Put Nan to the output, x*Nan = Nan */
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &OperandsParameters[0].rOperands[0],
                    &unsignROperand);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectionContext1,
                                        gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part, |x| < 1.0, normal cases */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;



                    status = clDefineSelectionBegin(Compiler,
                                                    CodeGenerator,
                                                    gcvTRUE,
                                                    &selectionContext3);

                    if (gcmIS_ERROR(status)) return status;





                    /* The condition part: |x| <= 0.7072 */
                    status = clGenSelectionCompareConditionCode(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext3,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                clvCONDITION_LESS_THAN_EQUAL,
                                                                &conditionROperand,
                                                                &firstROperand);

                    if (gcmIS_ERROR(status)) return status;

                    /* The true part for |x| <= 0.7072 */
                    status = clDefineSelectionTrueOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectionContext3);

                    if (gcmIS_ERROR(status)) return status;




                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&seventhCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.166669055227682020000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&sixthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.074884865445453627000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT) 0.046501967569552383000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.016390794631294996000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.076968205635099332000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.092613976768263495000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.111313961106833540000000);

                    /* mul from x, x */
                    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0],
                                    &OperandsParameters[0].rOperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, coefficient1 */
                    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[1],
                                                    &firstCoefROperand,
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient2 */
                    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[2],
                                    &secondCoefROperand,
                                    &intermROperands[1]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[3],
                                                    &intermROperands[2],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient3 */
                    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[4],
                                    &thirdCoefROperand,
                                    &intermROperands[3]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[5],
                                                    &intermROperands[4],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient4 */
                    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[6],
                                    &fourthCoefROperand,
                                    &intermROperands[5]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[7],
                                                    &intermROperands[6],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient5 */
                    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[8],
                                    &fifthCoefROperand,
                                    &intermROperands[7]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[9],
                                                    &intermROperands[8],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient6 */
                    clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[10],
                                    &sixthCoefROperand,
                                    &intermROperands[9]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[11],
                                                    &intermROperands[10],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient7 */
                    clsIOPERAND_New(Compiler, &intermIOperands[12], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[12],
                                    &seventhCoefROperand,
                                    &intermROperands[11]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[12], &intermIOperands[12]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[13],
                                                    &intermROperands[12],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add 1.0 to result */
                    clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[13]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[14],
                                    &intermROperands[13],
                                    &oneROperand);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul aSin(x)/x by x */
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    IOperand,
                                                    &OperandsParameters[0].rOperands[0],
                                                    &intermROperands[14]);

                    if (gcmIS_ERROR(status)) return status;


                    status = clDefineSelectionTrueOperandEnd(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            CodeGenerator,
                                                            &selectionContext3,
                                                            gcvFALSE);

                    if (gcmIS_ERROR(status)) return status;


                    /* The false part, |x| > 0.7072 */
                    status = clDefineSelectionFalseOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectionContext3);

                    if (gcmIS_ERROR(status)) return status;


                            /* The selection begins for |x| > 0.7072 */
                            status = clDefineSelectionBegin(Compiler,
                                                            CodeGenerator,
                                                            gcvTRUE,
                                                            &selectionContext4);

                            if (gcmIS_ERROR(status)) return status;

                            /* The condition part: x >= 0 */
                            status = clGenSelectionCompareConditionCode(Compiler,
                                                                        CodeGenerator,
                                                                        &selectionContext4,
                                                                        PolynaryExpr->exprBase.base.lineNo,
                                                                        PolynaryExpr->exprBase.base.stringNo,
                                                                        clvCONDITION_GREATER_THAN_EQUAL,
                                                                        &OperandsParameters[0].rOperands[0],
                                                                        &zeroROperand);

                            if (gcmIS_ERROR(status)) return status;

                            /* The true part for x >= 0 */
                            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext4);

                            if (gcmIS_ERROR(status)) return status;

                            /* assign x */
                            status = clGenAssignCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        firstLOperand,
                                        &OperandsParameters[0].rOperands[0]);

                            if (gcmIS_ERROR(status)) return status;

                            /* assign 1 */
                            status = clGenAssignCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        secondLOperand,
                                        &oneROperand);

                            if (gcmIS_ERROR(status)) return status;

                            status = clDefineSelectionTrueOperandEnd(Compiler,
                                                                    PolynaryExpr->exprBase.base.lineNo,
                                                                    PolynaryExpr->exprBase.base.stringNo,
                                                                    CodeGenerator,
                                                                    &selectionContext4,
                                                                    gcvFALSE);

                            if (gcmIS_ERROR(status)) return status;

                            /* The false part, x < 0 */
                            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext4);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul -1, x */
                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &switchIOperand[0],
                                                            &oneNegativeROperand,
                                                            &OperandsParameters[0].rOperands[0]);

                            if (gcmIS_ERROR(status)) return status;


                            /* assign -1 */
                            status = clGenAssignCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        secondLOperand,
                                        &oneNegativeROperand);

                            if (gcmIS_ERROR(status)) return status;


                            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext4);

                            if (gcmIS_ERROR(status)) return status;

                            /* The selection end */
                            status = clDefineSelectionEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext4);

                            if (gcmIS_ERROR(status)) return status;


                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthACosCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)1.4142137);
                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthACosCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.117850143753963380000000);
                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdACosCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.026542822144637060000000);
                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondACosCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.007648878368471626900000);
                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstACosCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.003572592606608010700000);


                            /* sub 1, x */
                            clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&switchROperand[0], &switchIOperand[0]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_SUB_RTZ,
                                                            &intermIOperands[15],
                                                            &oneROperand,
                                                            &switchROperand[0]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul result, coefficient1 */
                            clsIOPERAND_New(Compiler, &intermIOperands[16], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);


                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[16],
                                                            &firstACosCoefROperand,
                                                            &intermROperands[15]);

                            if (gcmIS_ERROR(status)) return status;

                            /* add to result, coefficient2 */
                            clsIOPERAND_New(Compiler, &intermIOperands[17], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[17],
                                            &secondACosCoefROperand,
                                            &intermROperands[16]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul result, previous result */
                            clsIOPERAND_New(Compiler, &intermIOperands[18], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[17]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[18],
                                                            &intermROperands[17],
                                                            &intermROperands[15]);

                            if (gcmIS_ERROR(status)) return status;

                            /* add to result, coefficient3 */
                            clsIOPERAND_New(Compiler, &intermIOperands[19], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[18]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[19],
                                            &thirdACosCoefROperand,
                                            &intermROperands[18]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul result, previous result */
                            clsIOPERAND_New(Compiler, &intermIOperands[20], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[19]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[20],
                                                            &intermROperands[19],
                                                            &intermROperands[15]);

                            if (gcmIS_ERROR(status)) return status;

                            /* add to result, coefficient4 */
                            clsIOPERAND_New(Compiler, &intermIOperands[21], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[20]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[21],
                                            &fourthACosCoefROperand,
                                            &intermROperands[20]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul result, previous result */
                            clsIOPERAND_New(Compiler, &intermIOperands[22], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[21], &intermIOperands[21]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[22],
                                                            &intermROperands[21],
                                                            &intermROperands[15]);

                            if (gcmIS_ERROR(status)) return status;

                            /* add to result, coefficient5 */
                            clsIOPERAND_New(Compiler, &intermIOperands[23], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[22], &intermIOperands[22]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[23],
                                            &fifthACosCoefROperand,
                                            &intermROperands[22]);

                            if (gcmIS_ERROR(status)) return status;

                            /* The selection begins for 1-x */
                            status = clDefineSelectionBegin(Compiler,
                                                            CodeGenerator,
                                                            gcvTRUE,
                                                            &selectionContext5);

                            if (gcmIS_ERROR(status)) return status;

                            clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);

                            /* The condition part: 1-x */
                            status = clGenSelectionCompareConditionCode(Compiler,
                                                                        CodeGenerator,
                                                                        &selectionContext5,
                                                                        PolynaryExpr->exprBase.base.lineNo,
                                                                        PolynaryExpr->exprBase.base.stringNo,
                                                                        clvCONDITION_NOT_EQUAL,
                                                                        &intermROperands[15],
                                                                        &zeroROperand);

                            if (gcmIS_ERROR(status)) return status;

                            /* both conditions will use this register for the final value */
                            clsIOPERAND_New(Compiler, &intermIOperands[29], clmGenCodeDataType(T_FLOAT));

                            /* The true part for 1-x != 0 */
                            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext5);

                            if (gcmIS_ERROR(status)) return status;

                            /* sqrt for (1-x) */
                            clsIOPERAND_New(Compiler, &intermIOperands[24], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);

                            status = clGenGenericCode1(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_SQRT,
                                                    &intermIOperands[24],
                                                    &intermROperands[15]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul sqrt(x-1), sqrt(1-x) */
                            clsIOPERAND_New(Compiler, &intermIOperands[25], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[23], &intermIOperands[24]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[25],
                                                            &intermROperands[23],
                                                            &intermROperands[23]);

                            if (gcmIS_ERROR(status)) return status;

                            /* sub from result, 1-x */
                            clsIOPERAND_New(Compiler, &intermIOperands[26], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[25]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_SUB_RTZ,
                                            &intermIOperands[26],
                                            &intermROperands[24],
                                            &intermROperands[15]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul sqrt(1-x), 2.0 */
                            clsIOPERAND_New(Compiler, &intermIOperands[27], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[23], &intermIOperands[24]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[27],
                                                            &intermROperands[23],
                                                            &twoROperand);

                            if (gcmIS_ERROR(status)) return status;

                            /* div top previous result from bottom result */
                            clsIOPERAND_New(Compiler, &intermIOperands[28], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[27]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[26]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_DIV,
                                                            &intermIOperands[28],
                                                            &intermROperands[25],
                                                            &intermROperands[26]);

                            if (gcmIS_ERROR(status)) return status;

                            /* sub from sqrt(1-x) the result */
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[27], &intermIOperands[28]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[23], &intermIOperands[24]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_SUB_RTZ,
                                            &intermIOperands[29],
                                            &intermROperands[23],
                                            &intermROperands[27]);

                            if (gcmIS_ERROR(status)) return status;

                            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext5,
                                            gcvFALSE);

                            if (gcmIS_ERROR(status)) return status;

                            /* The false part, 1-x = 0 */
                            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext5);

                            if (gcmIS_ERROR(status)) return status;

                            clsLOPERAND_InitializeUsingIOperand(thirdLOperand, &intermIOperands[29]);

                            /* assign 0 */
                            status = clGenAssignCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        thirdLOperand,
                                        &zeroROperand);

                            if (gcmIS_ERROR(status)) return status;

                            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext5);

                            if (gcmIS_ERROR(status)) return status;

                            /* The selection end */
                            status = clDefineSelectionEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext5);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul aCos(x)/sqrt(1-x) by Newton Raphson sqrt(1-x) */
                            clsIOPERAND_New(Compiler, &intermIOperands[30], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[29], &intermIOperands[23]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[28], &intermIOperands[29]);

                            clsIOPERAND_New(Compiler, &intermIOperands[31], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[30], &intermIOperands[30]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[31], &intermIOperands[31]);
                            /*The low part of  aCos(x)/sqrt(1-x), do currect rounding*/
                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MULLO_RTZ,
                                                            &intermIOperands[31],
                                                            &intermROperands[29],
                                                            &intermROperands[28]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[31],
                                                            &intermROperands[31],
                                                            &twoROperand);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[30],
                                                            &intermROperands[29],
                                                            &intermROperands[28]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_ADD_RTZ,
                                                            &intermIOperands[30],
                                                            &intermROperands[31],
                                                            &intermROperands[30]);

                            if (gcmIS_ERROR(status)) return status;

                            /* sub pi/2, result */

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_SUB_RTZ,
                                                            &intermIOperands[31],
                                                            &piHalvedROperand,
                                                            &intermROperands[30]);

                            if (gcmIS_ERROR(status)) return status;


                            /* mul (x>0) ? 1:-1 */
                            clsROPERAND_InitializeUsingIOperand(&switchTwoROperand[0], &switchTwoIOperand[0]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            IOperand,
                                                            &intermROperands[31],
                                                            &switchTwoROperand[0]);

                            if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionFalseOperandEnd(Compiler,
                                                            CodeGenerator,
                                                            &selectionContext3);

                    if (gcmIS_ERROR(status)) return status;

                    /* The selection end */
                    status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectionContext3);

                    if (gcmIS_ERROR(status)) return status;



    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext1);

    if (gcmIS_ERROR(status)) return status;



    return gcvSTATUS_OK;

}


static gceSTATUS
_GenNativeAsinCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(Compiler,
                               PolynaryExpr->exprBase.base.lineNo,
                               PolynaryExpr->exprBase.base.stringNo,
                               clvOPCODE_ASIN,
                               IOperand,
                               &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

#define pi_halved                ((float)1.570796326794896619231321691639)
#define pi_constant                ((float)3.141592653589793238462643383279)

static gceSTATUS
_GenAsinPiCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND piRcpROperand;
    clsIOPERAND intermIOperands[1];
    clsROPERAND intermROperands[1];

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piRcpROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_rcpPlus);

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    /*Get aSin(x) */
    _GenAsinCode(
                Compiler,
                CodeGenerator,
                PolynaryExpr,
                OperandCount,
                OperandsParameters,
                &intermIOperands[0]);

    /*Mul 1./Pi */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperands[0],
                                    &piRcpROperand);
    return gcvSTATUS_OK;

}



static gceSTATUS
_GenAcosCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsLOPERAND firstLOperand[1], secondLOperand[1], thirdLOperand[1];
    clsROPERAND zeroROperand, firstROperand, oneNegativeROperand, oneROperand, twoROperand, piHalvedROperand, piROperand, unsignROperand, dot5ROperand;
    clsIOPERAND intermIOperands[34];
    clsROPERAND intermROperands[34];
    clsIOPERAND switchIOperand[1], switchTwoIOperand[1], switchThreeIOperand[1];
    clsROPERAND switchROperand[1], switchTwoROperand[1], switchThreeROperand[1];
    clsIOPERAND conditionIOperand;
    clsROPERAND conditionROperand;

    clsSELECTION_CONTEXT    selectionContext1, selectionContext3, selectionContext4, selectionContext5;
    clsROPERAND        firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand, fifthCoefROperand, sixthCoefROperand,
                    seventhCoefROperand;
    clsROPERAND        firstACosCoefROperand, secondACosCoefROperand, thirdACosCoefROperand, fourthACosCoefROperand, fifthACosCoefROperand;

    clsROPERAND piRcpROperand;
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piRcpROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_rcpPlus);

    clsIOPERAND_New(Compiler, switchIOperand, clmGenCodeDataType(T_FLOAT));
    clsLOPERAND_InitializeUsingIOperand(firstLOperand, switchIOperand);

    clsIOPERAND_New(Compiler, switchTwoIOperand, clmGenCodeDataType(T_FLOAT));
    clsLOPERAND_InitializeUsingIOperand(secondLOperand, switchTwoIOperand);

    clsIOPERAND_New(Compiler, switchThreeIOperand, clmGenCodeDataType(T_FLOAT));
    clsLOPERAND_InitializeUsingIOperand(thirdLOperand, switchThreeIOperand);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&dot5ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.5);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.7072);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneNegativeROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) -1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_halved);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_constant);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x7fffffff);



    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsIOPERAND_New(Compiler, &conditionIOperand, clmGenCodeDataType(T_INT));

    /*Get the Abs(x) */
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &conditionIOperand,
                    &unsignROperand,
                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    clsROPERAND_InitializeUsingIOperand(&conditionROperand, &conditionIOperand);


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: |x| > 1.0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &conditionROperand,
                                                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for |x|>1.0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /*Put Nan to the output, x*Nan = Nan */
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &OperandsParameters[0].rOperands[0],
                    &unsignROperand);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectionContext1,
                                        gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part, |x| < 1.0, normal cases */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;



                    status = clDefineSelectionBegin(Compiler,
                                                    CodeGenerator,
                                                    gcvTRUE,
                                                    &selectionContext3);

                    if (gcmIS_ERROR(status)) return status;



                    /* The condition part: |x| <= 0.7072 */
                    status = clGenSelectionCompareConditionCode(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext3,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                clvCONDITION_LESS_THAN_EQUAL,
                                                                &conditionROperand,
                                                                &firstROperand);

                    if (gcmIS_ERROR(status)) return status;

                    /* The true part for |x| <= 0.7072 */
                    status = clDefineSelectionTrueOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectionContext3);

                    if (gcmIS_ERROR(status)) return status;



                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&seventhCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.166669055227682020000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&sixthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.074884865445453627000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT) 0.046501967569552383000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.016390794631294996000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.076968205635099332000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.092613976768263495000000);
                    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.111313961106833540000000);

                    /* mul from x, x */
                    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0],
                                    &OperandsParameters[0].rOperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, coefficient1 */
                    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[1],
                                                    &firstCoefROperand,
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient2 */
                    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[2],
                                    &secondCoefROperand,
                                    &intermROperands[1]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[3],
                                                    &intermROperands[2],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient3 */
                    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[4],
                                    &thirdCoefROperand,
                                    &intermROperands[3]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[5],
                                                    &intermROperands[4],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient4 */
                    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[6],
                                    &fourthCoefROperand,
                                    &intermROperands[5]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[7],
                                                    &intermROperands[6],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient5 */
                    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[8],
                                    &fifthCoefROperand,
                                    &intermROperands[7]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[9],
                                                    &intermROperands[8],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient6 */
                    clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[10],
                                    &sixthCoefROperand,
                                    &intermROperands[9]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[11],
                                                    &intermROperands[10],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add to result, coefficient7 */
                    clsIOPERAND_New(Compiler, &intermIOperands[12], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[12],
                                    &seventhCoefROperand,
                                    &intermROperands[11]);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul result, previous result */
                    clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[12], &intermIOperands[12]);
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[13],
                                                    &intermROperands[12],
                                                    &intermROperands[0]);

                    if (gcmIS_ERROR(status)) return status;

                    /* add 1.0 to result */
                    clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[13]);

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[14],
                                    &intermROperands[13],
                                    &oneROperand);

                    if (gcmIS_ERROR(status)) return status;

                    /* mul aSin(x)/x by x */
                    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_FLOAT));
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                    status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_MUL_RTZ,
                                                    &intermIOperands[15],
                                                    &OperandsParameters[0].rOperands[0],
                                                    &intermROperands[14]);

                    if (gcmIS_ERROR(status)) return status;

                    /* sub pi/2, result */
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);
                    if(PolynaryExpr->funcName->symbol[4] == 'p'){/*acospi */
                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[14],
                                                            &intermROperands[15],
                                                            &piRcpROperand);

                            status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_SUB_RTZ,
                                                    IOperand,
                                                    &dot5ROperand,
                                                    &intermROperands[14]);

                    }
                    else
                        status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_SUB_RTZ,
                                                    IOperand,
                                                    &piHalvedROperand,
                                                    &intermROperands[15]);

                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionTrueOperandEnd(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            CodeGenerator,
                                                            &selectionContext3,
                                                            gcvFALSE);

                    if (gcmIS_ERROR(status)) return status;


                    /* The false part, |x| > 0.7072 */
                    status = clDefineSelectionFalseOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectionContext3);

                    if (gcmIS_ERROR(status)) return status;

                            /* The selection begins for |x| > 0.7072 */
                            status = clDefineSelectionBegin(Compiler,
                                                            CodeGenerator,
                                                            gcvTRUE,
                                                            &selectionContext4);

                            if (gcmIS_ERROR(status)) return status;

                            /* The condition part: x < 0 */
                            status = clGenSelectionCompareConditionCode(Compiler,
                                                                        CodeGenerator,
                                                                        &selectionContext4,
                                                                        PolynaryExpr->exprBase.base.lineNo,
                                                                        PolynaryExpr->exprBase.base.stringNo,
                                                                        clvCONDITION_LESS_THAN_EQUAL,
                                                                        &OperandsParameters[0].rOperands[0],
                                                                        &zeroROperand);

                            if (gcmIS_ERROR(status)) return status;

                            /* The true part for x < 0 */
                            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext4);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul -1, x */
                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &switchIOperand[0],
                                                            &oneNegativeROperand,
                                                            &OperandsParameters[0].rOperands[0]);

                            if (gcmIS_ERROR(status)) return status;

                            /* assign -1 */
                            status = clGenAssignCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        secondLOperand,
                                        &oneNegativeROperand);

                            if (gcmIS_ERROR(status)) return status;

                            /* assign pi */
                            status = clGenAssignCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        thirdLOperand,
                                        PolynaryExpr->funcName->symbol[4] != 'p'?
                                        &piROperand : &oneROperand);

                            if (gcmIS_ERROR(status)) return status;

                            status = clDefineSelectionTrueOperandEnd(Compiler,
                                                                    PolynaryExpr->exprBase.base.lineNo,
                                                                    PolynaryExpr->exprBase.base.stringNo,
                                                                    CodeGenerator,
                                                                    &selectionContext4,
                                                                    gcvFALSE);

                            if (gcmIS_ERROR(status)) return status;

                            /* The false part, x >= 0 */
                            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext4);

                            if (gcmIS_ERROR(status)) return status;

                            /* assign x */
                            status = clGenAssignCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        firstLOperand,
                                        &OperandsParameters[0].rOperands[0]);

                            if (gcmIS_ERROR(status)) return status;

                            /* assign 1 */
                            status = clGenAssignCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        secondLOperand,
                                        &oneROperand);

                            if (gcmIS_ERROR(status)) return status;

                            /* assign 0 */
                            status = clGenAssignCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        thirdLOperand,
                                        &zeroROperand);

                            if (gcmIS_ERROR(status)) return status;

                            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext4);

                            if (gcmIS_ERROR(status)) return status;

                            /* The selection end */
                            status = clDefineSelectionEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext4);

                            if (gcmIS_ERROR(status)) return status;

                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthACosCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)1.4142137);
                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthACosCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.117850143753963380000000);
                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdACosCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.026542822144637060000000);
                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondACosCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.007648878368471626900000);
                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstACosCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.003572592606608010700000);


                            /* sub 1, x */
                            clsIOPERAND_New(Compiler, &intermIOperands[16], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&switchROperand[0], &switchIOperand[0]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_SUB_RTZ,
                                                            &intermIOperands[16],
                                                            &oneROperand,
                                                            &switchROperand[0]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul result, coefficient1 */
                            clsIOPERAND_New(Compiler, &intermIOperands[17], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[17],
                                                            &firstACosCoefROperand,
                                                            &intermROperands[16]);

                            if (gcmIS_ERROR(status)) return status;

                            /* add to result, coefficient2 */
                            clsIOPERAND_New(Compiler, &intermIOperands[18], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[17]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[18],
                                            &secondACosCoefROperand,
                                            &intermROperands[17]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul result, previous result */
                            clsIOPERAND_New(Compiler, &intermIOperands[19], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[18]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[19],
                                                            &intermROperands[18],
                                                            &intermROperands[16]);

                            if (gcmIS_ERROR(status)) return status;

                            /* add to result, coefficient3 */
                            clsIOPERAND_New(Compiler, &intermIOperands[20], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[19]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[20],
                                            &thirdACosCoefROperand,
                                            &intermROperands[19]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul result, previous result */
                            clsIOPERAND_New(Compiler, &intermIOperands[21], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[20]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[21],
                                                            &intermROperands[20],
                                                            &intermROperands[16]);

                            if (gcmIS_ERROR(status)) return status;

                            /* add to result, coefficient4 */
                            clsIOPERAND_New(Compiler, &intermIOperands[22], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[21], &intermIOperands[21]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[22],
                                            &fourthACosCoefROperand,
                                            &intermROperands[21]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul result, previous result */
                            clsIOPERAND_New(Compiler, &intermIOperands[23], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[22], &intermIOperands[22]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[23],
                                                            &intermROperands[22],
                                                            &intermROperands[16]);

                            if (gcmIS_ERROR(status)) return status;

                            /* add to result, coefficient5 */
                            clsIOPERAND_New(Compiler, &intermIOperands[24], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[23], &intermIOperands[23]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[24],
                                            &fifthACosCoefROperand,
                                            &intermROperands[23]);

                            if (gcmIS_ERROR(status)) return status;

                            /* The selection begins for 1-x */
                            status = clDefineSelectionBegin(Compiler,
                                                            CodeGenerator,
                                                            gcvTRUE,
                                                            &selectionContext5);

                            if (gcmIS_ERROR(status)) return status;

                            clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);

                            /* The condition part: 1-x */
                            status = clGenSelectionCompareConditionCode(Compiler,
                                                                        CodeGenerator,
                                                                        &selectionContext5,
                                                                        PolynaryExpr->exprBase.base.lineNo,
                                                                        PolynaryExpr->exprBase.base.stringNo,
                                                                        clvCONDITION_NOT_EQUAL,
                                                                        &intermROperands[16],
                                                                        &zeroROperand);

                            if (gcmIS_ERROR(status)) return status;

                            /* both conditions will use this register for the final value */
                            clsIOPERAND_New(Compiler, &intermIOperands[29], clmGenCodeDataType(T_FLOAT));

                            /* The true part for 1-x != 0 */
                            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext5);

                            if (gcmIS_ERROR(status)) return status;

                            /* sqrt for (1-x) */
                            clsIOPERAND_New(Compiler, &intermIOperands[25], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);

                            status = clGenGenericCode1(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_SQRT,
                                                    &intermIOperands[25],
                                                    &intermROperands[16]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul sqrt(x-1), sqrt(1-x) */
                            clsIOPERAND_New(Compiler, &intermIOperands[26], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[25]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[26],
                                                            &intermROperands[24],
                                                            &intermROperands[24]);

                            if (gcmIS_ERROR(status)) return status;

                            /* sub from result, 1-x */
                            clsIOPERAND_New(Compiler, &intermIOperands[27], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[26]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);

                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_SUB_RTZ,
                                            &intermIOperands[27],
                                            &intermROperands[25],
                                            &intermROperands[16]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul sqrt(1-x), 2.0 */
                            clsIOPERAND_New(Compiler, &intermIOperands[28], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[25]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[28],
                                                            &intermROperands[24],
                                                            &twoROperand);

                            if (gcmIS_ERROR(status)) return status;

                            /* div top previous result from bottom result */
                            clsIOPERAND_New(Compiler, &intermIOperands[29], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[27], &intermIOperands[28]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[27]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_DIV,
                                                            &intermIOperands[29],
                                                            &intermROperands[26],
                                                            &intermROperands[27]);

                            if (gcmIS_ERROR(status)) return status;

                            /* sub from sqrt(1-x) the result */
                            clsIOPERAND_New(Compiler, &intermIOperands[30], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[28], &intermIOperands[29]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[25]);


                            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_SUB_RTZ,
                                            &intermIOperands[30],
                                            &intermROperands[24],
                                            &intermROperands[28]);

                            if (gcmIS_ERROR(status)) return status;

                            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext5,
                                            gcvFALSE);

                            if (gcmIS_ERROR(status)) return status;

                            /* The false part, 1-x = 0 */
                            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext5);

                            if (gcmIS_ERROR(status)) return status;

                            clsLOPERAND_InitializeUsingIOperand(thirdLOperand, &intermIOperands[30]);

                            /* assign 0 */
                            status = clGenAssignCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        thirdLOperand,
                                        &zeroROperand);

                            if (gcmIS_ERROR(status)) return status;

                            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext5);

                            if (gcmIS_ERROR(status)) return status;

                            /* The selection end */
                            status = clDefineSelectionEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext5);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul aCos(x)/sqrt(1-x) by Newton Raphson sqrt(1-x) */
                            clsIOPERAND_New(Compiler, &intermIOperands[31], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[31], &intermIOperands[31]);

                            clsIOPERAND_New(Compiler, &intermIOperands[32], clmGenCodeDataType(T_FLOAT));
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[32], &intermIOperands[32]);

                            clsROPERAND_InitializeUsingIOperand(&intermROperands[30], &intermIOperands[24]);
                            clsROPERAND_InitializeUsingIOperand(&intermROperands[29], &intermIOperands[30]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[31],
                                                            &intermROperands[30],
                                                            &intermROperands[29]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MULLO_RTZ,
                                                            &intermIOperands[32],
                                                            &intermROperands[30],
                                                            &intermROperands[29]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[32],
                                                            &intermROperands[32],
                                                            &twoROperand);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_ADD_RTZ,
                                                            &intermIOperands[31],
                                                            &intermROperands[32],
                                                            &intermROperands[31]);

                            if (gcmIS_ERROR(status)) return status;

                            /* mul (x>0) ? 1:-1 */
                            clsROPERAND_InitializeUsingIOperand(&switchTwoROperand[0], &switchTwoIOperand[0]);

                            status = clGenArithmeticExprCode(Compiler,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvOPCODE_MUL_RTZ,
                                                            &intermIOperands[32],
                                                            &intermROperands[31],
                                                            &switchTwoROperand[0]);

                            if (gcmIS_ERROR(status)) return status;

                            /* add (x>0) ? 0:pi */
                            clsROPERAND_InitializeUsingIOperand(&switchThreeROperand[0], &switchThreeIOperand[0]);
                            if(PolynaryExpr->funcName->symbol[4] == 'p'){/*acospi */
                                    status = clGenArithmeticExprCode(Compiler,
                                                                    PolynaryExpr->exprBase.base.lineNo,
                                                                    PolynaryExpr->exprBase.base.stringNo,
                                                                    clvOPCODE_MUL_RTZ,
                                                                    &intermIOperands[32],
                                                                    &intermROperands[32],
                                                                    &piRcpROperand);
                            }

                            status = clGenArithmeticExprCode(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvOPCODE_ADD_RTZ,
                                                    IOperand,
                                                    &intermROperands[32],
                                                    &switchThreeROperand[0]);

                            if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionFalseOperandEnd(Compiler,
                                                            CodeGenerator,
                                                            &selectionContext3);

                    if (gcmIS_ERROR(status)) return status;

                    /* The selection end */
                    status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectionContext3);

                    if (gcmIS_ERROR(status)) return status;



    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext1);

    if (gcmIS_ERROR(status)) return status;





    return gcvSTATUS_OK;

}

static gceSTATUS
_GenNativeAcosCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS   status;

    gcmHEADER();

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(Compiler,
                               PolynaryExpr->exprBase.base.lineNo,
                               PolynaryExpr->exprBase.base.stringNo,
                               clvOPCODE_ACOS,
                               IOperand,
                               &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}


#define pi_halved                ((float)1.570796326794896619231321691639)
#define pi_constant                ((float)3.141592653589793238462643383279)
#define pi_rcp                    ((float)0.318309886183790671537767526745)


static gceSTATUS
_GenAcosPiCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND piRcpROperand;
    clsIOPERAND intermIOperands[1];
    clsROPERAND intermROperands[1];

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piRcpROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_rcpPlus);

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    /*Get aCos(x) */
    status = _GenAcosCode(
                Compiler,
                CodeGenerator,
                PolynaryExpr,
                OperandCount,
                OperandsParameters,
                IOperand);

    return gcvSTATUS_OK;

}

#define pi_halved                ((float)1.570796326794896619231321691639)

static gceSTATUS
_GenAtanCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsLOPERAND firstLOperand[1], secondLOperand[1], thirdLOperand[1], fourthLOperand[1];
    clsROPERAND zeroROperand, oneNegativeROperand, oneROperand, twoROperand, piHalvedROperand;
    clsIOPERAND intermIOperands[34];
    clsROPERAND intermROperands[34];
    clsIOPERAND switchAddIOperand[1], switchMultIOperand[1], switchMultTwoIOperand[1], switchIOperand[1], switchIntermIOperand[1];
    clsROPERAND switchAddROperand[1], switchMultROperand[1], switchMultTwoROperand[1], switchROperand[1], switchIntermROperand[1];
    clsIOPERAND conditionIOperand;
    clsROPERAND conditionROperand;



    clsSELECTION_CONTEXT    selectionContext1, selectionContext2, selectionContext3;
    clsROPERAND        firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand, fifthCoefROperand, sixthCoefROperand,
                    seventhCoefROperand, eighthCoefROperand;

    clsIOPERAND_New(Compiler, switchIOperand, clmGenCodeDataType(T_FLOAT));
    clsLOPERAND_InitializeUsingIOperand(firstLOperand, switchIOperand);

    clsIOPERAND_New(Compiler, switchAddIOperand, clmGenCodeDataType(T_FLOAT));
    clsLOPERAND_InitializeUsingIOperand(secondLOperand, switchAddIOperand);

    clsIOPERAND_New(Compiler, switchMultIOperand, clmGenCodeDataType(T_FLOAT));
    clsLOPERAND_InitializeUsingIOperand(thirdLOperand, switchMultIOperand);

    clsIOPERAND_New(Compiler, switchMultTwoIOperand, clmGenCodeDataType(T_FLOAT));
    clsLOPERAND_InitializeUsingIOperand(fourthLOperand, switchMultTwoIOperand);



    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneNegativeROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) -1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piHalvedROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_halved);


    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext1);

    if (gcmIS_ERROR(status)) return status;


    clsIOPERAND_New(Compiler, &conditionIOperand, clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ABS,
                                &conditionIOperand,
                                &OperandsParameters[0].rOperands[0]);

    if(gcmIS_ERROR(status)) return status;

    clsROPERAND_InitializeUsingIOperand(&conditionROperand, &conditionIOperand);

    /* The condition part: |x| > 1 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &conditionROperand,
                                                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for |x| > 1 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;


            /* The selection begins for x >= 0 */
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectionContext2);

            if (gcmIS_ERROR(status)) return status;

            /* The condition part: x > 0 */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext2,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_GREATER_THAN_EQUAL,
                                                        &OperandsParameters[0].rOperands[0],
                                                        &zeroROperand);

            if (gcmIS_ERROR(status)) return status;

            /* The true part for x > 0 */
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext2);

            if (gcmIS_ERROR(status)) return status;

            /* rcp for x */
            OperandsParameters[0].rOperands[0].dataType.elementType = clvTYPE_FLOAT;
            status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_INVERSE,
                                    &switchIOperand[0],
                                    &OperandsParameters[0].rOperands[0]);

            if (gcmIS_ERROR(status)) return status;

            /* assign pi/2 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        secondLOperand,
                        &piHalvedROperand);

            if (gcmIS_ERROR(status)) return status;

            /* assign -1 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        thirdLOperand,
                        &oneNegativeROperand);

            if (gcmIS_ERROR(status)) return status;

            /* assign 1 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        fourthLOperand,
                        &oneROperand);

            if (gcmIS_ERROR(status)) return status;



            status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectionContext2,
                                                    gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            /* The false part, x < -1 */
            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext2);

            if (gcmIS_ERROR(status)) return status;

            /* rcp for x */
            clsIOPERAND_New(Compiler, &switchIntermIOperand[0], clmGenCodeDataType(T_FLOAT));
            OperandsParameters[0].rOperands[0].dataType.elementType = clvTYPE_FLOAT;
            status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_INVERSE,
                                    &switchIntermIOperand[0],
                                    &OperandsParameters[0].rOperands[0]);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, -1 */
            clsROPERAND_InitializeUsingIOperand(&switchIntermROperand[0], &switchIntermIOperand[0]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &switchIOperand[0],
                                            &switchIntermROperand[0],
                                            &oneNegativeROperand);

            if (gcmIS_ERROR(status)) return status;

            /* assign pi/2 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        secondLOperand,
                        &piHalvedROperand);

            if (gcmIS_ERROR(status)) return status;

            /* assign -1 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        thirdLOperand,
                        &oneNegativeROperand);

            if (gcmIS_ERROR(status)) return status;

            /* assign -1 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        fourthLOperand,
                        &oneNegativeROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext2);

            if (gcmIS_ERROR(status)) return status;

            /* The selection end */
            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContext2);

            if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext1,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    /* The false part, |x| <= 1 */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;


            /* The selection begins for x >= 0 */
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectionContext3);

            if (gcmIS_ERROR(status)) return status;

            /* The condition part: x >= 0 */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext3,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_GREATER_THAN_EQUAL,
                                                        &OperandsParameters[0].rOperands[0],
                                                        &zeroROperand);

            if (gcmIS_ERROR(status)) return status;

            /* The true part for 0 <= x <= 1 */
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext3);

            if (gcmIS_ERROR(status)) return status;



            /* assign x */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        firstLOperand,
                        &OperandsParameters[0].rOperands[0]);

            if (gcmIS_ERROR(status)) return status;

            /* assign 0 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        secondLOperand,
                        &zeroROperand);

            if (gcmIS_ERROR(status)) return status;

            /* assign 1 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        thirdLOperand,
                        &oneROperand);

            if (gcmIS_ERROR(status)) return status;

            /* assign 1 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        fourthLOperand,
                        &oneROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectionContext3,
                                                    gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            /* The false part, -1 < x < 0 */
            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext3);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, -1 */
            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &switchIOperand[0],
                                            &OperandsParameters[0].rOperands[0],
                                            &oneNegativeROperand);

            if (gcmIS_ERROR(status)) return status;

            /* assign 0 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        secondLOperand,
                        &zeroROperand);

            if (gcmIS_ERROR(status)) return status;

            /* assign 1 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        thirdLOperand,
                        &oneROperand);

            if (gcmIS_ERROR(status)) return status;

            /* assign -1 */
            status = clGenAssignCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        fourthLOperand,
                        &oneNegativeROperand);

            if (gcmIS_ERROR(status)) return status;





            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext3);

            if (gcmIS_ERROR(status)) return status;

            /* The selection end */
            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContext3);

            if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;


    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext1);

    if (gcmIS_ERROR(status)) return status;



    clsROPERAND_InitializeFloatOrVecOrMatConstant(&eighthCoefROperand,
                                clmGenCodeDataType(T_FLOAT),
                                (gctFLOAT)-0.3333316699297187400000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&seventhCoefROperand,
                                clmGenCodeDataType(T_FLOAT),
                                (gctFLOAT)0.1999413798926269500000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&sixthCoefROperand,
                                clmGenCodeDataType(T_FLOAT),
                                (gctFLOAT)-0.1421421672382881500000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthCoefROperand,
                                clmGenCodeDataType(T_FLOAT),
                                (gctFLOAT)0.1067897461749452000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCoefROperand,
                                clmGenCodeDataType(T_FLOAT),
                                (gctFLOAT)-0.0758066023779866840000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCoefROperand,
                                clmGenCodeDataType(T_FLOAT),
                                (gctFLOAT)0.0435546078016456130000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCoefROperand,
                                clmGenCodeDataType(T_FLOAT),
                                (gctFLOAT)-0.0165818983910765820000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCoefROperand,
                                clmGenCodeDataType(T_FLOAT),
                                (gctFLOAT)0.0029747823851934670000);

    /* mul from x, x */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&switchROperand[0], &switchIOperand[0]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[0],
                    &switchROperand[0],
                    &switchROperand[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, coefficient1 */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[1],
                                    &firstCoefROperand,
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient2 */
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[2],
                    &secondCoefROperand,
                    &intermROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[3],
                                    &intermROperands[2],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient3 */
    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[4],
                    &thirdCoefROperand,
                    &intermROperands[3]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[5],
                                    &intermROperands[4],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient4 */
    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[6],
                    &fourthCoefROperand,
                    &intermROperands[5]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[7],
                                    &intermROperands[6],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient5 */
    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[8],
                    &fifthCoefROperand,
                    &intermROperands[7]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[9],
                                    &intermROperands[8],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient6 */
    clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[10],
                    &sixthCoefROperand,
                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[11],
                                    &intermROperands[10],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient7 */
    clsIOPERAND_New(Compiler, &intermIOperands[12], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[12],
                    &seventhCoefROperand,
                    &intermROperands[11]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[12], &intermIOperands[12]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[13],
                                    &intermROperands[12],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient8 */
    clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[13]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[14],
                    &eighthCoefROperand,
                    &intermROperands[13]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[15],
                    &intermROperands[14],
                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add 1.0 to result */
    clsIOPERAND_New(Compiler, &intermIOperands[16], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[16],
                    &intermROperands[15],
                    &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mul aTan(x)/x by x */
    clsIOPERAND_New(Compiler, &intermIOperands[17], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);
    clsROPERAND_InitializeUsingIOperand(&switchROperand[0], &switchIOperand[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[17],
                                    &switchROperand[0],
                                    &intermROperands[16]);

    if (gcmIS_ERROR(status)) return status;

    /* mul (0 <= x <= 1) ? 1 : -1 */
    clsIOPERAND_New(Compiler, &intermIOperands[18], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[17]);
    clsROPERAND_InitializeUsingIOperand(&switchMultROperand[0], &switchMultIOperand[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[18],
                                    &intermROperands[17],
                                    &switchMultROperand[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add (0 <= x <= 1) ? 0 : pi/2 */
    clsIOPERAND_New(Compiler, &intermIOperands[19], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[18]);
    clsROPERAND_InitializeUsingIOperand(&switchAddROperand[0], &switchAddIOperand[0]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[19],
                    &intermROperands[18],
                    &switchAddROperand[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul (0 <= x) ? 1 : -1 */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[19]);
    clsROPERAND_InitializeUsingIOperand(&switchMultTwoROperand[0], &switchMultTwoIOperand[0]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &intermROperands[19],
                    &switchMultTwoROperand[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenNativeAtanCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS   status = gcvSTATUS_OK;

    gcmHEADER();

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    if (OperandCount == 1)
    {
        status = clGenGenericCode1(Compiler,
                                   PolynaryExpr->exprBase.base.lineNo,
                                   PolynaryExpr->exprBase.base.stringNo,
                                   clvOPCODE_ATAN,
                                   IOperand,
                                   &OperandsParameters[0].rOperands[0]);
    }
    else
    {
        gcmASSERT(OperandCount == 2);

        status = clGenGenericCode2(Compiler,
                                   PolynaryExpr->exprBase.base.lineNo,
                                   PolynaryExpr->exprBase.base.stringNo,
                                   clvOPCODE_ATAN2,
                                   IOperand,
                                   &OperandsParameters[0].rOperands[0],
                                   &OperandsParameters[1].rOperands[0]);
    }

    gcmFOOTER();
    return status;
}

static gceSTATUS
_GenAtanPiCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND piRcpROperand;
    clsIOPERAND intermIOperands[1];
    clsROPERAND intermROperands[1];

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piRcpROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_rcpPlus);

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    /*Get aTan(x) */
    _GenAtanCode(
                Compiler,
                CodeGenerator,
                PolynaryExpr,
                OperandCount,
                OperandsParameters,
                &intermIOperands[0]);

    /*Mul 1./Pi */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperands[0],
                                    &piRcpROperand);
    return gcvSTATUS_OK;

}

static gceSTATUS
_GenAtan2Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND unsignROperand, signROperand, infROperand, zeroROperand,  piROperand, dot5ROperand;
    clsIOPERAND intermIOperands[34];
    clsROPERAND intermROperands[34];
    clsROPERAND tempROperand;
    clsSELECTION_CONTEXT    selectContextInfX, selectContextInfY , selectContextZeroX, selectContextNan,selectContextSpecial;
    clsSELECTION_CONTEXT    selectContextInfX1;
    int i, specialCase = 33;
    clsROPERAND cnstPiOver4ROperand;

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&cnstPiOver4ROperand,
                                                  clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT) 0.78539816339744830961566084581988f);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piROperand,
                                                  clmGenCodeDataType(T_FLOAT),
                                                  (gctFLOAT)3.141592653589793238462643383279f);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&dot5ROperand,
                                                  clmGenCodeDataType(T_FLOAT),
                                                  (gctFLOAT)0.5f);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x80000000);
    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7f800000);
    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x0);

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    for(i = 0; i<33; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }
    clsIOPERAND_New(Compiler, &intermIOperands[specialCase], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[specialCase], &intermIOperands[specialCase]);
    /*Set Special = 0, non-special */
    status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    &intermIOperands[specialCase],
                    &zeroROperand);

    /*Get Absolute value, floating point */
    for(i = 0; i<2; i++){
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ABS,
                &intermIOperands[i],
                &OperandsParameters[i].rOperands[0]);
        if (gcmIS_ERROR(status)) return status;

        /*Get the signs */
        intermIOperands[i+2].dataType.elementType = clvTYPE_UINT;
        status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[i+2],
                        &signROperand,
                        &OperandsParameters[i].rOperands[0]);
        if (gcmIS_ERROR(status)) return status;
    }

    /* |x| + |y| */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[10],
                &intermROperands[0],
                &intermROperands[1]);

    /*Clean the sign bit, since our Abs(-0) = -0 */
    intermIOperands[10].dataType.elementType = clvTYPE_UINT;
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[10],
                    &unsignROperand,
                    &intermROperands[10]);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectContextNan);
    if (gcmIS_ERROR(status)) return status;

    /* Check |x| + |y| > Inf? */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextNan,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN,
                                                &infROperand,
                                                &intermROperands[10]);
    if (gcmIS_ERROR(status)) return status;
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);
    if (gcmIS_ERROR(status)) return status;
    /*X == Nan or Y == Nan, do nothing, our Tan(x/y) can handle correctly */
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    &intermIOperands[specialCase],
                    &infROperand);


        /*return to Nan */
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &intermROperands[10]);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextNan,
                                    gcvFALSE);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                    CodeGenerator,
                                    &selectContextNan);
    if (gcmIS_ERROR(status)) return status;
    { /* Nan are exclude!!!*/

        clsSELECTION_CONTEXT    selectContextNegY;

        status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectContextNegY);

        if (gcmIS_ERROR(status)) return status;

        /*Sign of Y == SignMask? */
        status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextNegY,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &signROperand,
                                                &intermROperands[3]);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextNegY);
        { /*y < 0, r11 = pi */
            status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    &intermIOperands[11],
                    &piROperand);
            if (gcmIS_ERROR(status)) return status;
        }
        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextNegY,
                                        gcvFALSE);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextNegY);
        if (gcmIS_ERROR(status)) return status;
        { /*y >= 0, r11 = 0.0 */
            status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    &intermIOperands[11],
                    &zeroROperand);
            if (gcmIS_ERROR(status)) return status;
        }
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextNegY);
        status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextNegY);

    status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectContextZeroX);
    if (gcmIS_ERROR(status)) return status;

    /* Check |x| == 0? */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextZeroX,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[0],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    /*Now |x| = 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextZeroX);
    if (gcmIS_ERROR(status)) return status;

    { /*|x| = 0 */
        /*Set SpecialCaseFlag != 0 */
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    &intermIOperands[specialCase],
                    &infROperand);

        IOperand->dataType.elementType = clvTYPE_INT;
        status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_OR_BITWISE,
                        IOperand,
                        &intermROperands[2],
                        &intermROperands[11]);
        if (gcmIS_ERROR(status)) return status;
        /* Reset back the data type*/
        IOperand->dataType.elementType = clvTYPE_FLOAT;


    }/*End of |x| = 0 */

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextZeroX,
                                        gcvFALSE);
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextZeroX);

    { /*|x| != 0*/
        status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextInfY);
        if (gcmIS_ERROR(status)) return status;


        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfY,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &intermROperands[1],
                                                    &infROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInfY);
        if (gcmIS_ERROR(status)) return status;
        { /* |y| == inf */
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextInfX);
            if (gcmIS_ERROR(status)) return status;

            /* ((X)&0x7FFFFFFF) == 0x7F800000? Infinity*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextInfX,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &infROperand,
                                                        &intermROperands[0]);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX);
            if (gcmIS_ERROR(status)) return status;
            {    /*|X| = Inf */
                /*Y = -Inf, and Y = Inf, Angle Differ is Pi/2, so times 0.5 */
                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[12],
                                &dot5ROperand,
                                &intermROperands[11]);
                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[11],
                                &cnstPiOver4ROperand,
                                &intermROperands[12]);
            }/*End of |X| = Inf */

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextInfX,
                                        gcvFALSE);
            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX);
            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX);
            status = clDefineSelectionEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX);

            /*Set SpecialCaseFlag != 0 */
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[specialCase],
                        &infROperand);

            IOperand->dataType.elementType = clvTYPE_INT;
            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_OR_BITWISE,
                            IOperand,
                            &intermROperands[2],
                            &intermROperands[11]);
            if (gcmIS_ERROR(status)) return status;
            /* Reset back the data type*/
            IOperand->dataType.elementType = clvTYPE_FLOAT;
        } /*End of |y| == inf */
        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextInfY,
                                        gcvFALSE);
        if (gcmIS_ERROR(status)) return status;
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInfY);
        {
            /*|y| != inf, we need to handle |x| = inf case */
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextInfX1);
            if (gcmIS_ERROR(status)) return status;

            /* ((X)&0x7FFFFFFF) == 0x7F800000? Infinity*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextInfX1,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &infROperand,
                                                        &intermROperands[0]);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX1);
            if (gcmIS_ERROR(status)) return status;
            {    /*|X| = Inf */
                /*|Y| < inf, return to sign(x)*Pi/2 */
                /*Set SpecialCaseFlag != 0 */
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &intermIOperands[specialCase],
                            &infROperand);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[12],
                                &dot5ROperand,
                                &piROperand);
                IOperand->dataType.elementType = clvTYPE_INT;
                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                IOperand,
                                &intermROperands[2],
                                &intermROperands[12]);
                if (gcmIS_ERROR(status)) return status;
                /* Reset back the data type*/
                IOperand->dataType.elementType = clvTYPE_FLOAT;
            }/*End of |X| = Inf */

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInfX1,
                                            gcvFALSE);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX1);
            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX1);
            status = clDefineSelectionEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX1);

        } /*End of |y| != inf */


        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextInfY);
        status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextInfY);

    }/*End of X != 0 */

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextZeroX);
    status = clDefineSelectionEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextZeroX);



    } /* End of Nan are exclude*/

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);
    status = clDefineSelectionEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);


    status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectContextSpecial);
    if (gcmIS_ERROR(status)) return status;


    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextSpecial,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_NOT_EQUAL,
                                                &zeroROperand,
                                                &intermROperands[specialCase]);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextSpecial);
    if (gcmIS_ERROR(status)) return status;
    /*do nothing, special case already setup */
    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextSpecial,
                                    gcvFALSE);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                    CodeGenerator,
                                    &selectContextSpecial);
    if (gcmIS_ERROR(status)) return status;

        {    /*Now, the normal cases */
            /* Get x/y*/
            clGenDivCode(
                Compiler,
                CodeGenerator,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                OperandCount,
                OperandsParameters,
                &intermIOperands[13]);
            tempROperand = OperandsParameters[0].rOperands[0];
            OperandsParameters[0].rOperands[0] = intermROperands[13];
            _GenAtanCode(
                    Compiler,
                    CodeGenerator,
                    PolynaryExpr,
                    1,
                    OperandsParameters,
                    &intermIOperands[14]);
            /*y<0, we have sub/add Pi depends on x<0 */
            status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_OR_BITWISE,
                &intermIOperands[3],
                &intermROperands[2],
                &intermROperands[11]);

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            IOperand,
                            &intermROperands[14],
                            &intermROperands[3]);

            OperandsParameters[0].rOperands[0] = tempROperand;
        }/*End Normal cases */
    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextSpecial);
    status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextSpecial);

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenAtan2PiCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND piRcpROperand;
    clsIOPERAND intermIOperands[1];
    clsROPERAND intermROperands[1];

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&piRcpROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) pi_rcpPlus);
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    /*Get aTan(x) */
    _GenAtan2Code(
                Compiler,
                CodeGenerator,
                PolynaryExpr,
                OperandCount,
                OperandsParameters,
                &intermIOperands[0]);

    /*Mul 1./Pi */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperands[0],
                                    &piRcpROperand);
    return gcvSTATUS_OK;

}




static gceSTATUS
_GenSinhCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND    firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand, fifthCoefROperand;
    clsROPERAND constantROperand, zeroROperand, oneROperand, halfROperand;
    clsROPERAND firstROperand, secondROperand;
    clsIOPERAND intermIOperands[24];
    clsROPERAND intermROperands[24];
    clsIOPERAND signIOperand;
    clsIOPERAND conditionIOperand;
    clsROPERAND conditionROperand;

    clsSELECTION_CONTEXT     selectionContext1;


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.16666695);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.008332912523711332600000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.000198625885340371320000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.000002708826700987234400);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.000000029676529729870718);


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&halfROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.5);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 3.0);



    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);





    /* absolute value 1 */
    clsIOPERAND_New(Compiler, &conditionIOperand, clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ABS,
                &conditionIOperand,
                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;



    clsROPERAND_InitializeUsingIOperand(&conditionROperand, &conditionIOperand);


                        /* The selection begins for t0 >= 0.0 */
                        status = clDefineSelectionBegin(Compiler,
                                                        CodeGenerator,
                                                        gcvTRUE,
                                                        &selectionContext1);

                        if (gcmIS_ERROR(status)) return status;

                        /* The condition part: t0 <= 3.0 */
                        status = clGenSelectionCompareConditionCode(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext1,
                                                                    PolynaryExpr->exprBase.base.lineNo,
                                                                    PolynaryExpr->exprBase.base.stringNo,
                                                                    clvCONDITION_LESS_THAN_EQUAL,
                                                                    &conditionROperand,
                                                                    &secondROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* The true part for t0 <= 3.0 */
                        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext1);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul x, x */
                        clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));

                        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[0],
                                        &OperandsParameters[0].rOperands[0],
                                        &OperandsParameters[0].rOperands[0]);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, coefficient1 */
                        clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[1],
                                                        &firstCoefROperand,
                                                        &intermROperands[0]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coefficient2 */
                        clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

                        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[2],
                                        &secondCoefROperand,
                                        &intermROperands[1]);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x^2 */
                        clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[3],
                                                        &intermROperands[2],
                                                        &intermROperands[0]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coefficient3 */
                        clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

                        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[4],
                                        &thirdCoefROperand,
                                        &intermROperands[3]);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x^2 */
                        clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[5],
                                                        &intermROperands[4],
                                                        &intermROperands[0]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coefficient4 */
                        clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

                        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[6],
                                        &fourthCoefROperand,
                                        &intermROperands[5]);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x^2 */
                        clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[7],
                                                        &intermROperands[6],
                                                        &intermROperands[0]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coefficient5 */
                        clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

                        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[8],
                                        &fifthCoefROperand,
                                        &intermROperands[7]);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x^2 */
                        clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[9],
                                                        &intermROperands[8],
                                                        &intermROperands[0]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, 1.0 */
                        clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_ADD_RTZ,
                                                        &intermIOperands[10],
                                                        &intermROperands[9],
                                                        &constantROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x */
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        IOperand,
                                                        &intermROperands[10],
                                                        &OperandsParameters[0].rOperands[0]);

                        if (gcmIS_ERROR(status)) return status;


                        status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectionContext1,
                                                    gcvFALSE);

                        if (gcmIS_ERROR(status)) return status;

                        /* The false part, x > 3.0 */
                        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext1);

                        if (gcmIS_ERROR(status)) return status;

                        clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
                        {
                            clsGEN_CODE_PARAMETERS operandsParameters = OperandsParameters[0];
                            clsROPERAND tempROperand, cnst87ROperand;
                            clsSELECTION_CONTEXT     selectionContextOver126;

                            clsROPERAND_InitializeFloatOrVecOrMatConstant(&cnst87ROperand,
                                    clmGenCodeDataType(T_FLOAT), 87.0f);


                            status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectionContextOver126);

                            if (gcmIS_ERROR(status)) return status;

                            /* The condition part: t0*Log2(E) >126 */
                            status = clGenSelectionCompareConditionCode(Compiler,
                                                                        CodeGenerator,
                                                                        &selectionContextOver126,
                                                                        PolynaryExpr->exprBase.base.lineNo,
                                                                        PolynaryExpr->exprBase.base.stringNo,
                                                                        clvCONDITION_GREATER_THAN,
                                                                        &conditionROperand,
                                                                        &cnst87ROperand);

                            if (gcmIS_ERROR(status)) return status;

                            /* The true part for t0 >= 126 */
                            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContextOver126);

                            if (gcmIS_ERROR(status)) return status;


                            /*Later on, don't multiply 0.5, times 1.0 instead */
                            status = clGenGenericCode1(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ASSIGN,
                                            &intermIOperands[0],
                                            &constantROperand);

                            status = clDefineSelectionTrueOperandEnd(Compiler,
                                                                    PolynaryExpr->exprBase.base.lineNo,
                                                                    PolynaryExpr->exprBase.base.stringNo,
                                                                    CodeGenerator,
                                                                    &selectionContextOver126,
                                                                    gcvFALSE);
                            /*Normal cases, multiple 0.5 after E^t */
                            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContextOver126);

                            /*r0 = 0.5 */
                            status = clGenGenericCode1(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ASSIGN,
                                            &intermIOperands[0],
                                            &halfROperand);
                            if (gcmIS_ERROR(status)) return status;

                            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContextOver126);
                            if (gcmIS_ERROR(status)) return status;

                            status = clDefineSelectionEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectionContextOver126);
                            if (gcmIS_ERROR(status)) return status;

                            /*Get e^x from standard routine */
                            tempROperand = OperandsParameters[0].rOperands[0];
                            operandsParameters.rOperands[0] = conditionROperand;
                            status = _GenExp_E_10Code(
                                                Compiler,
                                                CodeGenerator,
                                                PolynaryExpr,
                                                OperandCount,
                                                &operandsParameters,
                                                &intermIOperands[11],
                                                87);
                            if (gcmIS_ERROR(status)) return status;
                            OperandsParameters[0].rOperands[0] = tempROperand;
                        }
        /* rcp e^x */
        clsIOPERAND_New(Compiler, &intermIOperands[19], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);
        intermROperands[11].dataType.elementType = clvTYPE_FLOAT;
        status = clGenGenericCode1(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_INVERSE,
                                        &intermIOperands[19],
                                        &intermROperands[11]);

        if (gcmIS_ERROR(status)) return status;
        /*N-R to refine the rcp */
        clsIOPERAND_New(Compiler, &intermIOperands[20], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[20]);
        clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[19]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[20],
                                        &intermROperands[19],
                                        &intermROperands[11]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[1],
                                        &oneROperand,
                                        &intermROperands[20]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[20],
                                        &intermROperands[19],
                                        &intermROperands[1]);

        {
            /*Last Step of N-R. Check if r19 == 0? If it is, don't add Inf*0 = Nan */
            clsSELECTION_CONTEXT     selectionContextRcp0;
            status = clDefineSelectionBegin(Compiler,
                CodeGenerator,
                gcvTRUE,
                &selectionContextRcp0);

            if (gcmIS_ERROR(status)) return status;

            /* RCP == 0? */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectionContextRcp0,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &intermROperands[19],
                                                        &firstROperand);

            if (gcmIS_ERROR(status)) return status;

            /* The true part for rcp == 0, do nothing*/
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextRcp0);

            if (gcmIS_ERROR(status)) return status;


            status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectionContextRcp0,
                                                    gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextRcp0);
            /*Normal cases, N-R refinement added*/
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[19],
                                        &intermROperands[19],
                                        &intermROperands[20]);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextRcp0);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContextRcp0);
            if (gcmIS_ERROR(status)) return status;
        }

        /* e^x - e^(-x), change sign first */
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[19],
                                        &firstROperand,
                                        &intermROperands[19]);


        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[20],
                                        &intermROperands[19],
                                        &intermROperands[11]);


        /*Get the right rounding */
        {
            clsROPERAND cnst2ROperand;
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&cnst2ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0f);
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADDLO_RTZ,
                                        &intermIOperands[2],
                                        &intermROperands[19],
                                        &intermROperands[11]);

            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[1],
                                        &intermROperands[2],
                                        &cnst2ROperand);

            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[20],
                                        &intermROperands[20],
                                        &intermROperands[1]);


        }

        if (gcmIS_ERROR(status)) return status;

        /* mul result, 0.5, r0 = 0.5 or 1.0 */

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[19],
                                        &intermROperands[20],
                                        &intermROperands[0]);


                        if (gcmIS_ERROR(status)) return status;

                        /* get the sign */
                        clsIOPERAND_New(Compiler, &signIOperand, clmGenCodeDataType(T_FLOAT));

                        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SIGN,
                                    &signIOperand,
                                    &OperandsParameters[0].rOperands[0]);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, by sign */
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[21], &signIOperand);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        IOperand,
                                                        &intermROperands[19],
                                                        &intermROperands[21]);

                        if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext1);
    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}


static gceSTATUS
_GenCoshCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND    firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand, fifthCoefROperand, sixthCoefROperand;
    clsROPERAND oneROperand, halfROperand;
    clsROPERAND firstROperand, secondROperand;
    clsIOPERAND intermIOperands[25];
    clsROPERAND intermROperands[25];
    clsIOPERAND conditionIOperand;
    clsROPERAND conditionROperand;

    clsSELECTION_CONTEXT    selectionContext1;

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&sixthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.50);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.041666720);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.0013888341);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.000024823852);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.00000027140925);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.0000000024506237);


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&halfROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.5);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 3.0);



    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);




    /* absolute value */
    clsIOPERAND_New(Compiler, &conditionIOperand, clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ABS,
                &conditionIOperand,
                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    clsROPERAND_InitializeUsingIOperand(&conditionROperand, &conditionIOperand);





    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: t0 <= 3.0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN_EQUAL,
                                                &conditionROperand,
                                                &secondROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for t0 <= 3.0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* mul x, x */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[0],
                    &OperandsParameters[0].rOperands[0],
                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, coefficient1 */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[1],
                                    &firstCoefROperand,
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, coefficient2 */
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[2],
                    &secondCoefROperand,
                    &intermROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[3],
                                    &intermROperands[2],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, coefficient3 */
    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[4],
                    &thirdCoefROperand,
                    &intermROperands[3]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[5],
                                    &intermROperands[4],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, coefficient4 */
    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[6],
                    &fourthCoefROperand,
                    &intermROperands[5]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[7],
                                    &intermROperands[6],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, coefficient5 */
    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[8],
                    &fifthCoefROperand,
                    &intermROperands[7]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[9],
                                    &intermROperands[8],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, coefficient6 */
    clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[10],
                    &sixthCoefROperand,
                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[11],
                                    &intermROperands[10],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, 1.0 */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    IOperand,
                                    &intermROperands[11],
                                    &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                CodeGenerator,
                                &selectionContext1,
                                gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part, x > 3.0 */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;


        clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
        {
            clsGEN_CODE_PARAMETERS operandsParameters = OperandsParameters[0];
            clsROPERAND tempROperand, cnst87ROperand;
            clsSELECTION_CONTEXT     selectionContextOver126;

            clsROPERAND_InitializeFloatOrVecOrMatConstant(&cnst87ROperand,
                    clmGenCodeDataType(T_FLOAT), 87.0f);


            status = clDefineSelectionBegin(Compiler,
                CodeGenerator,
                gcvTRUE,
                &selectionContextOver126);

            if (gcmIS_ERROR(status)) return status;

            /* The condition part: t0*Log2(E) >126 */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectionContextOver126,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_GREATER_THAN,
                                                        &conditionROperand,
                                                        &cnst87ROperand);

            if (gcmIS_ERROR(status)) return status;

            /* The true part for t0 >= 126 */
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextOver126);

            if (gcmIS_ERROR(status)) return status;


            /*Later on, don't multiply 0.5, times 1.0 instead */
            status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &intermIOperands[0],
                            &oneROperand);

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectionContextOver126,
                                                    gcvFALSE);
            /*Normal cases, multiple 0.5 after E^t */
            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextOver126);

            /*r0 = 0.5 */
            status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            &intermIOperands[0],
                            &halfROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextOver126);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContextOver126);
            if (gcmIS_ERROR(status)) return status;

            /*Get e^x from standard routine */
            tempROperand = OperandsParameters[0].rOperands[0];
            operandsParameters.rOperands[0] = conditionROperand;
            status = _GenExp_E_10Code(
                                Compiler,
                                CodeGenerator,
                                PolynaryExpr,
                                OperandCount,
                                &operandsParameters,
                                &intermIOperands[11],
                                87);
            if (gcmIS_ERROR(status)) return status;
            OperandsParameters[0].rOperands[0] = tempROperand;
        }

        /* rcp e^x */
        clsIOPERAND_New(Compiler, &intermIOperands[19], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);
        intermROperands[11].dataType.elementType = clvTYPE_FLOAT;
        status = clGenGenericCode1(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_INVERSE,
                                        &intermIOperands[19],
                                        &intermROperands[11]);

        if (gcmIS_ERROR(status)) return status;
        /*N-R to refine the rcp */
        clsIOPERAND_New(Compiler, &intermIOperands[20], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[20]);
        clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[19]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[20],
                                        &intermROperands[19],
                                        &intermROperands[11]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[1],
                                        &oneROperand,
                                        &intermROperands[20]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[20],
                                        &intermROperands[19],
                                        &intermROperands[1]);
        {
            /*Last Step of N-R. Check if r19 == 0? If it is, don't add Inf*0 = Nan */
            clsSELECTION_CONTEXT     selectionContextRcp0;
            status = clDefineSelectionBegin(Compiler,
                CodeGenerator,
                gcvTRUE,
                &selectionContextRcp0);

            if (gcmIS_ERROR(status)) return status;

            /* RCP == 0? */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectionContextRcp0,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &intermROperands[19],
                                                        &firstROperand);

            if (gcmIS_ERROR(status)) return status;

            /* The true part for rcp == 0, do nothing*/
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextRcp0);

            if (gcmIS_ERROR(status)) return status;


            status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectionContextRcp0,
                                                    gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextRcp0);
            /*Normal cases, N-R refinement added*/
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[19],
                                        &intermROperands[19],
                                        &intermROperands[20]);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextRcp0);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContextRcp0);
            if (gcmIS_ERROR(status)) return status;
        }
        /* e^x + e^(-x) */

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[20],
                                        &intermROperands[19],
                                        &intermROperands[11]);


        /*Get the right rounding */
        {
            clsROPERAND cnst2ROperand;
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&cnst2ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0f);
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADDLO_RTZ,
                                        &intermIOperands[2],
                                        &intermROperands[19],
                                        &intermROperands[11]);

            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[1],
                                        &intermROperands[2],
                                        &cnst2ROperand);

            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[20],
                                        &intermROperands[20],
                                        &intermROperands[1]);


        }

        if (gcmIS_ERROR(status)) return status;

        /* mul result, 0.5, r0 = 0.5 or 1.0 */

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        IOperand,
                                        &intermROperands[20],
                                        &intermROperands[0]);

        if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext1);

    if (gcmIS_ERROR(status)) return status;


    return gcvSTATUS_OK;
}
static gceSTATUS
_GenTanhCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND    firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand, fifthCoefROperand;
    clsROPERAND constantROperand, constantTwoROperand, halfROperand;
    clsROPERAND firstROperand, secondROperand;
    clsIOPERAND intermIOperands[26];
    clsROPERAND intermROperands[26];
    clsIOPERAND conditionIOperand;
    clsROPERAND conditionROperand;
    clsIOPERAND signIOperand;

    clsSELECTION_CONTEXT    selectionContext1;


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.333328941628655340000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.133231758524374600000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.053195575131690917000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.019226460629030960000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.004433710418278204200000);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&halfROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.5);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantTwoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.75);



    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);



    /* absolute value 1 */
    clsIOPERAND_New(Compiler, &conditionIOperand, clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ABS,
                &conditionIOperand,
                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    clsROPERAND_InitializeUsingIOperand(&conditionROperand, &conditionIOperand);


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: t0 <= 0.75 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN_EQUAL,
                                                &conditionROperand,
                                                &secondROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for t0 <= 0.75 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* mul x, x */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[0],
                    &OperandsParameters[0].rOperands[0],
                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, coefficient1 */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[1],
                                    &firstCoefROperand,
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, coefficient2 */
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[2],
                    &secondCoefROperand,
                    &intermROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[3],
                                    &intermROperands[2],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, coefficient3 */
    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[4],
                    &thirdCoefROperand,
                    &intermROperands[3]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[5],
                                    &intermROperands[4],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, coefficient4 */
    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[6],
                    &fourthCoefROperand,
                    &intermROperands[5]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[7],
                                    &intermROperands[6],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, coefficient5 */
    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[8],
                    &fifthCoefROperand,
                    &intermROperands[7]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x^2 */
    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[9],
                                    &intermROperands[8],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, 1.0 */
    clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[10],
                                    &intermROperands[9],
                                    &constantROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperands[10],
                                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                CodeGenerator,
                                &selectionContext1,
                                gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part, x > 0.75 */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    {
        /*Constant 34, if x>=34, return 1.0 */
        clsROPERAND cnst34ROperand;
        clsSELECTION_CONTEXT    selectContextOver34;
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&cnst34ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 34.0f);

        /* The selection begins */
        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextOver34);

        if (gcmIS_ERROR(status)) return status;

        /* The condition part: t0 >= 34 */
        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextOver34,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_GREATER_THAN,
                                                    &conditionROperand,
                                                    &cnst34ROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextOver34);
        /*Over34, return 1.0 (E^34-1)/(E^34+1) = 1.0 */
        status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[10],
                        &constantROperand);

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextOver34,
                                            0);

        status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextOver34);
        { /*Get the E^(2x) */
            clsROPERAND tempROperand = OperandsParameters[0].rOperands[0];
            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[0],
                            &constantTwoROperand,
                            &conditionROperand);

            OperandsParameters[0].rOperands[0] = intermROperands[0];

            status = _GenExp_E_10Code(
                                Compiler,
                                CodeGenerator,
                                PolynaryExpr,
                                OperandCount,
                                OperandsParameters,
                                &intermIOperands[1],
                                1);
            if (gcmIS_ERROR(status)) return status;
            OperandsParameters[0].rOperands[0] = tempROperand;
        }

        /*Calculate 1 / (E^(2x) + 1) */

        status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[0],
                        &intermROperands[1],
                        &constantROperand);

        /*r2 = rcp(r0) */
        intermROperands[0].dataType.elementType = clvTYPE_FLOAT;
        status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_INVERSE,
                            &intermIOperands[2],
                            &intermROperands[0]);

        /*N-R refinement */
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[5],
                                        &intermROperands[0],
                                        &intermROperands[2]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[3],
                                        &constantROperand,
                                        &intermROperands[5]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[4],
                                        &intermROperands[2],
                                        &intermROperands[3]);
        /* r3 = rcp(E^(2x) + 1), refined */
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[2],
                                        &intermROperands[4]);
        /*r0 = E^(2x) - 1 */
        status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[0],
                        &intermROperands[1],
                        &constantROperand);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[10],
                                        &intermROperands[0],
                                        &intermROperands[3]);

        status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextOver34);

        status = clDefineSelectionEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextOver34);


    }



    /* get the sign */
    clsIOPERAND_New(Compiler, &signIOperand, clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SIGN,
                &signIOperand,
                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, by sign */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &signIOperand);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperands[10],
                                    &intermROperands[25]);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext1);

    if (gcmIS_ERROR(status)) return status;


    return gcvSTATUS_OK;
}


static gceSTATUS
_GenAsinhCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND firstROperand, secondROperand, thirdROperand, fourthROperand;
    clsIOPERAND intermIOperands[33];
    clsROPERAND intermROperands[34];
    clsIOPERAND extraIOperands[5];
    clsROPERAND extraROperands[5];
    clsIOPERAND conditionIOperand;
    clsROPERAND conditionROperand;
    clsIOPERAND signIOperand;



    clsSELECTION_CONTEXT    selectionContext1, selectionContext2;
    clsROPERAND        firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand, fifthCoefROperand, sixthCoefROperand,
                    seventhCoefROperand, eighthCoefROperand, ninthCoefROperand, tenthCoefROperand, eleventhCoefROperand, twelfthCoefROperand,
                    thirteenthCoefROperand;

    clsROPERAND        constantROperand, constantTwoROperand, constantThreeROperand, logRCPROperand;


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.4);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.81474976710656e14);



    clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantTwoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)2.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantThreeROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)1.25);


    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);



    /* get the sign */
    clsIOPERAND_New(Compiler, &signIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&extraROperands[0], &signIOperand);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SIGN,
                &signIOperand,
                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;


    /* absolute value */
    clsIOPERAND_New(Compiler, &conditionIOperand, clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ABS,
                &conditionIOperand,
                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;


    clsROPERAND_InitializeUsingIOperand(&conditionROperand, &conditionIOperand);




    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: t0 >= 2.4 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &conditionROperand,
                                                &thirdROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for t0 >= 2.4 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

                /* The selection begins for t0 >= 2.4 */
                status = clDefineSelectionBegin(Compiler,
                                                CodeGenerator,
                                                gcvTRUE,
                                                &selectionContext2);

                if (gcmIS_ERROR(status)) return status;

                /* The condition part: t0 >= 2.81474976710656e14 */
                status = clGenSelectionCompareConditionCode(Compiler,
                                                            CodeGenerator,
                                                            &selectionContext2,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvCONDITION_GREATER_THAN_EQUAL,
                                                            &conditionROperand,
                                                            &fourthROperand);

                if (gcmIS_ERROR(status)) return status;

                /* The true part for t0 >= 2.81474976710656e14 */
                status = clDefineSelectionTrueOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext2);

                if (gcmIS_ERROR(status)) return status;

                /* log2 x */
                clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));

                status = clGenGenericCode1(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_LOG2,
                                        &intermIOperands[1],
                                        &conditionROperand);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, 1/log2(e) */
                clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[1]);

                clsROPERAND_InitializeFloatOrVecOrMatConstant(&logRCPROperand,
                      clmGenCodeDataType(T_FLOAT),
                      _RCP_OF_LOG2_E);

                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[2],
                                        &logRCPROperand,
                                        &intermROperands[2]);

                if (gcmIS_ERROR(status)) return status;

                /* add result, logE(2.0) */
                clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[2]);

                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[1],
                                        &logRCPROperand,
                                        &intermROperands[3]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                IOperand,
                                                &intermROperands[2],
                                                &extraROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext2,
                                            gcvFALSE);

                if (gcmIS_ERROR(status)) return status;

                /* The false part, 2.4 < x < 2.81474976710656e14 */
                status = clDefineSelectionFalseOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext2);

                if (gcmIS_ERROR(status)) return status;

                /* mul t0, t0 */
                clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));

                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[3],
                                        &OperandsParameters[0].rOperands[0],
                                        &OperandsParameters[0].rOperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add result, 1.0 */
                clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[3]);

                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[4],
                                        &intermROperands[4],
                                        &constantROperand);

                if (gcmIS_ERROR(status)) return status;

                /* sqrt result */
                clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[4]);

                status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SQRT,
                                &intermIOperands[5],
                                &intermROperands[5]);

                if (gcmIS_ERROR(status)) return status;

                /* add result, t0 */
                clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[5]);

                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[6],
                                        &conditionROperand,
                                        &intermROperands[6]);

                if (gcmIS_ERROR(status)) return status;

                /* log2 result */
                clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[6]);

                status = clGenGenericCode1(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_LOG2,
                                        &intermIOperands[7],
                                        &intermROperands[7]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, 1/log2(e) */
                clsIOPERAND_New(Compiler, &extraIOperands[0], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&extraROperands[1], &extraIOperands[0]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[7]);

                clsROPERAND_InitializeFloatOrVecOrMatConstant(&logRCPROperand,
                      clmGenCodeDataType(T_FLOAT),
                      _RCP_OF_LOG2_E);

                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &extraIOperands[0],
                                        &logRCPROperand,
                                        &intermROperands[8]);

                if (gcmIS_ERROR(status)) return status;

                /* make the right rounding, to add MulLow( )*2 */
                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MULLO_RTZ,
                                        &intermIOperands[6],
                                        &logRCPROperand,
                                        &intermROperands[8]);

                if (gcmIS_ERROR(status)) return status;

                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[7],
                                        &constantTwoROperand,
                                        &intermROperands[7]);

                if (gcmIS_ERROR(status)) return status;

                /* Add 2*MulLow*/
                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &extraIOperands[0],
                                        &extraROperands[1],
                                        &intermROperands[8]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, by sign */


                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                IOperand,
                                                &extraROperands[1],
                                                &extraROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionFalseOperandEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext2);

                if (gcmIS_ERROR(status)) return status;

                /* The selection end */
                status = clDefineSelectionEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext2);

                if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                CodeGenerator,
                                &selectionContext1,
                                gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* The false part, 0.0 < x < 2.4 */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;




    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.000054669490054948255000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.000133750188979320230000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.000119975156849250200000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.000675261253491044040000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.000815188221167773010000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&sixthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.000246399460593238470000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&seventhCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.001480567734688520400000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&eighthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.00581176951527595520000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&ninthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.012730394490063190000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&tenthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.015226633287966251000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&eleventhCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.014668535441160202000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twelfthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)-0.170703887939453130000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirteenthCoefROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)0.838074445724487300000000);









    /* sub x, 1.25 */
    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SUB_RTZ,
                    &intermIOperands[8],
                    &conditionROperand,
                    &constantThreeROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, coefficient1 */
    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[9],
                                    &firstCoefROperand,
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient2 */
    clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[9]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[10],
                    &secondCoefROperand,
                    &intermROperands[10]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[10]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[11],
                                    &intermROperands[11],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient3 */
    clsIOPERAND_New(Compiler, &intermIOperands[12], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[12], &intermIOperands[11]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[12],
                    &thirdCoefROperand,
                    &intermROperands[12]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[12]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[13],
                                    &intermROperands[13],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient4 */
    clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[13]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[14],
                    &fourthCoefROperand,
                    &intermROperands[14]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[14]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[15],
                                    &intermROperands[15],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient5 */
    clsIOPERAND_New(Compiler, &intermIOperands[16], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[15]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[16],
                    &fifthCoefROperand,
                    &intermROperands[16]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[17], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[16]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[17],
                                    &intermROperands[17],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient6 */
    clsIOPERAND_New(Compiler, &intermIOperands[18], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[17]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[18],
                    &sixthCoefROperand,
                    &intermROperands[18]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[19], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[18]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[19],
                                    &intermROperands[19],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient7 */
    clsIOPERAND_New(Compiler, &intermIOperands[20], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[19]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[20],
                    &seventhCoefROperand,
                    &intermROperands[20]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[21], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[21], &intermIOperands[20]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[21],
                                    &intermROperands[21],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient8 */
    clsIOPERAND_New(Compiler, &intermIOperands[22], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[22], &intermIOperands[21]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[22],
                    &eighthCoefROperand,
                    &intermROperands[22]);

    if (gcmIS_ERROR(status)) return status;








    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[23], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[23], &intermIOperands[22]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[23],
                                    &intermROperands[23],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient9 */
    clsIOPERAND_New(Compiler, &intermIOperands[24], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[23]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[24],
                    &ninthCoefROperand,
                    &intermROperands[24]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[25], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[24]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[25],
                                    &intermROperands[25],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient10 */
    clsIOPERAND_New(Compiler, &intermIOperands[26], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[25]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[26],
                    &tenthCoefROperand,
                    &intermROperands[26]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[27], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[27], &intermIOperands[26]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[27],
                                    &intermROperands[27],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient11 */
    clsIOPERAND_New(Compiler, &intermIOperands[28], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[28], &intermIOperands[27]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[28],
                    &eleventhCoefROperand,
                    &intermROperands[28]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[29], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[29], &intermIOperands[28]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[29],
                                    &intermROperands[29],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient12 */
    clsIOPERAND_New(Compiler, &intermIOperands[30], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[30], &intermIOperands[29]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[30],
                    &twelfthCoefROperand,
                    &intermROperands[30]);

    if (gcmIS_ERROR(status)) return status;


    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[31], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[31], &intermIOperands[30]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[31],
                                    &intermROperands[31],
                                    &intermROperands[9]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, coefficient13 */
    clsIOPERAND_New(Compiler, &intermIOperands[32], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[32], &intermIOperands[31]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[32],
                    &thirteenthCoefROperand,
                    &intermROperands[32]);

    if (gcmIS_ERROR(status)) return status;


    /* mul aSinh(x)/x by x */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[33], &intermIOperands[32]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &OperandsParameters[0].rOperands[0],
                                    &intermROperands[33]);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;


}


static gceSTATUS
_GenAcoshCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND firstROperand, secondROperand, thirdROperand;
    clsIOPERAND intermIOperands[33];
    clsROPERAND intermROperands[33];

    clsSELECTION_CONTEXT    selectionContext, selectionContext1, selectionContext2;
    clsROPERAND        firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand, fifthCoefROperand, sixthCoefROperand,
                    seventhCoefROperand, eighthCoefROperand;
    clsROPERAND        constantROperand, constantTwoROperand, logRCPROperand;

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 3.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.81474976710656e14);



    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);



    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: t0 > 1.0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &OperandsParameters[0].rOperands[0],
                                                &firstROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for t0 > 1.0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext);

    if (gcmIS_ERROR(status)) return status;

            /* The selection begins for t0 >= 1.0 */
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectionContext1);

            if (gcmIS_ERROR(status)) return status;

            /* The condition part: t0 <= 3.0 */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext1,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_LESS_THAN_EQUAL,
                                                        &OperandsParameters[0].rOperands[0],
                                                        &secondROperand);

            if (gcmIS_ERROR(status)) return status;

            /* The true part for t0 <= 3.0 */
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext1);

            if (gcmIS_ERROR(status)) return status;


            clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)1.414213536977550100000000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)-0.117849199956384490000000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT) 0.026493975066410286000000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)-0.007790949538526787500000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.002456785895046065000000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&sixthCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)-0.000688901305761696680000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&seventhCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.000135505527644357630000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&eighthCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)-0.000012883406055475172000);

            clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)1.0);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantTwoROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)2.0);




            /* sub from x, 1.0 */
            clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_SUB_RTZ,
                            &intermIOperands[0],
                            &OperandsParameters[0].rOperands[0],
                            &constantROperand);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, coefficient8 */
            clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[1],
                                            &eighthCoefROperand,
                                            &intermROperands[0]);

            if (gcmIS_ERROR(status)) return status;

            /* add to result, coefficient7 */
            clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[1]);

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[4],
                            &seventhCoefROperand,
                            &intermROperands[3]);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, previous result */
            clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[5],
                                            &intermROperands[4],
                                            &intermROperands[0]);

            if (gcmIS_ERROR(status)) return status;

            /* add to result, coefficient6 */
            clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[6],
                            &sixthCoefROperand,
                            &intermROperands[5]);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, previous result */
            clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[7],
                                            &intermROperands[6],
                                            &intermROperands[0]);

            if (gcmIS_ERROR(status)) return status;

            /* add to result, coefficient5 */
            clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[8],
                            &fifthCoefROperand,
                            &intermROperands[7]);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, previous result */
            clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[9],
                                            &intermROperands[8],
                                            &intermROperands[0]);

            if (gcmIS_ERROR(status)) return status;

            /* add to result, coefficient4 */
            clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[10],
                            &fourthCoefROperand,
                            &intermROperands[9]);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, previous result */
            clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[11],
                                            &intermROperands[10],
                                            &intermROperands[0]);

            if (gcmIS_ERROR(status)) return status;

            /* add to result, coefficient3 */
            clsIOPERAND_New(Compiler, &intermIOperands[12], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[12],
                            &thirdCoefROperand,
                            &intermROperands[11]);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, previous result */
            clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[12], &intermIOperands[12]);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[13],
                                            &intermROperands[12],
                                            &intermROperands[0]);

            if (gcmIS_ERROR(status)) return status;

            /* add to result, coefficient2 */
            clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[13]);

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[14],
                            &secondCoefROperand,
                            &intermROperands[13]);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, previous result */
            clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[15],
                                            &intermROperands[14],
                                            &intermROperands[0]);

            if (gcmIS_ERROR(status)) return status;

            /* add to result, coefficient1 */
            clsIOPERAND_New(Compiler, &intermIOperands[16], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[16],
                            &firstCoefROperand,
                            &intermROperands[15]);

            if (gcmIS_ERROR(status)) return status;

            /* sqrt for (x-1) */
            clsIOPERAND_New(Compiler, &intermIOperands[17], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[0]);

            status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SQRT,
                                    &intermIOperands[17],
                                    &intermROperands[16]);

            if (gcmIS_ERROR(status)) return status;

            /* mul sqrt(x-1), sqrt(x-1) */
            clsIOPERAND_New(Compiler, &intermIOperands[18], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[17]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[18],
                                            &intermROperands[17],
                                            &intermROperands[17]);

            if (gcmIS_ERROR(status)) return status;

            /* sub from result, (x-1)*/
            clsIOPERAND_New(Compiler, &intermIOperands[19], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[18]);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[0]);

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_SUB_RTZ,
                            &intermIOperands[19],
                            &intermROperands[19],
                            &intermROperands[18]);

            if (gcmIS_ERROR(status)) return status;

            /* mul sqrt(x-1), 2.0 */
            clsIOPERAND_New(Compiler, &intermIOperands[20], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[17]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[20],
                                            &intermROperands[17],
                                            &constantTwoROperand);

            if (gcmIS_ERROR(status)) return status;

            /* div top previous result from bottom result */
            clsIOPERAND_New(Compiler, &intermIOperands[21], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[21], &intermIOperands[19]);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[20]);


            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_DIV,
                                            &intermIOperands[21],
                                            &intermROperands[21],
                                            &intermROperands[20]);
            if (gcmIS_ERROR(status)) return status;

            /* sub from sqrt(x-1) the result */
            clsIOPERAND_New(Compiler, &intermIOperands[22], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[17]);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[22], &intermIOperands[21]);


            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_SUB_RTZ,
                            &intermIOperands[22],
                            &intermROperands[17],
                            &intermROperands[22]);

            if (gcmIS_ERROR(status)) return status;


            /* mul aCosh(x)/sqrt(x-1) by Newton Raphson sqrt(x-1) */
            clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[22]);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[23], &intermIOperands[16]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            IOperand,
                                            &intermROperands[24],
                                            &intermROperands[23]);

            if (gcmIS_ERROR(status)) return status;


            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext1,
                                            gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            /* The false part, t0 > 3.0 */

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext1);

            if (gcmIS_ERROR(status)) return status;


                        /* The selection begins */
                        status = clDefineSelectionBegin(Compiler,
                                                        CodeGenerator,
                                                        gcvTRUE,
                                                        &selectionContext2);

                        if (gcmIS_ERROR(status)) return status;

                        /* The condition part: t0 >= 2^48 */
                        status = clGenSelectionCompareConditionCode(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext2,
                                                                    PolynaryExpr->exprBase.base.lineNo,
                                                                    PolynaryExpr->exprBase.base.stringNo,
                                                                    clvCONDITION_GREATER_THAN_EQUAL,
                                                                    &OperandsParameters[0].rOperands[0],
                                                                    &thirdROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* The true part for t0 >= 2^48 */
                        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext2);

                        if (gcmIS_ERROR(status)) return status;

                        /* log2 x */
                        clsIOPERAND_New(Compiler, &intermIOperands[23], clmGenCodeDataType(T_FLOAT));

                        status = clGenGenericCode1(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_LOG2,
                                                &intermIOperands[23],
                                                &OperandsParameters[0].rOperands[0]);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, 1/log2(e) */
                        clsIOPERAND_New(Compiler, &intermIOperands[24], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[23]);

                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&logRCPROperand,
                              clmGenCodeDataType(T_FLOAT),
                              _RCP_OF_LOG2_E);

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[24],
                                                &logRCPROperand,
                                                &intermROperands[25]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, logE(2.0) */
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[24]);


                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_ADD_RTZ,
                                                IOperand,
                                                &logRCPROperand,
                                                &intermROperands[26]);

                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext2,
                                            gcvFALSE);

                        if (gcmIS_ERROR(status)) return status;

                        /* The false part, 3.0 < t0 < 2^48 */
                        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext2);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul t0, t0 */
                        clsIOPERAND_New(Compiler, &intermIOperands[25], clmGenCodeDataType(T_FLOAT));

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[25],
                                                &OperandsParameters[0].rOperands[0],
                                                &OperandsParameters[0].rOperands[0]);

                        if (gcmIS_ERROR(status)) return status;

                        /* sub result, 1.0 */
                        clsIOPERAND_New(Compiler, &intermIOperands[26], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[27], &intermIOperands[25]);

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_SUB_RTZ,
                                                &intermIOperands[26],
                                                &intermROperands[27],
                                                &constantROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* sqrt result */
                        clsIOPERAND_New(Compiler, &intermIOperands[27], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[28], &intermIOperands[26]);

                        status = clGenGenericCode1(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SQRT,
                                        &intermIOperands[27],
                                        &intermROperands[28]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, t0 */
                        clsIOPERAND_New(Compiler, &intermIOperands[28], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[27], &intermIOperands[27]);

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_ADD_RTZ,
                                                &intermIOperands[28],
                                                &OperandsParameters[0].rOperands[0],
                                                &intermROperands[27]);

                        if (gcmIS_ERROR(status)) return status;

                        /* log2 result */
                        clsIOPERAND_New(Compiler, &intermIOperands[29], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[28], &intermIOperands[28]);

                        status = clGenGenericCode1(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_LOG2,
                                                &intermIOperands[29],
                                                &intermROperands[28]);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, 1/log2(e) */
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[29], &intermIOperands[29]);

                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&logRCPROperand,
                              clmGenCodeDataType(T_FLOAT),
                              _RCP_OF_LOG2_E);

                        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MULLO_RTZ,
                                        &intermIOperands[28],
                                        &intermROperands[29],
                                        &logRCPROperand);

                        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[27],
                                        &intermROperands[28],
                                        &constantTwoROperand);

                        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[28],
                                        &intermROperands[29],
                                        &logRCPROperand);

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_ADD_RTZ,
                                                IOperand,
                                                &intermROperands[27],
                                                &intermROperands[28]);

                        if (gcmIS_ERROR(status)) return status;


                        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext2);

                        if (gcmIS_ERROR(status)) return status;

                        /* The selection end */
                        status = clDefineSelectionEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext2);

                        if (gcmIS_ERROR(status)) return status;


            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext1);

            if (gcmIS_ERROR(status)) return status;

            /* The selection end for t0 > 1.0 */
            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContext1);

            if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    /* The false part, t0 <= 1.0 */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext);

    if (gcmIS_ERROR(status)) return status;
    {
        clsSELECTION_CONTEXT    selectContextX1;
        clsROPERAND        nanROperand, zeroROperand;
        clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7fc00000);
        clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x00000);
        /* The selection begins */
        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextX1);

        if (gcmIS_ERROR(status)) return status;

        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextX1,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &OperandsParameters[0].rOperands[0],
                                                    &firstROperand);

        if (gcmIS_ERROR(status)) return status;

        /* The true part for t0 == 1.0 */
        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextX1);

        if (gcmIS_ERROR(status)) return status;
        /*return to zero */
        status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &zeroROperand);

        if (gcmIS_ERROR(status)) return status;
        status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectContextX1,
                                                gcvFALSE);

        if (gcmIS_ERROR(status)) return status;

        /* The false part, t0 < 1.0 */
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextX1);

        /* Outside the domain (t<1.0), return to Nan */

        status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &nanROperand);
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextX1);

        if (gcmIS_ERROR(status)) return status;


        /* The selection end */
        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextX1);

        if (gcmIS_ERROR(status)) return status;

    }
    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext);

    if (gcmIS_ERROR(status)) return status;


    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;

}
static gceSTATUS
_GenAtanhCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{

    clsIOPERAND        intermIOperands[40], signIOperand, absIOperand;
    clsROPERAND        intermROperands[40], signROperand, absROperand;
    clsROPERAND        firstROperand, secondROperand;
    clsROPERAND        rcpROperand;
    clsSELECTION_CONTEXT    selectContextOver1;

    clsROPERAND    getSignROperand, getAbsROperand;



    gceSTATUS    status;

    clsROPERAND        constantROperand, constantTwoROperand, constantFourROperand;

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantTwoROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)2.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantFourROperand,
                                                clmGenCodeDataType(T_FLOAT),
                                                (gctFLOAT)4.0);


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.57);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.75);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&rcpROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.5);

    clsROPERAND_InitializeIntOrIVecConstant(&getAbsROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&getSignROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x80000000);


    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsIOPERAND_New(Compiler, &signIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&signROperand, &signIOperand);

    clsIOPERAND_New(Compiler, &absIOperand, clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&absROperand, &absIOperand);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &absIOperand,
                    &getAbsROperand,
                    &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &signIOperand,
                    &getSignROperand,
                    &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextOver1);
    if (gcmIS_ERROR(status)) return status;

    /* The condition part: |t0| >= 1.0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextOver1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &absROperand,
                                                &constantROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for |t0| >= 1.0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextOver1);

    if (gcmIS_ERROR(status)) return status;
    {
        clsSELECTION_CONTEXT    selectContextX1;
        clsROPERAND        nanROperand, infROperand;
        clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7fc00000);
        clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7f800000);
        /* The selection begins */
        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextX1);

        if (gcmIS_ERROR(status)) return status;

        /*|t| = 1.0, return to (+/-)Inf */
        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextX1,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &absROperand,
                                                    &constantROperand);

        if (gcmIS_ERROR(status)) return status;

        /* The true part for |t0| == 1.0 */
        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextX1);

        if (gcmIS_ERROR(status)) return status;
        IOperand->dataType.elementType = clvTYPE_UINT;
        status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_OR_BITWISE,
                        IOperand,
                        &signROperand,
                        &infROperand);
        IOperand->dataType.elementType = clvTYPE_FLOAT;
        if (gcmIS_ERROR(status)) return status;
        status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectContextX1,
                                                gcvFALSE);

        if (gcmIS_ERROR(status)) return status;

        /* The false part, |t0| > 1.0 */
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextX1);

        /* Outside the domain (|t|>1.0), return to Nan */

        status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &nanROperand);
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextX1);

        if (gcmIS_ERROR(status)) return status;


        /* The selection end */
        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextX1);

        if (gcmIS_ERROR(status)) return status;

    }
    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextOver1,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    /* The false part, |t0| < 1 */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextOver1);

    absROperand.dataType.elementType = clvTYPE_FLOAT;

    /* sub x from 1.0 */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SUB_RTZ,
                    &intermIOperands[0],
                    &constantROperand,
                    &absROperand);

    if (gcmIS_ERROR(status)) return status;

    /* inverse result */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
    intermROperands[0].dataType.elementType = clvTYPE_FLOAT;
    status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_INVERSE,
                            &intermIOperands[1],
                            &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[2],
                    &intermROperands[1],
                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* sub result from 1.0 */
    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SUB_RTZ,
                    &intermIOperands[3],
                    &constantROperand,
                    &intermROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[4],
                    &intermROperands[3],
                    &intermROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* add result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[5],
                    &intermROperands[4],
                    &intermROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    /* mullo x, result */
    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MULLO_RTZ,
                    &intermIOperands[6],
                    &intermROperands[5],
                    &absROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, 4.0 */
    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[7],
                    &intermROperands[6],
                    &constantFourROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mul previous result, 2.0 */
    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[8],
                    &intermROperands[5],
                    &constantTwoROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, x */
    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[9],
                    &intermROperands[7],
                    &absROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add result, previous result*/
    clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[7]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[11],
                    &intermROperands[9],
                    &intermROperands[8]);
    if (gcmIS_ERROR(status)) return status;

    clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);

    intermROperands[12] = OperandsParameters[0].rOperands[0];
    OperandsParameters[0].rOperands[0] = intermROperands[11];

    /*Log(1+2t/(1-t)) */
    status = _GenLog2_E_10Code(
                    Compiler,
                    CodeGenerator,
                    PolynaryExpr,
                    OperandCount,
                    OperandsParameters,
                    &intermIOperands[9],
                    -1);
    if (gcmIS_ERROR(status)) return status;
    OperandsParameters[0].rOperands[0] = intermROperands[12];

    /* Times 0.5*/
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[11],
                    &intermROperands[9],
                    &rcpROperand);
    if (gcmIS_ERROR(status)) return status;


    IOperand->dataType.elementType = clvTYPE_UINT;
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    IOperand,
                    &signROperand,
                    &intermROperands[11]);
    IOperand->dataType.elementType = clvTYPE_FLOAT;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextOver1);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextOver1);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}





static gceSTATUS
_GenSinPiCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND        intermIOperands[5];
    clsROPERAND        intermROperands[5], sinCoefROperands[5];
    clsROPERAND thirtyOneROperand, oneROperand, infROperand, unsignROperand, nanROperand;
    clsSELECTION_CONTEXT    selectContextInf;
    int i;
    float sinTable[ ] = { /*using p(x^2) to approx sin(PI*x)/x, only 4 terms, x range: 0.0~0.5*/
          3.141592741012573200000000f,
         -5.167710304260253900000000f,
          2.550069570541381800000000f,
         -0.598242759704589840000000f,
          0.077560372650623322000000f
    };

    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);
#if FULL_PROFILE_TEST
    if (CodeGenerator->hasNEW_SIN_COS_LOG_DIV)
    {
        return _GenFullProfileSinCosPiCode(
                        Compiler,
                        CodeGenerator,
                        PolynaryExpr,
                        OperandCount,
                        OperandsParameters,
                        IOperand
                        );
    }
#endif
    for(i = 0; i<4; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }
    /*last one is Integer, the even/odd for the sign */
    clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);

    for(i = 0; i<5; i++){
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&sinCoefROperands[i],
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) sinTable[i]);
    }
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) 1.0f);

    clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 31);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7fc00000);



    intermIOperands[1].dataType.elementType = clvTYPE_INT;
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[1],
                    &unsignROperand,
                    &OperandsParameters[0].rOperands[0]);

    status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectContextInf);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: |x| >=Inf ? return NAN*/
    intermROperands[1].dataType.elementType = clvTYPE_UINT;
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextInf,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[1],
                                                &infROperand
                                                );

    if (gcmIS_ERROR(status)) return status;


    /* The true part for |x| >= Inf */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);

    if (gcmIS_ERROR(status)) return status;

    status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &nanROperand);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInf,
                                            gcvFALSE);

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);
    /* Normal case, use polynomial approximation */
    {
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SIGN,
                    &intermIOperands[0],
                    &OperandsParameters[0].rOperands[0]);


        intermIOperands[1].dataType.elementType = clvTYPE_FLOAT;
        intermROperands[1].dataType.elementType = clvTYPE_FLOAT;
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FRACT,
                    &intermIOperands[2],
                    &intermROperands[1]);

        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FLOOR,
                    &intermIOperands[3],
                    &intermROperands[1]);

        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FLOAT_TO_INT,
                    &intermIOperands[4],
                    &intermROperands[3]);

        status = clGenShiftExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_LSHIFT,
                                    &intermIOperands[4],
                                    &intermROperands[4],
                                    &thirtyOneROperand);

        intermIOperands[0].dataType.elementType = clvTYPE_UINT;

        /*Get the right sign */
        status = clGenBitwiseExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_XOR_BITWISE,
                            &intermIOperands[0],
                            &intermROperands[0],
                            &intermROperands[4]);
        if (gcmIS_ERROR(status)) return status;

        /*r3 = 1-r2, sin(r2*PI) = sin(r3*PI) */
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &intermIOperands[3],
                                    &oneROperand,
                                    &intermROperands[2]);
        /* r1 = min(r3, r2)*/
        status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MIN,
                    &intermIOperands[1],
                    &intermROperands[2],
                    &intermROperands[3]);

        /* r2 = r1*r1, understand as x^2 for |x|<0.5*/
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[2],
                                    &intermROperands[1],
                                    &intermROperands[1]);
        /* The polynomial, with r1 <= 0.5 */
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    &intermIOperands[3],
                    &sinCoefROperands[4]);

        for(i = 3; i >= 0; i--){
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[2],
                                        &intermROperands[3]);
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[3],
                                        &sinCoefROperands[i]);
        }
        /* times x*/
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[2],
                                        &intermROperands[1],
                                        &intermROperands[3]);

        /*set the sign */
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        IOperand,
                                        &intermROperands[2],
                                        &intermROperands[0]);

    }

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);

    status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextInf);
    return gcvSTATUS_OK;
}



static gceSTATUS
_GenCosPiCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND        intermIOperands[5];
    clsROPERAND        intermROperands[5], sinCoefROperands[5];
    clsROPERAND thirtyOneROperand, oneROperand, infROperand, unsignROperand, nanROperand;
    clsROPERAND maxEvenIntROperand, zeroROperand, dot5ROperand;
    clsSELECTION_CONTEXT    selectContextInf, selectContextInt;
    int i;
    float sinTable[ ] = { /*using p(x^2) to approx sin(PI*x)/x, only 4 terms, x range: 0.0~0.5*/
          3.141592741012573200000000f,
         -5.167710304260253900000000f,
          2.550069570541381800000000f,
         -0.598242759704589840000000f,
          0.077560372650623322000000f
    };

    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);
#if FULL_PROFILE_TEST
    if (CodeGenerator->hasNEW_SIN_COS_LOG_DIV)
    {
        return _GenFullProfileSinCosPiCode(
                        Compiler,
                        CodeGenerator,
                        PolynaryExpr,
                        OperandCount,
                        OperandsParameters,
                        IOperand
                        );
    }
#endif
    for(i = 0; i<4; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }
    /*last one is Integer, the even/odd for the sign */
    clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);

    for(i = 0; i<5; i++){
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&sinCoefROperands[i],
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) sinTable[i]);
    }
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) 1.0f);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&dot5ROperand,
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) 0.50f);

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0);

    clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 31);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&maxEvenIntROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x7ffffffe);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7fc00000);

    /*Don't need to worry about input sign, since cosine is even function */

    intermIOperands[1].dataType.elementType = clvTYPE_INT;
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[1],
                    &unsignROperand,
                    &OperandsParameters[0].rOperands[0]);

    status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectContextInf);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: |x| >=Inf ? return NAN*/
    intermROperands[1].dataType.elementType = clvTYPE_UINT;
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextInf,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[1],
                                                &infROperand
                                                );

    if (gcmIS_ERROR(status)) return status;


    /* The true part for |x| >= Inf */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);

    if (gcmIS_ERROR(status)) return status;

    status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &nanROperand);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInf,
                                            gcvFALSE);

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);
    /* Real number, not Inf/Nan */
    {
        intermIOperands[1].dataType.elementType = clvTYPE_FLOAT;
        intermROperands[1].dataType.elementType = clvTYPE_FLOAT;
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FRACT,
                    &intermIOperands[2],
                    &intermROperands[1]);

    status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectContextInt);

    if (gcmIS_ERROR(status)) return status;

    /*frac === 0, return to (-1)^oddX */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextInt,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[2],
                                                &zeroROperand
                                                );

    if (gcmIS_ERROR(status)) return status;


    /* The true part for frac(x) == 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInt);

    if (gcmIS_ERROR(status)) return status;
    {
        /*Go the integer */
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FLOAT_TO_INT,
                    &intermIOperands[4],
                    &intermROperands[1]);
        /* We use 2 instructions to avoid branch. If select are ready, just one select*/
        /*Since overflow number return to int(7ffffffff), an odd number. Actually, overflow number are even */
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &intermIOperands[4],
                                    &maxEvenIntROperand,
                                    &intermROperands[4]);

        /* -1 return to zero, change the odd attribute, otherwise, keep the odd/even attribute*/
        status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MAX,
                    &intermIOperands[4],
                    &intermROperands[4],
                    &zeroROperand);

        status = clGenShiftExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_LSHIFT,
                                    &intermIOperands[4],
                                    &intermROperands[4],
                                    &thirtyOneROperand);

        IOperand->dataType.elementType = clvTYPE_UINT;
        /*Set the right sign */
        status = clGenBitwiseExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_OR_BITWISE,
                            IOperand,
                            &intermROperands[4],
                            &oneROperand);
        if (gcmIS_ERROR(status)) return status;
        IOperand->dataType.elementType = clvTYPE_FLOAT;
    }

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInt,
                                            gcvFALSE);

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInt);
    {
        /* Normal case, use polynomial approximation */
        /*First, add 0.5 then change to sine calculation, it is lossless adding*/
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &intermIOperands[1],
                                    &dot5ROperand,
                                    &intermROperands[1]);

        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FRACT,
                    &intermIOperands[2],
                    &intermROperands[1]);


        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FLOOR,
                    &intermIOperands[3],
                    &intermROperands[1]);

        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FLOAT_TO_INT,
                    &intermIOperands[4],
                    &intermROperands[3]);

        /*Don't need check overflow, since the number with frac never overflow */
        status = clGenShiftExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_LSHIFT,
                                    &intermIOperands[4],
                                    &intermROperands[4],
                                    &thirtyOneROperand);

        /*r3 = 1-r2, sin(r2*PI) = sin(r3*PI) */
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &intermIOperands[3],
                                    &oneROperand,
                                    &intermROperands[2]);
        /* r1 = min(r3, r2)*/
        status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MIN,
                    &intermIOperands[1],
                    &intermROperands[2],
                    &intermROperands[3]);

        /* r2 = r1*r1, understand as x^2 for |x|<0.5*/
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[2],
                                    &intermROperands[1],
                                    &intermROperands[1]);
        /* The polynomial, with r1 <= 0.5 */
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    &intermIOperands[3],
                    &sinCoefROperands[4]);

        for(i = 3; i >= 0; i--){
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[2],
                                        &intermROperands[3]);
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[3],
                                        &sinCoefROperands[i]);
        }
        /* times x*/
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[2],
                                        &intermROperands[1],
                                        &intermROperands[3]);

            IOperand->dataType.elementType = clvTYPE_UINT;
            /*Set the right sign */
            status = clGenBitwiseExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                IOperand,
                                &intermROperands[4],
                                &intermROperands[2]);
            if (gcmIS_ERROR(status)) return status;
            IOperand->dataType.elementType = clvTYPE_FLOAT;
    }

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInt);

    status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextInt);

    }

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);

    status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextInf);
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenTanPiCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND        intermIOperands[5];
    clsROPERAND        intermROperands[5], tanCoefROperands[7];
    clsROPERAND thirtyOneROperand, oneROperand, infROperand, unsignROperand, nanROperand;
    clsROPERAND zeroROperand, dot5ROperand, dot25ROperand, signROperand;
    clsSELECTION_CONTEXT    selectContextInf, selectContextHalfInt, selectContextOverQ;
    int i;
    float tanTable[ ] = { /*using p(x^2) to approx tan(PI*x)/x, only 4 terms, x range: 0.0~0.25*/
        3.141592741012573200000000f,
        10.335345268249512000000000f,
        40.822700500488281000000000f,
        161.130020141601560000000000f,
        733.329833984375000000000000f,
        851.943298339843750000000000f,
        27579.964843750000000000000000f
    };
    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);
#if FULL_PROFILE_TEST
    if (CodeGenerator->hasNEW_SIN_COS_LOG_DIV)
    {
        return _GenFullProfileTanPiCode(
                        Compiler,
                        CodeGenerator,
                        PolynaryExpr,
                        OperandCount,
                        OperandsParameters,
                        IOperand
                        );
    }
#endif
    for(i = 0; i<4; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }
    /*last one is Integer, the even/odd for the sign */
    clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);

    for(i = 0; i<7; i++){
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&tanCoefROperands[i],
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) tanTable[i]);
    }
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) 1.0f);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&dot5ROperand,
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) 0.50f);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&dot25ROperand,
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) 0.250f);

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0);

    clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 31);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x80000000);


    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7fc00000);

    /*input sign, since tan is an odd function */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SIGN,
                &intermIOperands[0],
                &OperandsParameters[0].rOperands[0]);

    intermIOperands[1].dataType.elementType = clvTYPE_INT;
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[1],
                    &unsignROperand,
                    &OperandsParameters[0].rOperands[0]);

    status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectContextInf);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: |x| >=Inf ? return NAN*/
    intermROperands[1].dataType.elementType = clvTYPE_UINT;
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextInf,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[1],
                                                &infROperand
                                                );

    if (gcmIS_ERROR(status)) return status;


    /* The true part for |x| >= Inf */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);

    if (gcmIS_ERROR(status)) return status;

    status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &nanROperand);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInf,
                                            gcvFALSE);

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);
    /* Real number, not Inf/Nan */
    {
        intermIOperands[1].dataType.elementType = clvTYPE_FLOAT;
        intermROperands[1].dataType.elementType = clvTYPE_FLOAT;
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FRACT,
                    &intermIOperands[2],
                    &intermROperands[1]);


    status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectContextHalfInt);

    if (gcmIS_ERROR(status)) return status;

    /*frac === 0.5, return to Sign(x)*(-1)^oddX * Inf */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextHalfInt,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[2],
                                                &dot5ROperand
                                                );

    if (gcmIS_ERROR(status)) return status;


    /* The true part for frac(x) == 0.5 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextHalfInt);

    if (gcmIS_ERROR(status)) return status;
    {
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FLOAT_TO_INT,
                    &intermIOperands[4],
                    &intermROperands[1]);

        status = clGenShiftExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_LSHIFT,
                                    &intermIOperands[4],
                                    &intermROperands[4],
                                    &thirtyOneROperand);

        intermIOperands[0].dataType.elementType = clvTYPE_UINT;

        /*Get the right sign */
        status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_XOR_BITWISE,
                    &intermIOperands[0],
                            &intermROperands[0],
                            &intermROperands[4]);
        if (gcmIS_ERROR(status)) return status;


        /*Set the right sign to Inf */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperands[0],
                                    &infROperand);
        if (gcmIS_ERROR(status)) return status;

    }

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextHalfInt,
                                            gcvFALSE);

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextHalfInt);
    {
        intermIOperands[1].dataType.elementType = clvTYPE_FLOAT;
        intermROperands[1].dataType.elementType = clvTYPE_FLOAT;
        /* Normal case, use polynomial approximation, we need to seperate frac(x) > 0.25 or not */

        /*r3 = 1-r2, tan(r2*PI) = -tan(r3*PI) */
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &intermIOperands[3],
                                    &oneROperand,
                                    &intermROperands[2]);

        /* r1 = min(r3, r2)*/
        status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MIN,
                    &intermIOperands[1],
                    &intermROperands[2],
                    &intermROperands[3]);
        /*Calculate the sign */
        {
            intermIOperands[4].dataType.elementType = clvTYPE_FLOAT;
            /*min(1-r2, r2) - r2, if it is Neg, it means r1 = 1-r2, we need change sign*/
            status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &intermIOperands[4],
                                    &intermROperands[1],
                                    &intermROperands[2]);

            intermIOperands[4].dataType.elementType = clvTYPE_UINT;
            /*Keep the sign of r4, get rid of noise */
            status = clGenBitwiseExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &intermIOperands[4],
                                &signROperand,
                                &intermROperands[4]);
            if (gcmIS_ERROR(status)) return status;

            intermIOperands[0].dataType.elementType = clvTYPE_UINT;
            /*Get the right sign */
            status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_XOR_BITWISE,
                    &intermIOperands[0],
                                &intermROperands[0],
                                &intermROperands[4]);
            if (gcmIS_ERROR(status)) return status;
        }

    status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &selectContextOverQ);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: frac(x) >= 0.25 ? return 1./tan(Pi*(0.5 - x))*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextOverQ,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[1],
                                                &dot25ROperand
                                                );

    if (gcmIS_ERROR(status)) return status;


    /* The true part for |x| >= 0.25 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextOverQ);

    if (gcmIS_ERROR(status)) return status;
    {
        /*r1 = 0.5 - r1 */
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &intermIOperands[1],
                                    &dot5ROperand,
                                    &intermROperands[1]);

        /* r2 = r1*r1, understand as x^2 for |x|<0.25*/
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[2],
                                    &intermROperands[1],
                                    &intermROperands[1]);
        /* The polynomial, with r1 <= 0.25 */
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    &intermIOperands[3],
                    &tanCoefROperands[6]);

        for(i = 5; i >= 0; i--){
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[2],
                                        &intermROperands[3]);
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[3],
                                        &tanCoefROperands[i]);
        }
        /* times x*/
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[2],
                                        &intermROperands[1],
                                        &intermROperands[3]);
        /*Reciprocal r1 = 1/r2 */
        intermROperands[2].dataType.elementType = clvTYPE_FLOAT;
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INVERSE,
                &intermIOperands[1],
                &intermROperands[2]);

        /*N-R, r2 = r1 + r1*(1-r2*r1) since r1 >= 1.0, no corner case to worry about */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[3],
                                        &intermROperands[1],
                                        &intermROperands[2]);

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[2],
                                        &oneROperand,
                                        &intermROperands[3]);


    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[1],
                                        &intermROperands[2]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[2],
                                        &intermROperands[1],
                                        &intermROperands[3]);

    }
    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextOverQ,
                                            gcvFALSE);

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextOverQ);
    {

        /* r2 = r1*r1, understand as x^2 for |x|<0.25*/
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[2],
                                    &intermROperands[1],
                                    &intermROperands[1]);
        /* The polynomial, with r1 <= 0.25 */
    status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    &intermIOperands[3],
                    &tanCoefROperands[6]);

        for(i = 5; i >= 0; i--){
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[2],
                                        &intermROperands[3]);
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[3],
                                        &tanCoefROperands[i]);
        }
        /* times x*/
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[2],
                                        &intermROperands[1],
                                        &intermROperands[3]);
        }
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextOverQ);

        status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextOverQ);
        /*set the sign */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                        &intermROperands[2],
                                        &intermROperands[0]);

    }

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextHalfInt);

    status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextHalfInt);

    }

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);

    status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextInf);
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenCbrtCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsSELECTION_CONTEXT    selectContextInf,selectionContext1;
    clsLOPERAND firstLOperand[1], secondLOperand[1];
    clsROPERAND zeroROperand, threeROperand, oneTwentySevenROperand, twentyThreeROperand, twentyThreeLongROperand;
    clsROPERAND maskROperand, addROperand, maskTwoROperand, maskThreeROperand;
    clsROPERAND oneOver3ROperand, thirteenROperand;
    clsIOPERAND signIOperand, extraIOperands[4];
    clsROPERAND signROperand, extraROperands[4];
    clsIOPERAND secondIntermIOperand[1];
    clsIOPERAND intermIOperands[20];
    clsROPERAND intermROperands[20];



    clsIOPERAND_New(Compiler, secondIntermIOperand, clmGenCodeDataType(T_FLOAT));

    clsLOPERAND_InitializeUsingIOperand(firstLOperand, IOperand);
    clsLOPERAND_InitializeUsingIOperand(secondLOperand, secondIntermIOperand);


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) 0.0);
    clsROPERAND_InitializeIntOrIVecConstant(&threeROperand,
                                            clmGenCodeDataType(T_SHORT),
                                            (gctUINT16) 3);
    clsROPERAND_InitializeIntOrIVecConstant(&oneTwentySevenROperand,
                                            clmGenCodeDataType(T_SHORT),
                                            (gctUINT16) 127);
    clsROPERAND_InitializeIntOrIVecConstant(&twentyThreeROperand,
                                            clmGenCodeDataType(T_SHORT),
                                            (gctUINT16) 23);
    clsROPERAND_InitializeIntOrIVecConstant(&twentyThreeLongROperand,
                                            clmGenCodeDataType(T_SHORT),
                                            (gctUINT16) 23);
    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7f800000);
    clsROPERAND_InitializeIntOrIVecConstant(&addROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 127);
    clsROPERAND_InitializeIntOrIVecConstant(&maskTwoROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x007fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&maskThreeROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x3F800000);

    clsROPERAND_InitializeIntOrIVecConstant(&oneOver3ROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0xaab);
    clsROPERAND_InitializeIntOrIVecConstant(&thirteenROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 13);

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);



    /* get the sign */
    clsIOPERAND_New(Compiler, &signIOperand, clmGenCodeDataType(T_FLOAT));

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SIGN,
                &signIOperand,
                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    clsIOPERAND_New(Compiler, &extraIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&extraROperands[0], &extraIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &extraIOperands[0],
                                &maskROperand,
                                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /*For Infinit, Nan, just return the input */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextInf);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: x == Inf? */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextInf,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &extraROperands[0],
                                                &maskROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for x == INF */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);

    if (gcmIS_ERROR(status)) return status;

    status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &OperandsParameters[0].rOperands[0]);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInf,
                                            gcvFALSE);

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);
    /* shift right by 23 */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &intermIOperands[0],
                                &extraROperands[0],
                                &twentyThreeLongROperand);

    if (gcmIS_ERROR(status)) return status;

    /* sub from result */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[1],
                                &intermROperands[0],
                                &addROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: x != 0.0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_NOT_EQUAL,
                                                &OperandsParameters[0].rOperands[0],
                                                &zeroROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for x != 0.0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* get mant x */
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &intermIOperands[2],
                                &maskTwoROperand,
                                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* get exponent part to convert to float */
    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                &intermIOperands[3],
                                &maskThreeROperand,
                                &intermROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    /* mod exponent of x */
    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);

    /* div n by 3, r6 = ((n * 0xaab)>>13) - (n>>13) */
    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[4],
                                    &intermROperands[1],
                                    &oneOver3ROperand);

    if (gcmIS_ERROR(status)) return status;


    status = clGenShiftExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_RSHIFT,
                                    &intermIOperands[5],
                                    &intermROperands[4],
                                    &thirteenROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clGenShiftExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_RSHIFT,
                                    &intermIOperands[4],
                                    &intermROperands[1],
                                    &thirteenROperand);
    if (gcmIS_ERROR(status)) return status;


    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &intermIOperands[6],
                                    &intermROperands[5],
                                    &intermROperands[4]);


    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[5],
                                    &intermROperands[6],
                                    &threeROperand);
    /* r4 = n - (n/3)*3 */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &intermIOperands[4],
                                    &intermROperands[1],
                                    &intermROperands[5]);

    if (gcmIS_ERROR(status)) return status;

    /* add to result, 127 */
    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[7],
                                    &intermROperands[6],
                                    &oneTwentySevenROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift result 23 bits */
    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[8],
                                &intermROperands[7],
                                &twentyThreeROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add exp mod 3 127 */
    clsIOPERAND_New(Compiler, &extraIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &extraIOperands[1],
                                    &intermROperands[4],
                                    &oneTwentySevenROperand);

    if (gcmIS_ERROR(status)) return status;

    /* shift result 23 bits */
    clsIOPERAND_New(Compiler, &extraIOperands[2], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&extraROperands[1], &extraIOperands[1]);

    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &extraIOperands[2],
                                &extraROperands[1],
                                &twentyThreeROperand);

    if (gcmIS_ERROR(status)) return status;



    /* mul result by mantissa */
    clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&extraROperands[2], &extraIOperands[2]);

    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[13],
                                    &extraROperands[2],
                                    &intermROperands[3]);

    if (gcmIS_ERROR(status)) return status;

    /* log2 result */
    clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[13]);

    status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LOG2,
                            &intermIOperands[14],
                            &intermROperands[13]);

    if (gcmIS_ERROR(status)) return status;

    /* div result by 3 */
    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_DIV,
                                    &intermIOperands[15],
                                    &intermROperands[14],
                                    &threeROperand);

    if (gcmIS_ERROR(status)) return status;

    /* exp2 result */
    clsIOPERAND_New(Compiler, &intermIOperands[16], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);
    clsIOPERAND_New(Compiler, &intermIOperands[17], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[17]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);


    status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_EXP2,
                            &intermIOperands[16],
                            &intermROperands[15]);

    if (gcmIS_ERROR(status)) return status;

    /* For full profile, we need 2.0 ULP, iteration required*/
    if(CodeGenerator->supportRTNE)
    {
        clsROPERAND twoROperand;
        clsROPERAND_InitializeIntOrIVecConstant(&twoROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x2);

        clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);
        clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);

        /*For the calibrate to reach full profile precision*/
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[10],
                    &intermROperands[16],
                    &intermROperands[16]);

        /*Get (x^(1/3))^3 */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[9],
                    &intermROperands[16],
                    &intermROperands[10]);


        intermIOperands[9].dataType.elementType = clvTYPE_INT;
        intermROperands[9].dataType.elementType = clvTYPE_INT;

        intermIOperands[10].dataType.elementType = clvTYPE_INT;
        intermROperands[10].dataType.elementType = clvTYPE_INT;
        intermROperands[13].dataType.elementType = clvTYPE_INT;
        intermIOperands[16].dataType.elementType = clvTYPE_INT;
        intermROperands[16].dataType.elementType = clvTYPE_INT;

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SUB,
                    &intermIOperands[9],
                    &intermROperands[13],
                    &intermROperands[9]);

        status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &intermIOperands[10],
                                &intermROperands[9],
                                &twoROperand);

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD,
                    &intermIOperands[16],
                    &intermROperands[16],
                    &intermROperands[10]);

        intermROperands[13].dataType.elementType = clvTYPE_FLOAT;
        intermIOperands[16].dataType.elementType = clvTYPE_FLOAT;
        intermROperands[16].dataType.elementType = clvTYPE_FLOAT;

    }

    /* get final x^(1/3) */



    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[17],
                &intermROperands[16],
                &intermROperands[8]);

    if (gcmIS_ERROR(status)) return status;





    /* multiply result by sign */

    clsROPERAND_InitializeUsingIOperand(&signROperand, &signIOperand);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                IOperand,
                &intermROperands[17],
                &signROperand);

    if (gcmIS_ERROR(status)) return status;




    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext1,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;




    /* The false part, x is zero */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;



    /* mov 0 into mantissa, since x is zero */

    status = clGenAssignCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                firstLOperand,
                &zeroROperand);

    if (gcmIS_ERROR(status)) return status;






    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;


    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInf);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextInf);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}


static gceSTATUS
_GenHypotCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND intermIOperands[34];
    clsROPERAND intermROperands[34];
    clsROPERAND twoROperand;
    clsIOPERAND expIOperands[3];
    clsROPERAND expROperands[3];
    clsROPERAND maskROperand, smallROperand, rcpROperand,unsignROperand;
    int i;

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                                            clmGenCodeDataType(T_FLOAT),
                                            (gctFLOAT) 2.0);


    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                                            clmGenCodeDataType(T_UINT),
                                            (gctUINT) 0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&rcpROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x7f000000);

    clsROPERAND_InitializeIntOrIVecConstant(&smallROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x00800000);
    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x7fffffff);


    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    for(i = 0; i<34; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    /*Get Absolute value */
    for(i = 0; i<2; i++){
        intermIOperands[i].dataType.elementType = clvTYPE_INT;
        status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[i],
                        &unsignROperand,
                        &OperandsParameters[i].rOperands[0]);
        if (gcmIS_ERROR(status)) return status;
    }
    intermROperands[0].dataType.elementType = clvTYPE_INT;
    intermROperands[1].dataType.elementType = clvTYPE_INT;
    intermIOperands[13].dataType.elementType = clvTYPE_INT;
    intermIOperands[14].dataType.elementType = clvTYPE_INT;
    /*Get Max of the |x|, |y|, integer comparison, otherwise, if Nan involve, cannot get it */
    status = clGenGenericCode2(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MAX,
                &intermIOperands[13],
                &intermROperands[0],
                &intermROperands[1]);
    if (gcmIS_ERROR(status)) return status;

    status = clGenGenericCode2(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MIN,
                &intermIOperands[14],
                &intermROperands[0],
                &intermROperands[1]);
    if (gcmIS_ERROR(status)) return status;
    intermROperands[0].dataType.elementType = clvTYPE_FLOAT;
    intermROperands[1].dataType.elementType = clvTYPE_FLOAT;

    for(i = 0; i<2; i++){
        clsIOPERAND_New(Compiler, &expIOperands[i], clmGenCodeDataType(T_INT));
        clsROPERAND_InitializeUsingIOperand(&expROperands[i], &expIOperands[i]);
    }
    /*Get the exponential part */
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &expIOperands[1],
                        &maskROperand,
                        &intermROperands[13]);

    if (gcmIS_ERROR(status)) return status;


    /*Get the rcp of 2^n of Max(|x|, |y|} */
    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &expIOperands[0],
                                &rcpROperand,
                                &expROperands[1]);
    if (gcmIS_ERROR(status)) return status;

    /* avoid extreme case, we have rcp non-zero*/
    status = clGenGenericCode2(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MAX,
                &expIOperands[0],
                &smallROperand,
                &expROperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /*Scale |x|, |y| */
    for(i = 0; i<2; i++){
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[i+2],
                                &intermROperands[i],
                                &expROperands[0]);
        if (gcmIS_ERROR(status)) return status;

        /* x^2 or y^2*/
        status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[i+4],
                        &intermROperands[i+2],
                        &intermROperands[i+2]);
        if (gcmIS_ERROR(status)) return status;
        /*Small part */
        status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MULLO_RTZ,
                        &intermIOperands[i+6],
                        &intermROperands[i+2],
                        &intermROperands[i+2]);
        if (gcmIS_ERROR(status)) return status;
    }

    /*main part of |x|^2 + |y|^2 */
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[8],
                    &intermROperands[4],
                    &intermROperands[5]);
    if (gcmIS_ERROR(status)) return status;

    /*Low part of x^2 + y^2 */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[9],
                &intermROperands[6],
                &intermROperands[7]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADDLO_RTZ,
                    &intermIOperands[6],
                    &intermROperands[4],
                    &intermROperands[5]);
    if (gcmIS_ERROR(status)) return status;

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[9],
                &intermROperands[6],
                &intermROperands[9]);

    /*Low part *2 */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[10],
                &intermROperands[9],
                &twoROperand);
    /*Low part + mainPart */
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[11],
                    &intermROperands[10],
                    &intermROperands[8]);
    if (gcmIS_ERROR(status)) return status;

    /*sqrt */
    status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SQRT,
                        &intermIOperands[12],
                        &intermROperands[11]);
    if (gcmIS_ERROR(status)) return status;

    /*Multiply back the scale */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &expIOperands[1],
                &rcpROperand,
                &expROperands[0]);
    if (gcmIS_ERROR(status)) return status;

    {
        clsSELECTION_CONTEXT    selectContextInf;
        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextInf);

        if (gcmIS_ERROR(status)) return status;

        /* The condition part: x == Inf? */
        intermROperands[14].dataType.elementType = clvTYPE_INT;
        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInf,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &intermROperands[14],
                                                    &maskROperand);

        if (gcmIS_ERROR(status)) return status;

        /* The true part for x == INF */
        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInf);

        if (gcmIS_ERROR(status)) return status;
        /* Return to Inf*/
        status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &maskROperand);

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectContextInf,
                                                gcvFALSE);

        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInf);
        /*Normal cases, scale back */
        status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_MUL, /* Depends on the rounding mode */
            IOperand,
            &intermROperands[12],
            &expROperands[1]);
        if (gcmIS_ERROR(status)) return status;

        if ((CodeGenerator->chipModel <= gcv2100 && CodeGenerator->chipRevision <= 0x5130) ||
        (CodeGenerator->chipModel == gcv4000 &&
         (CodeGenerator->chipRevision == 0x5208 || CodeGenerator->chipRevision == 0x5222 ||
            CodeGenerator->chipRevision == 0x4633)))
    {
        clsROPERAND_InitializeUsingIOperand(&intermROperands[0], IOperand);
        clmGEN_CODE_IF(Compiler,  /*IF_F */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[0],
                 clvCONDITION_EQUAL,
                 &maskROperand);
        clmGEN_CODE_IF(Compiler,  /*IF_G */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[13],
                 clvCONDITION_EQUAL,
                 &maskROperand);
        /* Max(|x|, |y|) == Inf, return to inf*/
       clmGEN_CODE_ELSE(Compiler, /*IF_G */
                       CodeGenerator,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo);

        /*GC2100, calculate to inf, but max(|x|, |y|) < Inf, return to finite */

        IOperand->dataType.elementType = clvTYPE_INT;

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_XOR_BITWISE,
                    IOperand,
                    &smallROperand,
                    &unsignROperand);

        IOperand->dataType.elementType = clvTYPE_FLOAT;

       clmGEN_CODE_ENDIF(Compiler, /*IF_G*/
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

       clmGEN_CODE_ELSE(Compiler, /*IF_F */
                       CodeGenerator,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo);
       /*Finite return, do nothing */
       clmGEN_CODE_ENDIF(Compiler, /*IF_F*/
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);
    }


        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextInf);
        status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextInf);
    }
    return gcvSTATUS_OK;
OnError:
    return status;
}

static gceSTATUS
_GenPow0Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS            status;
    clsLOPERAND            lOperand;
    clsROPERAND            constantROperand;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);
    gcmASSERT(clmIsElementTypeFloating(clmGEN_CODE_elementType_GET(IOperand->dataType)));

    /* mov result, 1.0 */
    clsLOPERAND_InitializeUsingIOperand(&lOperand, IOperand);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantROperand,
                              IOperand->dataType,
                              (gctFLOAT)1.0);

    status = clGenAssignCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                &lOperand,
                &constantROperand);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenPow1Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS            status;
    clsLOPERAND            lOperand;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* mov result, x */
    clsLOPERAND_InitializeUsingIOperand(&lOperand, IOperand);

    status = clGenAssignCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                &lOperand,
                &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenPow2Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS            status;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* mul result, x, x */
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &OperandsParameters[0].rOperands[0],
                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenPow3Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS        status;
    clsIOPERAND        intermIOperand;
    clsROPERAND        intermROperand;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* mul t0, x, x */
    clsIOPERAND_New(Compiler, &intermIOperand, OperandsParameters[0].dataTypes[0].def);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperand,
                    &OperandsParameters[0].rOperands[0],
                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, t0, x */
    clsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperand,
                                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenPow4Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS        status;
    clsIOPERAND        intermIOperand;
    clsROPERAND        intermROperand;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* mul t0, x, x */
    clsIOPERAND_New(Compiler, &intermIOperand, OperandsParameters[0].dataTypes[0].def);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperand,
                                    &OperandsParameters[0].rOperands[0],
                                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, t0, t0 */
    clsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperand,
                                    &intermROperand);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenPow5Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS        status;
    clsIOPERAND        intermIOperands[2];
    clsROPERAND        intermROperands[2];

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* mul t0, x, x */
    clsIOPERAND_New(Compiler, &intermIOperands[0], OperandsParameters[0].dataTypes[0].def);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0],
                                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul t1, t0, t0 */
    clsIOPERAND_New(Compiler, &intermIOperands[1], OperandsParameters[0].dataTypes[0].def);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[1],
                                    &intermROperands[0],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, t1, x */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperands[1],
                                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenPow6Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS        status;
    clsIOPERAND        intermIOperands[2];
    clsROPERAND        intermROperands[2];

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* mul t0, x, x */
    clsIOPERAND_New(Compiler, &intermIOperands[0], OperandsParameters[0].dataTypes[0].def);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0],
                                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul t1, t0, t0 */
    clsIOPERAND_New(Compiler, &intermIOperands[1], OperandsParameters[0].dataTypes[0].def);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[1],
                                    &intermROperands[0],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, t1, t0 */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperands[1],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenPow8Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS        status;
    clsIOPERAND        intermIOperands[2];
    clsROPERAND        intermROperands[2];

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* mul t0, x, x */
    clsIOPERAND_New(Compiler, &intermIOperands[0], OperandsParameters[0].dataTypes[0].def);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0],
                                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul t1, t0, t0 */
    clsIOPERAND_New(Compiler, &intermIOperands[1], OperandsParameters[0].dataTypes[0].def);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[1],
                                    &intermROperands[0],
                                    &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, t1, t1 */
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenArithmeticExprCode(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    IOperand,
                                    &intermROperands[1],
                                    &intermROperands[1]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

typedef gceSTATUS
(* cltGEN_POW_N_CODE_FUNC_PTR)(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    );

#define POW_N_COUNT        9

const cltGEN_POW_N_CODE_FUNC_PTR        GenPowNCodeTable[POW_N_COUNT] =
{
    _GenPow0Code,
    _GenPow1Code,
    _GenPow2Code,
    _GenPow3Code,
    _GenPow4Code,
    _GenPow5Code,
    _GenPow6Code,
    gcvNULL,
    _GenPow8Code
};

static gceSTATUS
_GenPowCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS                    status;
    gctINT                        i;
    float coefLog2H[] = {1.4426950f,    -0.72134751f, 0.48090076f, -0.36067486f,
            0.28838408f, -0.24014819f,  0.20910098f, -0.19027853f,
            0.15066716f, -0.064344354f};
    float coefLog2L[] = { (float)(1.3270738e-008), (float)(-2.6557434e-008),};
                            /*mantissa > 1.5,  x^y very small */
    clsSELECTION_CONTEXT    slctCntxtOverDot5, slctCntxtSmallPow;
    clsROPERAND coefROperand[12];
    clsROPERAND zeroROperand, oneROperand, maskROperand, expMaskROperand;
    clsROPERAND twenty3ROperand, one27ROperand, hideOneROperand,oneDot5ROperand;
    clsROPERAND twenty4To1ROperand,oneTo24ROperand, twenty5To1ROperand, logE2ROperand;
    clsIOPERAND expIOperand, mantissaIOperand, tempIOperand;
    clsIOPERAND fMantissaIOperand, fExpIOperand, yTimeLog2IOperand0, yTimeLog2IOperand1;
    clsIOPERAND sumPolyIOperand, multiPolyIOperand;
    clsIOPERAND sumEpsIOperand0, sumEpsIOperand1;
    clsROPERAND tempROperand;
    clsROPERAND expROperand; /*The exponential part of X */
    clsROPERAND mantissaROperand; /* Mantissa part of X*/
    /*float type: mantissa-1, floating point of exp, y*Log2*/
    clsROPERAND fMantissaROperand, fExpROperand, yTimeLog2ROperand0, yTimeLog2ROperand1;
    /*sum of polynomial, MUltiple to x, eps0, eps1 */
    clsROPERAND sumPolyROperand, multiPolyROperand, sumEpsROperand0, sumEpsROperand1;


    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    for(i = 0; i<10; i++){
        clsROPERAND_InitializeFloatOrVecOrMatConstant(& coefROperand[i],
                                        clmGenCodeDataType(T_FLOAT),
                                        coefLog2H[i]);
    }
    clsROPERAND_InitializeFloatOrVecOrMatConstant(& coefROperand[i],
                                    clmGenCodeDataType(T_FLOAT),
                                    coefLog2L[0]);
    i++;
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&coefROperand[i],
                                    clmGenCodeDataType(T_FLOAT),
                                    coefLog2L[1]);

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0);
    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            1);
    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x007fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&oneDot5ROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x00400000);
    clsROPERAND_InitializeIntOrIVecConstant(&expMaskROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x7f800000);
    clsROPERAND_InitializeIntOrIVecConstant(&hideOneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x00800000);
    clsROPERAND_InitializeIntOrIVecConstant(&twenty3ROperand,
                                            clmGenCodeDataType(T_UINT),
                                            23);
    clsROPERAND_InitializeIntOrIVecConstant(&one27ROperand,
                                            clmGenCodeDataType(T_UINT),
                                            127);
    /*1/2^24,*/
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twenty4To1ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (float)1.1920929e-007 );
    /*2^24,*/
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneTo24ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (float)(1<<24) );

    /*1/2^25,*/
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twenty5To1ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (float)(1.1920929e-007)/2.0f );

    /*Log(e,2), use for Taylor expansion for espilon term */
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logE2ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        0.69314718055994530941723212145818f );

    clsIOPERAND_New(Compiler, &expIOperand, clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&expROperand, &expIOperand);
    /* exp = X & 0x7f800000 */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &expIOperand,
                &expMaskROperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    clsIOPERAND_New(Compiler, &tempIOperand, clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&tempROperand, &tempIOperand);
    /* temp = exp >> 23 */
    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_RSHIFT,
                &tempIOperand,
                &expROperand,
                &twenty3ROperand);
    if (gcmIS_ERROR(status)) return status;

    /*exp = temp - 127 */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &expIOperand,
                                    &tempROperand,
                                    &one27ROperand);

    if (gcmIS_ERROR(status)) return status;




    clsIOPERAND_New(Compiler, &mantissaIOperand, clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&mantissaROperand, &mantissaIOperand);

    /* mantissa = X & 0x007fffff*/
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &mantissaIOperand,
                &maskROperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    clsIOPERAND_New(Compiler, &fMantissaIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&fMantissaROperand, &fMantissaIOperand);


    /* The selection begins, for mantissa > 1.5? */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &slctCntxtOverDot5);

    if (gcmIS_ERROR(status)) return status;

    /*  */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &slctCntxtOverDot5,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &mantissaROperand,
                                                &oneDot5ROperand);

    if (gcmIS_ERROR(status)) return status;

    /* When Mantissa > 1.5, use mantissa/2 to calculate Log(mantissa) */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &slctCntxtOverDot5);
    if (gcmIS_ERROR(status)) return status;

    /*exp = exp + 1 */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &expIOperand,
                                    &expROperand,
                                    &oneROperand);
    if (gcmIS_ERROR(status)) return status;

    /*temp = 2 - (mantissaX + HideOne) = HideOne - mantissaX  */
    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &tempIOperand,
                                &mantissaROperand,
                                &hideOneROperand);
    if (gcmIS_ERROR(status)) return status;

    /* i2F */
    fMantissaIOperand.dataType.elementType = clvTYPE_INT;
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INT_TO_FLOAT,
                &fMantissaIOperand,
                &tempROperand);
    if (gcmIS_ERROR(status)) return status;
    fMantissaIOperand.dataType.elementType = clvTYPE_FLOAT;

    /* scale to right float value. 2^25 instead of 1/2^24, use: 1-mantissa/2*/
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &fMantissaIOperand,
                                    &fMantissaROperand,
                                    &twenty5To1ROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &slctCntxtOverDot5,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* For mantissa < 1.5, use mantissaX - 1*/
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &slctCntxtOverDot5);
    if (gcmIS_ERROR(status)) return status;

    /* i2F, not hideOne, so it is mantissaX - 1 already */
    fMantissaIOperand.dataType.elementType = clvTYPE_INT;
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INT_TO_FLOAT,
                &fMantissaIOperand,
                &mantissaROperand);
    if (gcmIS_ERROR(status)) return status;
    fMantissaIOperand.dataType.elementType = clvTYPE_FLOAT;

    /* scale to right float value, hidenOne->1.0*/
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &fMantissaIOperand,
                                    &fMantissaROperand,
                                    &twenty4To1ROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &slctCntxtOverDot5);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &slctCntxtOverDot5);
    if (gcmIS_ERROR(status)) return status;

    clsIOPERAND_New(Compiler, &fExpIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&fExpROperand, &fExpIOperand);
    /*Make the exp part into floating point, later times Y */
    /*destination decide input type, float*/
    fExpIOperand.dataType.elementType = clvTYPE_INT;
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INT_TO_FLOAT,
                &fExpIOperand,
                &expROperand);
    if (gcmIS_ERROR(status)) return status;
    /*back to float */
    fExpIOperand.dataType.elementType = clvTYPE_FLOAT;

    /*Now start the polynomial approximation*/
    clsIOPERAND_New(Compiler, &sumPolyIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&sumPolyROperand, &sumPolyIOperand);

    clsIOPERAND_New(Compiler, &multiPolyIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&multiPolyROperand, &multiPolyIOperand);

    clsIOPERAND_New(Compiler, &sumEpsIOperand0, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&sumEpsROperand0, &sumEpsIOperand0);

    clsIOPERAND_New(Compiler, &sumEpsIOperand1, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&sumEpsROperand1, &sumEpsIOperand1);

    clsIOPERAND_New(Compiler, &yTimeLog2IOperand0, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&yTimeLog2ROperand0, &yTimeLog2IOperand0);

    clsIOPERAND_New(Compiler, &yTimeLog2IOperand1, clmGenCodeDataType(T_FLOAT));

    clsROPERAND_InitializeUsingIOperand(&yTimeLog2ROperand1, &yTimeLog2IOperand1);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &multiPolyIOperand,
                &fMantissaROperand,
                &coefROperand[9]);
    if (gcmIS_ERROR(status)) return status;

    for(i = 8; i>=0; i--){
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &sumPolyIOperand,
                &coefROperand[i],
                &multiPolyROperand);
        if (gcmIS_ERROR(status)) return status;
        if(i <= 3){ /*Eps part. */
            status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADDLO_RTZ,
                i == 3? &sumEpsIOperand1 : &sumEpsIOperand0,
                &coefROperand[i],
                &multiPolyROperand);
            if (gcmIS_ERROR(status)) return status;
            if(i<3){ /* Accumulate the with previous eps*/
                status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &sumEpsIOperand1,
                    &sumEpsROperand0,
                    &sumEpsROperand1);
                if (gcmIS_ERROR(status)) return status;
                if(i<2){ /*the low part of the coefficients */
                    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &sumEpsIOperand1,
                        &coefROperand[10+i],
                        &sumEpsROperand1);
                    if (gcmIS_ERROR(status)) return status;
                }
            }
        }

        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &multiPolyIOperand,
                &fMantissaROperand,
                &sumPolyROperand);
        if (gcmIS_ERROR(status)) return status;

        if(i <= 3){
            /*The previous sumEps also need involve polynomial powers */
            status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &sumEpsIOperand1,
                &fMantissaROperand,
                &sumEpsROperand1);
            if (gcmIS_ERROR(status)) return status;

            status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULLO_RTZ,
                &sumEpsIOperand0,
                &fMantissaROperand,
                &sumPolyROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &sumEpsIOperand1,
                &sumEpsROperand0,
                &sumEpsROperand1);
            if (gcmIS_ERROR(status)) return status;
        }
    }
    /*After All, log2(MantissaX) + ExpOfX = log2(X)  */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ADD_RTZ,
            &yTimeLog2IOperand0,
            &multiPolyROperand,
            &fExpROperand);
    if (gcmIS_ERROR(status)) return status;

    /*collect the epsilon term */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ADDLO_RTZ,
            &sumEpsIOperand0,
            &multiPolyROperand,
            &fExpROperand);
    if (gcmIS_ERROR(status)) return status;

    /*accumulate the epsilon term */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ADD_RTZ,
            &sumEpsIOperand1,
            &sumEpsROperand0,
            &sumEpsROperand1);
    if (gcmIS_ERROR(status)) return status;

    /*times Y, (log2X)*Y */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_MUL_RTZ,
            &yTimeLog2IOperand1,
            &yTimeLog2ROperand0,
            &OperandsParameters[1].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /*epsilon term also needs to time Y */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_MUL_RTZ,
            &sumEpsIOperand0,
            &sumEpsROperand1,
            &OperandsParameters[1].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /*collect the epsilon term */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_MULLO_RTZ,
            &sumEpsIOperand1,
            &yTimeLog2ROperand0,
            &OperandsParameters[1].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /*accumulate the epsilon term */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ADD_RTZ,
            &sumEpsIOperand1,
            &sumEpsROperand0,
            &sumEpsROperand1);
    if (gcmIS_ERROR(status)) return status;


    /*After accumulation, perhapes espilon is too big to use Taylor expension*/
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ADD_RTZ,
            &yTimeLog2IOperand0,
            &yTimeLog2ROperand1,
            &sumEpsROperand1);
    if (gcmIS_ERROR(status)) return status;
    /*Get the epsilon term */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ADDLO_RTZ,
            &sumEpsIOperand0,
            &yTimeLog2ROperand1,
            &sumEpsROperand1);
    if (gcmIS_ERROR(status)) return status;



    /*Calculate main part of x^y = 2^(y*Log2(x)) */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_EXP2,
                &fExpIOperand,
                &yTimeLog2ROperand0);
    if (gcmIS_ERROR(status)) return status;

    /*    Take care epsilon term 2^eps = 1.0 + eps*log(e,2)*/
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_MUL_RTZ,
            &sumEpsIOperand1,
            &logE2ROperand,
            &sumEpsROperand0);
    if (gcmIS_ERROR(status)) return status;

    /* x^y = mainPart + mainPart*eps, if mainPart too small, mainPart*eps=0*/
    status = clDefineSelectionBegin(Compiler,
                                CodeGenerator,
                                gcvTRUE,
                                &slctCntxtSmallPow);

    if (gcmIS_ERROR(status)) return status;

    /* Use integer comparison, avoid inf, Nan case */
    fExpROperand.dataType.elementType = clvTYPE_INT;
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &slctCntxtSmallPow,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN,
                                                &fExpROperand,
                                                &twenty4To1ROperand);
    if (gcmIS_ERROR(status)) return status;
    fExpROperand.dataType.elementType = clvTYPE_FLOAT;

    /* For small mainPart of x^y */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &slctCntxtSmallPow);
    if (gcmIS_ERROR(status)) return status;

    /*boost the mainPart, by times 2^(24) */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_MUL_RTZ,
            &yTimeLog2IOperand0,
            &fExpROperand,
            &oneTo24ROperand);
    if (gcmIS_ERROR(status)) return status;

    /* eps*log2*mainPart */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_MUL_RTZ,
            &sumEpsIOperand0,
            &sumEpsROperand1,
            &yTimeLog2ROperand0);
    if (gcmIS_ERROR(status)) return status;

    /*mainPart + eps*log2*mainPart */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ADD_RTZ,
            &yTimeLog2IOperand1,
            &sumEpsROperand0,
            &yTimeLog2ROperand0);
    if (gcmIS_ERROR(status)) return status;


    /* Scale back */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_MUL_RTZ,
            IOperand,
            &yTimeLog2ROperand1,
            &twenty5To1ROperand);

    {/* x^y main part == 0*/
        clsSELECTION_CONTEXT selectContextMain0;

        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextMain0);
        if (gcmIS_ERROR(status)) return status;


        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextMain0,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &zeroROperand,
                                                    &fExpROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextMain0);

        if (gcmIS_ERROR(status)) return status;


        status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &zeroROperand);

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextMain0,
                                        gcvFALSE);

        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextMain0);


        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextMain0);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextMain0);
    } /*End Main0 cases */


    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &slctCntxtSmallPow,
                                            gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /*Normal case, don't need to enlarge the mainPart */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &slctCntxtSmallPow);
    if (gcmIS_ERROR(status)) return status;

    /* eps*log2*mainPart */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_MUL_RTZ,
            &sumEpsIOperand0,
            &sumEpsROperand1,
            &fExpROperand);
    if (gcmIS_ERROR(status)) return status;

    {/* eps == 0*/
        clsSELECTION_CONTEXT selectContextEps0;

        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextEps0);
        if (gcmIS_ERROR(status)) return status;

        /* if eps1 == 0, we shouldn't add, otherwise when fExpROperand = inf, error*/
        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextEps0,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &zeroROperand,
                                                    &sumEpsROperand1);
        if (gcmIS_ERROR(status)) return status;
        /*Do nothing, for eps == 0 */

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextEps0);

        if (gcmIS_ERROR(status)) return status;

        /*mainPart + eps*log2*mainPart */
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                IOperand,
                &zeroROperand,
                &fExpROperand);
        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextEps0,
                                        gcvFALSE);

        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextEps0);

        /*mainPart + eps*log2*mainPart */
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                IOperand,
                &sumEpsROperand0,
                &fExpROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextEps0);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextEps0);
    } /*End eps0 cases */



    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &slctCntxtSmallPow);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                            CodeGenerator,
                            &slctCntxtSmallPow);
    if (gcmIS_ERROR(status)) return status;

    {/* Now we handle corner cases: Get the Abs(X), ABS(Y)*/
        clsIOPERAND        intermIOperands[10];
        clsROPERAND        intermROperands[10];
        clsROPERAND        unsignROperand,signROperand, floatOneROperand;
        clsSELECTION_CONTEXT selectContextNan, selectContextSat, selectContextOddIntY;

        clsSELECTION_CONTEXT selectContextY0;

        for(i = 0; i<10; i++){
            clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_UINT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
        }
        clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                        clmGenCodeDataType(T_UINT),
                                        0x7fffffff);

        clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x80000000);


        /*1.0f*/
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&floatOneROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        1.0f );

        status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &unsignROperand,
                &OperandsParameters[0].rOperands[0]);

        status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[1],
                &unsignROperand,
                &OperandsParameters[1].rOperands[0]);

        {/*Denormal */
            clsSELECTION_CONTEXT selectContextDenormX;
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextDenormX);
            if (gcmIS_ERROR(status)) return status;

            /* x = Denormal Value, set mantissa part zero*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextDenormX,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_NOT_EQUAL,
                                                        &OperandsParameters[0].rOperands[0],
                                                        &zeroROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextDenormX);

            if (gcmIS_ERROR(status)) return status;


            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextDenormX,
                                            gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextDenormX);

            /*In some cases, the denormal*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[0],
                        &zeroROperand);

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextDenormX);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextDenormX);
        } /*End Denormal cases */


        {/*x = 1.0f */
            clsSELECTION_CONTEXT selectContextX1;
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextX1);
            if (gcmIS_ERROR(status)) return status;

            /* x == 1.0, always return 1.0, no matter y == NAN*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextX1,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &floatOneROperand,
                                                        &OperandsParameters[0].rOperands[0]);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextX1);

            if (gcmIS_ERROR(status)) return status;

            /*Set y = 0, avoid Nan, Infinity Case*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[1],
                        &zeroROperand);


            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &floatOneROperand);


            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextX1,
                                            gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextX1);

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextX1);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextX1);
        } /*End x == 1 cases */

        {/*y = 0.0f */
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextY0);
            if (gcmIS_ERROR(status)) return status;

            /* y == 0.0, always return 1.0, no matter x == NAN*/
            /* use NOT_EQUAL, since EQUAL compare may put NAN==0*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextY0,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_NOT_EQUAL,
                                                        &OperandsParameters[1].rOperands[0],
                                                        &zeroROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextY0);

            if (gcmIS_ERROR(status)) return status;


            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextY0,
                                            gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextY0);
            /*y == 0, Set x = 1, avoid Nan, Infinity Case*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[0],
                        &floatOneROperand);

            if (gcmIS_ERROR(status)) return status;


            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextY0);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextY0);
        } /*End y == 0 cases */

        { /*Handle the Nan case. either X or Y is Nan, return to Nan */
        /*r2 = max(|X|,|Y|), unsigned type */
        status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MAX,
                    &intermIOperands[2],
                    &intermROperands[0],
                    &intermROperands[1]);

        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextNan);
        if (gcmIS_ERROR(status)) return status;

        /* (max(|X|,|Y|)&0x7FFFFFFF) > 0x7F800000? NaN*/
        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextNan,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_GREATER_THAN,
                                                    &intermROperands[2],
                                                    &expMaskROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextNan);

        if (gcmIS_ERROR(status)) return status;

        /*For Nan*/
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &unsignROperand);

        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextNan,
                                        gcvFALSE);

        if (gcmIS_ERROR(status)) return status;

        /* Non-Nan case */
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextNan);
        if (gcmIS_ERROR(status)) return status;

        {    /*Handdle X == Infinity , Y == Infinity , X == 0*/
            clsSELECTION_CONTEXT   selectContextInfX, selectContextX0, selectContextInfY;


                /*Get the sign r2 = sign(X),r3 = sign(Y) */
                status = clGenBitwiseExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[2],
                        &OperandsParameters[0].rOperands[0],
                        &signROperand);

                status = clGenBitwiseExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[3],
                        &signROperand,
                        &OperandsParameters[1].rOperands[0]);


                intermROperands[1].dataType.elementType = clvTYPE_FLOAT;
                intermROperands[4].dataType.elementType = clvTYPE_FLOAT;
                intermIOperands[4].dataType.elementType = clvTYPE_FLOAT;
                intermIOperands[5].dataType.elementType = clvTYPE_FLOAT;
                intermROperands[5].dataType.elementType = clvTYPE_FLOAT;
                /* r4 = floor(|y|) */
                status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_FLOOR,
                            &intermIOperands[4],
                            &intermROperands[1]);

                if (gcmIS_ERROR(status)) return status;

                /*r5 = |y| - floor(|Y|) */

                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[5],
                        &intermROperands[1],
                        &intermROperands[4]);

                /* r6 = F2I(r4)*/
                intermIOperands[6].dataType.elementType = clvTYPE_INT;
                status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_FLOAT_TO_INT,
                            &intermIOperands[6],
                            &intermROperands[4]);

                intermIOperands[6].dataType.elementType = clvTYPE_UINT;
                intermROperands[1].dataType.elementType = clvTYPE_UINT;
                intermROperands[4].dataType.elementType = clvTYPE_UINT;

                /* r7 = r6 & 0x01, but beware, 0x7fffffff is an even number if it from F2I
                  since it is from Saturation. F2I have max odd number 0x00ffffff, then*/
                status = clGenBitwiseExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[7],
                        &oneROperand,
                        &intermROperands[6]);

                { /* Handdle the F2I(y) = 0x7fffffff, In this case, y is even*/
                    status = clDefineSelectionBegin(Compiler,
                                                    CodeGenerator,
                                                    gcvTRUE,
                                                    &selectContextSat);
                    if (gcmIS_ERROR(status)) return status;

                    /* r6 == 0x7fffffff? from Saturation*/
                    status = clGenSelectionCompareConditionCode(Compiler,
                                                                CodeGenerator,
                                                                &selectContextSat,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                clvCONDITION_EQUAL,
                                                                &intermROperands[6],
                                                                &unsignROperand);
                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionTrueOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectContextSat);

                    /* This correct "Saturation is Odd number" */
                    status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ASSIGN,
                                &intermIOperands[7],
                                &zeroROperand);

                    status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectContextSat,
                                                    gcvFALSE);

                    status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextSat);

                    status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextSat);

                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextSat);
                    if (gcmIS_ERROR(status)) return status;
                } /*End of Sat */

                /*Now we process ( floor(|Y|) & 0x01 ) + frac(Y), should be 1 for odd
                r6 = r7 + r5, r5 should be zero or >= 0x00800000 integer*/

                status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[6],
                                    &intermROperands[7],
                                    &intermROperands[5]);

                { /*Y Odd Integer? */
                    status = clDefineSelectionBegin(Compiler,
                                                    CodeGenerator,
                                                    gcvTRUE,
                                                    &selectContextOddIntY);
                    if (gcmIS_ERROR(status)) return status;

                    /* r6 == 1? Y is odd integer*/
                    status = clGenSelectionCompareConditionCode(Compiler,
                                                                CodeGenerator,
                                                                &selectContextOddIntY,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                clvCONDITION_EQUAL,
                                                                &intermROperands[6],
                                                                &oneROperand);
                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionTrueOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectContextOddIntY);

                    /* r4 = 0x80000000: Y is odd Integer */
                    status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ASSIGN,
                                &intermIOperands[4],
                                &signROperand);

                    status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectContextOddIntY,
                                                    gcvFALSE);

                    status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextOddIntY);

                    /* r4 = 0: Y is Not odd Integer */
                    status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ASSIGN,
                                &intermIOperands[4],
                                &zeroROperand);

                    status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextOddIntY);

                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextOddIntY);
                    if (gcmIS_ERROR(status)) return status;
                }/*End of Y == OldInt, r4 is it. r5 = frac(|y|) */

                {    /* For Y = Inf, just Pow(1.0, Y) = 1, else*/
                    status = clDefineSelectionBegin(Compiler,
                                                    CodeGenerator,
                                                    gcvTRUE,
                                                    &selectContextInfY);
                    if (gcmIS_ERROR(status)) return status;

                    /* Y == Infinity?*/
                    status = clGenSelectionCompareConditionCode(Compiler,
                                                                CodeGenerator,
                                                                &selectContextInfY,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                clvCONDITION_EQUAL,
                                                                &intermROperands[1],
                                                                &expMaskROperand);
                    if (gcmIS_ERROR(status)) return status;

                    /*Now |Y| = Inf, |x| < 1, set |x| = 0, |x| > 1, set |x| = inf, else keep it */
                    status = clDefineSelectionTrueOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectContextInfY);

                    if (gcmIS_ERROR(status)) return status;

                    {/*x < 1.0f */
                        clsSELECTION_CONTEXT   selectContextXLess1;
                        status = clDefineSelectionBegin(Compiler,
                                                        CodeGenerator,
                                                        gcvTRUE,
                                                        &selectContextXLess1);
                        if (gcmIS_ERROR(status)) return status;

                        /* x < 1.0*/
                        status = clGenSelectionCompareConditionCode(Compiler,
                                                                    CodeGenerator,
                                                                    &selectContextXLess1,
                                                                    PolynaryExpr->exprBase.base.lineNo,
                                                                    PolynaryExpr->exprBase.base.stringNo,
                                                                    clvCONDITION_LESS_THAN,
                                                                    &intermROperands[0],
                                                                    &floatOneROperand);
                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectContextXLess1);

                        if (gcmIS_ERROR(status)) return status;

                        /*Set X = 0*/
                        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    &intermIOperands[0],
                                    &zeroROperand);

                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionTrueOperandEnd(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        CodeGenerator,
                                                        &selectContextXLess1,
                                                        gcvFALSE);

                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectContextXLess1);
                    {/*x > 1.0f */
                        clsSELECTION_CONTEXT   selectContextXGreater1;
                        status = clDefineSelectionBegin(Compiler,
                                                        CodeGenerator,
                                                        gcvTRUE,
                                                        &selectContextXGreater1);
                        if (gcmIS_ERROR(status)) return status;

                        /* x > 1.0*/
                        status = clGenSelectionCompareConditionCode(Compiler,
                                                                    CodeGenerator,
                                                                    &selectContextXGreater1,
                                                                    PolynaryExpr->exprBase.base.lineNo,
                                                                    PolynaryExpr->exprBase.base.stringNo,
                                                                    clvCONDITION_GREATER_THAN,
                                                                    &intermROperands[0],
                                                                    &floatOneROperand);
                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectContextXGreater1);

                        if (gcmIS_ERROR(status)) return status;

                        /*Set |X| = 0, and change Y sign*/
                        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    &intermIOperands[0],
                                    &expMaskROperand);

                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionTrueOperandEnd(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        CodeGenerator,
                                                        &selectContextXGreater1,
                                                        gcvFALSE);

                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectContextXGreater1);

                        /*Now |x| = 1 (actually, x = -1), numerical program deliever wrong, RESET output */
                        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    IOperand,
                                    &floatOneROperand);
                        /*Assign Y is an integer, otherwise, frac(Int) = Nan */
                        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    &intermIOperands[5],
                                    &zeroROperand);

                        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                                CodeGenerator,
                                                                &selectContextXGreater1);
                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextXGreater1);
                    } /*End |x| > 1 cases */



                        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                                CodeGenerator,
                                                                &selectContextXLess1);
                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextXLess1);
                    } /*End |x| < 1 cases */



                    status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectContextInfY,
                                                    gcvFALSE);

                    status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInfY);


                    status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfY);

                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextInfY);
                    if (gcmIS_ERROR(status)) return status;
                }/*End of Y == Inf */


                {
                    /* For X = Inf, just Pow(Inf, y) = Pow(0.0, -y)*/
                    status = clDefineSelectionBegin(Compiler,
                                                    CodeGenerator,
                                                    gcvTRUE,
                                                    &selectContextInfX);
                    if (gcmIS_ERROR(status)) return status;

                    /* ((X)&0x7FFFFFFF) == 0x7F800000? Infinity*/
                    status = clGenSelectionCompareConditionCode(Compiler,
                                                                CodeGenerator,
                                                                &selectContextInfX,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                clvCONDITION_EQUAL,
                                                                &intermROperands[0],
                                                                &expMaskROperand);
                    if (gcmIS_ERROR(status)) return status;

                    /*Now |X| = Inf */
                    status = clDefineSelectionTrueOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectContextInfX);

                    if (gcmIS_ERROR(status)) return status;

                    /* set |X| = 0, later on will go to |X| = 0 case*/
                    status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ASSIGN,
                                &intermIOperands[0],
                                &zeroROperand);
                    /*Change Y Sign for this case */
                    status = clGenBitwiseExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_XOR_BITWISE,
                        &intermIOperands[3],
                        &signROperand,
                        &intermROperands[3]);

                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectContextInfX,
                                                    gcvFALSE);

                    status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInfX);


                    status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX);

                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextInfX);
                    if (gcmIS_ERROR(status)) return status;
                }/*End of X == Inf */


                {    /* |X| == 0? */
                    status = clDefineSelectionBegin(Compiler,
                                                    CodeGenerator,
                                                    gcvTRUE,
                                                    &selectContextX0);
                    if (gcmIS_ERROR(status)) return status;

                    status = clGenSelectionCompareConditionCode(Compiler,
                                                                CodeGenerator,
                                                                &selectContextX0,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                clvCONDITION_EQUAL,
                                                                &intermROperands[0],
                                                                &zeroROperand);
                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionTrueOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectContextX0);

                    {/* For X = 0.0, verify Y<0?*/
                        clsSELECTION_CONTEXT   selectContextNegY;
                    status = clDefineSelectionBegin(Compiler,
                                                    CodeGenerator,
                                                    gcvTRUE,
                                                    &selectContextNegY);
                    if (gcmIS_ERROR(status)) return status;

                    status = clGenSelectionCompareConditionCode(Compiler,
                                                                CodeGenerator,
                                                                &selectContextNegY,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                clvCONDITION_NOT_EQUAL,
                                                                &intermROperands[3],
                                                                &zeroROperand);
                    if (gcmIS_ERROR(status)) return status;

                    /* Y<0, return to pow(0.0, Y) = infinity | (Y==OddInt? SignX) */
                    status = clDefineSelectionTrueOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectContextNegY);



                    /*r1 = signed(X) & IntOdd(Y)  */
                    status = clGenBitwiseExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_AND_BITWISE,
                            &intermIOperands[1],
                            &intermROperands[2],
                            &intermROperands[4]);

                    /*Add the signed bit to the infinity 0x7f800000*/
                    IOperand->dataType.elementType = clvTYPE_UINT;
                    status = clGenBitwiseExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_OR_BITWISE,
                            IOperand,
                            &expMaskROperand,
                            &intermROperands[1]);
                    IOperand->dataType.elementType = clvTYPE_FLOAT;

                    status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectContextNegY,
                                                    gcvFALSE);

                    status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextNegY);

                    /* y>=0, pow(0.0, y) = 0.0*/
                    status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ASSIGN,
                                IOperand,
                                &zeroROperand);

                    status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextNegY);

                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextNegY);
                    if (gcmIS_ERROR(status)) return status;
                    }/* End For X = 0.0, verify Y<0?*/

                    status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectContextX0,
                                                    gcvFALSE);

                    status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextX0);

                    {/*x < 0.0f */
                        clsSELECTION_CONTEXT   selectContextNegX;
                        status = clDefineSelectionBegin(Compiler,
                                                        CodeGenerator,
                                                        gcvTRUE,
                                                        &selectContextNegX);
                        if (gcmIS_ERROR(status)) return status;

                        /* x < 0.0*/
                        status = clGenSelectionCompareConditionCode(Compiler,
                                                                    CodeGenerator,
                                                                    &selectContextNegX,
                                                                    PolynaryExpr->exprBase.base.lineNo,
                                                                    PolynaryExpr->exprBase.base.stringNo,
                                                                    clvCONDITION_NOT_EQUAL,
                                                                    &zeroROperand,
                                                                    &intermROperands[2]);
                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectContextNegX);

                        if (gcmIS_ERROR(status)) return status;

                { /*Y  Integer? */
                    clsSELECTION_CONTEXT   selectContextIntegerY;
                    clsROPERAND    finalROperands[1];
                    clsROPERAND_InitializeUsingIOperand(&finalROperands[0], IOperand);

                    status = clDefineSelectionBegin(Compiler,
                                                    CodeGenerator,
                                                    gcvTRUE,
                                                    &selectContextIntegerY);
                    if (gcmIS_ERROR(status)) return status;

                    /* r5 == 0? Y is an integer*/
                    status = clGenSelectionCompareConditionCode(Compiler,
                                                                CodeGenerator,
                                                                &selectContextIntegerY,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                clvCONDITION_EQUAL,
                                                                &intermROperands[5],
                                                                &zeroROperand);
                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionTrueOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectContextIntegerY);

                    /*Clear the Sign bit */
                    status = clGenBitwiseExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_AND_BITWISE,
                            &intermIOperands[8],
                            &finalROperands[0],
                            &unsignROperand);

                    /*Add the Neg sign bit or not, depends on Y is OddInt */
                    IOperand->dataType.elementType = clvTYPE_UINT;
                    status = clGenBitwiseExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_OR_BITWISE,
                            IOperand,
                            &intermROperands[8],
                            &intermROperands[4]);
                    IOperand->dataType.elementType = clvTYPE_FLOAT;

                    status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectContextIntegerY,
                                                    gcvFALSE);

                    status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextIntegerY);

                    /* No A integer, return to NAN */
                    status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ASSIGN,
                                IOperand,
                                &unsignROperand);

                    status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextIntegerY);

                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextIntegerY);
                    if (gcmIS_ERROR(status)) return status;
                }/*End of Y is integer */


                        status = clDefineSelectionTrueOperandEnd(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        CodeGenerator,
                                                        &selectContextNegX,
                                                        gcvFALSE);

                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectContextNegX);

                        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                                CodeGenerator,
                                                                &selectContextNegX);
                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextNegX);
                    } /*End x < 0.0 cases */

                    status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextX0);

                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextX0);
                    if (gcmIS_ERROR(status)) return status;
                } /* End of X==0*/

        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextNan);

        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextNan);
        if (gcmIS_ERROR(status)) return status;
        } /*End of Nan Case*/


        }

    }
    return gcvSTATUS_OK;
}
/*Should be simpler than Pow, but we call pow here. Right wait is to call pow normal part */
static gceSTATUS
_GenPowrCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    clsROPERAND zeroROperand, nanROperand,infROperand, unsignROperand, signROperand;
    clsSELECTION_CONTEXT    slctCntxtNeg, selectContextNan;
    clsIOPERAND sumIOperand;
    clsROPERAND sumROperand;
    clsIOPERAND        intermIOperands[2];
    clsROPERAND        intermROperands[2];
    gceSTATUS                    status;
    int i;
    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7fc00000);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x80000000);


    clsIOPERAND_New(Compiler, &sumIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&sumROperand, &sumIOperand);
    for(i = 0; i<2; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                   clvOPCODE_ABS,
                                   &intermIOperands[i],
                                   &OperandsParameters[i].rOperands[0]);
    }



    /* |x| + |y| */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &sumIOperand,
                                    &intermROperands[0],
                                    &intermROperands[1]);


    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextNan);
    if (gcmIS_ERROR(status)) return status;

    sumROperand.dataType.elementType = clvTYPE_UINT;
    /* (|X|+|Y|)> 0x7F800000? NaN*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextNan,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &sumROperand,
                                                &infROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);

    if (gcmIS_ERROR(status)) return status;

    /*For Nan*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &nanROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextNan,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* Non-Nan case */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);
    if (gcmIS_ERROR(status)) return status;
    {
        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &slctCntxtNeg);
        if (gcmIS_ERROR(status)) return status;

        status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &slctCntxtNeg,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN,
                                                &signROperand,
                                                &OperandsParameters[0].rOperands[0]);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &slctCntxtNeg);

        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    IOperand,
                                    &nanROperand);

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &slctCntxtNeg,
                                        gcvFALSE);
        /*x>=0 */
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &slctCntxtNeg);
        {
            clsSELECTION_CONTEXT selectContextLogx_yNan;
            status = clGenGenericCode1(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_LOG2,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0]);
            /* r1 = log(x)*y */
            status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[1],
                                    &OperandsParameters[1].rOperands[0],
                                    &intermROperands[0]);
            intermIOperands[0].dataType.elementType = clvTYPE_UINT;
            /*Get Abs value, otherwise 0*(-inf) = -Nan */
            status = clGenBitwiseExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_AND_BITWISE,
                                &intermIOperands[0],
                                &unsignROperand,
                                &intermROperands[1]);

        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextLogx_yNan);
        if (gcmIS_ERROR(status)) return status;



        intermROperands[0].dataType.elementType = clvTYPE_UINT;
        /* (log|X| * |Y|)= 0x7FC00000? NaN*/
        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextLogx_yNan,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_GREATER_THAN_EQUAL,
                                                    &intermROperands[0],
                                                    &nanROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextLogx_yNan);

        if (gcmIS_ERROR(status)) return status;

        /*For Nan*/
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &nanROperand);

        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextLogx_yNan,
                                        gcvFALSE);

        if (gcmIS_ERROR(status)) return status;

        /* Non-Nan case */
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextLogx_yNan);
            {    /*Finally, use Pow(x, y) call */
                intermIOperands[0].dataType.elementType = clvTYPE_FLOAT;
                _GenPowCode(
                    Compiler,
                    CodeGenerator,
                    PolynaryExpr,
                    OperandCount,
                    OperandsParameters,
                    &intermIOperands[0]
                    );
                    /* Some times, 0x80000000 = 0, but out pow(x, y) give wrong result*/
                    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
                    status = clGenGenericCode1(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ABS,
                                        IOperand,
                                        &intermROperands[0]);

            }
            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextLogx_yNan);
            status = clDefineSelectionEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextLogx_yNan);
            if (gcmIS_ERROR(status)) return status;
        }
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &slctCntxtNeg);
        status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &slctCntxtNeg);
    }
    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextNan);
    status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextNan);
    if (gcmIS_ERROR(status)) return status;


    return gcvSTATUS_OK;
}

static gceSTATUS
_GenPownCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    clsROPERAND zeroROperand, nanROperand, unsignROperand, signROperand, oddROperand, infROperand, logE2ROperand, neg1ROperand, mantissaROperand,oneROperand;
    clsSELECTION_CONTEXT selectContextSmallY, selectContextNormal;
    clsIOPERAND sumIOperand;
    clsROPERAND sumROperand;
    clsIOPERAND        intermIOperands[15];
    clsROPERAND        intermROperands[15];
    gceSTATUS                    status;
    int i;
    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7fC00000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x80000000);
        clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&oddROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x1);
    clsROPERAND_InitializeIntOrIVecConstant(&mantissaROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x007fffff);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                          clmGenCodeDataType(T_FLOAT),
                          (gctFLOAT) 1.0);/*1.0f*/
    clsIOPERAND_New(Compiler, &sumIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&sumROperand, &sumIOperand);
    for(i = 0; i<15; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    intermIOperands[0].dataType.elementType = clvTYPE_INT;

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INT_TO_FLOAT,
                &intermIOperands[0],
                &OperandsParameters[1].rOperands[0]);

    intermIOperands[0].dataType.elementType = clvTYPE_FLOAT;

    intermIOperands[1].dataType.elementType = clvTYPE_INT;
    /*Since floating number is only 24 bit mantissa, int2float may lost precision for big number */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_FLOAT_TO_INT,
                &intermIOperands[1],
                &intermROperands[0]);


        /* r3 = y&0x01 */
        /* r4 = sign(x) */
        intermIOperands[3].dataType.elementType = clvTYPE_INT;
        intermROperands[3].dataType.elementType = clvTYPE_INT;

        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[3],
            &OperandsParameters[1].rOperands[0],
            &oddROperand);

        intermIOperands[4].dataType.elementType = clvTYPE_INT;
        intermROperands[4].dataType.elementType = clvTYPE_INT;
        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[4],
            &OperandsParameters[0].rOperands[0],
            &signROperand);

        /*r3 = r3*43, the final sign */
        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[3],
                                    &intermROperands[4],
                                    &intermROperands[3]);

            /* r4 = abs(x)*/
            status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[4],
                &OperandsParameters[0].rOperands[0],
                &unsignROperand);
            intermROperands[4].dataType.elementType = clvTYPE_FLOAT;

            intermROperands[0].dataType.elementType = clvTYPE_FLOAT;
            intermROperands[10] = OperandsParameters[1].rOperands[0];
            OperandsParameters[1].rOperands[0] = intermROperands[0];
            intermROperands[9] = OperandsParameters[0].rOperands[0];
            OperandsParameters[0].rOperands[0] = intermROperands[4];
            /* r5 = |X| ^ mainPart(y) */
            _GenPowCode(
                Compiler,
                CodeGenerator,
                PolynaryExpr,
                OperandCount,
                OperandsParameters,
                &intermIOperands[5]
                );
            OperandsParameters[1].rOperands[0] = intermROperands[10];
            OperandsParameters[0].rOperands[0] = intermROperands[9];

        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextSmallY);
        if (gcmIS_ERROR(status)) return status;



        intermROperands[0].dataType.elementType = clvTYPE_INT;
        /* int(float(y)) == y*/
        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextSmallY,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &OperandsParameters[1].rOperands[0],
                                                    &intermROperands[1]);
        if (gcmIS_ERROR(status)) return status;
        intermROperands[0].dataType.elementType = clvTYPE_FLOAT;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextSmallY);

        if (gcmIS_ERROR(status)) return status;


        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextSmallY,
                                        gcvFALSE);

        if (gcmIS_ERROR(status)) return status;

        /* When y is too big, more than 24 bits*/
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextSmallY);
        {
            /* r2 = y - int(float(y))*/
            intermIOperands[2].dataType.elementType = clvTYPE_INT;
            intermROperands[2].dataType.elementType = clvTYPE_INT;
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[2],
                                        &OperandsParameters[1].rOperands[0],
                                        &intermROperands[1]);
            {
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&logE2ROperand,
                          clmGenCodeDataType(T_FLOAT),
                          (gctFLOAT) 1.0);/*_LOG2_E);*/
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&neg1ROperand,
                          clmGenCodeDataType(T_FLOAT),
                          (gctFLOAT) -1.0f);
                /*Check if |x|^y is normal or not. If it is, time (1 + (log|X|)*residue(y)) */
                status = clDefineSelectionBegin(Compiler,
                                                CodeGenerator,
                                                gcvTRUE,
                                                &selectContextNormal);
                if (gcmIS_ERROR(status)) return status;

                intermIOperands[7].dataType.elementType = clvTYPE_INT;
                intermROperands[7].dataType.elementType = clvTYPE_INT;
                status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[7],
                    &mantissaROperand,
                    &intermROperands[5]);
                /* If mantissa part are zero, not adjust needed */
                status = clGenSelectionCompareConditionCode(Compiler,
                                                            CodeGenerator,
                                                            &selectContextNormal,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvCONDITION_EQUAL,
                                                            &zeroROperand,
                                                            &intermROperands[7]);
                if (gcmIS_ERROR(status)) return status;

                intermIOperands[7].dataType.elementType = clvTYPE_FLOAT;
                intermROperands[7].dataType.elementType = clvTYPE_FLOAT;

                status = clDefineSelectionTrueOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContextNormal);

                if (gcmIS_ERROR(status)) return status;

                /* Do nothing, since x^y is same as x^main(y)*/

                status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectContextNormal,
                                                gcvFALSE);

                if (gcmIS_ERROR(status)) return status;

                /* Now x^y is normal*/
                status = clDefineSelectionFalseOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContextNormal);
                {
                clsSELECTION_CONTEXT   selectContextSmallExp;
                clsROPERAND oneTo24ROperand, twenty5To1ROperand;
                /*2^24,*/
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneTo24ROperand,
                                                    clmGenCodeDataType(T_FLOAT),
                                                    (float)(1<<24) );

                /*1/2^25,*/
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&twenty5To1ROperand,
                                                    clmGenCodeDataType(T_FLOAT),
                                                    (float)(1.1920929e-007)/2.0f );

                status = clDefineSelectionBegin(Compiler,
                                                CodeGenerator,
                                                gcvTRUE,
                                                &selectContextSmallExp);
                if (gcmIS_ERROR(status)) return status;

                status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextSmallExp,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_LESS_THAN,
                                                        &intermROperands[5],
                                                        &twenty5To1ROperand);
                if (gcmIS_ERROR(status)) return status;

                /* when pow(x,y) too small, boost */
                status = clDefineSelectionTrueOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContextSmallExp);

                /*Boost r5 */
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[5],
                        &intermROperands[5],
                        &oneTo24ROperand);
                /* Scale back value*/
                    status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[11],
                        &twenty5To1ROperand);
            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextSmallExp,
                                            gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            /* If x^y is not too small, not boost needs*/
            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextSmallExp);
            /*Scale back value = 1.0 */
                    status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[11],
                        &oneROperand);
            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContextSmallExp);
            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextSmallExp);

                /*Quick calculate |x|^residue(y) */

                intermIOperands[6].dataType.elementType = clvTYPE_INT;
                status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_INT_TO_FLOAT,
                            &intermIOperands[6],
                            &intermROperands[2]);

                intermIOperands[6].dataType.elementType = clvTYPE_FLOAT;

                /*r7 = logE(|x|) = |x| - 1*/
            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[7],
                            &intermROperands[4],
                            &neg1ROperand);


                /*r8 = residue(y)*r7 */
                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[8],
                                        &intermROperands[7],
                                        &intermROperands[6]);

                /*r7 = r8 * r5 */
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[7],
                        &intermROperands[8],
                        &intermROperands[5]);

                /* r7 = r5 + (log|x|)*residue(y) * r5 */
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[6],
                        &intermROperands[7],
                        &intermROperands[5]);

                /*r5 = r7*r9, scale back */
                status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[5],
                        &intermROperands[6],
                        &intermROperands[11]);

                }
                status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextNormal);
                status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextNormal);
                if (gcmIS_ERROR(status)) return status;

            }
        }
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextSmallY);
        status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextSmallY);
        if (gcmIS_ERROR(status)) return status;

        /*Add the sign back to the final result */
        IOperand->dataType.elementType = clvTYPE_UINT;
        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_OR_BITWISE,
            IOperand,
            &intermROperands[5],
            &intermROperands[3]);
        IOperand->dataType.elementType = clvTYPE_FLOAT;


    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenRootnCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    clsROPERAND zeroROperand, nanROperand, unsignROperand, signROperand, oddROperand, infROperand, logE2ROperand, oneROperand, mantissaROperand;
    clsSELECTION_CONTEXT  selectContextY0, selectContextNegX, selectContextSpecialCase, selectContextInfX;
    clsIOPERAND        intermIOperands[15];
    clsROPERAND        intermROperands[15];
    gceSTATUS                    status;
    int i;

#if FULL_PROFILE_TEST
    if (CodeGenerator->hasNEW_SIN_COS_LOG_DIV)
    {
        return _GenFullProfileRootnCode(
                        Compiler,
                        CodeGenerator,
                        PolynaryExpr,
                        OperandCount,
                        OperandsParameters,
                        IOperand
                        );
    }
#endif

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7fC00000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x80000000);
        clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&oddROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x1);
    clsROPERAND_InitializeIntOrIVecConstant(&mantissaROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x007fffff);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                          clmGenCodeDataType(T_FLOAT),
                          (gctFLOAT) 1.0f);


    for(i = 0; i<15; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    intermIOperands[0].dataType.elementType = clvTYPE_INT;

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INT_TO_FLOAT,
                &intermIOperands[0],
                &OperandsParameters[1].rOperands[0]);

    intermIOperands[0].dataType.elementType = clvTYPE_FLOAT;



        /* r3 = y&0x01 */
        /* r4 = sign(x) */
        intermIOperands[3].dataType.elementType = clvTYPE_INT;
        intermROperands[3].dataType.elementType = clvTYPE_INT;

        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[3],
            &OperandsParameters[1].rOperands[0],
            &oddROperand);

        intermIOperands[4].dataType.elementType = clvTYPE_INT;
        intermROperands[4].dataType.elementType = clvTYPE_INT;
        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[4],
            &OperandsParameters[0].rOperands[0],
            &signROperand);

        /* r5 = abs(x)*/
        intermIOperands[5].dataType.elementType = clvTYPE_INT;
        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[5],
            &OperandsParameters[0].rOperands[0],
            &unsignROperand);
        intermROperands[5].dataType.elementType = clvTYPE_FLOAT;

        intermIOperands[14].dataType.elementType = clvTYPE_INT;
        status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            &intermIOperands[14],
            &zeroROperand);
        /* r0: float(Y), r1: res(Y), r3: oddY, r4: sign(x), r5: abs(x), r14: 0,normal case  */

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextY0);
    if (gcmIS_ERROR(status)) return status;

    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextY0,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &OperandsParameters[1].rOperands[0],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    /* y == 0, return to Nan */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextY0);

        status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            IOperand,
            &nanROperand);

        status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            &intermIOperands[14],
            &oddROperand);
    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextY0,
                                            gcvFALSE);
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextY0);
    {/* x < 0 && y even test*/
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextNegX);
    if (gcmIS_ERROR(status)) return status;

    /* x < 0?*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextNegX,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN,
                                                &OperandsParameters[0].rOperands[0],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNegX);

        status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            IOperand,
            &nanROperand);
        /* If y is even, return to nan, otherwise, up instruction not use*/
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[14],
                                &oddROperand,
                                &intermROperands[3]);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextNegX,
                                            gcvFALSE);
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextNegX);
    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextNegX);
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextNegX);

    }
    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextY0);
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextY0);



    /* r7 = 1/r0, a quick estimation*/
        intermROperands[0].dataType.elementType = clvTYPE_FLOAT;
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INVERSE,
                &intermIOperands[7],
                &intermROperands[0]);

        /* N-R, remember, we try to get  better 1/(r0) */
        for(i = 0; i<1; i++){ /*iteration twice */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[8],
                                &intermROperands[0],
                                &intermROperands[7]);
        /* r9 = 1 - r0*r7*/
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[9],
                                &oneROperand,
                                &intermROperands[8]);

        /* r8 = r7*r9*/
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_MUL_RTZ,
                                &intermIOperands[8],
                                &intermROperands[9],
                                &intermROperands[7]);
            if(i == 2){/*r7 update */
                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[7],
                                &intermROperands[8],
                                &intermROperands[7]);
            }
        }
        /*Now, r7 + r8 is well approximation of 1/y. But pow(x, 1/y) only allow main part inside */
        {
            clsROPERAND    temp[2];
            temp[1] = OperandsParameters[1].rOperands[0];
            OperandsParameters[1].rOperands[0] = intermROperands[7];
            temp[0] = OperandsParameters[0].rOperands[0];
            OperandsParameters[0].rOperands[0] = intermROperands[5];
            /* r5 = |X| ^ mainPart(y) */
            _GenPowCode(
                Compiler,
                CodeGenerator,
                PolynaryExpr,
                OperandCount,
                OperandsParameters,
                &intermIOperands[9]
                );
            OperandsParameters[1].rOperands[0] = temp[1];
            OperandsParameters[0].rOperands[0] = temp[0];

            status = clGenGenericCode1(
                                    Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_LOG2,
                                    &intermIOperands[10],
                                    &intermROperands[5]);
            /*|log|x|| == Inf */
            status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[5],
                &unsignROperand,
                &intermROperands[10]);


            { /* adjust, only work with |log|x|| < inf*/
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextInfX);
    if (gcmIS_ERROR(status)) return status;

    /* |x| == INF?*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextInfX,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[5],
                                                &infROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextInfX);


    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInfX,
                                            gcvFALSE);
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextInfX);
    /*x<inf, we can to adjustment r9 = r9 + log2|x|*res(y)*log2*r9 */


            status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[11],
                    &intermROperands[8],
                    &intermROperands[10]);

            status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[10],
                    &intermROperands[9],
                    &intermROperands[11]);

            clsROPERAND_InitializeFloatOrVecOrMatConstant(&logE2ROperand,
                          clmGenCodeDataType(T_FLOAT),
                          (gctFLOAT) _LOGE_2);


            status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[11],
                    &logE2ROperand,
                    &intermROperands[10]);

            status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[9],
                    &intermROperands[9],
                    &intermROperands[11]);
    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextInfX);
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextInfX);



            }
        }

        intermROperands[14].dataType.elementType = clvTYPE_INT;
    /* Special cases, already set*/
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextSpecialCase);
    if (gcmIS_ERROR(status)) return status;

    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextSpecialCase,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_NOT_EQUAL,
                                                &intermROperands[14],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextSpecialCase);

    /*Do nothing, the value (nan) already set */
    status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextSpecialCase,
                                            gcvFALSE);
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextSpecialCase);
        /* Only oddY+negX effect the sign */
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[3],
                &intermROperands[4],
                &intermROperands[3]);

        IOperand->dataType.elementType = clvTYPE_UINT;
        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_OR_BITWISE,
            IOperand,
            &intermROperands[9],
            &intermROperands[3]);
        IOperand->dataType.elementType = clvTYPE_FLOAT;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextSpecialCase);
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextSpecialCase);


    return gcvSTATUS_OK;
}

static gceSTATUS
_GenExp_E_10Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand,
    IN gctINT    baseIndex /*1: base E, 10: base 10, -1: E^x-1 (expm1(x)), 87: E^(x)/(x>87?:2:1)*/
    )
{
    gceSTATUS        status;
    clsROPERAND        oneROperand, logEROperand, logTwoROperand, logTwoLowROperand, zeroROperand, infROperand;
    clsIOPERAND        intermIOperands[9];
    clsROPERAND        intermROperands[9], oneIntROperand,maskROperand;
    clsSELECTION_CONTEXT   selectContextExp0;

#if FULL_PROFILE_TEST
    if (CodeGenerator->hasNEW_SIN_COS_LOG_DIV)
    {
        return _GenFullProfileExpE_10Code(
                        Compiler,
                        CodeGenerator,
                        PolynaryExpr,
                        OperandCount,
                        OperandsParameters,
                        IOperand,
                        baseIndex
                        );
    }
#endif

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              1.0f);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logEROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) _LOGE_2);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logTwoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              ( baseIndex == 10? _LOG2_10_high : _LOG2_E_high ) );

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logTwoLowROperand,
                              clmGenCodeDataType(T_FLOAT),
                              ( baseIndex == 10? _LOG2_10_low : _LOG2_E_low ));

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                              clmGenCodeDataType(T_FLOAT),
                              0.0f);

    clsROPERAND_InitializeIntOrIVecConstant(&oneIntROperand,
                                            clmGenCodeDataType(T_UINT),
                                            1);

    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x007fffff);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7f800000);
    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* mul x, _LOG2_E */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0],
                                    &logTwoROperand);

    if (gcmIS_ERROR(status)) return status;

    /* exp2 result */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    if(baseIndex == 87){ /* When x>=87, sub 1 directly*/
        clsSELECTION_CONTEXT   selectContextOver87;
        clsROPERAND        cnst87ROperand;

        clsROPERAND_InitializeFloatOrVecOrMatConstant(&cnst87ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              87.0f);

        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextOver87);
        if (gcmIS_ERROR(status)) return status;

        status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextOver87,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &OperandsParameters[0].rOperands[0],
                                                &cnst87ROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextOver87);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[0],
                                        &intermROperands[0],
                                        &oneROperand);
        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextOver87,
                                        gcvFALSE);
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextOver87);
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextOver87);
        status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextOver87);
    }
    status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_EXP2,
                            &intermIOperands[1],
                            &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /*If exp2 result is zero, the adjust term may become inf, inf*0 = Nan*/
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextExp0);

    if (gcmIS_ERROR(status)) return status;

    intermROperands[1].dataType.elementType = clvTYPE_UINT;
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextExp0,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[1],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    intermROperands[1].dataType.elementType = clvTYPE_FLOAT;

    /* when exp2(x) = 0, return to 0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextExp0);


    if(baseIndex != -1){
        status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            IOperand,
            &intermROperands[1]);
    }
    else{ /*E^x-1 */
                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        IOperand,
                                        &intermROperands[1],
                                        &oneROperand);

        }


    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextExp0,
                                    gcvFALSE);


    /*normal case */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                CodeGenerator,
                                &selectContextExp0);


    /* mullo x, _LOG2_E */
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MULLO_RTZ,
                                    &intermIOperands[2],
                                    &OperandsParameters[0].rOperands[0],
                                    &logTwoROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mul x, _LOG2_E_low */
    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[3],
                                    &OperandsParameters[0].rOperands[0],
                                    &logTwoLowROperand);

    if (gcmIS_ERROR(status)) return status;

    /* add result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[4],
                                    &intermROperands[3],
                                    &intermROperands[2]);

    if (gcmIS_ERROR(status)) return status;

    /* mul x, _LOG2_E_low */
    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);

    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_MUL_RTZ,
                                    &intermIOperands[5],
                                    &intermROperands[4],
                                    &logEROperand);

    if (gcmIS_ERROR(status)) return status;

    /* mul result, previous result */
    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

    { /*When r1 very small, r1*eps are force to zero. So we have to enlarge it */

        clsSELECTION_CONTEXT   selectContextSmallExp;
        clsROPERAND oneTo24ROperand, twenty5To1ROperand;
        /*2^24,*/
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneTo24ROperand,
                                            clmGenCodeDataType(T_FLOAT),
                                            (float)(1<<24) );

        /*1/2^25,*/
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&twenty5To1ROperand,
                                            clmGenCodeDataType(T_FLOAT),
                                            (float)(1.1920929e-007)/2.0f );

        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextSmallExp);
        if (gcmIS_ERROR(status)) return status;

        status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextSmallExp,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN,
                                                &intermROperands[1],
                                                &twenty5To1ROperand);
        if (gcmIS_ERROR(status)) return status;

        /* when exp2(x) = 0, return to 0 */
        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextSmallExp);

        /*boost the mainPart, by times 2^(24) */
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[2],
                &intermROperands[1],
                &oneTo24ROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[6],
                                        &intermROperands[5],
                                        &intermROperands[2]);

        if (gcmIS_ERROR(status)) return status;

        /* mul result, previous result */
        clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);
        if(baseIndex == -1){ /*Minus 1 */
                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[6],
                                        &intermROperands[6],
                                        &oneTo24ROperand);

        }

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[1],
                                        &intermROperands[6],
                                        &intermROperands[2]);

        if (gcmIS_ERROR(status)) return status;

        /*divided by times 2^(24) */
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                IOperand,
                &intermROperands[1],
                &twenty5To1ROperand);

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextSmallExp,
                                        gcvFALSE);


        /*normal case */
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                    CodeGenerator,
                                    &selectContextSmallExp);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[6],
                                        &intermROperands[5],
                                        &intermROperands[1]);

        if (gcmIS_ERROR(status)) return status;

        /* mul result, previous result */
        clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);
        if(baseIndex == -1){ /*Minus 1 */
                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[6],
                                        &intermROperands[6],
                                        &oneROperand);

                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[1],
                                        &intermROperands[6],
                                        &intermROperands[1]);
                { /*Increase by 1 LSB, but don't work on Infinity */
                    intermROperands[1].dataType.elementType = clvTYPE_UINT;
                    IOperand->dataType.elementType = clvTYPE_UINT;

                    clmGEN_CODE_IF(Compiler,
                                 CodeGenerator,
                                 PolynaryExpr->exprBase.base.lineNo,
                                 PolynaryExpr->exprBase.base.stringNo,
                                 &intermROperands[1],
                                 clvCONDITION_EQUAL,
                                 &infROperand);


                    status = clGenGenericCode1(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ASSIGN,
                                            IOperand,
                                            &infROperand);

            if (gcmIS_ERROR(status)) return status;

            clmGEN_CODE_ELSE(Compiler,
                       CodeGenerator,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo);



                status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        IOperand,
                                        &intermROperands[1],
                                        &oneIntROperand);
                intermROperands[1].dataType.elementType = clvTYPE_FLOAT;
                IOperand->dataType.elementType = clvTYPE_FLOAT;

           clmGEN_CODE_ENDIF(Compiler,
                             CodeGenerator,
                             PolynaryExpr->exprBase.base.lineNo,
                             PolynaryExpr->exprBase.base.stringNo);


                }
        }
        else
            status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        IOperand,
                                        &intermROperands[6],
                                        &intermROperands[1]);

        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextSmallExp);

        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionEnd(Compiler,
                    CodeGenerator,
                    &selectContextSmallExp);
        if (gcmIS_ERROR(status)) return status;

    }/*End of small r1 */




    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextExp0);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                CodeGenerator,
                &selectContextExp0);
    if (gcmIS_ERROR(status)) return status;

OnError:
    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;
}


static gceSTATUS
_GenExpCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    return _GenExp_E_10Code(
    Compiler,
    CodeGenerator,
    PolynaryExpr,
    OperandCount,
    OperandsParameters,
    IOperand,
    1);
}

static gceSTATUS
_GenExp10Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    return _GenExp_E_10Code(
    Compiler,
    CodeGenerator,
    PolynaryExpr,
    OperandCount,
    OperandsParameters,
    IOperand,
    10);
}




static gceSTATUS
_GenExpm1Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND intermIOperands[50];
    clsROPERAND intermROperands[50];

    clsSELECTION_CONTEXT    selectionContext1, selectionContext2, selectionContext3;
    clsROPERAND        logEROperand, logTwoROperand, logTwoLowROperand;
    clsROPERAND        firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand, fifthCoefROperand, sixthCoefROperand,
                    seventhCoefROperand, eighthCoefROperand, ninthCoefROperand, tenthCoefROperand, eleventhCoefROperand, twelfthCoefROperand,
                    thirteenthCoefROperand, fourteenthCoefROperand, fifteenthCoefROperand, sixteenthCoefROperand, seventeenthCoefROperand,
                    eighteenthCoefROperand;
    clsROPERAND        oneROperand, secondROperand, thirdROperand, negROperand;

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&negROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) -1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 3.5);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logEROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) _LOGE_2);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logTwoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) _LOG2_E_high);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logTwoLowROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) _LOG2_E_low);


    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);
#if FULL_PROFILE_TEST
    if (CodeGenerator->hasNEW_SIN_COS_LOG_DIV)
    {
        return _GenFullProfileExpE_10Code(
                        Compiler,
                        CodeGenerator,
                        PolynaryExpr,
                        OperandCount,
                        OperandsParameters,
                        IOperand,
                        -1
                        );
    }
#endif


    /* The selection begins */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The condition part: t0 >= -1.0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &OperandsParameters[0].rOperands[0],
                                                &negROperand);

    if (gcmIS_ERROR(status)) return status;

    /* The true part for t0 >= -1.0 */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

            /* The selection begins for t0 >= -1.0 */
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectionContext2);

            if (gcmIS_ERROR(status)) return status;

            /* The condition part: t0 <= 1.0 */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext2,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_LESS_THAN_EQUAL,
                                                        &OperandsParameters[0].rOperands[0],
                                                        &oneROperand);

            if (gcmIS_ERROR(status)) return status;

            /* The true part for t0 <= 1.0 */
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext2);

            if (gcmIS_ERROR(status)) return status;


            clsROPERAND_InitializeFloatOrVecOrMatConstant(&eighthCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)1.000000000000000000000000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&seventhCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.500000059604644780000000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&sixthCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.166667297482490540000000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.041666258126497269000000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.008329953067004680600000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.001389508252032101200000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.000203911025892011820000);
            clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCoefROperand,
                                                        clmGenCodeDataType(T_FLOAT),
                                                        (gctFLOAT)0.000024800308892736211000);



            /* mul coef1 ,x */
            clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[0],
                                            &OperandsParameters[0].rOperands[0],
                                            &firstCoefROperand);

            if (gcmIS_ERROR(status)) return status;

            /* add result, coef2 */
            clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[1],
                                            &intermROperands[0],
                                            &secondCoefROperand);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, x */
            clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[2],
                                            &OperandsParameters[0].rOperands[0],
                                            &intermROperands[1]);

            if (gcmIS_ERROR(status)) return status;

            /* add result, coef3 */
            clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[3],
                                            &intermROperands[2],
                                            &thirdCoefROperand);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, x */
            clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[4],
                                            &OperandsParameters[0].rOperands[0],
                                            &intermROperands[3]);

            if (gcmIS_ERROR(status)) return status;

            /* add result, coef4 */
            clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[5],
                                            &intermROperands[4],
                                            &fourthCoefROperand);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, x */
            clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[6],
                                            &OperandsParameters[0].rOperands[0],
                                            &intermROperands[5]);

            if (gcmIS_ERROR(status)) return status;

            /* add result, coef5 */
            clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[7],
                                            &intermROperands[6],
                                            &fifthCoefROperand);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, x */
            clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[8],
                                            &OperandsParameters[0].rOperands[0],
                                            &intermROperands[7]);

            if (gcmIS_ERROR(status)) return status;

            /* add result, coef6 */
            clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[9],
                                            &intermROperands[8],
                                            &sixthCoefROperand);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, x */
            clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[10],
                                            &OperandsParameters[0].rOperands[0],
                                            &intermROperands[9]);

            if (gcmIS_ERROR(status)) return status;

            /* add result, coef7 */
            clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[11],
                                            &intermROperands[10],
                                            &seventhCoefROperand);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, x */
            clsIOPERAND_New(Compiler, &intermIOperands[12], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            &intermIOperands[12],
                                            &OperandsParameters[0].rOperands[0],
                                            &intermROperands[11]);

            if (gcmIS_ERROR(status)) return status;

            /* add result, coef8 */
            clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[12], &intermIOperands[12]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ADD_RTZ,
                                            &intermIOperands[13],
                                            &intermROperands[12],
                                            &eighthCoefROperand);

            if (gcmIS_ERROR(status)) return status;

            /* mul result, x */
            clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[13]);

            status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            IOperand,
                                            &OperandsParameters[0].rOperands[0],
                                            &intermROperands[13]);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectionContext2,
                                            gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            /* The false part, t0 > 1.0 */
            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext2);

            if (gcmIS_ERROR(status)) return status;


                        /* The selection begins for t0 > 1.0 */
                        status = clDefineSelectionBegin(Compiler,
                                                        CodeGenerator,
                                                        gcvTRUE,
                                                        &selectionContext3);

                        if (gcmIS_ERROR(status)) return status;

                        /* The condition part: t0 <= 3.5 */
                        status = clGenSelectionCompareConditionCode(Compiler,
                                                                    CodeGenerator,
                                                                    &selectionContext3,
                                                                    PolynaryExpr->exprBase.base.lineNo,
                                                                    PolynaryExpr->exprBase.base.stringNo,
                                                                    clvCONDITION_LESS_THAN_EQUAL,
                                                                    &OperandsParameters[0].rOperands[0],
                                                                    &secondROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* The true part for t0 <= 3.5 */
                        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext3);

                        if (gcmIS_ERROR(status)) return status;



                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&eighteenthCoefROperand,
                                                                    clmGenCodeDataType(T_FLOAT),
                                                                    (gctFLOAT)3.194528102874755900000000);
                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&seventeenthCoefROperand,
                                                                    clmGenCodeDataType(T_FLOAT),
                                                                    (gctFLOAT)2.097264051437377900000000);
                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&sixteenthCoefROperand,
                                                                    clmGenCodeDataType(T_FLOAT),
                                                                    (gctFLOAT)0.798631966114044190000000);
                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifteenthCoefROperand,
                                                                    clmGenCodeDataType(T_FLOAT),
                                                                    (gctFLOAT)0.216438397765159610000000);
                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourteenthCoefROperand,
                                                                    clmGenCodeDataType(T_FLOAT),
                                                                    (gctFLOAT)0.045719388872385025000000);
                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirteenthCoefROperand,
                                                                    clmGenCodeDataType(T_FLOAT),
                                                                    (gctFLOAT)0.007928929291665554000000);
                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&twelfthCoefROperand,
                                                                    clmGenCodeDataType(T_FLOAT),
                                                                    (gctFLOAT)0.001167065580375492600000);
                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&eleventhCoefROperand,
                                                                    clmGenCodeDataType(T_FLOAT),
                                                                    (gctFLOAT)0.000148403007187880580000);
                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&tenthCoefROperand,
                                                                    clmGenCodeDataType(T_FLOAT),
                                                                    (gctFLOAT)0.000017227986973011866000);
                        clsROPERAND_InitializeFloatOrVecOrMatConstant(&ninthCoefROperand,
                                                                    clmGenCodeDataType(T_FLOAT),
                                                                    (gctFLOAT)0.000002139415073543204900);


                        /* sub from x, 2.0 */
                        clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_FLOAT));

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_SUB_RTZ,
                                                        &intermIOperands[14],
                                                        &OperandsParameters[0].rOperands[0],
                                                        &thirdROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul coef9 , x - 2.0 */
                        clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[15],
                                                        &intermROperands[14],
                                                        &ninthCoefROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coef10 */
                        clsIOPERAND_New(Compiler, &intermIOperands[16], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_ADD_RTZ,
                                                        &intermIOperands[16],
                                                        &intermROperands[15],
                                                        &tenthCoefROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x */
                        clsIOPERAND_New(Compiler, &intermIOperands[17], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[17],
                                                        &intermROperands[14],
                                                        &intermROperands[16]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coef11 */
                        clsIOPERAND_New(Compiler, &intermIOperands[18], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[17]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_ADD_RTZ,
                                                        &intermIOperands[18],
                                                        &intermROperands[17],
                                                        &eleventhCoefROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x */
                        clsIOPERAND_New(Compiler, &intermIOperands[19], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[18]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[19],
                                                        &intermROperands[14],
                                                        &intermROperands[18]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coef12 */
                        clsIOPERAND_New(Compiler, &intermIOperands[20], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[19]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_ADD_RTZ,
                                                        &intermIOperands[20],
                                                        &intermROperands[19],
                                                        &twelfthCoefROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x */
                        clsIOPERAND_New(Compiler, &intermIOperands[21], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[20]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[21],
                                                        &intermROperands[14],
                                                        &intermROperands[20]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coef13 */
                        clsIOPERAND_New(Compiler, &intermIOperands[22], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[21], &intermIOperands[21]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_ADD_RTZ,
                                                        &intermIOperands[22],
                                                        &intermROperands[21],
                                                        &thirteenthCoefROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x */
                        clsIOPERAND_New(Compiler, &intermIOperands[23], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[22], &intermIOperands[22]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[23],
                                                        &intermROperands[14],
                                                        &intermROperands[22]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coef14 */
                        clsIOPERAND_New(Compiler, &intermIOperands[24], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[23], &intermIOperands[23]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_ADD_RTZ,
                                                        &intermIOperands[24],
                                                        &intermROperands[23],
                                                        &fourteenthCoefROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x */
                        clsIOPERAND_New(Compiler, &intermIOperands[25], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[24]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[25],
                                                        &intermROperands[14],
                                                        &intermROperands[24]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coef15 */
                        clsIOPERAND_New(Compiler, &intermIOperands[26], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[25], &intermIOperands[25]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_ADD_RTZ,
                                                        &intermIOperands[26],
                                                        &intermROperands[25],
                                                        &fifteenthCoefROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x */
                        clsIOPERAND_New(Compiler, &intermIOperands[27], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[26], &intermIOperands[26]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[27],
                                                        &intermROperands[14],
                                                        &intermROperands[26]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coef16 */
                        clsIOPERAND_New(Compiler, &intermIOperands[28], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[27], &intermIOperands[27]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_ADD_RTZ,
                                                        &intermIOperands[28],
                                                        &intermROperands[27],
                                                        &sixteenthCoefROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x */
                        clsIOPERAND_New(Compiler, &intermIOperands[29], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[28], &intermIOperands[28]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[29],
                                                        &intermROperands[14],
                                                        &intermROperands[28]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coef17 */
                        clsIOPERAND_New(Compiler, &intermIOperands[30], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[29], &intermIOperands[29]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_ADD_RTZ,
                                                        &intermIOperands[30],
                                                        &intermROperands[29],
                                                        &seventeenthCoefROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x */
                        clsIOPERAND_New(Compiler, &intermIOperands[31], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[30], &intermIOperands[30]);
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        &intermIOperands[31],
                                                        &intermROperands[14],
                                                        &intermROperands[30]);

                        if (gcmIS_ERROR(status)) return status;

                        /* add result, coef18 */
                        clsIOPERAND_New(Compiler, &intermIOperands[32], clmGenCodeDataType(T_FLOAT));
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[31], &intermIOperands[31]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_ADD_RTZ,
                                                        &intermIOperands[32],
                                                        &intermROperands[31],
                                                        &eighteenthCoefROperand);

                        if (gcmIS_ERROR(status)) return status;

                        /* mul result, x */
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[32], &intermIOperands[32]);

                        status = clGenArithmeticExprCode(Compiler,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvOPCODE_MUL_RTZ,
                                                        IOperand,
                                                        &OperandsParameters[0].rOperands[0],
                                                        &intermROperands[32]);

                        if (gcmIS_ERROR(status)) return status;

                        status = clDefineSelectionTrueOperandEnd(Compiler,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                CodeGenerator,
                                                                &selectionContext3,
                                                                gcvFALSE);

                        if (gcmIS_ERROR(status)) return status;

                        /* The false part, t0 < -1.0 */
                        status = clDefineSelectionTrueOperandEnd(Compiler,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                CodeGenerator,
                                                                &selectionContext1,
                                                                gcvFALSE);

                        if (gcmIS_ERROR(status)) return status;
                        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext1);

                        if (gcmIS_ERROR(status)) return status;
                        /* The false part, x > 3.5 */
                        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext3);

                        if (gcmIS_ERROR(status)) return status;

                        /*When x<-1.0 or x>3.5, calculate E^x directly */
                        status =     _GenExp_E_10Code(
                                            Compiler,
                                            CodeGenerator,
                                            PolynaryExpr,
                                            OperandCount,
                                            OperandsParameters,
                                            IOperand,
                                            -1);
                        if (gcmIS_ERROR(status)) return status;


                        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                                CodeGenerator,
                                                                &selectionContext3);

                        if (gcmIS_ERROR(status)) return status;

                        /* The selection end */
                        status = clDefineSelectionEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext3);

                        if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext2);

            if (gcmIS_ERROR(status)) return status;

            /* The selection end for t0 > 1.0 */
            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContext2);

            if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* The selection end */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;

}

static gceSTATUS
_GenLogCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
#if FULL_PROFILE_TEST
    if (CodeGenerator->hasNEW_SIN_COS_LOG_DIV)
    {
        return _GenFullProfileLogCode(
                        Compiler,
                        CodeGenerator,
                        PolynaryExpr,
                        OperandCount,
                        OperandsParameters,
                        IOperand
                        );
    }
#endif

    return _GenLog2_E_10Code(
    Compiler,
    CodeGenerator,
    PolynaryExpr,
    OperandCount,
    OperandsParameters,
    IOperand,
    1);
}

static gceSTATUS
_GenExp2Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_EXP2,
                            IOperand,
                            &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}




static gceSTATUS
_GenLog2_E_10Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand,
    IN gctINT logBaseIndicate /*2: log2(x), 1: log(x), 10: log10(x), -1: log(1+x) */
    )
{
    gceSTATUS    status;
    clsROPERAND    nanROperand, zeroROperand, neg1ROperand;
    clsSELECTION_CONTEXT selectContextNan;
    clsIOPERAND        intermIOperands[30];
    clsROPERAND        intermROperands[30];
    clsROPERAND        constantROperand, float2ROperand;
    clsROPERAND        rcpROperand;
    clsROPERAND        firstROperand, secondROperand;
    clsROPERAND        firstCoefROperand, secondCoefROperand, thirdCoefROperand, fourthCoefROperand, fifthCoefROperand, sixthCoefROperand,
                    seventhCoefROperand, eighthCoefROperand, ninthCoefROperand, tenthCoefROperand, eleventhCoefROperand, twelfthCoefROperand;

    float    logTable[] = { /*To calculate logE(1+x) for small x, avoid log */
            1.0000000f,
            -0.50000032384345272f,
            0.33332569253278976f,
            -0.24997254298362576f,
            0.20024110219013430f,
            -0.16742798587580177f,
            0.14050048179662275f,
            -0.11641229544672624f,
            0.11643517351250515f,
            -0.13903758700270363f,
            0.11628276324675631f,
            -0.041253149805459369f,
    };

    int i = 0;
    clsSELECTION_CONTEXT    selectionContext, selectionContext1;

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstROperand,
                              clmGenCodeDataType(T_FLOAT),
                              ((logBaseIndicate == -1) ? 0.57f-1.0f : 0.57f));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondROperand,
                              clmGenCodeDataType(T_FLOAT),
                              ((logBaseIndicate == -1) ? 1.75f - 1.0f: 1.75f));

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&float2ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              2.0f);


    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);


    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                                        clmGenCodeDataType(T_UINT),
                                        0x7fc00000);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (float)0.0f );

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&neg1ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (-1.0f) );


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&rcpROperand,
                              clmGenCodeDataType(T_FLOAT),
                              ((logBaseIndicate == 10)? _LOG10_2 : _RCP_OF_LOG2_E)
                              );

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextNan);

    if (gcmIS_ERROR(status)) return status;

    /* If x >= 0, normal Log, else (include Nan input) return to Nan */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextNan,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN,
                                                &OperandsParameters[0].rOperands[0],
                                                (logBaseIndicate == -1)? &neg1ROperand: &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);

    if (gcmIS_ERROR(status)) return status;
    /*For Nan*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &nanROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextNan,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* Normal case */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);
    if (gcmIS_ERROR(status)) return status;


    {   /* Normal Log(x) calculation */
        /* The selection begins */
        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectionContext);

        if (gcmIS_ERROR(status)) return status;

        /* The condition part: t0 > 0.57 */
        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectionContext,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_GREATER_THAN,
                                                    &OperandsParameters[0].rOperands[0],
                                                    &firstROperand);

        if (gcmIS_ERROR(status)) return status;

        /* The true part for t0 > 0.57 */
        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectionContext);

        if (gcmIS_ERROR(status)) return status;


                /* The selection begins for t0 > 0.57 */
                status = clDefineSelectionBegin(Compiler,
                                                CodeGenerator,
                                                gcvTRUE,
                                                &selectionContext1);

                if (gcmIS_ERROR(status)) return status;

                /* The condition part: t0 < 1.75 */
                status = clGenSelectionCompareConditionCode(Compiler,
                                                            CodeGenerator,
                                                            &selectionContext1,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvCONDITION_LESS_THAN,
                                                            &OperandsParameters[0].rOperands[0],
                                                            &secondROperand);

                if (gcmIS_ERROR(status)) return status;

                /* The true part for t0 < 1.75 */
                status = clDefineSelectionTrueOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext1);

                if (gcmIS_ERROR(status)) return status;

                clsROPERAND_InitializeFloatOrVecOrMatConstant(&firstCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] : (gctFLOAT)1.442695140838623000000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&secondCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT)-0.721347987651824950000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirdCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT) 0.480887323617935180000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourthCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT)-0.360634148120880130000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&fifthCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT)0.288886845111846920000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&sixthCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT)-0.241547524929046630000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&seventhCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT)0.202699348330497740000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&eighthCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT)-0.167947441339492800000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&ninthCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT)0.167980447411537170000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&tenthCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT)-0.200588837265968320000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&eleventhCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT)0.167760565876960750000000);
                clsROPERAND_InitializeFloatOrVecOrMatConstant(&twelfthCoefROperand,
                                                            clmGenCodeDataType(T_FLOAT),
                                                            PolynaryExpr->funcName->symbol[0] == 'a' ? logTable[i++] :(gctFLOAT)-0.059515714645385742000000);


                clsROPERAND_InitializeFloatOrVecOrMatConstant(&constantROperand,
                                          clmGenCodeDataType(T_FLOAT),
                                          (gctFLOAT)1.0);





                /* sub from t0, 1.0 */
                clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));
                if(logBaseIndicate == -1){ /*log(1+x), x small, use x directly */
                    status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0]);
                }
                else{ /*x - 1 */
                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0],
                                    &constantROperand);
                }
                if (gcmIS_ERROR(status)) return status;

                /* mul result, coefficient12 */
                clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[1],
                                                &twelfthCoefROperand,
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient11 */
                clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[2],
                                &eleventhCoefROperand,
                                &intermROperands[1]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[3],
                                                &intermROperands[2],
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient10 */
                clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[4],
                                &tenthCoefROperand,
                                &intermROperands[3]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[5],
                                                &intermROperands[4],
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient9 */
                clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[6],
                                &ninthCoefROperand,
                                &intermROperands[5]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[7],
                                                &intermROperands[6],
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient8 */
                clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[8],
                                &eighthCoefROperand,
                                &intermROperands[7]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[9],
                                                &intermROperands[8],
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient7 */
                clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[10],
                                &seventhCoefROperand,
                                &intermROperands[9]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[11],
                                                &intermROperands[10],
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient6 */
                clsIOPERAND_New(Compiler, &intermIOperands[12], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[12],
                                &sixthCoefROperand,
                                &intermROperands[11]);

                if (gcmIS_ERROR(status)) return status;


                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[12], &intermIOperands[12]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[13],
                                                &intermROperands[12],
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient5 */
                clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[13]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[14],
                                &fifthCoefROperand,
                                &intermROperands[13]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[15],
                                                &intermROperands[14],
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient4 */
                clsIOPERAND_New(Compiler, &intermIOperands[16], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[16],
                                &fourthCoefROperand,
                                &intermROperands[15]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[17], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[16], &intermIOperands[16]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[17],
                                                &intermROperands[16],
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient3 */
                clsIOPERAND_New(Compiler, &intermIOperands[18], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[17], &intermIOperands[17]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[18],
                                &thirdCoefROperand,
                                &intermROperands[17]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[19], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[18], &intermIOperands[18]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[19],
                                                &intermROperands[18],
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient2 */
                clsIOPERAND_New(Compiler, &intermIOperands[20], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[19], &intermIOperands[19]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[20],
                                &secondCoefROperand,
                                &intermROperands[19]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[21], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[20], &intermIOperands[20]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[21],
                                                &intermROperands[20],
                                                &intermROperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* add to result, coefficient1 */
                clsIOPERAND_New(Compiler, &intermIOperands[22], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[21], &intermIOperands[21]);

                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[22],
                                &firstCoefROperand,
                                &intermROperands[21]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, previous result */
                clsIOPERAND_New(Compiler, &intermIOperands[23], clmGenCodeDataType(T_FLOAT));
                clsROPERAND_InitializeUsingIOperand(&intermROperands[22], &intermIOperands[22]);
                clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[19],
                                                &intermROperands[22],
                                                &intermROperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MULLO_RTZ,
                                                &intermIOperands[20],
                                                &intermROperands[22],
                                                &intermROperands[0]);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MUL_RTZ,
                                                &intermIOperands[21],
                                                &intermROperands[20],
                                                &float2ROperand);

                status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_ADD_RTZ,
                                                &intermIOperands[23],
                                                &intermROperands[21],
                                                &intermROperands[19]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result t0, _RCP_OF_LOG2_E */

                clsROPERAND_InitializeUsingIOperand(&intermROperands[23], &intermIOperands[23]);

                if(logBaseIndicate == 2 || PolynaryExpr->funcName->symbol[0] == 'a')/*Log2 or atanh */
                    status = clGenGenericCode1(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_ASSIGN,
                                                IOperand,
                                                &intermROperands[23]);
                else{ /*Log(x) or Log10(x) */
                    status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            IOperand,
                                            &intermROperands[23],
                                            &rcpROperand);
                    if(1){
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[29], IOperand);

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MULLO_RTZ,
                                                &intermIOperands[22],
                                                &intermROperands[23],
                                                &rcpROperand);

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_ADD_RTZ,
                                                &intermIOperands[23],
                                                &intermROperands[22],
                                                &intermROperands[22]);

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_ADD_RTZ,
                                                IOperand,
                                                &intermROperands[23],
                                                &intermROperands[29]);
                    }
                }
                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectionContext1,
                                                gcvFALSE);

                if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectionContext,
                                                gcvFALSE);

        if (gcmIS_ERROR(status)) return status;

        /* The false part, t0 < 0.57 */
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectionContext);

        if (gcmIS_ERROR(status)) return status;

                /* The false part, t0 >= 1.75 */
                status = clDefineSelectionFalseOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext1);

                if (gcmIS_ERROR(status)) return status;

                /* log2 t0, x */
                clsIOPERAND_New(Compiler, &intermIOperands[24], clmGenCodeDataType(T_FLOAT));
                if(logBaseIndicate == -1){ /* calculate 1+x*/


                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[0],
                                    &OperandsParameters[0].rOperands[0],
                                    &constantROperand);
                    if (gcmIS_ERROR(status)) return status;
                    /* Rounding for the add*/
                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADDLO_RTZ,
                                    &intermIOperands[1],
                                    &OperandsParameters[0].rOperands[0],
                                    &constantROperand);
                    if (gcmIS_ERROR(status)) return status;

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[2],
                                    &intermROperands[1],
                                    &intermROperands[1]);
                    if (gcmIS_ERROR(status)) return status;

                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &intermIOperands[1],
                                    &intermROperands[2],
                                    &intermROperands[0]);
                    if (gcmIS_ERROR(status)) return status;

                }

                status = clGenGenericCode1(
                                        Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_LOG2,
                                        &intermIOperands[24],
                                        logBaseIndicate == -1 ? &intermROperands[1]:
                                        &OperandsParameters[0].rOperands[0]);

                if (gcmIS_ERROR(status)) return status;

                /* mul result, t0, _RCP_OF_LOG2_E */


                clsROPERAND_InitializeUsingIOperand(&intermROperands[24], &intermIOperands[24]);

                if(logBaseIndicate == 2)/*Log2 */
                    status = clGenGenericCode1(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_ASSIGN,
                                                IOperand,
                                                &intermROperands[24]);
                else{ /*Log(x) or Log10(x) */
                    status = clGenArithmeticExprCode(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_MUL_RTZ,
                                            IOperand,
                                            &intermROperands[24],
                                            &rcpROperand);

                    if(1){
                        clsROPERAND_InitializeUsingIOperand(&intermROperands[29], IOperand);

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_MULLO_RTZ,
                                                &intermIOperands[22],
                                                &intermROperands[24],
                                                &rcpROperand);

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_ADD_RTZ,
                                                &intermIOperands[23],
                                                &intermROperands[22],
                                                &intermROperands[22]);

                        status = clGenArithmeticExprCode(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvOPCODE_ADD_RTZ,
                                                IOperand,
                                                &intermROperands[23],
                                                &intermROperands[29]);

                    }

                }
                if (gcmIS_ERROR(status)) return status;


                status = clDefineSelectionFalseOperandEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectionContext1);

                if (gcmIS_ERROR(status)) return status;


                /* The selection end for t0 > 0.57 */
                status = clDefineSelectionEnd(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

                if (gcmIS_ERROR(status)) return status;



        status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectionContext);

        if (gcmIS_ERROR(status)) return status;


        /* The selection end */
        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContext);

        if (gcmIS_ERROR(status)) return status;


    }

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                            CodeGenerator,
                            &selectContextNan);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenLog10Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
#if FULL_PROFILE_TEST
    if (CodeGenerator->hasNEW_SIN_COS_LOG_DIV)
    {
        return _GenFullProfileLog10Code(
                        Compiler,
                        CodeGenerator,
                        PolynaryExpr,
                        OperandCount,
                        OperandsParameters,
                        IOperand
                        );
    }
#endif

    return _GenLog2_E_10Code(
    Compiler,
    CodeGenerator,
    PolynaryExpr,
    OperandCount,
    OperandsParameters,
    IOperand,
    10);
}

static gceSTATUS
_GenLog2Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
#if FULL_PROFILE_TEST
    if (CodeGenerator->hasNEW_SIN_COS_LOG_DIV)
    {
        return _GenFullProfileLog2Code(
                        Compiler,
                        CodeGenerator,
                        PolynaryExpr,
                        OperandCount,
                        OperandsParameters,
                        IOperand
                        );
    }
#endif

    return _GenLog2_E_10Code(
    Compiler,
    CodeGenerator,
    PolynaryExpr,
    OperandCount,
    OperandsParameters,
    IOperand,
    2);
}

static gceSTATUS
_GenLog1pCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
#if FULL_PROFILE_TEST
    if (CodeGenerator->hasNEW_SIN_COS_LOG_DIV)
    {
        return _GenFullProfileLog1pCode(
                        Compiler,
                        CodeGenerator,
                        PolynaryExpr,
                        OperandCount,
                        OperandsParameters,
                        IOperand
                        );
    }
#endif

    return _GenLog2_E_10Code(
    Compiler,
    CodeGenerator,
    PolynaryExpr,
    OperandCount,
    OperandsParameters,
    IOperand,
    -1);
}

static gceSTATUS
_EvaluateSqrt(
    IN cloCOMPILER Compiler,
    IN gctUINT OperandCount,
    IN cloIR_CONSTANT * OperandConstants,
    IN OUT cloIR_CONSTANT ResultConstant
    )
{
    gceSTATUS           status;
    gctUINT             i, componentCount;
    cluCONSTANT_VALUE   values[16];

    gcmHEADER();

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandConstants);

    gcmASSERT(clmDECL_IsFloatOrVec(&OperandConstants[0]->exprBase.decl));
    gcmASSERT(clsDECL_IsEqual(&ResultConstant->exprBase.decl,
                              &OperandConstants[0]->exprBase.decl));

    componentCount = clmDATA_TYPE_vectorSize_GET(OperandConstants[0]->exprBase.decl.dataType);
    if(componentCount == 0) componentCount = 1;

    for (i = 0; i < componentCount; i++)
    {
        values[i].floatValue = gcoMATH_SquareRoot(OperandConstants[0]->values[i].floatValue);
    }

    status = cloIR_CONSTANT_AddValues(Compiler,
                                      ResultConstant,
                                      componentCount,
                                      values);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenSqrtCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SQRT,
                    IOperand,
                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}


static gceSTATUS
_GenNativeInverseCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    OperandsParameters[0].rOperands[0].dataType.elementType = clvTYPE_FLOAT;
    status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_INVERSE,
                    IOperand,
                    &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_EvaluateInverseSqrt(
    IN cloCOMPILER Compiler,
    IN gctUINT OperandCount,
    IN cloIR_CONSTANT * OperandConstants,
    IN OUT cloIR_CONSTANT ResultConstant
    )
{
    gceSTATUS           status;
    gctUINT             i, componentCount;
    cluCONSTANT_VALUE   values[16];

    gcmHEADER();

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandConstants);

    gcmASSERT(clmDECL_IsFloatOrVec(&OperandConstants[0]->exprBase.decl));
    gcmASSERT(clsDECL_IsEqual(&ResultConstant->exprBase.decl,
                              &OperandConstants[0]->exprBase.decl));

    componentCount = clmDATA_TYPE_vectorSize_GET(OperandConstants[0]->exprBase.decl.dataType);
    if(componentCount == 0) componentCount = 1;

    for (i = 0; i < componentCount; i++)
    {
        values[i].floatValue = gcoMATH_ReciprocalSquareRoot(OperandConstants[0]->values[i].floatValue);
    }

    status = cloIR_CONSTANT_AddValues(Compiler,
                                      ResultConstant,
                                      componentCount,
                                      values);
    if (gcmIS_ERROR(status)) { gcmFOOTER(); return status; }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenInverseSqrtCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_INVERSE_SQRT,
                            IOperand,
                            &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenFabsCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ABS,
                            IOperand,
                            &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenFloorCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_FLOOR,
                            IOperand,
                            &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenRintCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND    intermROperands[3], signROperand, unsignROperand,oneTo24ROperand,oneROperand,dot5ROperand;
    clsIOPERAND intermIOperands[3];
    clsSELECTION_CONTEXT selectContextBigX;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x80000000);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneTo24ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (float)(1<<24) );

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&dot5ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (float)(0.5));

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x00000001);

    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);
    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    intermIOperands[0].dataType.elementType = clvTYPE_INT;

    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &unsignROperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    {

        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextBigX);
        if (gcmIS_ERROR(status)) return status;

        status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextBigX,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[0],
                                                &oneTo24ROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextBigX);

        /*|X| >= 2^24, already integer, return x */
        status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ASSIGN,
                            IOperand,
                            &OperandsParameters[0].rOperands[0]);

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextBigX,
                                        gcvFALSE);

        status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextBigX);
        /*r1 = |X| + 0.5 */
        status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[1],
                            &dot5ROperand,
                            &intermROperands[0]);

        /*r2 = floor(r1) */
        status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FLOOR,
                    &intermIOperands[2],
                    &intermROperands[1]);

        /* r1 = frac(|x|) */
        status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FRACT,
                    &intermIOperands[1],
                    &intermROperands[0]);


        {
            clsSELECTION_CONTEXT selectContextFrac05;
            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextFrac05);
            if (gcmIS_ERROR(status)) return status;

            status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextFrac05,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &intermROperands[1],
                                                    &dot5ROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextFrac05);

            /*r0 = INT(r2) */
            status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_FLOAT_TO_INT,
                                &intermIOperands[0],
                                &intermROperands[2]);

            /*r0 &= 0x01 */
            status = clGenBitwiseExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[0],
                        &oneROperand,
                        &intermROperands[0]);

            /*if r2 = r2 - float(int(r2)%2) */
            status = clGenGenericCode1(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_INT_TO_FLOAT,
                                &intermIOperands[1],
                                &intermROperands[0]);

            status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_SUB_RTZ,
                            &intermIOperands[2],
                            &intermROperands[2],
                            &intermROperands[1]);

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextFrac05,
                                            gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextFrac05);

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextFrac05);
            status = clDefineSelectionEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextFrac05);

        }

        status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SIGN,
                    &intermIOperands[1],
                    &OperandsParameters[0].rOperands[0]);

        status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            IOperand,
                            &intermROperands[1],
                            &intermROperands[2]);

        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextBigX);
        status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextBigX);



    }
    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}



static gceSTATUS
_GenCeilCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    status = clGenGenericCode1(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_CEIL,
                            IOperand,
                            &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenFractCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND    intermROperands[2];
    clsIOPERAND intermIOperands[2];
    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsIOPERAND_New(Compiler, &intermIOperands[0], OperandsParameters[0].dataTypes[0].def);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenGenericCode1(
                Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_FLOOR,
                &intermIOperands[0],
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;
#if FULL_PROFILE_TEST
    status = clGenGenericCode1(
                Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_FRACT_RTNE,
                IOperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;
#else
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB,
                IOperand,
                &OperandsParameters[0].rOperands[0],
                &intermROperands[0]);
#endif
{ /* Save out the r0*/
    clsLOPERAND lOperand[1];
    clsROPERAND zeroROperand;

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x0);

    clsLOPERAND_InitializeUsingROperand(lOperand, &OperandsParameters[1].rOperands[0]);
    status = clGenStoreCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                &intermROperands[0],
                                lOperand,
                                OperandsParameters[1].rOperands[0].dataType,
                                &zeroROperand);
        if (gcmIS_ERROR(status)) return status;
} /*End of Save out */
{ /*Handle the inf cases */

    clsROPERAND outROperand, unsignedROperand, infROperand, zeroROperand;
    clsIOPERAND_New(Compiler, &intermIOperands[1], OperandsParameters[0].dataTypes[0].def);
    intermIOperands[1].dataType.elementType = clvTYPE_INT;
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);
    clsROPERAND_InitializeUsingIOperand(&outROperand, IOperand);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignedROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x0);
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[1],
                &unsignedROperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;
    if(clmGEN_CODE_IsScalarDataType(OperandsParameters[0].dataTypes[0].def)){

            clmGEN_CODE_IF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo,
                         &intermROperands[1],
                         clvCONDITION_EQUAL,
                         &infROperand);

            /* add the word with rounding */
            status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    IOperand,
                                    &zeroROperand);

            if (gcmIS_ERROR(status)) return status;

           clmGEN_CODE_ELSE(Compiler,
                       CodeGenerator,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo);


            /*else, do nothing */

           clmGEN_CODE_ENDIF(Compiler,
                             CodeGenerator,
                             PolynaryExpr->exprBase.base.lineNo,
                             PolynaryExpr->exprBase.base.stringNo);


    }
    else{ /*vector case, avoid branch/jump */
        status = clGenGenericCode2(
                                Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_NOT_EQUAL,
                                &intermIOperands[1],
                                &intermROperands[1],
                                &infROperand);

        IOperand->dataType.elementType = clvTYPE_INT;
        status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    IOperand,
                    &intermROperands[1],
                    &outROperand);
        IOperand->dataType.elementType = clvTYPE_FLOAT;
        if (gcmIS_ERROR(status)) return status;
    }
}

    return gcvSTATUS_OK;
OnError:
    return status;
}


static gceSTATUS
_GenModfCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND    intermROperands[4], signROperand;
    clsIOPERAND intermIOperands[4];
    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x80000000);
    clsIOPERAND_New(Compiler, &intermIOperands[0], OperandsParameters[0].dataTypes[0].def);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    clsIOPERAND_New(Compiler, &intermIOperands[1], OperandsParameters[0].dataTypes[0].def);
    intermIOperands[1].dataType.elementType = clvTYPE_INT;
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    clsIOPERAND_New(Compiler, &intermIOperands[2], OperandsParameters[0].dataTypes[0].def);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    clsIOPERAND_New(Compiler, &intermIOperands[3], OperandsParameters[0].dataTypes[0].def);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);



    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[1],
                &signROperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ABS,
                    &intermIOperands[3],
                    &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /* Get the integer part of |x|*/
    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FLOOR,
                    &intermIOperands[0],
                    &intermROperands[3]);



    /*Get the frac part of |x| */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[2],
                &intermROperands[3],
                &intermROperands[0]);



    if (gcmIS_ERROR(status)) return status;

    /*Add the sign bits */
    IOperand->dataType.elementType = clvTYPE_INT;
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_OR_BITWISE,
                IOperand,
                &intermROperands[1],
                &intermROperands[2]);
    IOperand->dataType.elementType = clvTYPE_FLOAT;
    if (gcmIS_ERROR(status)) return status;

    intermIOperands[0].dataType.elementType = clvTYPE_INT;
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_OR_BITWISE,
                &intermIOperands[0],
                &intermROperands[1],
                &intermROperands[0]);
    if (gcmIS_ERROR(status)) return status;


{ /* Save out the r0*/
    clsLOPERAND lOperand[1];
    clsROPERAND zeroROperand;

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x0);

    clsLOPERAND_InitializeUsingROperand(lOperand, &OperandsParameters[1].rOperands[0]);
    status = clGenStoreCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                &intermROperands[0],
                                lOperand,
                                OperandsParameters[1].rOperands[0].dataType,
                                &zeroROperand);
        if (gcmIS_ERROR(status)) return status;
} /*End of Save out */

{ /*Handle the inf cases */

    clsROPERAND outROperand, unsignedROperand, infROperand, zeroROperand;
    clsIOPERAND_New(Compiler, &intermIOperands[1], OperandsParameters[0].dataTypes[0].def);
    intermIOperands[1].dataType.elementType = clvTYPE_INT;
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);
    clsROPERAND_InitializeUsingIOperand(&outROperand, IOperand);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignedROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x0);
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[1],
                &unsignedROperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;
    if(clmGEN_CODE_IsScalarDataType(OperandsParameters[0].dataTypes[0].def)){
        /*Inf + Nan, original document, only Inf, but lot reference put Modf(Nan, &dd) result 0 */
            clmGEN_CODE_IF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo,
                         &intermROperands[1],
                         clvCONDITION_EQUAL,
                         &infROperand);
            IOperand->dataType.elementType = clvTYPE_INT;
            status = clGenBitwiseExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        IOperand,
                        &signROperand,
                        &OperandsParameters[0].rOperands[0]);
            IOperand->dataType.elementType = clvTYPE_FLOAT;
            if (gcmIS_ERROR(status)) return status;

           clmGEN_CODE_ELSE(Compiler,
                       CodeGenerator,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo);


            /*else, do nothing */

           clmGEN_CODE_ENDIF(Compiler,
                             CodeGenerator,
                             PolynaryExpr->exprBase.base.lineNo,
                             PolynaryExpr->exprBase.base.stringNo);


    }
    else{
        /*vector case, avoid branch/jump */
        /*Inf + Nan, original document, only Inf, but lot reference put Modf(Nan, &dd) result 0 */
        status = clGenGenericCode2(
                                Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_NOT_EQUAL,
                                &intermIOperands[1],
                                &intermROperands[1],
                                &infROperand);

        IOperand->dataType.elementType = clvTYPE_INT;
        intermIOperands[2].dataType.elementType = clvTYPE_INT;
        intermROperands[2].dataType.elementType = clvTYPE_INT;

        status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[2],
                    &intermROperands[1],
                    &outROperand);

        status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[1],
                    &signROperand,
                    &OperandsParameters[0].rOperands[0]);

        status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    IOperand,
                    &intermROperands[1],
                    &intermROperands[2]);

        IOperand->dataType.elementType = clvTYPE_FLOAT;
        if (gcmIS_ERROR(status)) return status;
    }
}

    return gcvSTATUS_OK;
OnError:
    return status;
}


static gceSTATUS
_GenFrexpCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND    intermROperands[5], expROperand, signMantROperand, exp2ROperand, zeroROperand, dot5ROperand, twenty3ROperand, unsignedROperand, mantROperand;
    clsIOPERAND intermIOperands[5];
    clsSELECTION_CONTEXT selectContextX0;
    int i;
    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsROPERAND_InitializeIntOrIVecConstant(&expROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x7f800000);
    clsROPERAND_InitializeIntOrIVecConstant(&exp2ROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x3fc00000);
    clsROPERAND_InitializeIntOrIVecConstant(&signMantROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x807fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x00000000);

    clsROPERAND_InitializeIntOrIVecConstant(&dot5ROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x3f000000);
    clsROPERAND_InitializeIntOrIVecConstant(&twenty3ROperand, /*23*/
                                            clmGenCodeDataType(T_INT),
                                            23);
    clsROPERAND_InitializeIntOrIVecConstant(&unsignedROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&mantROperand,
                                        clmGenCodeDataType(T_INT),
                                        0x007fffff);
    for(i = 0; i<5; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i],
            i == 0? clmGenCodeDataType(T_FLOAT) : clmGenCodeDataType(T_INT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }
    /*r1 = expMask & X */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[1],
                &expROperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /*r2 = r1 - (expMask/2) */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[2],
                &intermROperands[1],
                &exp2ROperand);

    if (gcmIS_ERROR(status)) return status;

    /* r3 = abs(r2)*/
    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ABS,
                    &intermIOperands[3],
                    &intermROperands[2]);
    if (gcmIS_ERROR(status)) return status;

    /*if r3 == expMask/2, means |X| == either 0 or inf/Nan, special cases */

    status = clDefineSelectionBegin(Compiler,
                            CodeGenerator,
                            gcvTRUE,
                            &selectContextX0);
    if (gcmIS_ERROR(status)) return status;

    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextX0,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[3],
                                                &exp2ROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextX0);
    { /*special cases, return to X, *out = 0 */
        clmGEN_CODE_IF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo,
                     &intermROperands[1],
                     clvCONDITION_EQUAL,
                     &expROperand);

        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    IOperand,
                                    &OperandsParameters[0].rOperands[0]);
       clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);
       /*Exponent part = 0, denormal value, return 0 */
        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    IOperand,
                                    &zeroROperand);

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    &intermIOperands[1],
                                    &zeroROperand);

    }
    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextX0,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextX0);
    if (gcmIS_ERROR(status)) return status;
    {
        /*Normal cases, put the 0x3f000000 to the mantisaa+Sign part  */
        /*step 1: clean the exp part */
        status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[2],
                    &signMantROperand,
                    &OperandsParameters[0].rOperands[0]);
        if (gcmIS_ERROR(status)) return status;

        /*step 2: add the 0x3f000000 to the return value */
        IOperand->dataType.elementType = clvTYPE_INT;
        status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    IOperand,
                    &dot5ROperand,
                    &intermROperands[2]);
        if (gcmIS_ERROR(status)) return status;
        IOperand->dataType.elementType = clvTYPE_FLOAT;


        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[2],
                &intermROperands[1],
                &dot5ROperand);
        status = clGenShiftExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_RSHIFT,
                    &intermIOperands[1],
                    &intermROperands[2],
                    &twenty3ROperand);

    }
    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextX0);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextX0);
    if (gcmIS_ERROR(status)) return status;





    { /* Save out the r1*/
        clsLOPERAND lOperand[1];
        clsLOPERAND_InitializeUsingROperand(lOperand, &OperandsParameters[1].rOperands[0]);
        status = clGenStoreCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    &intermROperands[1],
                                    lOperand,
                                    OperandsParameters[1].rOperands[0].dataType,
                                    &zeroROperand);
            if (gcmIS_ERROR(status)) return status;
    } /*End of Save out */

    return gcvSTATUS_OK;
OnError:
       return status;
}


static gceSTATUS
_GenNextAfterCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{ /*The algorithm comes from reference_math.c */
    clsROPERAND zeroROperand, nanROperand, unsignROperand, oneROperand, signROperand, infROperand;
    clsSELECTION_CONTEXT    selectContextEq, selectContextNan, selectContextNeg[3];
    clsIOPERAND sumIOperand;
    clsROPERAND sumROperand;
    clsIOPERAND        intermIOperands[2], tempIOperands[4];
    clsROPERAND        intermROperands[2], tempROperands[4];
    gceSTATUS                    status;
    int i;
    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7fC00000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 0x1);

    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x80000000);
    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                          clmGenCodeDataType(T_UINT),
                          (gctUINT) 0x7f800000);


    clsIOPERAND_New(Compiler, &sumIOperand, clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&sumROperand, &sumIOperand);
    for(i = 0; i<2; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
        intermIOperands[i].dataType.elementType =  clvTYPE_INT;
        status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[i],
                    &unsignROperand,
                    &OperandsParameters[i].rOperands[0]);
    }
    for(i = 0; i<4; i++){
        clsIOPERAND_New(Compiler, &tempIOperands[i], clmGenCodeDataType(T_INT));
        clsROPERAND_InitializeUsingIOperand(&tempROperands[i], &tempIOperands[i]);
    }


    /* |x| + |y| */
    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &sumIOperand,
                                    &intermROperands[0],
                                    &intermROperands[1]);


    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextNan);
    if (gcmIS_ERROR(status)) return status;

    sumROperand.dataType.elementType = clvTYPE_INT;
    /* (|X|+|Y|)> 0x7F800000? NaN*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextNan,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &sumROperand,
                                                &infROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);

    if (gcmIS_ERROR(status)) return status;

    /*For Nan*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &nanROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextNan,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* Non-Nan case */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);
    if (gcmIS_ERROR(status)) return status;



    {
        OperandsParameters[0].rOperands[0].dataType.elementType = clvTYPE_INT;
        OperandsParameters[1].rOperands[0].dataType.elementType = clvTYPE_INT;
        sumIOperand.dataType.elementType = clvTYPE_INT;
        sumROperand.dataType.elementType = clvTYPE_INT;

        /* |x| + |y| */
        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &sumIOperand,
                                        &intermROperands[0],
                                        &intermROperands[1]);

        /*If |x| + |y| == 0 (include -0.0, 0.0) */
        clmGEN_CODE_IF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo,
                     &sumROperand,
                     clvCONDITION_EQUAL,
                     &zeroROperand);

        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    IOperand,
                                    &OperandsParameters[1].rOperands[0]);

        clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);


        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextEq);
        if (gcmIS_ERROR(status)) return status;

        status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextEq,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &OperandsParameters[0].rOperands[0],
                                                &OperandsParameters[1].rOperands[0]);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextEq);
        /*x == y, return to x */
        status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ASSIGN,
                                    IOperand,
                                    &OperandsParameters[0].rOperands[0]);

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextEq,
                                        gcvFALSE);
        /*x != y */
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextEq);
        {
            for(i = 0; i<2; i++){
                status = clDefineSelectionBegin(Compiler,
                                                CodeGenerator,
                                                gcvTRUE,
                                                &selectContextNeg[i]);
                if (gcmIS_ERROR(status)) return status;

                status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextNeg[i],
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_LESS_THAN,
                                                        &OperandsParameters[i].rOperands[0],
                                                        &zeroROperand);
                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionTrueOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContextNeg[i]);

                status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &tempIOperands[i],
                                    &signROperand,
                                    &OperandsParameters[i].rOperands[0]);


                status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectContextNeg[i],
                                                gcvFALSE);
                /*x y >= 0 */
                status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextNeg[i]);
                /*xy>=0, keep it */
                status = clGenGenericCode1(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ASSIGN,
                                            &tempIOperands[i],
                                            &OperandsParameters[i].rOperands[0]);
                status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextNeg[i]);
                status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextNeg[i]);
            }

            /* x += sign(y-x), but y-x may over flow, so we use condition y>x */
            {
                clsSELECTION_CONTEXT    selectContextXlessY;
                status = clDefineSelectionBegin(Compiler,
                                                CodeGenerator,
                                                gcvTRUE,
                                                &selectContextXlessY);
                if (gcmIS_ERROR(status)) return status;

                status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextXlessY,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_LESS_THAN,
                                                        &tempROperands[0],
                                                        &tempROperands[1]);
                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionTrueOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContextXlessY);

                /*x += 1 (add LSB) */
                status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ADD_RTZ,
                                    &tempIOperands[2],
                                    &tempROperands[0],
                                    &oneROperand);



                status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectContextXlessY,
                                                gcvFALSE);
                /*x > y*/
                status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextXlessY);
                /*x -= 1 (add LSB) */
                status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    &tempIOperands[2],
                                    &tempROperands[0],
                                    &oneROperand);

                status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextXlessY);
                status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextXlessY);
            }

            /*Handle possible Neg result */

            for(i = 2; i<3; i++){ /* just on i == 2*/
                status = clDefineSelectionBegin(Compiler,
                                                CodeGenerator,
                                                gcvTRUE,
                                                &selectContextNeg[i]);

                if (gcmIS_ERROR(status)) return status;
                status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextNeg[i],
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_LESS_THAN,
                                                        &tempROperands[i],
                                                        &zeroROperand);
                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionTrueOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContextNeg[i]);

                IOperand->dataType.elementType = clvTYPE_INT;
                status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_SUB_RTZ,
                                    IOperand,
                                    &signROperand,
                                    &tempROperands[i]);
                IOperand->dataType.elementType = clvTYPE_FLOAT;


                status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectContextNeg[i],
                                                gcvFALSE);
                /*x y >= 0 */
                status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextNeg[i]);
                /*xy>=0, keep it */
                status = clGenGenericCode1(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            clvOPCODE_ASSIGN,
                                            IOperand,
                                            &tempROperands[i]);
                status = clDefineSelectionFalseOperandEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextNeg[i]);
                status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextNeg[i]);
            }
        }
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextEq);



        OperandsParameters[0].rOperands[0].dataType.elementType = clvTYPE_FLOAT;
        OperandsParameters[1].rOperands[0].dataType.elementType = clvTYPE_FLOAT;
        status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextEq);

        /*End of |x| + |y| == 0 */
       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);
    }

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextNan);
    status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextNan);
    if (gcmIS_ERROR(status)) return status;


    return gcvSTATUS_OK;
OnError:
    return status;

}

static gctFLOAT
_Mod(
     IN gctFLOAT Operand0,
     IN gctFLOAT Operand1
     )
{
    return Operand0 - Operand1 * (gctFLOAT)(gctINT)(Operand0 / Operand1);
}

static gceSTATUS
_EvaluateMod(
    IN cloCOMPILER Compiler,
    IN gctUINT OperandCount,
    IN cloIR_CONSTANT * OperandConstants,
    IN OUT cloIR_CONSTANT ResultConstant
    )
{
    gceSTATUS            status;
    gctUINT                i, componentCount;
    cluCONSTANT_VALUE    values[16];

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandConstants);

    gcmASSERT(clmDECL_IsFloatOrVec(&OperandConstants[0]->exprBase.decl));
    gcmASSERT(clsDECL_IsEqual(&ResultConstant->exprBase.decl,
                              &OperandConstants[0]->exprBase.decl));

    componentCount = clmDATA_TYPE_vectorSize_GET(OperandConstants[0]->exprBase.decl.dataType);
    if(componentCount == 0) componentCount = 1;

    for (i = 0; i < componentCount; i++) {
        if (clmDECL_IsFloat(&OperandConstants[1]->exprBase.decl)) {
            values[i].floatValue = _Mod(OperandConstants[0]->values[i].floatValue,
                            OperandConstants[1]->values[0].floatValue);
        }
        else {
            values[i].floatValue = _Mod(OperandConstants[0]->values[i].floatValue,
                            OperandConstants[1]->values[i].floatValue);
        }
    }

    status = cloIR_CONSTANT_AddValues(Compiler,
                                      ResultConstant,
                                      componentCount,
                                      values);
    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}



/*Old method of x/y, first get 2^32/y, then (x*(2^32/y))>>32 */
static gceSTATUS
_GenModCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsSELECTION_CONTEXT    selectionContextGreater1,selectionContext0, selectionContext1;
    clsROPERAND firstROperand[1], secondROperand[2];
    clsROPERAND zeroROperand, oneROperand, fourROperand, minIntROperand;
    clsIOPERAND secondIntermIOperand[2];
    clsIOPERAND intermIOperands[20], signIOperands[1];
    clsROPERAND intermROperands[20], signROperands[1];
    cleOPCODE opcode;
    gctUINT LineNo = PolynaryExpr->exprBase.base.lineNo;
    gctUINT StringNo = PolynaryExpr->exprBase.base.stringNo;

    /* Verify the arguments. */
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    opcode = PolynaryExpr->funcName->symbol[0] == 'm'? clvOPCODE_MOD : clvOPCODE_DIV;

    if(clmIsElementTypePacked(IOperand->dataType.elementType) ||
        IOperand->dataType.elementType == clvTYPE_CHAR ||
        IOperand->dataType.elementType == clvTYPE_UCHAR ||
        IOperand->dataType.elementType == clvTYPE_LONG ||
        IOperand->dataType.elementType == clvTYPE_ULONG ||
        IOperand->dataType.elementType == clvTYPE_SHORT ||
        IOperand->dataType.elementType == clvTYPE_USHORT){
        status = clGenArithmeticExprCode(
                        Compiler,
                        LineNo,
                        StringNo,
                        opcode,
                        IOperand,
                        &OperandsParameters[0].rOperands[0],
                        &OperandsParameters[1].rOperands[0]);
        if (gcmIS_ERROR(status)) return status;
        return gcvSTATUS_OK;
    }

    IOperand->dataType.elementType = clvTYPE_UINT;

    clsIOPERAND_New(Compiler, secondIntermIOperand, clmGenCodeDataType(T_UINT));
    clsIOPERAND_New(Compiler, &secondIntermIOperand[1], clmGenCodeDataType(T_UINT));

    clsROPERAND_InitializeUsingIOperand(firstROperand, IOperand);
    clsROPERAND_InitializeUsingIOperand(secondROperand, secondIntermIOperand);
    clsROPERAND_InitializeUsingIOperand(&secondROperand[1], &secondIntermIOperand[1]);

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0);
    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            1);

    clsROPERAND_InitializeIntOrIVecConstant(&fourROperand, /*-(32<<23) + 4*/
                                            clmGenCodeDataType(T_UINT),
                                            0xf0000004);

    clsROPERAND_InitializeIntOrIVecConstant(&minIntROperand, /*minIntROperand, abs(y) ineffective*/
                                            clmGenCodeDataType(T_INT),
                                            0x80000000);
    if(OperandsParameters[0].dataTypes->def.elementType == clvTYPE_INT){/* For int32 type*/

        clsIOPERAND_New(Compiler, &signIOperands[0], clmGenCodeDataType(T_INT));
        IOperand->dataType.elementType = clvTYPE_INT;

        /* Sign of X */
        status = clGenGenericCode1(
                        Compiler,
                        LineNo,
                        StringNo,
                        clvOPCODE_SIGN,
                        &signIOperands[0],
                        &OperandsParameters[1].rOperands[0]);
        if (gcmIS_ERROR(status)) return status;
        clsROPERAND_InitializeUsingIOperand(&signROperands[0], &signIOperands[0]);

        /* Sign of Y */
        status = clGenGenericCode1(
                        Compiler,
                        LineNo,
                        StringNo,
                        clvOPCODE_SIGN,
                        IOperand,
                        &OperandsParameters[0].rOperands[0]);

        /* Sign of X/Y */
        status = clGenArithmeticExprCode(Compiler,
                    LineNo,
                    StringNo,
                    clvOPCODE_MUL_RTZ,
                    &signIOperands[0],
                    &signROperands[0],
                    &firstROperand[0]);

        /* Get Abs(X) */
        status = clGenGenericCode1(
                    Compiler,
                    LineNo,
                    StringNo,
                    clvOPCODE_ABS,
                    secondIntermIOperand,
                    &OperandsParameters[0].rOperands[0]);

        /* Get Abs(Y) */
        status = clGenGenericCode1(
                    Compiler,
                    LineNo,
                    StringNo,
                    clvOPCODE_ABS,
                    &secondIntermIOperand[1],
                    &OperandsParameters[1].rOperands[0]);

        /*Now we are ready to use 32 bit unsigned divider to handle Abs(x)/Abs(y) */
    }

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContextGreater1);
    if (gcmIS_ERROR(status)) return status;

    /* If Y > 1, normal step, else result X/Y = X*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContextGreater1,
                                                LineNo,
                                                StringNo,
                                                clvCONDITION_GREATER_THAN,
                                                OperandsParameters[0].dataTypes->def.elementType == clvTYPE_INT?
                                                &secondROperand[1]:
                                                &OperandsParameters[1].rOperands[0],
                                                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    /*Normal step */
    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextGreater1);
    if (gcmIS_ERROR(status)) return status;

    /* Goto float, r0 = ITOF(y) */
    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));

    status = clGenGenericCode1(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_UINT_TO_FLOAT,
                &intermIOperands[0],
                OperandsParameters[0].dataTypes->def.elementType == clvTYPE_INT?
                &secondROperand[1]:
                &OperandsParameters[1].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* r1 = r0*2^(-32) + 4_of_(LSB), inlarge y, make reciproal(y1) <= 2^32/y */
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[1],
                &fourROperand,
                &intermROperands[0]);
    if (gcmIS_ERROR(status)) return status;


    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    /* The data type should be FLOAT. */
    intermROperands[1].dataType.elementType = clvTYPE_FLOAT;

    /*r2 = 1/r1, float approx. of (1<<32)/y */
    intermROperands[1].dataType.elementType = clvTYPE_FLOAT;
    status = clGenGenericCode1(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_INVERSE,
                &intermIOperands[2],
                &intermROperands[1]);
    if (gcmIS_ERROR(status)) return status;

    /* r3 = UINT(r2)*/
    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    intermROperands[2].dataType.elementType = clvTYPE_UINT;
    status = clGenGenericCode1(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_FLOAT_TO_UINT,
                &intermIOperands[3],
                &intermROperands[2]);
    if (gcmIS_ERROR(status)) return status;
    intermROperands[2].dataType.elementType = clvTYPE_FLOAT;

    /* r4 = -y, useful for N-R, subtraction ...*/
    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_UINT));
    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[4],
                &zeroROperand,
                OperandsParameters[0].dataTypes->def.elementType == clvTYPE_INT?
                &secondROperand[1]:
                &OperandsParameters[1].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /* N-R, r6 = r3 +  ((r3*((-y)*r3))>>32) */

    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_UINT));
    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);
    /*r5 = (-y) * r3 */
    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[5],
                &intermROperands[4],
                &intermROperands[3]);
    if (gcmIS_ERROR(status)) return status;

    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);
    /*r5 = (r5 * r3) >>32 */
    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_MULHI,
                &intermIOperands[5],
                &intermROperands[5],
                &intermROperands[3]);
    if (gcmIS_ERROR(status)) return status;

    /* r6 = r3 + r5*/
    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[6],
                &intermROperands[5],
                &intermROperands[3]);
    if (gcmIS_ERROR(status)) return status;

    /* Now r6 is either 2^32/y or 2^32/y-1 */
    /* in order to check the 2nd case, we check r6*y + y <= 2^32*/
    /* r6 = r6 + ( r6*y <= (-y)? 1:0 )*/
    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);

    /* r7 = r6*y */
    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[7],
                &intermROperands[6],
                OperandsParameters[0].dataTypes->def.elementType == clvTYPE_INT?
                &secondROperand[1]:
                &OperandsParameters[1].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext0);
    if (gcmIS_ERROR(status)) return status;

    /* Check r6 * y <= (-y), i.e. r6 * y + y <= 2^32 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext0,
                                                LineNo,
                                                StringNo,
                                                clvCONDITION_LESS_THAN_EQUAL,
                                                &intermROperands[7],
                                                &intermROperands[4]);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext0);

    if (gcmIS_ERROR(status)) return status;

    /* r6 = r6 + 1, since (1 + r6)*y <= 2^32*/
    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[6],
                &intermROperands[6],
                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    LineNo,
                                    StringNo,
                                    CodeGenerator,
                                    &selectionContext0,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* No operation needs, r6 is exact 2^32/y */

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext0);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContext0);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext0);
    if (gcmIS_ERROR(status)) return status;


    /* Now r6 is exact (1<<32)/y, r8 = (x*r6>>32), very close to x/y, either x/y or x/y-1  */
    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_UINT));

    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_MULHI,
                &intermIOperands[8],
                &intermROperands[6],
                OperandsParameters[0].dataTypes->def.elementType == clvTYPE_INT?
                &secondROperand[0]:
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /* r9 = x + r8 * (-y)   get the residue, to see if the residue >= y*/
    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);

    /* r9 = r8 * (-y) */
    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[9],
                &intermROperands[8],
                &intermROperands[4]);
    if (gcmIS_ERROR(status)) return status;

    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

    /*r9 = x + r8 * (-y) get the remainder*/
    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[9],
                OperandsParameters[0].dataTypes->def.elementType == clvTYPE_INT?
                &secondROperand[0]:
                &OperandsParameters[0].rOperands[0],
                &intermROperands[9]);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext1);
    if (gcmIS_ERROR(status)) return status;

    /* r9 >= y  remainder >= y ? if yes, r8 is 1 smaller than the true x/y */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext1,
                                                LineNo,
                                                StringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[9],
                                                OperandsParameters[0].dataTypes->def.elementType == clvTYPE_INT?
                                                &secondROperand[1]:
                                                &OperandsParameters[1].rOperands[0]);



    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* return (r8 + 1) */
    status = clGenArithmeticExprCode(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_ADD_RTZ,
                IOperand,
                &intermROperands[8],
                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    LineNo,
                                    StringNo,
                                    CodeGenerator,
                                    &selectionContext1,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext1);
    if (gcmIS_ERROR(status)) return status;

    /* return (r8) */
    status = clGenGenericCode1(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &intermROperands[8]);

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContext1);

    if (gcmIS_ERROR(status)) return status;

    /* End of r8+1 and r8 pick */
    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext1);
    if (gcmIS_ERROR(status)) return status;

    /*End of Normal U32 divider */
    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    LineNo,
                                    StringNo,
                                    CodeGenerator,
                                    &selectionContextGreater1,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* For 0<=y<= 1 */
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextGreater1);
    if (gcmIS_ERROR(status)) return status;

    /* Move x (abs(x) for S32) to destination */
    status = clGenGenericCode1(Compiler,
                LineNo,
                StringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                OperandsParameters[0].dataTypes->def.elementType == clvTYPE_INT?
                &secondROperand[0]:
                &OperandsParameters[0].rOperands[0]);

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextGreater1);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContextGreater1);


    if (gcmIS_ERROR(status)) return status;
    /* For S32 case, multiple back the sign, get x/y */
    if(OperandsParameters[0].dataTypes->def.elementType == clvTYPE_INT){
        status = clGenArithmeticExprCode(Compiler,
                    LineNo,
                    StringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &signROperands[0],
                    &firstROperand[0]);

    }
    /* Now use x - y*(x/y) to get the remainder, actually, r9 also the remainder*/
    if(opcode ==clvOPCODE_MOD){
        status = clGenArithmeticExprCode(Compiler,
                    LineNo,
                    StringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &OperandsParameters[1].rOperands[0],
                    &firstROperand[0]);

        status = clGenArithmeticExprCode(Compiler,
                    LineNo,
                    StringNo,
                    clvOPCODE_SUB_RTZ,
                    IOperand,
                    &OperandsParameters[0].rOperands[0],
                    &firstROperand[0]);
    }
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenNanCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND nanROperand;
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsROPERAND_InitializeIntOrIVecConstant(&nanROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x7fc00000);

    IOperand->dataType.elementType = clvTYPE_INT;
    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    IOperand,
                    &nanROperand,
                    &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;
    /* Reset back the data type*/
    IOperand->dataType.elementType = clvTYPE_FLOAT;

    return gcvSTATUS_OK;

}

static gceSTATUS
_GenRoundCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND dot5ROperand;
    clsIOPERAND intermIOperands[2];
    clsROPERAND intermROperands[2];

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);


    clsROPERAND_InitializeFloatOrVecOrMatConstant(&dot5ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        0.5f);

    clsIOPERAND_New(Compiler, &intermIOperands[0], IOperand->dataType);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
    clsIOPERAND_New(Compiler, &intermIOperands[1], IOperand->dataType);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SIGN,
                    &intermIOperands[0],
                    &OperandsParameters[0].rOperands[0]);


    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ABS,
                    &intermIOperands[1],
                    &OperandsParameters[0].rOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[1],
                    &dot5ROperand,
                    &intermROperands[1]);


    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FLOOR,
                    &intermIOperands[1],
                    &intermROperands[1]);


    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &intermROperands[0],
                    &intermROperands[1]);

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenCopySignCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND signROperand, unsignROperand;
    clsIOPERAND intermIOperands[2];
    clsROPERAND intermROperands[2];

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x80000000);

    IOperand->dataType.elementType = clvTYPE_INT;
    clsIOPERAND_New(Compiler, &intermIOperands[0], IOperand->dataType);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
    clsIOPERAND_New(Compiler, &intermIOperands[1], IOperand->dataType);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &unsignROperand,
                &OperandsParameters[0].rOperands[0]);


    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[1],
                &signROperand,
                &OperandsParameters[1].rOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    IOperand,
                    &intermROperands[0],
                    &intermROperands[1]);
    if (gcmIS_ERROR(status)) return status;
    /* Reset back the data type*/
    IOperand->dataType.elementType = clvTYPE_FLOAT;

    return gcvSTATUS_OK;
}
static gceSTATUS
_GenTruncCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND intermIOperands[2];
    clsROPERAND intermROperands[2];

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsIOPERAND_New(Compiler, &intermIOperands[0], IOperand->dataType);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
    clsIOPERAND_New(Compiler, &intermIOperands[1], IOperand->dataType);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SIGN,
                    &intermIOperands[0],
                    &OperandsParameters[0].rOperands[0]);


    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ABS,
                    &intermIOperands[1],
                    &OperandsParameters[0].rOperands[0]);


    status = clGenGenericCode1(
                    Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_FLOOR,
                    &intermIOperands[1],
                    &intermROperands[1]);


    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &intermROperands[0],
                    &intermROperands[1]);

    return gcvSTATUS_OK;
}


static gceSTATUS
_GenILogbCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND zeroROperand, unsignROperand, oneROperand, twenty3ROperand, maskROperand, minROperand, one27ROperand;
    clsSELECTION_CONTEXT   selectContextInfX, selectContextX0;
    clsIOPERAND intermIOperands[2];
    clsROPERAND intermROperands[2];

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);


    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x1);
    clsROPERAND_InitializeIntOrIVecConstant(&twenty3ROperand,
                                            clmGenCodeDataType(T_INT),
                                            23);
    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x0);
    clsROPERAND_InitializeIntOrIVecConstant(&minROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x80000000);
    clsROPERAND_InitializeIntOrIVecConstant(&one27ROperand,
                                            clmGenCodeDataType(T_INT),
                                            127);

    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &maskROperand,
                &OperandsParameters[0].rOperands[0]);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextX0);
    if (gcmIS_ERROR(status)) return status;

    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextX0,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[0],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextX0);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &minROperand);
    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextX0,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextX0);
    if (gcmIS_ERROR(status)) return status;
    {
        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextInfX);
        if (gcmIS_ERROR(status)) return status;

        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &intermROperands[0],
                                                    &maskROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInfX);

        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &unsignROperand);
        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextInfX,
                                        gcvFALSE);

        if (gcmIS_ERROR(status)) return status;


        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInfX);
        if (gcmIS_ERROR(status)) return status;
        {
            status = clGenShiftExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_RSHIFT,
                        &intermIOperands[1],
                        &intermROperands[0],
                        &twenty3ROperand);

            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        IOperand,
                        &intermROperands[1],
                        &one27ROperand);
        }
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextInfX);

        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextInfX);
        if (gcmIS_ERROR(status)) return status;


    }
    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextX0);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextX0);
    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenLogbCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND zeroROperand, unsignROperand, negInfROperand, twenty3ROperand, maskROperand, one27ROperand;
    clsSELECTION_CONTEXT   selectContextInfX, selectContextX0;
    clsIOPERAND intermIOperands[2];
    clsROPERAND intermROperands[2];

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);


    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&negInfROperand,
                                            clmGenCodeDataType(T_INT),
                                            0xff800000);
    clsROPERAND_InitializeIntOrIVecConstant(&twenty3ROperand,
                                            clmGenCodeDataType(T_INT),
                                            23);
    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&one27ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (gctFLOAT)127.0f);

    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &maskROperand,
                &OperandsParameters[0].rOperands[0]);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextX0);
    if (gcmIS_ERROR(status)) return status;

    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextX0,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[0],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextX0);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &negInfROperand);
    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextX0,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextX0);
    if (gcmIS_ERROR(status)) return status;
    {
        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextInfX);
        if (gcmIS_ERROR(status)) return status;

        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &intermROperands[0],
                                                    &maskROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInfX);

        /* return to Inf or Nan, base on X == inf/Nan*/
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &OperandsParameters[0].rOperands[0],
                    &OperandsParameters[0].rOperands[0]);

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextInfX,
                                        gcvFALSE);

        if (gcmIS_ERROR(status)) return status;


        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInfX);
        if (gcmIS_ERROR(status)) return status;
        {
            status = clGenShiftExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_RSHIFT,
                        &intermIOperands[1],
                        &intermROperands[0],
                        &twenty3ROperand);

        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INT_TO_FLOAT,
                &intermIOperands[0],
                &intermROperands[1]);

            intermROperands[0].dataType.elementType = clvTYPE_FLOAT;
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        IOperand,
                        &intermROperands[0],
                        &one27ROperand);


        }
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextInfX);

        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextInfX);
        if (gcmIS_ERROR(status)) return status;


    }
    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextX0);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextX0);
    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;
}

static gceSTATUS
_GenLdexpCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{

    gceSTATUS    status;
    clsROPERAND zeroROperand, unsignROperand, oneROperand, twenty3ROperand;
    clsROPERAND maskROperand, signROperand, one27ROperand, two55ROperand, notExpROperand;
    clsSELECTION_CONTEXT   selectContextInfX, selectContextX0;
    clsIOPERAND intermIOperands[4];
    clsROPERAND intermROperands[4];
    int i;

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);


    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x7fffffff);
    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x1);
    clsROPERAND_InitializeIntOrIVecConstant(&twenty3ROperand,
                                            clmGenCodeDataType(T_INT),
                                            23);
    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x7f800000);
    clsROPERAND_InitializeIntOrIVecConstant(&notExpROperand,
                                            clmGenCodeDataType(T_INT),
                                            ~(0x7f800000));

    clsROPERAND_InitializeIntOrIVecConstant(&two55ROperand,
                                            clmGenCodeDataType(T_INT),
                                            0xff);


    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x0);
    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_INT),
                                            0x80000000);
    clsROPERAND_InitializeIntOrIVecConstant(&one27ROperand,
                                            clmGenCodeDataType(T_INT),
                                            127);
    for(i = 0; i<4; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_INT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &maskROperand,
                &OperandsParameters[0].rOperands[0]);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextX0);
    if (gcmIS_ERROR(status)) return status;

    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextX0,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[0],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextX0);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &zeroROperand);
    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextX0,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextX0);
    if (gcmIS_ERROR(status)) return status;
    {
        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectContextInfX);
        if (gcmIS_ERROR(status)) return status;

        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_EQUAL,
                                                    &intermROperands[0],
                                                    &maskROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInfX);

        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &OperandsParameters[0].rOperands[0]);
        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectContextInfX,
                                        gcvFALSE);

        if (gcmIS_ERROR(status)) return status;


        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectContextInfX);
        if (gcmIS_ERROR(status)) return status;
        {/*Normal case */
            status = clGenShiftExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_RSHIFT,
                        &intermIOperands[1],
                        &intermROperands[0],
                        &twenty3ROperand);


            /*255 - exp */
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[0],
                        &two55ROperand,
                        &intermROperands[1]);
            {/* Check if overflow, y>= 255 - exp(x)*/
                clsSELECTION_CONTEXT   selectContextXYOver;
                status = clDefineSelectionBegin(Compiler,
                                                CodeGenerator,
                                                gcvTRUE,
                                                &selectContextXYOver);
                if (gcmIS_ERROR(status)) return status;

                status = clGenSelectionCompareConditionCode(Compiler,
                                                            CodeGenerator,
                                                            &selectContextXYOver,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvCONDITION_GREATER_THAN_EQUAL,
                                                            &OperandsParameters[1].rOperands[0],
                                                            &intermROperands[0]);
                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionTrueOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContextXYOver);
                /* Overflow case, assign the Inf*signOf(x)*/
                status = clGenBitwiseExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_AND_BITWISE,
                            &intermIOperands[0],
                            &signROperand,
                            &OperandsParameters[0].rOperands[0]);

                IOperand->dataType.elementType = clvTYPE_INT;
                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                IOperand,
                                &intermROperands[0],
                                &maskROperand);
                if (gcmIS_ERROR(status)) return status;
                /* Reset back the data type*/
                IOperand->dataType.elementType = clvTYPE_FLOAT;

                status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectContextXYOver,
                                                gcvFALSE);

                if (gcmIS_ERROR(status)) return status;


                status = clDefineSelectionFalseOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContextXYOver);
                if (gcmIS_ERROR(status)) return status;
                {
                    clsSELECTION_CONTEXT   selectContextXYUnder;

                    /*r0 = exp(x) + y */
                    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_ADD_RTZ,
                                &intermIOperands[0],
                                &OperandsParameters[1].rOperands[0],
                                &intermROperands[1]);

                    status = clDefineSelectionBegin(Compiler,
                                                    CodeGenerator,
                                                    gcvTRUE,
                                                    &selectContextXYUnder);
                    if (gcmIS_ERROR(status)) return status;
                    /*r0 <= 0? underflow or not */
                    status = clGenSelectionCompareConditionCode(Compiler,
                                                                CodeGenerator,
                                                                &selectContextXYUnder,
                                                                PolynaryExpr->exprBase.base.lineNo,
                                                                PolynaryExpr->exprBase.base.stringNo,
                                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                                &zeroROperand,
                                                                &intermROperands[0]);
                    if (gcmIS_ERROR(status)) return status;

                    status = clDefineSelectionTrueOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectContextXYUnder);
                    /* underflow case, assign the 0*signOf(x)*/

                    IOperand->dataType.elementType = clvTYPE_INT;
                    status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_AND_BITWISE,
                                    IOperand,
                                    &signROperand,
                                    &OperandsParameters[0].rOperands[0]);
                    if (gcmIS_ERROR(status)) return status;
                    /* Reset back the data type*/
                    IOperand->dataType.elementType = clvTYPE_FLOAT;

                    status = clDefineSelectionTrueOperandEnd(Compiler,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    CodeGenerator,
                                                    &selectContextXYUnder,
                                                    gcvFALSE);

                    if (gcmIS_ERROR(status)) return status;


                    status = clDefineSelectionFalseOperandBegin(Compiler,
                                                            CodeGenerator,
                                                            &selectContextXYUnder);
                    if (gcmIS_ERROR(status)) return status;
                    { /*Normal cases, left shift to the exp position */
                        status = clGenShiftExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_LSHIFT,
                                    &intermIOperands[1],
                                    &intermROperands[0],
                                    &twenty3ROperand);
                        /*clean the exp bits */
                        status = clGenArithmeticExprCode(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_AND_BITWISE,
                                    &intermIOperands[0],
                                    &notExpROperand,
                                    &OperandsParameters[0].rOperands[0]);

                IOperand->dataType.elementType = clvTYPE_INT;
                /*Put the exponential bits */
                status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_OR_BITWISE,
                                IOperand,
                                &intermROperands[0],
                                &intermROperands[1]);
                if (gcmIS_ERROR(status)) return status;
                /* Reset back the data type*/
                IOperand->dataType.elementType = clvTYPE_FLOAT;


                    }
                    status = clDefineSelectionFalseOperandEnd(Compiler,
                                                            CodeGenerator,
                                                            &selectContextXYUnder);
                    if (gcmIS_ERROR(status)) return status;
                    status = clDefineSelectionEnd(Compiler,
                                                CodeGenerator,
                                                &selectContextXYUnder);
                    if (gcmIS_ERROR(status)) return status;


                }
                status = clDefineSelectionFalseOperandEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectContextXYOver);
                if (gcmIS_ERROR(status)) return status;
                status = clDefineSelectionEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextXYOver);
                if (gcmIS_ERROR(status)) return status;
            }
        }
        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextInfX);

        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextInfX);
        if (gcmIS_ERROR(status)) return status;


    }
    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextX0);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextX0);
    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;



}

static gceSTATUS
_GenFModCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsSELECTION_CONTEXT   selectionContextUp1,selectionContext0, selectionContext20;
    clsSELECTION_CONTEXT   selectionContextLoop, selectionContextLoopBack, selectContextNan;
    clsROPERAND zeroROperand, oneROperand, maskROperand, hideOneROperand;
    clsROPERAND scaleDown4ROperand, scaleDownROperand, twentyROperand, expMaskROperand;
    clsROPERAND twenty3ROperand, twenty8ROperand, twenty4To1ROperand, unsignROperand,signROperand;
    clsIOPERAND intermIOperands[20];
    clsROPERAND intermROperands[20];


    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);


    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0);
    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            1);
    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x007fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&hideOneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x00800000);
    clsROPERAND_InitializeIntOrIVecConstant(&scaleDown4ROperand, /*-(52<<23) + 4*/
                                            clmGenCodeDataType(T_UINT),
                                            0x31000004);

    clsROPERAND_InitializeIntOrIVecConstant(&scaleDownROperand, /*-(52<<23)*/
                                            clmGenCodeDataType(T_UINT),
                                            0x31000000);

    clsROPERAND_InitializeIntOrIVecConstant(&twentyROperand, /*20*/
                                            clmGenCodeDataType(T_UINT),
                                            20);

    clsROPERAND_InitializeIntOrIVecConstant(&twenty3ROperand, /*23*/
                                            clmGenCodeDataType(T_UINT),
                                            23);

    clsROPERAND_InitializeIntOrIVecConstant(&twenty8ROperand, /*28*/
                                            clmGenCodeDataType(T_UINT),
                                            28);

    clsROPERAND_InitializeIntOrIVecConstant(&expMaskROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x80000000);

    /*1/2^24,*/
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twenty4To1ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (float)1.1920929e-007 );


    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    /* Move Y to r0, then use fixed operation */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &unsignROperand,
                &OperandsParameters[1].rOperands[0]);

    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    /* r1 = r0 & mantissaMask */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[1],
                &intermROperands[0],
                &maskROperand);

    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext0);
    if (gcmIS_ERROR(status)) return status;

    /* Check r1 == 0? PowOf2 Value */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext0,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[1],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext0);

    if (gcmIS_ERROR(status)) return status;

    /* r2 = r1 + (-52)<<23*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[2],
                &intermROperands[1],
                &scaleDownROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContext0,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /*  */

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext0);
    if (gcmIS_ERROR(status)) return status;

    /* r2 = r1 + (-52)<<23 + 4*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[2],
                &intermROperands[1],
                &scaleDown4ROperand);


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContext0);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext0);
    if (gcmIS_ERROR(status)) return status;


    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

    /*r3 = 1/r2, float approx. of (1<<52)/Mantissa(y) */
    intermROperands[2].dataType.elementType = clvTYPE_FLOAT;
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INVERSE,
                &intermIOperands[3],
                &intermROperands[2]);
    if (gcmIS_ERROR(status)) return status;

    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);


    /* r4 = F2I(r3), approximation of 2^52/Mantissa(Y) */
    intermROperands[3].dataType.elementType = clvTYPE_UINT;
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_FLOAT_TO_UINT,
                &intermIOperands[4],
                &intermROperands[3]);
    if (gcmIS_ERROR(status)) return status;
    intermROperands[2].dataType.elementType = clvTYPE_FLOAT;

    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

    /* r5 = r1 + hideOne */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_OR_BITWISE,
                &intermIOperands[5],
                &intermROperands[1],
                &hideOneROperand);


    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);

    /* r6 = -r5 */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[6],
                &zeroROperand,
                &intermROperands[5]);

    /* N-R, r9 = r4 + (MulHi(r4,r4*(r6))>>20) */
    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[7],
                &intermROperands[4],
                &intermROperands[6]);

    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[8],
                &intermROperands[4],
                &intermROperands[7]);

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_RSHIFT,
                &intermIOperands[8],
                &intermROperands[8],
                &twentyROperand);
    if (gcmIS_ERROR(status)) return status;


    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[9],
                &intermROperands[4],
                &intermROperands[8]);
    /* End of N-R iteration, r9 is either 2^52/(MantisaY) or 2^52/(MantisaY) - 1 */


    clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);

    /*r10 = (MantisaY * (r9+1))>>32, add1 first*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[2],
                &oneROperand,
                &intermROperands[9]);

    /*r10 = MantisaY * r9>>32*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[10],
                &intermROperands[5],
                &intermROperands[2]);

    clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);
    /*r11 = r10 - (r10>>20)  */
    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_RSHIFT,
                &intermIOperands[11],
                &intermROperands[10],
                &twentyROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[11],
                &intermROperands[2],
                &intermROperands[11]);

    /* Now r11 is (1<<52/mantisaY) */

    clsIOPERAND_New(Compiler, &intermIOperands[12], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[12], &intermIOperands[12]);

    /* r12 = expX*/
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[12],
            &expMaskROperand,
            &OperandsParameters[0].rOperands[0]);



    clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[13]);

    /* r13 = expY*/
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[13],
            &expMaskROperand,
            &OperandsParameters[1].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;


    /* r0 = x & mantissaMask */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &maskROperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /* r0 = x | hideOne */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_OR_BITWISE,
                &intermIOperands[0],
                &hideOneROperand,
                &intermROperands[0]);
    if (gcmIS_ERROR(status)) return status;
    /*Later on, the r0 should be update as the remainder */
    /* r1 is set to zero, is the quo value after updating*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[1],
                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;



    clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);


    /* r12 = r12 - r13 */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_SUB_RTZ,
            &intermIOperands[12],
            &intermROperands[12],
            &intermROperands[13]);
    if (gcmIS_ERROR(status)) return status;

    /* shift to the right scale */
    status = clGenShiftExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_RSHIFT,
            &intermIOperands[12],
            &intermROperands[12],
            &twenty3ROperand);
    if (gcmIS_ERROR(status)) return status;


    if (gcmIS_ERROR(status)) return status;
/*while loop begin */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContextLoop);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContextLoopBack);
    if (gcmIS_ERROR(status)) return status;

    /* Loop End, jump back here*/
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoopBack);


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextLoopBack);

    if (gcmIS_ERROR(status)) return status;

    /* Check r12 >= 0? ExpX - ExpY >= 0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContextLoop,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[12],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoop);

    if (gcmIS_ERROR(status)) return status;


    /*r14 = min(28, r12)*/
    status = clGenGenericCode2(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MIN,
                        &intermIOperands[14],
                        &intermROperands[12],
                        &twenty8ROperand);

    /* compare leftshift (r14) with 20*/
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext20);
    if (gcmIS_ERROR(status)) return status;

    /* Check r14 <= 20? leftShift/rightShift */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext20,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN_EQUAL,
                                                &intermROperands[14],
                                                &twentyROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext20);

    if (gcmIS_ERROR(status)) return status;

    /* r15 = (r0 * r11)>>(32 + 20 - leftshift)*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[15],
                &intermROperands[11],
                &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* r2 = 20 - leftshift*/
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_SUB_RTZ,
            &intermIOperands[2],
            &twentyROperand,
            &intermROperands[14]);

    if (gcmIS_ERROR(status)) return status;

    /* R15 = ((r0*r11)>>32) >> r2*/
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_RSHIFT,
                        &intermIOperands[15],
                        &intermROperands[15],
                        &intermROperands[2]);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContext20,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext20);
    if (gcmIS_ERROR(status)) return status;

    /* r2 = leftshift - 20 */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_SUB_RTZ,
            &intermIOperands[2],
            &intermROperands[14],
            &twentyROperand);

    /* r15 = r0 << r2*/
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_LSHIFT,
                        &intermIOperands[15],
                        &intermROperands[0],
                        &intermROperands[2]);

    /* r15 = ((r0 <<r3) * r11)>>32 */
    intermIOperands[15].dataType.elementType = clvTYPE_UINT;
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[15],
                &intermROperands[11],
                &intermROperands[15]);

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContext20);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext20);
    if (gcmIS_ERROR(status)) return status;

    /* r0 = r0<<r14 */
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_LSHIFT,
                        &intermIOperands[0],
                        &intermROperands[0],
                        &intermROperands[14]);

    /* r2 = mantisaY*r15 */
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[2],
                        &intermROperands[5], /* mantisaY */
                        &intermROperands[15]);

    /* r0 = r0 - r2 */
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[0],
                        &intermROperands[0],
                        &intermROperands[2]);

    /* r1 = r1<<r14 */
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_LSHIFT,
                        &intermIOperands[1],
                        &intermROperands[1],
                        &intermROperands[14]);

    /* r1 = r1 + r15 */
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[1],
                        &intermROperands[1],
                        &intermROperands[15]);




    /* expX -= r14*/
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[12],
                        &intermROperands[12],
                        &intermROperands[14]);


    /* compare leftshift (r14) with 20*/
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContextUp1);
    if (gcmIS_ERROR(status)) return status;

    /* Check r0 >= mantissaY? quo should addup 1, r0 -= mantissaY, else OK */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContextUp1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[0],
                                                &intermROperands[5]);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextUp1);

    if (gcmIS_ERROR(status)) return status;

    /* r1++ */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[1],
                &intermROperands[1],
                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    /* r0 -= mantisaY, r5*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[0],
                &intermROperands[0],
                &intermROperands[5]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContextUp1,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextUp1);
    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextUp1);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContextUp1);
    if (gcmIS_ERROR(status)) return status;


    /* break condition expX-expY <= 0, break*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContextLoopBack,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN_EQUAL,
                                                &intermROperands[12],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoopBack);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContextLoopBack,
                                    gcvFALSE);

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContextLoopBack);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContextLoop,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /*loop End*/

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoop);
    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextLoop);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContextLoop);
    if (gcmIS_ERROR(status)) return status;

    {
        clsIOPERAND signIOperands[1];
        clsROPERAND signROperands[1];

        clsIOPERAND_New(Compiler, &signIOperands[0], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&signROperands[0], &signIOperands[0]);

        /*This part is from fixed r0 to floating point value */
        intermIOperands[3].dataType.elementType = clvTYPE_UINT; /* Force to unsigned; */
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_UINT_TO_FLOAT,
                &intermIOperands[3],
                &intermROperands[0]);
        /* r3 = r0/2^24, scale back to the right float scale*/
        intermIOperands[3].dataType.elementType = clvTYPE_FLOAT;
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[3],
                    &intermROperands[3],
                    &twenty4To1ROperand);

        /* Go back to the normal Exp*/
        status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[12],
                &intermROperands[12],
                &twenty3ROperand);

        /* r12 = r12 + r13 */
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[12],
                &intermROperands[12],
                &intermROperands[13]);
        if (gcmIS_ERROR(status)) return status;



        /* The exp part add to the remainder */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[3],
                    &intermROperands[3],
                    &intermROperands[12]);

        /*Get the sign of X */
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SIGN,
                &signIOperands[0],
                &OperandsParameters[0].rOperands[0]);

        /*set sign, same as the X */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[3],
                    &intermROperands[3],
                    &signROperands[0]);


    }

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &intermROperands[3]);

    /* Now we handle corner cases: Get the Abs(X), ABS(Y)*/
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[0],
            &unsignROperand,
            &OperandsParameters[0].rOperands[0]);

    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[1],
            &unsignROperand,
            &OperandsParameters[1].rOperands[0]);

    /*r5 = max(|X|,|Y|), unsigned type */
    status = clGenGenericCode2(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MAX,
                &intermIOperands[5],
                &intermROperands[0],
                &intermROperands[1]);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextNan);
    if (gcmIS_ERROR(status)) return status;

    /* (max(|X|,|Y|)&0x7FFFFFFF) > 0x7F800000? NaN*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextNan,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &intermROperands[5],
                                                &expMaskROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);

    if (gcmIS_ERROR(status)) return status;

    /*For Nan*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &unsignROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextNan,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* For Non-Nan case */

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);
    if (gcmIS_ERROR(status)) return status;
    {
        /*Handdle X == Infinity || Y == Infinity || Y == 0*/
        clsSELECTION_CONTEXT   selectContextInfX, selectContextY0, selectContextInfY;

        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[0],
            &unsignROperand,
            &OperandsParameters[0].rOperands[0]);


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextY0);
            if (gcmIS_ERROR(status)) return status;

            /* |Y| == 0? */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextY0,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &intermROperands[1],
                                                        &zeroROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextY0);
            /*Same as X = Infinity*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[0],
                        &expMaskROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextY0,
                                            gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextY0);

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextY0);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextY0);
            if (gcmIS_ERROR(status)) return status;


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextInfX);
            if (gcmIS_ERROR(status)) return status;

            /* ((X)&0x7FFFFFFF) == 0x7F800000? Infinity*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextInfX,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &intermROperands[0],
                                                        &expMaskROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX);

            if (gcmIS_ERROR(status)) return status;

            /*For Nan*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &unsignROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInfX,
                                            gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextInfX);



            status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &unsignROperand,
                &OperandsParameters[1].rOperands[0]);


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextInfY);
            if (gcmIS_ERROR(status)) return status;

            /* ((Y)&0x7FFFFFFF) == 0x7F800000? Infinity*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextInfY,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &intermROperands[0],
                                                        &expMaskROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfY);

            if (gcmIS_ERROR(status)) return status;

            /*Y=Inf, X is the result*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &OperandsParameters[0].rOperands[0]);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInfY,
                                            gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextInfY);

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInfY);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextInfY);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInfX);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextInfX);
            if (gcmIS_ERROR(status)) return status;


    }





    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextNan);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextNan);
    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenRemainderCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsSELECTION_CONTEXT   selectionContextUp1,selectionContext0, selectionContext20;
    clsSELECTION_CONTEXT   selectionContextLoop, selectionContextLoopBack, selectContextNan;
    clsROPERAND zeroROperand, oneROperand, maskROperand, hideOneROperand;
    clsROPERAND scaleDown4ROperand, scaleDownROperand, twentyROperand, expMaskROperand;
    clsROPERAND twenty3ROperand, twenty8ROperand, twenty4To1ROperand, unsignROperand,signROperand;
    clsIOPERAND intermIOperands[20];
    clsROPERAND intermROperands[20];


    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);


    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0);
    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            1);
    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x007fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&hideOneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x00800000);
    clsROPERAND_InitializeIntOrIVecConstant(&scaleDown4ROperand, /*-(52<<23) + 4*/
                                            clmGenCodeDataType(T_UINT),
                                            0x31000004);

    clsROPERAND_InitializeIntOrIVecConstant(&scaleDownROperand, /*-(52<<23)*/
                                            clmGenCodeDataType(T_UINT),
                                            0x31000000);

    clsROPERAND_InitializeIntOrIVecConstant(&twentyROperand, /*20*/
                                            clmGenCodeDataType(T_UINT),
                                            20);

    clsROPERAND_InitializeIntOrIVecConstant(&twenty3ROperand, /*23*/
                                            clmGenCodeDataType(T_UINT),
                                            23);

    clsROPERAND_InitializeIntOrIVecConstant(&twenty8ROperand, /*28*/
                                            clmGenCodeDataType(T_UINT),
                                            28);

    clsROPERAND_InitializeIntOrIVecConstant(&expMaskROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x80000000);

    /*1/2^24,*/
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twenty4To1ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (float)1.1920929e-007 );

    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    /* Move Y to r0, then use fixed operation */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &unsignROperand,
                &OperandsParameters[1].rOperands[0]);

    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    /* r1 = r0 & mantissaMask */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[1],
                &intermROperands[0],
                &maskROperand);

    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext0);
    if (gcmIS_ERROR(status)) return status;

    /* Check r1 == 0? PowOf2 Value */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext0,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[1],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext0);

    if (gcmIS_ERROR(status)) return status;

    /* r2 = r1 + (-52)<<23*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[2],
                &intermROperands[1],
                &scaleDownROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContext0,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /*  */

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext0);
    if (gcmIS_ERROR(status)) return status;

    /* r2 = r1 + (-52)<<23 + 4*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[2],
                &intermROperands[1],
                &scaleDown4ROperand);


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContext0);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext0);
    if (gcmIS_ERROR(status)) return status;


    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

    /*r3 = 1/r2, float approx. of (1<<52)/Mantissa(y) */
    intermROperands[2].dataType.elementType = clvTYPE_FLOAT;
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INVERSE,
                &intermIOperands[3],
                &intermROperands[2]);
    if (gcmIS_ERROR(status)) return status;

    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);


    /* r4 = F2I(r3), approximation of 2^52/Mantissa(Y) */
    intermROperands[3].dataType.elementType = clvTYPE_UINT;
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_FLOAT_TO_UINT,
                &intermIOperands[4],
                &intermROperands[3]);
    if (gcmIS_ERROR(status)) return status;
    intermROperands[2].dataType.elementType = clvTYPE_FLOAT;

    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

    /* r5 = r1 + hideOne */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_OR_BITWISE,
                &intermIOperands[5],
                &intermROperands[1],
                &hideOneROperand);


    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);

    /* r6 = -r5 */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[6],
                &zeroROperand,
                &intermROperands[5]);

    /* N-R, r9 = r4 + (MulHi(r4,r4*(r6))>>20) */
    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[7],
                &intermROperands[4],
                &intermROperands[6]);

    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[8],
                &intermROperands[4],
                &intermROperands[7]);

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_RSHIFT,
                &intermIOperands[8],
                &intermROperands[8],
                &twentyROperand);
    if (gcmIS_ERROR(status)) return status;


    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[9],
                &intermROperands[4],
                &intermROperands[8]);
    /* End of N-R iteration, r9 is either 2^52/(MantisaY) or 2^52/(MantisaY) - 1 */


    clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);

    /*r10 = (MantisaY * (r9+1))>>32, add1 first*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[2],
                &oneROperand,
                &intermROperands[9]);

    /*r10 = MantisaY * r9>>32*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[10],
                &intermROperands[5],
                &intermROperands[2]);

    clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);
    /*r11 = r10 - (r10>>20)  */
    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_RSHIFT,
                &intermIOperands[11],
                &intermROperands[10],
                &twentyROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[11],
                &intermROperands[2],
                &intermROperands[11]);

    /* Now r11 is (1<<52/mantisaY) */

    clsIOPERAND_New(Compiler, &intermIOperands[12], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[12], &intermIOperands[12]);

    /* r12 = expX*/
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[12],
            &expMaskROperand,
            &OperandsParameters[0].rOperands[0]);



    clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[13]);

    /* r13 = expY*/
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[13],
            &expMaskROperand,
            &OperandsParameters[1].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;


    /* r0 = x & mantissaMask */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &maskROperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /* r0 = x | hideOne */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_OR_BITWISE,
                &intermIOperands[0],
                &hideOneROperand,
                &intermROperands[0]);
    if (gcmIS_ERROR(status)) return status;
    /*Later on, the r0 should be update as the remainder */
    /* r1 is set to zero, is the quo value after updating*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[1],
                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;



    clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);


    /* r12 = r12 - r13 */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_SUB_RTZ,
            &intermIOperands[12],
            &intermROperands[12],
            &intermROperands[13]);
    if (gcmIS_ERROR(status)) return status;

    /* shift to the right scale */
    status = clGenShiftExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_RSHIFT,
            &intermIOperands[12],
            &intermROperands[12],
            &twenty3ROperand);
    if (gcmIS_ERROR(status)) return status;


    if (gcmIS_ERROR(status)) return status;
/*while loop begin */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContextLoop);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContextLoopBack);
    if (gcmIS_ERROR(status)) return status;

    /* Loop End, jump back here*/
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoopBack);


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextLoopBack);

    if (gcmIS_ERROR(status)) return status;

    /* Check r12 >= 0? ExpX - ExpY >= 0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContextLoop,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[12],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoop);

    if (gcmIS_ERROR(status)) return status;


    /*r14 = min(28, r12)*/
    status = clGenGenericCode2(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MIN,
                        &intermIOperands[14],
                        &intermROperands[12],
                        &twenty8ROperand);

    /* compare leftshift (r14) with 20*/
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext20);
    if (gcmIS_ERROR(status)) return status;

    /* Check r14 <= 20? leftShift/rightShift */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext20,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN_EQUAL,
                                                &intermROperands[14],
                                                &twentyROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext20);

    if (gcmIS_ERROR(status)) return status;

    /* r15 = (r0 * r11)>>(32 + 20 - leftshift)*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[15],
                &intermROperands[11],
                &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* r2 = 20 - leftshift*/
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_SUB_RTZ,
            &intermIOperands[2],
            &twentyROperand,
            &intermROperands[14]);

    if (gcmIS_ERROR(status)) return status;

    /* R15 = ((r0*r11)>>32) >> r2*/
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_RSHIFT,
                        &intermIOperands[15],
                        &intermROperands[15],
                        &intermROperands[2]);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContext20,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext20);
    if (gcmIS_ERROR(status)) return status;

    /* r2 = leftshift - 20 */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_SUB_RTZ,
            &intermIOperands[2],
            &intermROperands[14],
            &twentyROperand);

    /* r15 = r0 << r2*/
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_LSHIFT,
                        &intermIOperands[15],
                        &intermROperands[0],
                        &intermROperands[2]);

    /* r15 = ((r0 <<r3) * r11)>>32 */
    intermIOperands[15].dataType.elementType = clvTYPE_UINT;
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[15],
                &intermROperands[11],
                &intermROperands[15]);

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContext20);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext20);
    if (gcmIS_ERROR(status)) return status;

    /* r0 = r0<<r14 */
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_LSHIFT,
                        &intermIOperands[0],
                        &intermROperands[0],
                        &intermROperands[14]);

    /* r2 = mantisaY*r15 */
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[2],
                        &intermROperands[5], /* mantisaY */
                        &intermROperands[15]);

    /* r0 = r0 - r2 */
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[0],
                        &intermROperands[0],
                        &intermROperands[2]);

    /* r1 = r1<<r14 */
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_LSHIFT,
                        &intermIOperands[1],
                        &intermROperands[1],
                        &intermROperands[14]);

    /* r1 = r1 + r15 */
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[1],
                        &intermROperands[1],
                        &intermROperands[15]);




    /* expX -= r14*/
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[12],
                        &intermROperands[12],
                        &intermROperands[14]);


    /* compare leftshift (r14) with 20*/
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContextUp1);
    if (gcmIS_ERROR(status)) return status;

    /* Check r0 >= mantissaY? quo should addup 1, r0 -= mantissaY, else OK */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContextUp1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[0],
                                                &intermROperands[5]);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextUp1);

    if (gcmIS_ERROR(status)) return status;

    /* r1++ */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[1],
                &intermROperands[1],
                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    /* r0 -= mantisaY, r5*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[0],
                &intermROperands[0],
                &intermROperands[5]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContextUp1,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextUp1);
    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextUp1);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContextUp1);
    if (gcmIS_ERROR(status)) return status;


    /* break condition expX-expY <= 0, break*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContextLoopBack,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN_EQUAL,
                                                &intermROperands[12],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoopBack);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContextLoopBack,
                                    gcvFALSE);



    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContextLoopBack);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContextLoop,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /*loop End*/

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoop);
    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextLoop);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContextLoop);
    if (gcmIS_ERROR(status)) return status;

    {
        clsIOPERAND signIOperands[1];
        clsROPERAND signROperands[1];

        clsIOPERAND_New(Compiler, &signIOperands[0], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&signROperands[0], &signIOperands[0]);

        /*This part is from fixed r0 to floating point value */
        intermIOperands[3].dataType.elementType = clvTYPE_UINT; /* Force to unsigned; */
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_UINT_TO_FLOAT,
                &intermIOperands[3],
                &intermROperands[0]);
        /* r3 = r0/2^24, scale back to the right float scale*/
        intermIOperands[3].dataType.elementType = clvTYPE_FLOAT;
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[3],
                    &intermROperands[3],
                    &twenty4To1ROperand);

        /* Go back to the normal Exp*/
        status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[12],
                &intermROperands[12],
                &twenty3ROperand);

        /* r12 = r12 + r13 */
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[12],
                &intermROperands[12],
                &intermROperands[13]);
        if (gcmIS_ERROR(status)) return status;



        /* The exp part add to the remainder */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[3],
                    &intermROperands[3],
                    &intermROperands[12]);
        { /*For Remainder, we need to check if 2*r3 > |abs(y)| */
            /* abs(Y) */
            clsSELECTION_CONTEXT selectContext2ROverY, selectContext2RSameY;
            status = clGenBitwiseExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[4],
                    &unsignROperand,
                    &OperandsParameters[1].rOperands[0]);
            /*r5 = 2*Remainder */
            intermIOperands[5].dataType.elementType = clvTYPE_FLOAT;
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[5],
                        &intermROperands[3],
                        &intermROperands[3]);


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContext2ROverY);
            if (gcmIS_ERROR(status)) return status;

            /* r5 > |y|*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContext2ROverY,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_GREATER_THAN,
                                                        &intermROperands[5],
                                                        &intermROperands[4]);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContext2ROverY);

            if (gcmIS_ERROR(status)) return status;

            /*Remainder -= |Y|*/
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[3],
                        &intermROperands[3],
                        &intermROperands[4]);

            if (gcmIS_ERROR(status)) return status;
            /* quo += 1*/
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[1],
                        &intermROperands[1],
                        &oneROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContext2ROverY,
                                            gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContext2ROverY);

            { /*Test if 2*r == Y */
                status = clDefineSelectionBegin(Compiler,
                                                CodeGenerator,
                                                gcvTRUE,
                                                &selectContext2RSameY);
                if (gcmIS_ERROR(status)) return status;

                /* r5 == |y|*/
                status = clGenSelectionCompareConditionCode(Compiler,
                                                            CodeGenerator,
                                                            &selectContext2RSameY,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvCONDITION_EQUAL,
                                                            &intermROperands[5],
                                                            &intermROperands[4]);
                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionTrueOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContext2RSameY);

                if (gcmIS_ERROR(status)) return status;

                /* r6 = odd(quo)*/
                status = clGenBitwiseExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[6],
                        &oneROperand,
                        &intermROperands[1]);

                intermROperands[6].dataType.elementType = clvTYPE_UINT;
                /* r4 = 0 or |y|, based on odd(quo) */
                status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[4],
                            &intermROperands[6],
                            &intermROperands[4]);

                /*Remainder -= |Y|*/
                status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_SUB_RTZ,
                            &intermIOperands[3],
                            &intermROperands[3],
                            &intermROperands[4]);

                if (gcmIS_ERROR(status)) return status;
                /* quo += odd(quo)*/
                status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[1],
                            &intermROperands[1],
                            &intermROperands[6]);

                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectContext2RSameY,
                                                gcvFALSE);

                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionFalseOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContext2RSameY);
                status = clDefineSelectionFalseOperandEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectContext2RSameY);
                status = clDefineSelectionEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectContext2RSameY);
            }


            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContext2ROverY);
            status = clDefineSelectionEnd(Compiler,
                                          CodeGenerator,
                                          &selectContext2ROverY);


        }
        /*Get the sign of X */
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SIGN,
                &signIOperands[0],
                &OperandsParameters[0].rOperands[0]);

        /*set sign,  the X */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[3],
                    &intermROperands[3],
                    &signROperands[0]);
    }

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &intermROperands[3]);

    /* Now we handle corner cases: Get the Abs(X), ABS(Y)*/
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[0],
            &unsignROperand,
            &OperandsParameters[0].rOperands[0]);

    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[1],
            &unsignROperand,
            &OperandsParameters[1].rOperands[0]);

    /*r5 = max(|X|,|Y|), unsigned type */
    intermIOperands[5].dataType.elementType = clvTYPE_UINT;

    status = clGenGenericCode2(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MAX,
                &intermIOperands[5],
                &intermROperands[0],
                &intermROperands[1]);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextNan);
    if (gcmIS_ERROR(status)) return status;

    /* (max(|X|,|Y|)&0x7FFFFFFF) > 0x7F800000? NaN*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextNan,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &intermROperands[5],
                                                &expMaskROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);

    if (gcmIS_ERROR(status)) return status;

    /*For Nan*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &unsignROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextNan,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* For Non-Nan case */

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);
    if (gcmIS_ERROR(status)) return status;
    {
        /*Handdle X == Infinity || Y == Infinity || Y == 0*/
        clsSELECTION_CONTEXT   selectContextInfX, selectContextY0, selectContextInfY;

        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[0],
            &unsignROperand,
            &OperandsParameters[0].rOperands[0]);


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextY0);
            if (gcmIS_ERROR(status)) return status;

            /* |Y| == 0? */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextY0,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &intermROperands[1],
                                                        &zeroROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextY0);
            /*Same as X = Infinity*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[0],
                        &expMaskROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextY0,
                                            gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextY0);

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextY0);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextY0);
            if (gcmIS_ERROR(status)) return status;


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextInfX);
            if (gcmIS_ERROR(status)) return status;

            /* ((X)&0x7FFFFFFF) == 0x7F800000? Infinity*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextInfX,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &intermROperands[0],
                                                        &expMaskROperand);
            if (gcmIS_ERROR(status)) return status;
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX);

            if (gcmIS_ERROR(status)) return status;

            /*For Nan*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &unsignROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInfX,
                                            gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextInfX);



            status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &unsignROperand,
                &OperandsParameters[1].rOperands[0]);


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextInfY);
            if (gcmIS_ERROR(status)) return status;

            /* ((Y)&0x7FFFFFFF) == 0x7F800000? Infinity*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextInfY,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &intermROperands[0],
                                                        &expMaskROperand);
            if (gcmIS_ERROR(status)) return status;
            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfY);

            if (gcmIS_ERROR(status)) return status;

            /*Y=Inf, X is the result*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &OperandsParameters[0].rOperands[0]);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInfY,
                                            gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextInfY);

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInfY);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextInfY);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInfX);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextInfX);
            if (gcmIS_ERROR(status)) return status;


    }





    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextNan);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextNan);
    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}

static gceSTATUS
_GenRemquoCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsSELECTION_CONTEXT   selectionContextUp1,selectionContext0, selectionContext20;
    clsSELECTION_CONTEXT   selectionContextLoop, selectionContextLoopBack, selectContextNan;
    clsROPERAND zeroROperand, oneROperand, maskROperand, hideOneROperand;
    clsROPERAND scaleDown4ROperand, scaleDownROperand, twentyROperand, expMaskROperand;
    clsROPERAND twenty3ROperand, twenty8ROperand, twenty4To1ROperand, unsignROperand,signROperand;
    clsROPERAND ox7fROperand;
    clsIOPERAND intermIOperands[20];
    clsROPERAND intermROperands[20];


    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 3);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);


    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0);
    clsROPERAND_InitializeIntOrIVecConstant(&ox7fROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x7f);
    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            1);
    clsROPERAND_InitializeIntOrIVecConstant(&maskROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x007fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&hideOneROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x00800000);
    clsROPERAND_InitializeIntOrIVecConstant(&scaleDown4ROperand, /*-(52<<23) + 4*/
                                            clmGenCodeDataType(T_UINT),
                                            0x31000004);

    clsROPERAND_InitializeIntOrIVecConstant(&scaleDownROperand, /*-(52<<23)*/
                                            clmGenCodeDataType(T_UINT),
                                            0x31000000);

    clsROPERAND_InitializeIntOrIVecConstant(&twentyROperand, /*20*/
                                            clmGenCodeDataType(T_UINT),
                                            20);

    clsROPERAND_InitializeIntOrIVecConstant(&twenty3ROperand, /*23*/
                                            clmGenCodeDataType(T_UINT),
                                            23);

    clsROPERAND_InitializeIntOrIVecConstant(&twenty8ROperand, /*28*/
                                            clmGenCodeDataType(T_UINT),
                                            28);

    clsROPERAND_InitializeIntOrIVecConstant(&expMaskROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_UINT),
                                            0x80000000);

    /*1/2^24,*/
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twenty4To1ROperand,
                                        clmGenCodeDataType(T_FLOAT),
                                        (float)1.1920929e-007 );

    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    /* Move Y to r0, then use fixed operation */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &unsignROperand,
                &OperandsParameters[1].rOperands[0]);

    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    /* r1 = r0 & mantissaMask */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[1],
                &intermROperands[0],
                &maskROperand);

    clsIOPERAND_New(Compiler, &intermIOperands[2], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[2], &intermIOperands[2]);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext0);
    if (gcmIS_ERROR(status)) return status;

    /* Check r1 == 0? PowOf2 Value */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext0,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_EQUAL,
                                                &intermROperands[1],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext0);

    if (gcmIS_ERROR(status)) return status;

    /* r2 = r1 + (-52)<<23*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[2],
                &intermROperands[1],
                &scaleDownROperand);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContext0,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /*  */

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext0);
    if (gcmIS_ERROR(status)) return status;

    /* r2 = r1 + (-52)<<23 + 4*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[2],
                &intermROperands[1],
                &scaleDown4ROperand);


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContext0);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext0);
    if (gcmIS_ERROR(status)) return status;


    clsIOPERAND_New(Compiler, &intermIOperands[3], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[3], &intermIOperands[3]);

    /*r3 = 1/r2, float approx. of (1<<52)/Mantissa(y) */
    intermROperands[2].dataType.elementType = clvTYPE_FLOAT;
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INVERSE,
                &intermIOperands[3],
                &intermROperands[2]);
    if (gcmIS_ERROR(status)) return status;

    clsIOPERAND_New(Compiler, &intermIOperands[4], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[4], &intermIOperands[4]);


    /* r4 = F2I(r3), approximation of 2^52/Mantissa(Y) */
    intermROperands[3].dataType.elementType = clvTYPE_UINT;
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_FLOAT_TO_UINT,
                &intermIOperands[4],
                &intermROperands[3]);
    if (gcmIS_ERROR(status)) return status;

    clsIOPERAND_New(Compiler, &intermIOperands[5], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[5], &intermIOperands[5]);

    /* r5 = r1 + hideOne */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_OR_BITWISE,
                &intermIOperands[5],
                &intermROperands[1],
                &hideOneROperand);


    clsIOPERAND_New(Compiler, &intermIOperands[6], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[6], &intermIOperands[6]);

    /* r6 = -r5 */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[6],
                &zeroROperand,
                &intermROperands[5]);

    /* N-R, r9 = r4 + (MulHi(r4,r4*(r6))>>20) */
    clsIOPERAND_New(Compiler, &intermIOperands[7], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[7], &intermIOperands[7]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[7],
                &intermROperands[4],
                &intermROperands[6]);

    clsIOPERAND_New(Compiler, &intermIOperands[8], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[8], &intermIOperands[8]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[8],
                &intermROperands[4],
                &intermROperands[7]);

    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_RSHIFT,
                &intermIOperands[8],
                &intermROperands[8],
                &twentyROperand);
    if (gcmIS_ERROR(status)) return status;


    clsIOPERAND_New(Compiler, &intermIOperands[9], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[9], &intermIOperands[9]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[9],
                &intermROperands[4],
                &intermROperands[8]);
    /* End of N-R iteration, r9 is either 2^52/(MantisaY) or 2^52/(MantisaY) - 1 */


    clsIOPERAND_New(Compiler, &intermIOperands[10], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[10], &intermIOperands[10]);

    /*r10 = (MantisaY * (r9+1))>>32, add1 first*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[2],
                &oneROperand,
                &intermROperands[9]);

    /*r10 = MantisaY * r9>>32*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[10],
                &intermROperands[5],
                &intermROperands[2]);

    clsIOPERAND_New(Compiler, &intermIOperands[11], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[11], &intermIOperands[11]);
    /*r11 = r10 - (r10>>20)  */
    status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_RSHIFT,
                &intermIOperands[11],
                &intermROperands[10],
                &twentyROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[11],
                &intermROperands[2],
                &intermROperands[11]);

    /* Now r11 is (1<<52/mantisaY) */

    clsIOPERAND_New(Compiler, &intermIOperands[12], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[12], &intermIOperands[12]);

    /* r12 = expX*/
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[12],
            &expMaskROperand,
            &OperandsParameters[0].rOperands[0]);



    clsIOPERAND_New(Compiler, &intermIOperands[13], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[13], &intermIOperands[13]);

    /* r13 = expY*/
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[13],
            &expMaskROperand,
            &OperandsParameters[1].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;


    /* r0 = x & mantissaMask */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &maskROperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    /* r0 = x | hideOne */
    status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_OR_BITWISE,
                &intermIOperands[0],
                &hideOneROperand,
                &intermROperands[0]);
    if (gcmIS_ERROR(status)) return status;
    /*Later on, the r0 should be update as the remainder */
    /* r1 is set to zero, is the quo value after updating*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[1],
                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;



    clsIOPERAND_New(Compiler, &intermIOperands[14], clmGenCodeDataType(T_INT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[14], &intermIOperands[14]);

    clsIOPERAND_New(Compiler, &intermIOperands[15], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[15], &intermIOperands[15]);


    /* r12 = r12 - r13 */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_SUB_RTZ,
            &intermIOperands[12],
            &intermROperands[12],
            &intermROperands[13]);
    if (gcmIS_ERROR(status)) return status;

    /* shift to the right scale */
    status = clGenShiftExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_RSHIFT,
            &intermIOperands[12],
            &intermROperands[12],
            &twenty3ROperand);
    if (gcmIS_ERROR(status)) return status;


    if (gcmIS_ERROR(status)) return status;
/*while loop begin */
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContextLoop);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContextLoopBack);
    if (gcmIS_ERROR(status)) return status;

    /* Loop End, jump back here*/
    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoopBack);


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextLoopBack);

    if (gcmIS_ERROR(status)) return status;

    /* Check r12 >= 0? ExpX - ExpY >= 0 */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContextLoop,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[12],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoop);

    if (gcmIS_ERROR(status)) return status;


    /*r14 = min(28, r12)*/
    status = clGenGenericCode2(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MIN,
                        &intermIOperands[14],
                        &intermROperands[12],
                        &twenty8ROperand);

    /* compare leftshift (r14) with 20*/
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContext20);
    if (gcmIS_ERROR(status)) return status;

    /* Check r14 <= 20? leftShift/rightShift */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContext20,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN_EQUAL,
                                                &intermROperands[14],
                                                &twentyROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext20);

    if (gcmIS_ERROR(status)) return status;

    /* r15 = (r0 * r11)>>(32 + 20 - leftshift)*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[15],
                &intermROperands[11],
                &intermROperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /* r2 = 20 - leftshift*/
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_SUB_RTZ,
            &intermIOperands[2],
            &twentyROperand,
            &intermROperands[14]);

    if (gcmIS_ERROR(status)) return status;

    /* R15 = ((r0*r11)>>32) >> r2*/
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_RSHIFT,
                        &intermIOperands[15],
                        &intermROperands[15],
                        &intermROperands[2]);

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContext20,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContext20);
    if (gcmIS_ERROR(status)) return status;

    /* r2 = leftshift - 20 */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_SUB_RTZ,
            &intermIOperands[2],
            &intermROperands[14],
            &twentyROperand);

    /* r15 = r0 << r2*/
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_LSHIFT,
                        &intermIOperands[15],
                        &intermROperands[0],
                        &intermROperands[2]);

    /* r15 = ((r0 <<r3) * r11)>>32 */
    intermIOperands[15].dataType.elementType = clvTYPE_UINT;
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MULHI,
                &intermIOperands[15],
                &intermROperands[11],
                &intermROperands[15]);

    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContext20);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContext20);
    if (gcmIS_ERROR(status)) return status;

    /* r0 = r0<<r14 */
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_LSHIFT,
                        &intermIOperands[0],
                        &intermROperands[0],
                        &intermROperands[14]);

    /* r2 = mantisaY*r15 */
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[2],
                        &intermROperands[5], /* mantisaY */
                        &intermROperands[15]);

    /* r0 = r0 - r2 */
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[0],
                        &intermROperands[0],
                        &intermROperands[2]);

    /* r1 = r1<<r14 */
    status = clGenShiftExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_LSHIFT,
                        &intermIOperands[1],
                        &intermROperands[1],
                        &intermROperands[14]);

    /* r1 = r1 + r15 */
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[1],
                        &intermROperands[1],
                        &intermROperands[15]);




    /* expX -= r14*/
    status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[12],
                        &intermROperands[12],
                        &intermROperands[14]);


    /* compare leftshift (r14) with 20*/
    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectionContextUp1);
    if (gcmIS_ERROR(status)) return status;

    /* Check r0 >= mantissaY? quo should addup 1, r0 -= mantissaY, else OK */
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContextUp1,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN_EQUAL,
                                                &intermROperands[0],
                                                &intermROperands[5]);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextUp1);

    if (gcmIS_ERROR(status)) return status;

    /* r1++ */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[1],
                &intermROperands[1],
                &oneROperand);

    if (gcmIS_ERROR(status)) return status;

    /* r0 -= mantisaY, r5*/
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[0],
                &intermROperands[0],
                &intermROperands[5]);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContextUp1,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextUp1);
    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextUp1);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContextUp1);
    if (gcmIS_ERROR(status)) return status;


    /* break condition expX-expY <= 0, break*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectionContextLoopBack,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_LESS_THAN_EQUAL,
                                                &intermROperands[12],
                                                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoopBack);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContextLoopBack,
                                    gcvFALSE);



    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContextLoopBack);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectionContextLoop,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /*loop End*/

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectionContextLoop);
    if (gcmIS_ERROR(status)) return status;


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextLoop);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectionContextLoop);
    if (gcmIS_ERROR(status)) return status;
    {
        clsSELECTION_CONTEXT   selectContext2ROverY;
        /* r12 == 0 && (2*r0) >= r5, need to do the rounding*/
        /*We use ((r0<<1)>>(-r12))) >= r5 to verify, since r12 <=0, r12+2<=2 */

        status = clGenArithmeticExprCode(
                        Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[14],
                        &zeroROperand,
                        &intermROperands[12]);

        status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[15],
                &intermROperands[0],
                &oneROperand);
        /*scale r5 to the right scale */
        status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[11],
                &intermROperands[5],
                &intermROperands[14]);

        status = clGenGenericCode2(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MIN,
                &intermIOperands[14],
                &twenty8ROperand,
                &intermROperands[14]);


        status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_RSHIFT,
                &intermIOperands[15],
                &intermROperands[15],
                &intermROperands[14]);


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContext2ROverY);
            if (gcmIS_ERROR(status)) return status;

            /* 2*r5 > |y|*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContext2ROverY,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_GREATER_THAN,
                                                        &intermROperands[15],
                                                        &intermROperands[5]);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContext2ROverY);

            if (gcmIS_ERROR(status)) return status;

            /*Remainder -= |Y|*/
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[0],
                        &intermROperands[0],
                        &intermROperands[11]);

            if (gcmIS_ERROR(status)) return status;
            /* quo += 1*/
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[1],
                        &intermROperands[1],
                        &oneROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContext2ROverY,
                                            gcvFALSE);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContext2ROverY);

            { /*Test if 2*r == Y */
                clsSELECTION_CONTEXT   selectContext2RSameY;
                status = clDefineSelectionBegin(Compiler,
                                                CodeGenerator,
                                                gcvTRUE,
                                                &selectContext2RSameY);
                if (gcmIS_ERROR(status)) return status;

                /* r5 == |y|*/
                status = clGenSelectionCompareConditionCode(Compiler,
                                                            CodeGenerator,
                                                            &selectContext2RSameY,
                                                            PolynaryExpr->exprBase.base.lineNo,
                                                            PolynaryExpr->exprBase.base.stringNo,
                                                            clvCONDITION_EQUAL,
                                                            &intermROperands[15],
                                                            &intermROperands[5]);
                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionTrueOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContext2RSameY);

                if (gcmIS_ERROR(status)) return status;

                /* r6 = odd(quo)*/
                status = clGenBitwiseExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[6],
                        &oneROperand,
                        &intermROperands[1]);

                intermROperands[6].dataType.elementType = clvTYPE_UINT;
                /* r14 = 0 or |y|, based on odd(quo) */
                status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[14],
                            &intermROperands[6],
                            &intermROperands[11]);

                /*Remainder -= |Y|*/
                status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_SUB_RTZ,
                            &intermIOperands[0],
                            &intermROperands[0],
                            &intermROperands[14]);

                if (gcmIS_ERROR(status)) return status;
                /* quo += odd(quo)*/
                status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[1],
                            &intermROperands[1],
                            &intermROperands[6]);

                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionTrueOperandEnd(Compiler,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                CodeGenerator,
                                                &selectContext2RSameY,
                                                gcvFALSE);

                if (gcmIS_ERROR(status)) return status;

                status = clDefineSelectionFalseOperandBegin(Compiler,
                                                        CodeGenerator,
                                                        &selectContext2RSameY);
                status = clDefineSelectionFalseOperandEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectContext2RSameY);
                status = clDefineSelectionEnd(Compiler,
                                                        CodeGenerator,
                                                        &selectContext2RSameY);
            }


            status = clDefineSelectionFalseOperandEnd(Compiler,
                                                    CodeGenerator,
                                                    &selectContext2ROverY);
            status = clDefineSelectionEnd(Compiler,
                                          CodeGenerator,
                                          &selectContext2ROverY);


    }

    {
        clsIOPERAND signIOperands[2];
        clsROPERAND signROperands[2];


        clsIOPERAND_New(Compiler, &signIOperands[0], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&signROperands[0], &signIOperands[0]);
        clsIOPERAND_New(Compiler, &signIOperands[1], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&signROperands[1], &signIOperands[1]);


        /*This part is from fixed r0 to floating point value */
        intermIOperands[3].dataType.elementType = clvTYPE_INT; /* Force to signed; */
        intermROperands[0].dataType.elementType = clvTYPE_INT;
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INT_TO_FLOAT,
                &intermIOperands[3],
                &intermROperands[0]);
        intermROperands[0].dataType.elementType = clvTYPE_UINT;
        /* r3 = r0/2^24, scale back to the right float scale*/
        {
        intermIOperands[3].dataType.elementType = clvTYPE_FLOAT;
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[3],
                    &intermROperands[3],
                    &twenty4To1ROperand);

        /* Go back to the normal Exp*/
        status = clGenShiftExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LSHIFT,
                &intermIOperands[12],
                &intermROperands[12],
                &twenty3ROperand);

        /* r12 = r12 + r13 */
        status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[12],
                &intermROperands[12],
                &intermROperands[13]);
        if (gcmIS_ERROR(status)) return status;

        }

        /* The exp part add to the remainder */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[3],
                    &intermROperands[3],
                    &intermROperands[12]);

        /*Get the sign of X */
        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SIGN,
                &signIOperands[0],
                &OperandsParameters[0].rOperands[0]);

        /*set sign,  the X */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[3],
                    &intermROperands[3],
                    &signROperands[0]);
        /*for r1 &= 0x7f, then r1 *= sign(x)sign(y) */

        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[4],
            &ox7fROperand,
            &intermROperands[1]);

        status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SIGN,
                &signIOperands[1],
                &OperandsParameters[1].rOperands[0]);

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &signIOperands[1],
                    &signROperands[1],
                    &signROperands[0]);

        signIOperands[0].dataType.elementType = clvTYPE_INT;
        signROperands[0].dataType.elementType = clvTYPE_INT;
        status = clGenGenericCode1(Compiler,
                                   PolynaryExpr->exprBase.base.lineNo,
                                   PolynaryExpr->exprBase.base.stringNo,
                                   clvOPCODE_FLOAT_TO_INT,
                                   &signIOperands[0],
                                   &signROperands[1]);
        if (gcmIS_ERROR(status)) return status;

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[1],
                    &signROperands[0],
                    &intermROperands[4]);

    }

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &intermROperands[3]);

    /* Now we handle corner cases: Get the Abs(X), ABS(Y)*/
    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[0],
            &unsignROperand,
            &OperandsParameters[0].rOperands[0]);

    status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[4],
            &unsignROperand,
            &OperandsParameters[1].rOperands[0]);

    /*r5 = max(|X|,|Y|), unsigned type */
    intermIOperands[5].dataType.elementType = clvTYPE_UINT;

    status = clGenGenericCode2(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MAX,
                &intermIOperands[5],
                &intermROperands[0],
                &intermROperands[4]);

    status = clDefineSelectionBegin(Compiler,
                                    CodeGenerator,
                                    gcvTRUE,
                                    &selectContextNan);
    if (gcmIS_ERROR(status)) return status;

    /* (max(|X|,|Y|)&0x7FFFFFFF) > 0x7F800000? NaN*/
    status = clGenSelectionCompareConditionCode(Compiler,
                                                CodeGenerator,
                                                &selectContextNan,
                                                PolynaryExpr->exprBase.base.lineNo,
                                                PolynaryExpr->exprBase.base.stringNo,
                                                clvCONDITION_GREATER_THAN,
                                                &intermROperands[5],
                                                &expMaskROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);

    if (gcmIS_ERROR(status)) return status;

    /*For Nan*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &unsignROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                &intermIOperands[1],
                &zeroROperand);
    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionTrueOperandEnd(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    CodeGenerator,
                                    &selectContextNan,
                                    gcvFALSE);

    if (gcmIS_ERROR(status)) return status;

    /* For Non-Nan case */

    status = clDefineSelectionFalseOperandBegin(Compiler,
                                            CodeGenerator,
                                            &selectContextNan);
    if (gcmIS_ERROR(status)) return status;
    {
        /*Handdle X == Infinity || Y == Infinity || Y == 0*/
        clsSELECTION_CONTEXT   selectContextInfX, selectContextY0, selectContextInfY;

        status = clGenBitwiseExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_AND_BITWISE,
            &intermIOperands[0],
            &unsignROperand,
            &OperandsParameters[0].rOperands[0]);


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextY0);
            if (gcmIS_ERROR(status)) return status;

            /* |Y| == 0? */
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextY0,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_LESS_THAN_EQUAL,
                                                        &intermROperands[4],
                                                        &maskROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextY0);
            /*Same as X = Infinity*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[0],
                        &expMaskROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextY0,
                                            gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextY0);

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextY0);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextY0);
            if (gcmIS_ERROR(status)) return status;


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextInfX);
            if (gcmIS_ERROR(status)) return status;

            /* ((X)&0x7FFFFFFF) == 0x7F800000? Infinity*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextInfX,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &intermROperands[0],
                                                        &expMaskROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfX);

            if (gcmIS_ERROR(status)) return status;

            /*For Nan*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &unsignROperand);

            if (gcmIS_ERROR(status)) return status;

            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[1],
                        &zeroROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInfX,
                                            gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextInfX);



            status = clGenBitwiseExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[0],
                &unsignROperand,
                &OperandsParameters[1].rOperands[0]);


            status = clDefineSelectionBegin(Compiler,
                                            CodeGenerator,
                                            gcvTRUE,
                                            &selectContextInfY);
            if (gcmIS_ERROR(status)) return status;

            /* ((Y)&0x7FFFFFFF) == 0x7F800000? Infinity*/
            status = clGenSelectionCompareConditionCode(Compiler,
                                                        CodeGenerator,
                                                        &selectContextInfY,
                                                        PolynaryExpr->exprBase.base.lineNo,
                                                        PolynaryExpr->exprBase.base.stringNo,
                                                        clvCONDITION_EQUAL,
                                                        &intermROperands[4],
                                                        &expMaskROperand);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionTrueOperandBegin(Compiler,
                                                    CodeGenerator,
                                                    &selectContextInfY);

            if (gcmIS_ERROR(status)) return status;

            /*Y=Inf, X is the result*/
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &OperandsParameters[0].rOperands[0]);

            if (gcmIS_ERROR(status)) return status;
            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[1],
                        &zeroROperand);
            if (gcmIS_ERROR(status)) return status;
            status = clDefineSelectionTrueOperandEnd(Compiler,
                                            PolynaryExpr->exprBase.base.lineNo,
                                            PolynaryExpr->exprBase.base.stringNo,
                                            CodeGenerator,
                                            &selectContextInfY,
                                            gcvFALSE);

            status = clDefineSelectionFalseOperandBegin(Compiler,
                                        CodeGenerator,
                                        &selectContextInfY);

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInfY);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextInfY);
            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionFalseOperandEnd(Compiler,
                                            CodeGenerator,
                                            &selectContextInfX);

            if (gcmIS_ERROR(status)) return status;

            status = clDefineSelectionEnd(Compiler,
                                        CodeGenerator,
                                        &selectContextInfX);
            if (gcmIS_ERROR(status)) return status;


    }


    status = clDefineSelectionFalseOperandEnd(Compiler,
                                    CodeGenerator,
                                    &selectContextNan);

    if (gcmIS_ERROR(status)) return status;

    status = clDefineSelectionEnd(Compiler,
                                CodeGenerator,
                                &selectContextNan);
    if (gcmIS_ERROR(status)) return status;

{ /* Save out the r1*/
    clsLOPERAND lOperand[1];

    clsLOPERAND_InitializeUsingROperand(lOperand, &OperandsParameters[2].rOperands[0]);
    status = clGenStoreCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                &intermROperands[1],
                                lOperand,
                                OperandsParameters[2].rOperands[0].dataType,
                                &zeroROperand);
        if (gcmIS_ERROR(status)) return status;
} /*End of Save out */


    return gcvSTATUS_OK;
}

gceSTATUS
_GenMadCode0(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND intermIOperands[7];
    clsROPERAND intermROperands[7], infROperand, thirtyROperand;

    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 3);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsIOPERAND_New(Compiler, &intermIOperands[0], OperandsParameters[0].dataTypes[0].def);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[0],
                            &OperandsParameters[1].rOperands[0],
                            &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    if(OperandsParameters[1].rOperands[0].dataType.elementType == clvTYPE_FLOAT){
        /*We need to make sure |x*y| < inf, if max(|x|, |y|)<inf */
        int i;
        for(i = 1; i<7; i++){
            clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
            clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
        }
        clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT) 0x7F800000);
        clsROPERAND_InitializeIntOrIVecConstant(&thirtyROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT) 30);

        status = clGenGenericCode1(Compiler,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo,
                       clvOPCODE_ABS,
                       &intermIOperands[1],
                       &OperandsParameters[1].rOperands[0]);

        status = clGenGenericCode1(Compiler,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo,
                       clvOPCODE_ABS,
                       &intermIOperands[2],
                       &OperandsParameters[0].rOperands[0]);

        status = clGenGenericCode2(Compiler,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo,
                       clvOPCODE_MAX,
                       &intermIOperands[3],
                       &intermROperands[1],
                       &intermROperands[2]);

        clmGEN_CODE_IF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo,
                     &intermROperands[3],
                     clvCONDITION_LESS_THAN,
                     &infROperand);


        status = clGenGenericCode1(Compiler,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo,
                     clvOPCODE_ABS,
                     &intermIOperands[4],
                     &intermROperands[0]);

        intermROperands[4].dataType.elementType = clvTYPE_INT;
        clmGEN_CODE_IF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo,
                     &intermROperands[4],
                     clvCONDITION_EQUAL,
                     &infROperand);

        /*|x*y| == inf, we use (x*y) -/+ 1*/
        intermIOperands[0].dataType.elementType = clvTYPE_INT;
        intermIOperands[5].dataType.elementType = clvTYPE_INT;
        intermROperands[0].dataType.elementType = clvTYPE_INT;
        intermROperands[5].dataType.elementType = clvTYPE_INT;

        /* (+inf)>>30 = 1, (-Inf>>30) = -1*/
        status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &intermIOperands[5],
                                &intermROperands[0],
                                &thirtyROperand);

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SUB_RTZ,
                    &intermIOperands[0],
                    &intermROperands[0],
                    &intermROperands[5]);

        clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);


       clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);
        intermIOperands[0].dataType.elementType = clvTYPE_FLOAT;
        intermROperands[0].dataType.elementType = clvTYPE_FLOAT;

    }


    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            IOperand,
                            &OperandsParameters[2].rOperands[0],
                            &intermROperands[0]
                            );

    if (gcmIS_ERROR(status)) return status;

OnError:
       return gcvSTATUS_OK;
}

static gceSTATUS
_GenMadCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    clsIOPERAND intermIOperand;
    clsROPERAND intermROperand;

    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 3);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsIOPERAND_New(Compiler, &intermIOperand, OperandsParameters[0].dataTypes[0].def);

    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperand,
                            &OperandsParameters[1].rOperands[0],
                            &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    /*clsIOPERAND_New(Compiler, &intermIOperands, OperandsParameters[0].dataTypes[0].def);*/

    clsROPERAND_InitializeUsingIOperand(&intermROperand, &intermIOperand);


    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            IOperand,
                            &OperandsParameters[2].rOperands[0],
                            &intermROperand
                            );

    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}
static gceSTATUS
_GenFmaPoundCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND intermIOperands[9];
    clsROPERAND intermROperands[9], infROperand, thirtyROperand, thirtyOneROperand, infLessROperand, oneROperand;


    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 3);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsIOPERAND_New(Compiler, &intermIOperands[0], OperandsParameters[0].dataTypes[0].def);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[0],
                            &OperandsParameters[1].rOperands[0],
                            &OperandsParameters[0].rOperands[0]);

    if (gcmIS_ERROR(status)) return status;

    if(OperandsParameters[1].rOperands[0].dataType.elementType == clvTYPE_FLOAT){
        /*We need to make sure |x*y| < inf, if max(|x|, |y|)<inf */
        /* We use Arithmetic calculation to avoid if/else condition, good for vector*/
        /*r1 = ExpPart(x*y), r2 = ExpPart(max(|x|,|y|)), r3 = max(r1, r2) */
        /*r4 = (r2 - r3)>>31, r5 = (0x7f000000 - r3)>>31, r6 = r4&r5 (-1 or 0)  */
        /* We see r4 = r3>r2? 0:0xfffffff, r5 = r3==Inf? -1:0, r6 = (r2<inf && r3 == inf)? -1:0 */
        /*r7 = (x*y)>>30 (Get sign part), r7 = (x*y)==Inf? 1:-1 */
        /*r8 = r7 & r6, r0 -= r8 */

        int i;
        intermIOperands[0].dataType.elementType = clvTYPE_INT;
        intermROperands[0].dataType.elementType = clvTYPE_INT;
        for(i = 1; i<9; i++){
            clsIOPERAND_New(Compiler, &intermIOperands[i], OperandsParameters[0].dataTypes[0].def);
            intermIOperands[i].dataType.elementType = clvTYPE_INT;
            clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
        }
        clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT) 0x7F800000);
        clsROPERAND_InitializeIntOrIVecConstant(&infLessROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT) 0x7F7fffff);
        clsROPERAND_InitializeIntOrIVecConstant(&thirtyROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT) 30);
        clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT) 31);
        clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT)1);
        for(i = 0; i<2; i++){
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[1+i],
                        &infROperand,
                        &OperandsParameters[i].rOperands[0]);
        }

        status = clGenGenericCode2(Compiler,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo,
                       clvOPCODE_MAX,
                       &intermIOperands[2],
                       &intermROperands[1],
                       &intermROperands[2]);

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[1],
                    &infROperand,
                    &intermROperands[0]);

        status = clGenGenericCode2(Compiler,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo,
                       clvOPCODE_MAX,
                       &intermIOperands[3],
                       &intermROperands[1],
                       &intermROperands[2]);


       status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_SUB_RTZ,
                            &intermIOperands[5],
                            &intermROperands[2],
                            &intermROperands[3]);
       /*r4 = (r2 - r3)>>31 */
       intermIOperands[4].dataType.elementType = clvTYPE_UINT;
       status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &intermIOperands[4],
                                &intermROperands[5],
                                &thirtyOneROperand);

       status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_SUB_RTZ,
                            &intermIOperands[6],
                            &infLessROperand,
                            &intermROperands[3]);

       /*r5 = (inf - 1 - r3)>>31 */
       intermIOperands[5].dataType.elementType = clvTYPE_UINT;
       status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_RSHIFT,
                                &intermIOperands[5],
                                &intermROperands[6],
                                &thirtyOneROperand);

       /*r6 = r5 & r4, either 1 or 0 */
        status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[6],
                        &intermROperands[5],
                        &intermROperands[4]);


        /* if x*y == inf and max(|x|, |y|)< inf, the x*y are adjusted to finite number*/
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SUB_RTZ,
                    &intermIOperands[0],
                    &intermROperands[0],
                    &intermROperands[6]);

        intermIOperands[0].dataType.elementType = clvTYPE_FLOAT;
        intermROperands[0].dataType.elementType = clvTYPE_FLOAT;

    }


    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            IOperand,
                            &OperandsParameters[2].rOperands[0],
                            &intermROperands[0]
                            );

    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;

}



static gceSTATUS
_GenAddSub64Int(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN clsROPERAND *input0LowROperand,
    IN clsROPERAND *input0HighROperand,
    IN clsROPERAND *input1LowROperand,
    IN clsROPERAND *input1HighROperand,
    OUT clsIOPERAND * outLowIOperand,
    OUT clsIOPERAND * outHighIOperand,
    IN    int subflag
    )
{
    gceSTATUS    status;
    clsIOPERAND intermIOperands[2];
    clsROPERAND intermROperands[2], oneROperand;

    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_UINT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT)1);

    if(subflag == 0){
            clsROPERAND_InitializeUsingIOperand(&intermROperands[1], outHighIOperand);
            status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            outLowIOperand,
                            input1LowROperand,
                            input0LowROperand
                        );
            status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            outHighIOperand,
                            input1HighROperand,
                            input0HighROperand
                        );
            status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_NOT_BITWISE,
                    &intermIOperands[0],
                    input1LowROperand);

            clmGEN_CODE_IF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo,
                         input0LowROperand,
                         clvCONDITION_GREATER_THAN,
                         &intermROperands[0]);

            status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            outHighIOperand,
                            &intermROperands[1],
                            &oneROperand
                        );
           clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);
           /*Do nothing */
           clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

    }
    else{
            status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_NOT_BITWISE,
                    &intermIOperands[0],
                    input1LowROperand);

            status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_NOT_BITWISE,
                    &intermIOperands[1],
                    input1HighROperand);

            status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            outLowIOperand,
                            &intermROperands[0],
                            input0LowROperand
                        );
            status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            outHighIOperand,
                            &intermROperands[1],
                            input0HighROperand
                        );
            clsROPERAND_InitializeUsingIOperand(&intermROperands[0], outLowIOperand);
            clsROPERAND_InitializeUsingIOperand(&intermROperands[1], outHighIOperand);
            /*A - B = A + (~B + 1) */
            status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            outLowIOperand,
                            &intermROperands[0],
                            &oneROperand
                        );
            /*if and only if A >= B, A+(~B+1) will have overflow bit */
            clmGEN_CODE_IF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo,
                         input0LowROperand,
                         clvCONDITION_GREATER_THAN_EQUAL,
                         input1LowROperand);

            status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            outHighIOperand,
                            &intermROperands[1],
                            &oneROperand
                        );
           clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);
           /*Do nothing */
           clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);
    }

    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;

OnError:
    return status;


}

/* a*b, b = high + low, a only one term, return to high/low part. We don't check the range here*/
static gceSTATUS
_GenHighPrecFloatMul(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN clsROPERAND *input0ROperand,
    IN clsROPERAND *input1LowROperand,
    IN clsROPERAND *input1HighROperand,
    OUT clsIOPERAND * outLowIOperand,
    OUT clsIOPERAND * outHighIOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND intermIOperands[2];
    clsROPERAND intermROperands[2];

    clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);
    clsIOPERAND_New(Compiler, &intermIOperands[1], clmGenCodeDataType(T_FLOAT));
    clsROPERAND_InitializeUsingIOperand(&intermROperands[1], &intermIOperands[1]);

    /*return to a*bH + mul_Lo(a,bH) */


    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MULLO_RTZ,
                            &intermIOperands[1],
                            input0ROperand,
                            input1HighROperand
                            );

    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[0],
                            input0ROperand,
                            input1LowROperand
                            );

    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[0],
                            &intermROperands[0],
                            &intermROperands[1]
                            );

    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[1],
                            input0ROperand,
                            input1HighROperand
                            );

    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            outHighIOperand,
                            &intermROperands[0],
                            &intermROperands[1]
                            );

    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADDLO_RTZ,
                            outLowIOperand,
                            &intermROperands[0],
                            &intermROperands[1]
                            );


    if (gcmIS_ERROR(status)) return status;
    return gcvSTATUS_OK;
}

/*Calculate Gamma function for 1<x<2 */
static gceSTATUS
_GenGammaIn1To2(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN clsROPERAND *inputROperand,
    OUT clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND oneDot5ROperand, coefROperand[10];
    clsIOPERAND intermIOperands[5];
    clsROPERAND intermROperands[5];
    int i;
    float coef[10] = {
       0.886226952075958250000000f,
       0.032338183373212814000000f,
       0.414807498455047610000000f,
      -0.107280515134334560000000f,
       0.144833192229270940000000f,
      -0.077796541154384613000000f,
       0.056571122258901596000000f,
      -0.035850975662469864000000f,
       0.034597411751747131000000f,
      -0.024472925812005997000000f
    };
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneDot5ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.5);
    for(i = 0; i<10; i++){
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&coefROperand[i],
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) coef[i]);
    }
    for(i = 0; i<5; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }
    /*r0 = x - 1.5 */
   status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SUB_RTZ,
                    &intermIOperands[0],
                    inputROperand,
                    &oneDot5ROperand);

    status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[1],
                    &intermROperands[0],
                    &coefROperand[9]);
    for(i = 8; i >= 1; i--){
       status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[1],
                    &intermROperands[1],
                    &coefROperand[i]);

        status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[1],
                        &intermROperands[1],
                        &intermROperands[0]);
    }

   status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                IOperand,
                &intermROperands[1],
                &coefROperand[0]);

   return status;

}


static gceSTATUS
_GenFastFmaCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS status;
    clsIOPERAND intermIOperands[1];
    clsROPERAND intermROperands[1];

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 3);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsIOPERAND_New(Compiler, &intermIOperands[0],OperandsParameters[0].rOperands[0].dataType);
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_FMA_MUL,
                        intermIOperands,
                        &OperandsParameters[0].rOperands[0],
                        &OperandsParameters[1].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;


    status = clGenArithmeticExprCode(Compiler,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo,
                   clvOPCODE_FMA_ADD,
                   IOperand,
                   intermROperands,
                   &OperandsParameters[2].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

    return gcvSTATUS_OK;
}


static gceSTATUS
_GenFmaCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND intermIOperands[30];
    clsROPERAND intermROperands[30], destROperand;
    clsROPERAND infROperand, thirtyROperand, thirtyOneROperand, thirtyTwoROperand, oneROperand, twenty3ROperand, twenty4ROperand, fiftyROperand, ox8000ROperand ;
    clsROPERAND infLessROperand, mantissaROperand, hideOneROperand, floatOneROperand, offsetExpROperand, eightROperand, sixty4ROperand, zeroROperand, ffROperand, signROperand;
    int i;


    /* Verify the arguments. */

    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 3);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsROPERAND_InitializeUsingIOperand(&destROperand, IOperand);
    for(i = 0; i<30; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], OperandsParameters[0].dataTypes[0].def);
        intermIOperands[i].dataType.elementType = clvTYPE_UINT;
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }



    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 0x7F800000);
    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 0x80000000);
    clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 0x0);
    clsROPERAND_InitializeIntOrIVecConstant(&infLessROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 0x7F7fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 30);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 31);
    clsROPERAND_InitializeIntOrIVecConstant(&thirtyTwoROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 32);
    clsROPERAND_InitializeIntOrIVecConstant(&oneROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT)1);
    clsROPERAND_InitializeIntOrIVecConstant(&mantissaROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT)0x007fffff);
    clsROPERAND_InitializeIntOrIVecConstant(&hideOneROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT)0x00800000);
    clsROPERAND_InitializeIntOrIVecConstant(&floatOneROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 0x3F800000);
    clsROPERAND_InitializeIntOrIVecConstant(&twenty3ROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 23);
    clsROPERAND_InitializeIntOrIVecConstant(&twenty4ROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 24);

    clsROPERAND_InitializeIntOrIVecConstant(&eightROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 8);

    clsROPERAND_InitializeIntOrIVecConstant(&fiftyROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 50);

    clsROPERAND_InitializeIntOrIVecConstant(&sixty4ROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 64);

    clsROPERAND_InitializeIntOrIVecConstant(&ffROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) 0xff);

    clsROPERAND_InitializeIntOrIVecConstant(&offsetExpROperand,
                          clmGenCodeDataType(T_INT),
                          (gctINT) (127 - 17) );
    clsROPERAND_InitializeIntOrIVecConstant(&ox8000ROperand,
                           clmGenCodeDataType(T_INT),
                          (gctINT) (0x00008000) );

    /*Get exponent part */
    for(i = 0; i<3; i++){
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[i],
                    &infROperand,
                    &OperandsParameters[i].rOperands[0]);
    }
    /*Get maximum of expABC */
    status = clGenGenericCode2(Compiler,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo,
               clvOPCODE_MAX,
               &intermIOperands[3],
               &intermROperands[1],
               &intermROperands[0]);

    status = clGenGenericCode2(Compiler,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo,
               clvOPCODE_MAX,
               &intermIOperands[4],
               &intermROperands[3],
               &intermROperands[2]);

    /*If max{expA, expB, expC} == inf? just use a*b+c */

    /*IF_0 */
    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[4],
                 clvCONDITION_EQUAL,
                 &infROperand);

    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            IOperand,
                            &OperandsParameters[0].rOperands[0],
                            &OperandsParameters[1].rOperands[0]
                            );
        if ((CodeGenerator->chipModel <= gcv2100 && CodeGenerator->chipRevision <= 0x5130) ||
        (CodeGenerator->chipModel == gcv4000 &&
         (CodeGenerator->chipRevision == 0x5208 || CodeGenerator->chipRevision == 0x5222 ||
            CodeGenerator->chipRevision == 0x4633)))
    {
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[4],
                    &infROperand,
                    &destROperand);
        clmGEN_CODE_IF(Compiler,  /*IF_G */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[4],
                 clvCONDITION_EQUAL,
                 &infROperand);

        clmGEN_CODE_IF(Compiler,  /*IF_H */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[3],
                 clvCONDITION_LESS_THAN,
                 &infROperand);
        /*GC2100, calculate to inf, return to finite, keep the sign */
        /*Since c is either finite or Nan, a*b finite, so setting to zero doesn't matter */
       status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &zeroROperand);

       clmGEN_CODE_ELSE(Compiler, /*IF_H */
                       CodeGenerator,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo);
       /*Finite return, do nothing */
       clmGEN_CODE_ENDIF(Compiler, /*IF_H*/
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);
       clmGEN_CODE_ELSE(Compiler, /*IF_G */
                       CodeGenerator,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo);
       /*Finite return, do nothing */
       clmGEN_CODE_ENDIF(Compiler, /*IF_G*/
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);
    }



    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            IOperand,
                            &OperandsParameters[2].rOperands[0],
                            &destROperand
                            );

    /*IF_0 */
   clmGEN_CODE_ELSE(Compiler,
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*Get minimum of expABC, if one of them is zero, use normal calculation */
    status = clGenGenericCode2(Compiler,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo,
               clvOPCODE_MIN,
               &intermIOperands[3],
               &intermROperands[1],
               &intermROperands[2]);

    status = clGenGenericCode2(Compiler,
               PolynaryExpr->exprBase.base.lineNo,
               PolynaryExpr->exprBase.base.stringNo,
               clvOPCODE_MIN,
               &intermIOperands[4],
               &intermROperands[3],
               &intermROperands[0]);
    /*IF_1 */
    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[4],
                 clvCONDITION_EQUAL,
                 &zeroROperand);


    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            IOperand,
                            &OperandsParameters[0].rOperands[0],
                            &OperandsParameters[1].rOperands[0]
                            );

    status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            IOperand,
                            &OperandsParameters[2].rOperands[0],
                            &destROperand
                            );
        if ((CodeGenerator->chipModel <= gcv2100 && CodeGenerator->chipRevision <= 0x5130) ||
        (CodeGenerator->chipModel == gcv4000 &&
         (CodeGenerator->chipRevision == 0x5208 || CodeGenerator->chipRevision == 0x5222 ||
            CodeGenerator->chipRevision == 0x4633)))
    {
        /* We should push Inf to finite */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[4],
                    &infROperand,
                    &destROperand);
        clmGEN_CODE_IF(Compiler,  /*IF_F */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[4],
                 clvCONDITION_EQUAL,
                 &infROperand);

        /* Calculate to inf, return to finite, keep the sign */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_AND_BITWISE,
                    &intermIOperands[4],
                    &signROperand,
                    &destROperand);
        IOperand->dataType.elementType = clvTYPE_INT;

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    IOperand,
                    &intermROperands[4],
                    &infLessROperand);

        IOperand->dataType.elementType = clvTYPE_FLOAT;
       clmGEN_CODE_ELSE(Compiler, /*IF_F */
                       CodeGenerator,
                       PolynaryExpr->exprBase.base.lineNo,
                       PolynaryExpr->exprBase.base.stringNo);
       /*Finite return, do nothing */
       clmGEN_CODE_ENDIF(Compiler, /*IF_F*/
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);
    }

    /*IF_1 */
   clmGEN_CODE_ELSE(Compiler,
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /*Normal case, not zero involve, use fix point calculation  */


   /*Get the sign */
   for(i = 0; i<3; i++){
       /*Use the signed shift, get -1 or 0 */
       intermIOperands[3+i].dataType.elementType = clvTYPE_INT;
       status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_RSHIFT,
                            &intermIOperands[3+i],
                            &OperandsParameters[i].rOperands[0],
                            &thirtyOneROperand);
       intermIOperands[3+i].dataType.elementType = clvTYPE_UINT;
   }
   /*r3 = sign(a * b), r5 = sign(c) */
   status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_XOR_BITWISE,
                &intermIOperands[3],
                &intermROperands[3],
                &intermROperands[4]);

   /*Get Mantissa */
   for(i = 0; i<3; i++){
           status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_AND_BITWISE,
                &intermIOperands[i+6],
                &mantissaROperand,
                &OperandsParameters[i].rOperands[0]);

       status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    &intermIOperands[i+6],
                    &intermROperands[i+6],
                    &hideOneROperand);
   }
   /*r10, r11 are A*B, mantissa part */
   status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[10],
                            &intermROperands[6],
                            &intermROperands[7]);

   status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MULHI,
                            &intermIOperands[11],
                            &intermROperands[6],
                            &intermROperands[7]);

   clmGEN_CODE_IF(Compiler, /*IF_B1*/
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[11],
                 clvCONDITION_GREATER_THAN_EQUAL,
                 &ox8000ROperand);
   /*MantissA*MantissaB > 2.0, we need to adjust c*1.0 exp and mantissa */
   /*make c = mantissaC*2 with ExpC - 1  */
   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LSHIFT,
                            &intermIOperands[8],
                            &intermROperands[8],
                            &oneROperand);
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[2],
                        &intermROperands[2],
                        &hideOneROperand);

   clmGEN_CODE_ELSE(Compiler, /*IF_B1*/
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*Do nothing */

   clmGEN_CODE_ENDIF(Compiler, /*IF_B1*/
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);



   /*r12, r13 = c*hideOne, the mantissa of c*1.0 */
   status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            &intermIOperands[12],
                            &intermROperands[8],
                            &hideOneROperand);

   status = clGenArithmeticExprCode(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MULHI,
                            &intermIOperands[13],
                            &intermROperands[8],
                            &hideOneROperand);

   /*The expA + expB */
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[0],
                        &intermROperands[1],
                        &intermROperands[0]);

   /* expC + exp1.0, similar to exponent of (c*1.0)*/
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[2],
                        &intermROperands[2],
                        &floatOneROperand);

    /*Sorting, since we have 3 components, combine exp and MantissaH get one component */

   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_OR_BITWISE,
                        &intermIOperands[20],
                        &intermROperands[0],
                        &intermROperands[11]);

   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_OR_BITWISE,
                        &intermIOperands[22],
                        &intermROperands[2],
                        &intermROperands[13]);


   clmGEN_CODE_IF(Compiler,  /*IF_2 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[20],
                 clvCONDITION_EQUAL,
                 &intermROperands[22]);
   /*IF high bit part are the same, upgrade the low bit part to compare */
   for(i = 0; i<4; i+= 2){
       status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    &intermIOperands[20 + i],
                    &intermROperands[10 + i]);
   }

   /*IF_2 */
   clmGEN_CODE_ELSE(Compiler,
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*Do nothing */

   clmGEN_CODE_ENDIF(Compiler, /*IF_2 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);


   clmGEN_CODE_IF(Compiler, /*IF_3 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[20],
                 clvCONDITION_LESS_THAN,
                 &intermROperands[22]);

   /*|a*b| < |c|, swapping the position, r0, r2:exp, r3, r5: sign, r10, r12: ManLow, r11:r13 ManHigh */
   for(i = 0; i<12; i++){
       if(i == 0 || i == 10 || i == 11 || i == 3){
           status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[20],
                        &intermROperands[i]);

           status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[i],
                        &intermROperands[i+2]);

           status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        &intermIOperands[i+2],
                        &intermROperands[20]);
       }
   }


   clmGEN_CODE_ELSE(Compiler,  /*IF_3 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*Already sorted, Do nothing */

   clmGEN_CODE_ENDIF(Compiler,  /*IF_3 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);
   /*r4 = r3^r5, indicate different sign of (a*b) and c */
   status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_XOR_BITWISE,
            &intermIOperands[4],
            &intermROperands[3],
            &intermROperands[5]);

   /*Now |a*b| and |c| are sorted  */

   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[1],
                        &intermROperands[0],
                        &intermROperands[2]);

   intermROperands[1].dataType.elementType = clvTYPE_UINT;
   /*r1 = (r0 - r2) >> 23, the Rshift for the small term */
   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_RSHIFT,
                            &intermIOperands[1],
                            &intermROperands[1],
                            &twenty3ROperand);

   intermIOperands[14].dataType.elementType = clvTYPE_UINT;
   intermIOperands[15].dataType.elementType = clvTYPE_UINT;

   clmGEN_CODE_IF(Compiler,  /*IF_4 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[1],
                 clvCONDITION_GREATER_THAN,
                 &fiftyROperand);
   /*if smaller part need to shift more than 50, set all value 0 or -1, depends the value  */
        _GenAddSub64Int(
            Compiler,
            CodeGenerator,
            PolynaryExpr,
            &intermROperands[10],
            &intermROperands[11],
            &intermROperands[4],
            &intermROperands[4],
            &intermIOperands[14],
            &intermIOperands[15],
            0);

   clmGEN_CODE_ELSE(Compiler,  /*IF_4 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_IF(Compiler,  /*IF_5 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[1],
                 clvCONDITION_GREATER_THAN,
                 &thirtyOneROperand);
   /*Shift more than 31, the low bit are zero, high bit shift */
   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_RSHIFT,
                            &intermIOperands[16],
                            &intermROperands[13],
                            &intermROperands[1]); /*Actually r1 - 32, but Rshift only take lsb 5 bits */
   clmGEN_CODE_IF(Compiler,  /*IF_6 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[4],
                 clvCONDITION_EQUAL,
                 &zeroROperand);
   /*Just add */
        _GenAddSub64Int(
            Compiler,
            CodeGenerator,
            PolynaryExpr,
            &intermROperands[10],
            &intermROperands[11],
            &intermROperands[16],
            &zeroROperand,
            &intermIOperands[14],
            &intermIOperands[15],
            0);
   clmGEN_CODE_ELSE(Compiler,  /*IF_6 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*subtraction happened */
   /*Check if the truncation has value, if has, we need to add one for subtraction term */
   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LSHIFT,
                            &intermIOperands[17],
                            &intermROperands[16],
                            &intermROperands[1]);
   /*r18 = r13 - ((r13>>r1)<<r1), check if have any residue */
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[18],
                        &intermROperands[13],
                        &intermROperands[17]);
   /*r19: the right shift bits, are all zero? */
   status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_OR_BITWISE,
            &intermIOperands[19],
            &intermROperands[18],
            &intermROperands[12]);

   clmGEN_CODE_IF(Compiler,  /*IF_7 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[19],
                 clvCONDITION_NOT_EQUAL,
                 &zeroROperand);
   /*small term truncation part non-zero, add one to the low bit. Don't worry, not overflow happen */
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[16],
                        &intermROperands[16],
                        &oneROperand);
   clmGEN_CODE_ELSE(Compiler,  /*IF_7 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*truncated part are all zero, Do nothing */
   clmGEN_CODE_ENDIF(Compiler,  /*IF_7 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

           _GenAddSub64Int(
            Compiler,
            CodeGenerator,
            PolynaryExpr,
            &intermROperands[10],
            &intermROperands[11],
            &intermROperands[16],
            &zeroROperand,
            &intermIOperands[14],
            &intermIOperands[15],
            1);
    clmGEN_CODE_ENDIF(Compiler,  /*IF_6 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

    clmGEN_CODE_ELSE(Compiler,  /*IF_5 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
    /* Now RShift < 32 */
    status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_RSHIFT,
                            &intermIOperands[16],
                            &intermROperands[12],
                            &intermROperands[1]);

    status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_RSHIFT,
                            &intermIOperands[17],
                            &intermROperands[13],
                            &intermROperands[1]);

   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LSHIFT,
                            &intermIOperands[18],
                            &intermROperands[17],
                            &intermROperands[1]);
   /*The value need to move to low32 bit */
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[19],
                        &intermROperands[13],
                        &intermROperands[18]);

   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[20],
                        &thirtyTwoROperand,
                        &intermROperands[1]);

   /*More low bit to correct position */
   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LSHIFT,
                            &intermIOperands[18],
                            &intermROperands[19],
                            &intermROperands[20]);

   status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_OR_BITWISE,
            &intermIOperands[16],
            &intermROperands[18],
            &intermROperands[16]);

   clmGEN_CODE_IF(Compiler,  /*IF_8 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[4],
                 clvCONDITION_EQUAL,
                 &zeroROperand);
   /*Just add */
        _GenAddSub64Int(
            Compiler,
            CodeGenerator,
            PolynaryExpr,
            &intermROperands[10],
            &intermROperands[11],
            &intermROperands[16],
            &intermROperands[17],
            &intermIOperands[14],
            &intermIOperands[15],
            0);
   clmGEN_CODE_ELSE(Compiler,  /*IF_8 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*subtraction happened */
   /*Check if the truncation has value, if has, we need to add one for subtraction term */
   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LSHIFT,
                            &intermIOperands[19],
                            &intermROperands[16],
                            &intermROperands[1]);
   /*r18 = r12 - ((r12>>r1)<<r1), check if have any residue */
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[18],
                        &intermROperands[12],
                        &intermROperands[19]);

   clmGEN_CODE_IF(Compiler,  /*IF_9 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[18],
                 clvCONDITION_NOT_EQUAL,
                 &zeroROperand);
   /*small term truncation part non-zero, add one to the low bit. never mind, MantissA*MantissB will not have 32 1's */
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[16],
                        &intermROperands[16],
                        &oneROperand);
   clmGEN_CODE_ELSE(Compiler,  /*IF_9 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*truncated part are all zero, Do nothing */
   clmGEN_CODE_ENDIF(Compiler,  /*IF_9 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

           _GenAddSub64Int(
            Compiler,
            CodeGenerator,
            PolynaryExpr,
            &intermROperands[10],
            &intermROperands[11],
            &intermROperands[16],
            &intermROperands[17],
            &intermIOperands[14],
            &intermIOperands[15],
            1);
    clmGEN_CODE_ENDIF(Compiler,  /*IF_8 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);


     clmGEN_CODE_ENDIF(Compiler,  /*IF_5 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

    clmGEN_CODE_ENDIF(Compiler,  /*IF_4 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

    /*We get the mantiss, exp and the sign, we have to make the float */
    /*r0,exp, r3, sign, r14: ManLow, r15 ManHigh */

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LEADZERO,
                &intermIOperands[1],
                &intermROperands[15]);

   clmGEN_CODE_IF(Compiler,  /*IF_A */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[1],
                 clvCONDITION_EQUAL,
                 &thirtyTwoROperand);

   /*Get low bit leading zero */
   status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_LEADZERO,
                &intermIOperands[1],
                &intermROperands[14]);

   clmGEN_CODE_IF(Compiler,  /*IF_A1 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[1],
                 clvCONDITION_LESS_THAN_EQUAL,
                 &eightROperand);
   /*The 24 bit mantissa comes from r-shift of r14  */

   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[2],
                        &eightROperand,
                        &intermROperands[1]);

   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_RSHIFT,
                            &intermIOperands[10],
                            &intermROperands[14],
                            &intermROperands[2]);


   clmGEN_CODE_ELSE(Compiler,  /*IF_A1 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /*The 24 bit mantissa comes from l-shift of r14  */

   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[2],
                        &intermROperands[1],
                        &eightROperand);

   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LSHIFT,
                            &intermIOperands[10],
                            &intermROperands[14],
                            &intermROperands[2]);

   clmGEN_CODE_IF(Compiler,  /*IF_A2 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[18],
                 clvCONDITION_NOT_EQUAL,
                 &zeroROperand);
   /*Previous -1 is too much, now add back */

   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[19],
                        &intermROperands[2],
                        &oneROperand);

   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LSHIFT,
                            &intermIOperands[19],
                            &oneROperand,
                            &intermROperands[19]);

   status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    &intermIOperands[10],
                    &intermROperands[10],
                    &intermROperands[19]);


   clmGEN_CODE_ELSE(Compiler,  /*IF_A2 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*truncated part are all zero, Do nothing */
   clmGEN_CODE_ENDIF(Compiler,  /*IF_A2 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);



   clmGEN_CODE_ENDIF(Compiler,  /*IF_A1 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

   /*Compare with high bit leading zero, add 32 */
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[1],
                        &intermROperands[1],
                        &thirtyTwoROperand);

   clmGEN_CODE_ELSE(Compiler,  /*IF_A */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /*mantissa comes from some part of r15 and r14, beware r1>=17 */
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[2],
                        &intermROperands[1],
                        &eightROperand);

   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LSHIFT,
                            &intermIOperands[10],
                            &intermROperands[15],
                            &intermROperands[2]);

   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[2],
                        &thirtyTwoROperand,
                        &intermROperands[2]);

   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_RSHIFT,
                            &intermIOperands[11],
                            &intermROperands[14],
                            &intermROperands[2]);

   status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    &intermIOperands[10],
                    &intermROperands[10],
                    &intermROperands[11]);

   clmGEN_CODE_ENDIF(Compiler,  /*IF_A */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_IF(Compiler,  /*IF_B */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[1],
                 clvCONDITION_EQUAL,
                 &sixty4ROperand);
   /*leading zero = 64, means mantissa = 0, a*b+c = 0 */

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &zeroROperand);

   clmGEN_CODE_ELSE(Compiler,  /*IF_B */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /*now r10 mantissa */

   status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_XOR_BITWISE,
                    &intermIOperands[10],
                    &intermROperands[10],
                    &hideOneROperand);

   /*Put the sign bit on the top */
   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LSHIFT,
                            &intermIOperands[4],
                            &intermROperands[3],
                            &thirtyOneROperand);
   /*The sign bit */
   status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    &intermIOperands[10],
                    &intermROperands[10],
                    &intermROperands[4]);

   /*Handle the exponential */
   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_RSHIFT,
                            &intermIOperands[11],
                            &intermROperands[0],
                            &twenty3ROperand);

  /*Handle the exponential: Sub the leading one */
   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[12],
                        &intermROperands[11],
                        &intermROperands[1]);
   /*sub the offset */


   status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_SUB_RTZ,
                        &intermIOperands[0],
                        &intermROperands[12],
                        &offsetExpROperand);
   /*signed integer comparison  */
   intermROperands[0].dataType.elementType = clvTYPE_INT;

   clmGEN_CODE_IF(Compiler,  /*IF_C */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[0],
                 clvCONDITION_LESS_THAN_EQUAL,
                 &zeroROperand);
   intermROperands[0].dataType.elementType = clvTYPE_UINT;
   /*exp <= 0, return to zero*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &zeroROperand);

   clmGEN_CODE_ELSE(Compiler,  /*IF_C */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_IF(Compiler,  /*IF_D */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[0],
                 clvCONDITION_GREATER_THAN_EQUAL,
                 &ffROperand);

   /*exp >= 255, return to max_float, with the sign*/

   status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    &intermIOperands[10],
                    &intermROperands[10],
                    &infLessROperand);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &intermROperands[10]);

   clmGEN_CODE_ELSE(Compiler,  /*IF_D */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*Normal case, set the exponent part */

   status = clGenShiftExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_LSHIFT,
                            &intermIOperands[1],
                            &intermROperands[0],
                            &twenty3ROperand);
   status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_OR_BITWISE,
                    &intermIOperands[10],
                    &intermROperands[10],
                    &intermROperands[1]);

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &intermROperands[10]);

   clmGEN_CODE_ENDIF(Compiler,  /*IF_D */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);


   clmGEN_CODE_ENDIF(Compiler,  /*IF_C */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);


   clmGEN_CODE_ENDIF(Compiler,  /*IF_B */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler, /*IF_1 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler, /*IF_0 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

    return gcvSTATUS_OK;
OnError:
    return status;

}


static gceSTATUS
_GenGammaCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND intermIOperands[10];
    clsROPERAND intermROperands[10], infROperand, thirty6ROperand, thirtyOneROperand, neg38ROperand, zeroROperand, oneROperand, twoROperand, unsignROperand, smallNegROperand;
    int i;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 1.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 0.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 2.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&thirty6ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 36.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&neg38ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) -38.0);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7F800000);
    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7FFFffff);

    clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 31);
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&smallNegROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) (-1.175494351e-038)*4.0);



    for(i = 0; i<10; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(i == 0? T_INT : T_FLOAT));
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[0],
                        &infROperand,
                        &OperandsParameters[0].rOperands[0]);

   clmGEN_CODE_IF(Compiler,  /*IF_0*/
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[0],
                 clvCONDITION_EQUAL,
                 &infROperand);

   /*x = inf or Nan, return to |x| */
   IOperand->dataType.elementType = clvTYPE_UINT;
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        IOperand,
                        &unsignROperand,
                        &OperandsParameters[0].rOperands[0]);
    IOperand->dataType.elementType = clvTYPE_FLOAT;

   clmGEN_CODE_ELSE(Compiler,  /*IF_0 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);


   clmGEN_CODE_IF(Compiler,  /*IF_1*/
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &OperandsParameters[0].rOperands[0],
                 clvCONDITION_GREATER_THAN_EQUAL,
                 &thirty6ROperand);

   /*x >= 35.0, return to Inf */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &infROperand);

   clmGEN_CODE_ELSE(Compiler,  /*IF_1 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_IF(Compiler,  /*IF_2*/
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &OperandsParameters[0].rOperands[0],
                 clvCONDITION_GREATER_THAN_EQUAL,
                 &oneROperand);

   /* Now 1<x<35, good range, using Gamma(x) = (x-1.0)*Gamma(x-1) = (x-2.0)*Gamma(x-2)... */
   status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            &intermIOperands[1],
            &OperandsParameters[0].rOperands[0]);

   status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            &intermIOperands[2],
            &oneROperand);
   status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            &intermIOperands[3],
            &zeroROperand);
  clmGEN_CODE_IF(Compiler,  /*IF_2A*/
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_GREATER_THAN,
             &twoROperand);
  /*if x > 2.0, go to the loop otherwise, in the randge of [1,2], calculate directly */
   {
       clsSELECTION_CONTEXT   selectionContextLoopBack;

        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectionContextLoopBack);
        if (gcmIS_ERROR(status)) return status;

        /* Loop End, jump back here*/
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectionContextLoopBack);

        /*x = x-1.0f */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[1],
                                &intermROperands[1],
                                &oneROperand);

        _GenHighPrecFloatMul(
            Compiler,
            CodeGenerator,
            PolynaryExpr,
            &intermROperands[1],
            &intermROperands[3],
            &intermROperands[2],
            &intermIOperands[3],
            &intermIOperands[2]
            );

        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContextLoopBack);

        if (gcmIS_ERROR(status)) return status;


        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextLoopBack,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_LESS_THAN,
                                                    &intermROperands[1],
                                                    &twoROperand);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectionContextLoopBack);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectionContextLoopBack,
                                        gcvFALSE);


        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextLoopBack);
        if (gcmIS_ERROR(status)) return status;
    }
   clmGEN_CODE_ELSE(Compiler,  /*IF_2A */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

  clmGEN_CODE_ENDIF(Compiler,  /*IF_2A */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo);

       _GenGammaIn1To2(
            Compiler,
            CodeGenerator,
            PolynaryExpr,
            &intermROperands[1],
            &intermIOperands[4]
            );

    status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            IOperand,
                            &intermROperands[4],
                            &intermROperands[2]);

   clmGEN_CODE_ELSE(Compiler,  /*IF_2 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);


   /*Now x < 1.0, let's calculate integer first */

   status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_FLOOR,
                &intermIOperands[1],
                &OperandsParameters[0].rOperands[0]);


   clmGEN_CODE_IF(Compiler,  /*IF_3*/
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &OperandsParameters[0].rOperands[0],
                 clvCONDITION_EQUAL,
                 &intermROperands[1]);
   /*x = floor(x), then x is integer, return to (-1)^x * Inf */

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_FLOAT_TO_INT,
                &intermIOperands[0],
                &intermROperands[1]);

    /*(x << 31), get the sign, beware very small x is even value (saturated to 0x80000000) */
    status = clGenShiftExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_LSHIFT,
                                &intermIOperands[0],
                                &intermROperands[0],
                                &thirtyOneROperand);

    /*Add the sign bit to infinite */
    IOperand->dataType.elementType = clvTYPE_UINT;
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_OR_BITWISE,
                        IOperand,
                        &infROperand,
                        &intermROperands[0]);
    IOperand->dataType.elementType = clvTYPE_FLOAT;

    clmGEN_CODE_ELSE(Compiler,  /*IF_3 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

    /*Now x < 1.0, floating point */
   clmGEN_CODE_IF(Compiler,  /*IF_4*/
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &OperandsParameters[0].rOperands[0],
                 clvCONDITION_LESS_THAN_EQUAL,
                 &neg38ROperand);
   /*Zeros, for x <= -38.0, non-integer  */
   status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &zeroROperand);

    clmGEN_CODE_ELSE(Compiler,  /*IF_4 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
    /*Now... -38.0<x<=1.0, Gamma(x) = Gamma(x+1)/x */

    status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_SUB_RTZ,
                            &intermIOperands[1],
                            &OperandsParameters[0].rOperands[0],
                            &intermROperands[1]);
    /*r5 = frac(x) + 1, in the range of (1, 2), Gamma(r5)/something */
    status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_ADD_RTZ,
                            &intermIOperands[5],
                            &oneROperand,
                            &intermROperands[1]);

   status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            &intermIOperands[2],
            &oneROperand);
   status = clGenGenericCode1(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            clvOPCODE_ASSIGN,
            &intermIOperands[3],
            &zeroROperand);

   clmGEN_CODE_IF(Compiler,  /*IF_A*/
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &OperandsParameters[0].rOperands[0],
                 clvCONDITION_GREATER_THAN_EQUAL,
                 &smallNegROperand);
   /*x = frac(x), x in the (0, 1), skip the iteration */
   clmGEN_CODE_ELSE(Compiler,  /*IF_A */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /*The x < 0.0 */
   {
       clsSELECTION_CONTEXT   selectionContextLoopBack;

        status = clDefineSelectionBegin(Compiler,
                                        CodeGenerator,
                                        gcvTRUE,
                                        &selectionContextLoopBack);
        if (gcmIS_ERROR(status)) return status;

        /* Loop End, jump back here*/
        status = clDefineSelectionFalseOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectionContextLoopBack);

        _GenHighPrecFloatMul(
            Compiler,
            CodeGenerator,
            PolynaryExpr,
            &intermROperands[1],
            &intermROperands[3],
            &intermROperands[2],
            &intermIOperands[3],
            &intermIOperands[2]
            );

        /*x = x-1.0f */
        status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clvOPCODE_SUB_RTZ,
                                &intermIOperands[1],
                                &intermROperands[1],
                                &oneROperand);

        status = clDefineSelectionFalseOperandEnd(Compiler,
                                        CodeGenerator,
                                        &selectionContextLoopBack);

        if (gcmIS_ERROR(status)) return status;


        status = clGenSelectionCompareConditionCode(Compiler,
                                                    CodeGenerator,
                                                    &selectionContextLoopBack,
                                                    PolynaryExpr->exprBase.base.lineNo,
                                                    PolynaryExpr->exprBase.base.stringNo,
                                                    clvCONDITION_LESS_THAN_EQUAL,
                                                    &intermROperands[1],
                                                    &OperandsParameters[0].rOperands[0]);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandBegin(Compiler,
                                                CodeGenerator,
                                                &selectionContextLoopBack);
        if (gcmIS_ERROR(status)) return status;

        status = clDefineSelectionTrueOperandEnd(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        CodeGenerator,
                                        &selectionContextLoopBack,
                                        gcvFALSE);


        status = clDefineSelectionEnd(Compiler,
                                    CodeGenerator,
                                    &selectionContextLoopBack);
        if (gcmIS_ERROR(status)) return status;
    }
    clmGEN_CODE_ENDIF(Compiler,  /*IF_A */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

   /*Use original x instead of r1 = frac(x) + floor(x), when x is very close to -0, r1 < x */
    _GenHighPrecFloatMul(
            Compiler,
            CodeGenerator,
            PolynaryExpr,
            &OperandsParameters[0].rOperands[0],
            &intermROperands[3],
            &intermROperands[2],
            &intermIOperands[3],
            &intermIOperands[2]
            );

       _GenGammaIn1To2(
            Compiler,
            CodeGenerator,
            PolynaryExpr,
            &intermROperands[5],
            &intermIOperands[4]
            );

            /*Gamma(x) = Gamma(x + n)/((x+n-1)*...*x) */
    intermROperands[2].dataType.elementType = clvTYPE_FLOAT;
    clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_INVERSE,
                        &intermIOperands[6],
                        &intermROperands[2]);

    status = clGenArithmeticExprCode(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_MUL_RTZ,
                            IOperand,
                            &intermROperands[4],
                            &intermROperands[6]);

   clmGEN_CODE_ENDIF(Compiler,  /*IF_4 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);


   clmGEN_CODE_ENDIF(Compiler,  /*IF_3 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler,  /*IF_2 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);


   clmGEN_CODE_ENDIF(Compiler,  /*IF_1 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);


   clmGEN_CODE_ENDIF(Compiler,  /*IF_0 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);
    return gcvSTATUS_OK;
OnError:
    return status;
}



static gceSTATUS
_GenLGammaCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* Simply copy..., since ulp allow up to Inf, we should give better approximation*/
            status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &OperandsParameters[0].rOperands[0],
                    &OperandsParameters[0].rOperands[0]);

       return status;
}

static gceSTATUS
_GenLGamma_RCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;

    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    /* Simply copy..., since ulp allow up to Inf, we should give better approximation*/
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &OperandsParameters[0].rOperands[0]);
    if (gcmIS_ERROR(status)) return status;

            { /* Save out zero*/
            clsLOPERAND lOperand[1];
            clsROPERAND zeroROperand;

            clsROPERAND_InitializeIntOrIVecConstant(&zeroROperand,
                                                clmGenCodeDataType(T_INT),
                                                0x0);

            clsLOPERAND_InitializeUsingROperand(lOperand, &OperandsParameters[1].rOperands[0]);
            status = clGenStoreCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        &zeroROperand,
                                        lOperand,
                                        OperandsParameters[1].rOperands[0].dataType,
                                        &zeroROperand);
                if (gcmIS_ERROR(status)) return status;
        } /*End of Save out */

       return gcvSTATUS_OK;
}

static gceSTATUS
_GenMaxMagCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND                intermIOperands[2];
    clsROPERAND                intermROperands[2], infROperand, unsignROperand;
    int i;
    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7F800000);
     clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7FFFFFFF);

   clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));
   clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[0],
                        &unsignROperand,
                        &OperandsParameters[0].rOperands[0]);

        clmGEN_CODE_IF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo,
                         &intermROperands[0],
                         clvCONDITION_GREATER_THAN,
                         &infROperand);

        /* if x == Nan, return y, our comparison of Nan>y have trouble*/
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &OperandsParameters[1].rOperands[0]);

          clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

          /* x != Nan cases*/
        for(i = 0; i < 2; i++){
           clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
           clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
           status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ABS,
                                    &intermIOperands[i],
                                    &OperandsParameters[i].rOperands[0]);
            if (gcmIS_ERROR(status)) return status;
        }

         clmGEN_CODE_IF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo,
                         &intermROperands[0],
                         clvCONDITION_GREATER_THAN,
                         &intermROperands[1]);

        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &OperandsParameters[0].rOperands[0]);

          clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

          {
             clmGEN_CODE_IF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo,
                         &intermROperands[0],
                         clvCONDITION_LESS_THAN,
                         &intermROperands[1]);

            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &OperandsParameters[1].rOperands[0]);

          clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);
          /*If the absolute value are the same, get the max */
          status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MAX,
                    IOperand,
                    &OperandsParameters[0].rOperands[0],
                    &OperandsParameters[1].rOperands[0]);
          clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

          }
       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

OnError:
       return gcvSTATUS_OK;
}

static gceSTATUS
_GenMinMagCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND                intermIOperands[2];
    clsROPERAND                intermROperands[2], infROperand, unsignROperand;
    int i;
    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7F800000);
     clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                              clmGenCodeDataType(T_UINT),
                              (gctUINT) 0x7FFFFFFF);

   clsIOPERAND_New(Compiler, &intermIOperands[0], clmGenCodeDataType(T_UINT));
   clsROPERAND_InitializeUsingIOperand(&intermROperands[0], &intermIOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[0],
                        &unsignROperand,
                        &OperandsParameters[0].rOperands[0]);

        clmGEN_CODE_IF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo,
                         &intermROperands[0],
                         clvCONDITION_GREATER_THAN,
                         &infROperand);

        /* if x == Nan, return y, our comparison of Nan>y have trouble*/
        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &OperandsParameters[1].rOperands[0]);

          clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

          /* x != Nan cases*/
        for(i = 0; i < 2; i++){
           clsIOPERAND_New(Compiler, &intermIOperands[i], clmGenCodeDataType(T_FLOAT));
           clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
           status = clGenGenericCode1(Compiler,
                                    PolynaryExpr->exprBase.base.lineNo,
                                    PolynaryExpr->exprBase.base.stringNo,
                                    clvOPCODE_ABS,
                                    &intermIOperands[i],
                                    &OperandsParameters[i].rOperands[0]);
            if (gcmIS_ERROR(status)) return status;
        }

         clmGEN_CODE_IF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo,
                         &intermROperands[0],
                         clvCONDITION_LESS_THAN,
                         &intermROperands[1]);

        status = clGenGenericCode1(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ASSIGN,
                    IOperand,
                    &OperandsParameters[0].rOperands[0]);

          clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);

          {
             clmGEN_CODE_IF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo,
                         &intermROperands[0],
                         clvCONDITION_GREATER_THAN,
                         &intermROperands[1]);

            status = clGenGenericCode1(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ASSIGN,
                        IOperand,
                        &OperandsParameters[1].rOperands[0]);

          clmGEN_CODE_ELSE(Compiler,
                           CodeGenerator,
                           PolynaryExpr->exprBase.base.lineNo,
                           PolynaryExpr->exprBase.base.stringNo);
          /*If the absolute value are the same, get the min */
          status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MIN,
                    IOperand,
                    &OperandsParameters[0].rOperands[0],
                    &OperandsParameters[1].rOperands[0]);
          clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

          }

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

       clmGEN_CODE_ENDIF(Compiler,
                         CodeGenerator,
                         PolynaryExpr->exprBase.base.lineNo,
                         PolynaryExpr->exprBase.base.stringNo);

OnError:
       return gcvSTATUS_OK;
}
/*To avoid x (+,-,*) y = inf for |x|, |y| < inf*/
static gceSTATUS
_GenAddSubMul4Code(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsROPERAND unsignROperand, infROperand, thirtyOneROperand, maxFloatROperand;
    clsIOPERAND intermIOperands[20];
    clsROPERAND intermROperands[20];
    cleOPCODE opcode;
    gctUINT8 i;

    /* Verify the arguments. */
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    gcmASSERT(OperandCount == 2);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    opcode = PolynaryExpr->funcName->symbol[0] == 'a'?
        (CodeGenerator->fpConfig & cldFpROUND_TO_NEAREST ? clvOPCODE_ADD_RTNE : clvOPCODE_ADD_RTZ) :
        (PolynaryExpr->funcName->symbol[0] == 's'?
        (CodeGenerator->fpConfig & cldFpROUND_TO_NEAREST ? clvOPCODE_SUB_RTNE : clvOPCODE_SUB_RTZ) :
        (CodeGenerator->fpConfig & cldFpROUND_TO_NEAREST ? clvOPCODE_MUL_RTNE : clvOPCODE_MUL_RTZ));

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT) 0x7FFFFFFF);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT) 0x7F800000);

    clsROPERAND_InitializeIntOrIVecConstant(&maxFloatROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT) 0x7F7fffff);

    clsROPERAND_InitializeIntOrIVecConstant(&thirtyOneROperand,
                              clmGenCodeDataType(T_INT),
                              (gctINT) 31);


    /*General  */
    status = clGenArithmeticExprCode(Compiler,
            PolynaryExpr->exprBase.base.lineNo,
            PolynaryExpr->exprBase.base.stringNo,
            opcode,
            IOperand,
            &OperandsParameters[0].rOperands[0],
            &OperandsParameters[1].rOperands[0]);

    IOperand->dataType.elementType = clvTYPE_UINT;
    clsROPERAND_InitializeUsingIOperand(&intermROperands[0], IOperand);


    for(i = 1; i<20; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i],OperandsParameters[0].rOperands[0].dataType);
        intermIOperands[i].dataType.elementType = clvTYPE_INT;
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[1],
                        &intermROperands[0],
                        &unsignROperand);

    clmGEN_CODE_IF(Compiler,
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &intermROperands[1],
                 clvCONDITION_EQUAL,
                 &infROperand);
   /*Now some results are inf */
   /*Get max(|x|, |y|) */
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[10],
                        &OperandsParameters[0].rOperands[0],
                        &unsignROperand);

    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[11],
                        &OperandsParameters[1].rOperands[0],
                        &unsignROperand);

    /* r12 = max(|x|, |y|)...*/
    status = clGenGenericCode2(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MAX,
                    &intermIOperands[12],
                    &intermROperands[10],
                    &intermROperands[11]);


   /*r2 = r1 == infR */
    status = clGenGenericCode2(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_EQUAL,
                            &intermIOperands[2],
                            &intermROperands[1],
                            &infROperand);


    /* r3 = max(|x|, |y|) != inf */
    status = clGenGenericCode2(
                            Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_NOT_EQUAL,
                            &intermIOperands[3],
                            &intermROperands[12],
                            &infROperand);


    /*r5 = r4&r6, r5.s = -1 only if |f(x,y)|=inf and max(|x|, |y|)<inf, ELSE r5.S = 0 */
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[5],
                        &intermROperands[3],
                        &intermROperands[2]);


    /*f(x,y) + r5, unsigned add */
    status = clGenArithmeticExprCode(Compiler,
                                PolynaryExpr->exprBase.base.lineNo,
                                PolynaryExpr->exprBase.base.stringNo,
                                clmGEN_CODE_IsScalarDataType(OperandsParameters[0].dataTypes[0].def) ?
                                clvOPCODE_SUB_RTZ : clvOPCODE_ADD_RTZ,
                                IOperand,
                                &intermROperands[0],
                                &intermROperands[5]);

   clmGEN_CODE_ELSE(Compiler,
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
   /* Do nothing, if all the component not equal to inf, the original calculation was correct*/



   clmGEN_CODE_ENDIF(Compiler,
                     CodeGenerator,
                     PolynaryExpr->exprBase.base.lineNo,
                     PolynaryExpr->exprBase.base.stringNo);

OnError:
   IOperand->dataType.elementType = clvTYPE_FLOAT;
   return status;
}


static gceSTATUS
_GenAddSubMulCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status = gcvSTATUS_OK;
    clsROPERAND sliceROperand0, sliceROperand1, cpyROperand[2];
    clsLOPERAND tempLOperand, destLOperand;
    clsIOPERAND tempIOperand;
    clsROPERAND tempROperand;
    clsGEN_CODE_DATA_TYPE dataType;
    gctUINT8 i, vectorComponentCount = gcGetDataTypeComponentCount(OperandsParameters[0].rOperands[0].dataType);
    if(vectorComponentCount != 8 && vectorComponentCount != 16)
        return _GenAddSubMul4Code(
                Compiler,
                CodeGenerator,
                PolynaryExpr,
                OperandCount,
                OperandsParameters,
                IOperand
                );

    cpyROperand[0] = OperandsParameters[0].rOperands[0];
    cpyROperand[1] = OperandsParameters[1].rOperands[0];

    clsLOPERAND_InitializeUsingIOperand(&tempLOperand, IOperand);
    dataType = clGetSubsetDataType(IOperand->dataType, 4);
    clsIOPERAND_New(Compiler, &tempIOperand, dataType);
    clsROPERAND_InitializeUsingIOperand(&tempROperand, &tempIOperand);

    for(i = 0; i<vectorComponentCount; i += 4){
        clGetVectorROperandSlice(&cpyROperand[0],
                i,
                4,
                &sliceROperand0);
        clGetVectorROperandSlice(&cpyROperand[1],
                i,
                4,
                &sliceROperand1);
        clGetVectorLOperandSlice(&tempLOperand,
                    i,
                    4,
                    &destLOperand);

        OperandsParameters[0].rOperands[0] = sliceROperand0;
        OperandsParameters[1].rOperands[0] = sliceROperand1;
        status = _GenAddSubMul4Code(
                Compiler,
                CodeGenerator,
                PolynaryExpr,
                OperandCount,
                OperandsParameters,
                &tempIOperand
                );

        status = clGenAssignCode(
                Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                &destLOperand,
                &tempROperand);
        if (gcmIS_ERROR(status)) return status;
    }
    OperandsParameters[0].rOperands[0] = cpyROperand[0];
    OperandsParameters[1].rOperands[0] = cpyROperand[1];

    return status;
}


static gceSTATUS
_GenErfcCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status = gcvSTATUS_OK;
    clsIOPERAND intermIOperands[10];
    clsROPERAND intermROperands[10], nineDot25ROperand, dot75ROperand, neg4ROperand, zeroROperand, oneROperand, infROperand, unsignROperand ;
    clsROPERAND coef75ROperands[5], coefOutsideROperands[8], twoROperand, logTwoROperand, logTwoLowROperand, logE2ROperand, twoPow24ROperand;
    float erfcCoefLess75[] = { /*Approximation 1 - Erfc(x) directly for |x|<0.75, with {x, x^3, x^5...}*/
         -1.128377556800842300000000f,
          0.376091331243515010000000f,
         -0.112584494054317470000000f,
          0.026030769571661949000000f,
         -0.003914592787623405500000f,
        };

    float erfcCoefApprx[] = { /*0.564115762710571290000000f, //original */
                              0.56411582230000000f,          /*Add LSB1, to compansate the truncation loss.*/
                              0.566804051399230960000000f,
                              0.243914052844047550000000f,
                              0.016629695892333984000000f,
                             -2.053392171859741200000000f,
                              3.269657611846923800000000f,
                             -2.130216598510742200000000f,
                              0.516722261905670170000000f,
    };
    float twoPow24 = 16777216.0f, oneOverPow24 = 0.000000059604644775390625f;
    int i;


    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    for(i = 0; i<5; i++){
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&coef75ROperands[i],
                                  clmGenCodeDataType(T_FLOAT),
                                  (gctFLOAT)erfcCoefLess75[i]);
    }

    for(i = 0; i<8; i++){
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&coefOutsideROperands[i],
                                  clmGenCodeDataType(T_FLOAT),
                                  (gctFLOAT)erfcCoefApprx[i]*oneOverPow24);
    }


    for(i = 0; i<10; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i],OperandsParameters[0].rOperands[0].dataType);
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)0.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)1.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)2.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&dot75ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)0.75);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&neg4ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)-4.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&nineDot25ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)9.25);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logTwoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              -( _LOG2_E_high ) );

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logTwoLowROperand,
                              clmGenCodeDataType(T_FLOAT),
                              -( _LOG2_E_low ));
    clsROPERAND_InitializeFloatOrVecOrMatConstant(&logE2ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) _LOGE_2);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoPow24ROperand,
                              clmGenCodeDataType(T_FLOAT),
                              twoPow24 );

    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x7f800000);

  intermIOperands[0].dataType.elementType = clvTYPE_INT;
   intermROperands[0].dataType.elementType = clvTYPE_INT;
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[0],
                        &OperandsParameters[0].rOperands[0],
                        &unsignROperand);

   clmGEN_CODE_IF(Compiler,  /*IF_0 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &intermROperands[0],
             clvCONDITION_GREATER_THAN,
             &infROperand);

   /*Nan input, nan output */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &OperandsParameters[0].rOperands[0]);

    clmGEN_CODE_ELSE(Compiler,  /*IF_0 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
    /*Not Nan case */
   intermIOperands[0].dataType.elementType = clvTYPE_FLOAT;
   intermROperands[0].dataType.elementType = clvTYPE_FLOAT;

   clmGEN_CODE_IF(Compiler,  /*IF_1 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_LESS_THAN_EQUAL,
             &neg4ROperand);
   /*x<=-4, efrc(x) = 2.0 */

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &twoROperand);

   clmGEN_CODE_ELSE(Compiler,  /*IF_1 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_IF(Compiler,  /*IF_2 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &OperandsParameters[0].rOperands[0],
             clvCONDITION_GREATER_THAN_EQUAL,
             &nineDot25ROperand);
   /*x>=9.25, efrc(x) = 0.0 */

    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &zeroROperand);

   clmGEN_CODE_ELSE(Compiler,  /*IF_2 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /*Now we have -4.0<x<9.25 */

   clmGEN_CODE_IF(Compiler,  /*IF_4 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &intermROperands[0],
             clvCONDITION_LESS_THAN_EQUAL,
             &dot75ROperand);
   /* |x|<=.75, approximate efrc(x), 1-1.128*x + 0.37x^3 -..x^5  */

   /*Get x^2 */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[1],
                &OperandsParameters[0].rOperands[0],
                &OperandsParameters[0].rOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[2],
                &coef75ROperands[4],
                &intermROperands[1]);
    for(i = 3; i>=0; i--){
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[3],
                    &coef75ROperands[i],
                    &intermROperands[2]);

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[2],
                    &intermROperands[3],
                    i == 0? &OperandsParameters[0].rOperands[0]: &intermROperands[1]);
    }

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                IOperand,
                &oneROperand,
                &intermROperands[2]);

   clmGEN_CODE_ELSE(Compiler,  /*IF_4 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /*Now we have |x|>.75 */
   /*Get y = 1/(1+|x|) */
     status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ADD_RTZ,
                &intermIOperands[1],
                &oneROperand,
                &intermROperands[0]);

    intermROperands[1].dataType.elementType = clvTYPE_FLOAT;
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_INVERSE,
                &intermIOperands[2],
                &intermROperands[1]);
    /*Rcp must be high precision, N-R iteration once */

    status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[2],
                                        &intermROperands[1]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_SUB_RTZ,
                                        &intermIOperands[4],
                                        &oneROperand,
                                        &intermROperands[3]);


        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_MUL_RTZ,
                                        &intermIOperands[3],
                                        &intermROperands[2],
                                        &intermROperands[4]);

        status = clGenArithmeticExprCode(Compiler,
                                        PolynaryExpr->exprBase.base.lineNo,
                                        PolynaryExpr->exprBase.base.stringNo,
                                        clvOPCODE_ADD_RTZ,
                                        &intermIOperands[1],
                                        &intermROperands[2],
                                        &intermROperands[3]);
        /*Now r1 = 1/(1+|x|) */

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[2],
                    &coefOutsideROperands[7],
                    &intermROperands[1]);
        for(i = 6; i>=0; i--){
            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_ADD_RTZ,
                        &intermIOperands[3],
                        &coefOutsideROperands[i],
                        &intermROperands[2]);

            status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_MUL_RTZ,
                        &intermIOperands[2],
                        &intermROperands[3],
                        &intermROperands[1]);
        }
        /*Now r2=erfc(x)*E^(x*x)/(2^24), we have to get E(-x*x)*2^24 */

        /*r1 = |x|*|x|*/
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[1],
                    &intermROperands[0],
                    &intermROperands[0]);

        /*r3 = mulLow(x, x), -r3 should be compensation */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MULLO_RTZ,
                    &intermIOperands[3],
                    &intermROperands[0],
                    &intermROperands[0]);

        /*r4 = x^2*(-logE2) */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[4],
                    &logTwoROperand,
                    &intermROperands[1]);

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MULLO_RTZ,
                    &intermIOperands[5],
                    &logTwoROperand,
                    &intermROperands[1]);

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[6],
                    &logTwoLowROperand,
                    &intermROperands[1]);
        /*r7/log2 will be another compansation */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[7],
                    &intermROperands[5],
                    &intermROperands[6]);

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[6],
                    &intermROperands[7],
                    &logE2ROperand);
        /*Now r5 is the compensation part */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SUB_RTZ,
                    &intermIOperands[5],
                    &intermROperands[6],
                    &intermROperands[3]);
        /*r1 = 2^(-x*x*log2E), the main part */
        status = clGenGenericCode1(Compiler,
                            PolynaryExpr->exprBase.base.lineNo,
                            PolynaryExpr->exprBase.base.stringNo,
                            clvOPCODE_EXP2,
                            &intermIOperands[1],
                            &intermROperands[4]);
        /*boost r1, otherwise r1*r5 would be too small, chopped to zero */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[3],
                    &intermROperands[1],
                    &twoPow24ROperand);


        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[4],
                    &intermROperands[3],
                    &intermROperands[5]);

        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[1],
                    &intermROperands[3],
                    &intermROperands[4]);

      clmGEN_CODE_IF(Compiler,  /*IF_5 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo,
                 &OperandsParameters[0].rOperands[0],
                 clvCONDITION_GREATER_THAN_EQUAL,
                 &zeroROperand);

      /*x>=0, actually, x>= .75, erfc(x) = E^(-x*x) * r2 */

      status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    IOperand,
                    &intermROperands[1],
                    &intermROperands[2]);

    clmGEN_CODE_ELSE(Compiler,  /*IF_5 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
      /* for x< 0, erfc(x) = 2 - erfc(-x) */
      status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[4],
                    &intermROperands[1],
                    &intermROperands[2]);


      status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_SUB_RTZ,
                    IOperand,
                    &twoROperand,
                    &intermROperands[4]);


    clmGEN_CODE_ENDIF(Compiler,  /*IF_5 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler,  /*IF_4 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);


   clmGEN_CODE_ENDIF(Compiler,  /*IF_2 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);


   clmGEN_CODE_ENDIF(Compiler,  /*IF_1 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler,  /*IF_0 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

OnError:
   return status;

}



static gceSTATUS
_GenErfCode(
    IN cloCOMPILER Compiler,
    IN cloCODE_GENERATOR CodeGenerator,
    IN cloIR_POLYNARY_EXPR PolynaryExpr,
    IN gctUINT OperandCount,
    IN clsGEN_CODE_PARAMETERS * OperandsParameters,
    IN clsIOPERAND * IOperand
    )
{
    gceSTATUS    status;
    clsIOPERAND intermIOperands[10];
    clsROPERAND intermROperands[10], fourROperand, zeroROperand, oneROperand, infROperand, unsignROperand ;
    clsROPERAND coef0To2ROperands[9], coefOutsideROperands[9], twoROperand, threeROperand, signROperand;
    int i;
    float erfCoef0To2[] = { /*Approximation  Erf(x)/x directly for |x|<2.0, with {1, x^2, x^4...}*/
          1.128379106521606400000000f,
         -0.376122981309890750000000f,
          0.112815782427787780000000f,
         -0.026810081675648689000000f,
          0.005151107441633939700000f,
         -0.000800092413555830720000f,
          0.000095335948572028428000f,
         -0.000007613575689902063500f,
          0.000000296365357144168230f,
        };

    float erfCoef2To4Apprx[] = {  /*Approximation  Erf(x) directly for 2<x<4.0, with {1, x-3, (x-3)^2...}*/
                              0.999978005886077880000000f,
                              0.000139544092235155400000f,
                             -0.000420993659645318980000f,
                              0.000785408192314207550000f,
                             -0.001021939329802990000000f,
                              0.001026878948323428600000f,
                             -0.000792982114944607020000f,
                              0.000387110601877793670000f,
                             -0.000080945377703756094000f,
    };


    /* Verify the arguments. */
    clmVERIFY_OBJECT(Compiler, clvOBJ_COMPILER);
    clmVERIFY_IR_OBJECT(PolynaryExpr, clvIR_POLYNARY_EXPR);
    gcmASSERT(OperandCount == 1);
    gcmASSERT(OperandsParameters);
    gcmASSERT(IOperand);

    for(i = 0; i<9; i++){
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&coef0To2ROperands[i],
                                  clmGenCodeDataType(T_FLOAT),
                                  (gctFLOAT)erfCoef0To2[i]);
    }

    for(i = 0; i<9; i++){
        clsROPERAND_InitializeFloatOrVecOrMatConstant(&coefOutsideROperands[i],
                                  clmGenCodeDataType(T_FLOAT),
                                  (gctFLOAT)erfCoef2To4Apprx[i]);
    }


    for(i = 0; i<10; i++){
        clsIOPERAND_New(Compiler, &intermIOperands[i],OperandsParameters[0].rOperands[0].dataType);
        clsROPERAND_InitializeUsingIOperand(&intermROperands[i], &intermIOperands[i]);
    }

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&zeroROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)0.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&oneROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)1.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&twoROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)2.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&threeROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT)3.0);

    clsROPERAND_InitializeFloatOrVecOrMatConstant(&fourROperand,
                              clmGenCodeDataType(T_FLOAT),
                              (gctFLOAT) 4.0);


    clsROPERAND_InitializeIntOrIVecConstant(&unsignROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x7fffffff);

    clsROPERAND_InitializeIntOrIVecConstant(&infROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x7f800000);

    clsROPERAND_InitializeIntOrIVecConstant(&signROperand,
                                            clmGenCodeDataType(T_INT),
                                            (gctINT) 0x80000000);

   intermIOperands[0].dataType.elementType = clvTYPE_INT;
   intermROperands[0].dataType.elementType = clvTYPE_INT;
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[0],
                        &OperandsParameters[0].rOperands[0],
                        &unsignROperand);
   intermIOperands[1].dataType.elementType = clvTYPE_INT;
   intermROperands[1].dataType.elementType = clvTYPE_INT;
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_AND_BITWISE,
                        &intermIOperands[1],
                        &OperandsParameters[0].rOperands[0],
                        &signROperand);

   clmGEN_CODE_IF(Compiler,  /*IF_0 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &intermROperands[0],
             clvCONDITION_GREATER_THAN,
             &infROperand);

   /*Nan input, nan output */
    status = clGenGenericCode1(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_ASSIGN,
                IOperand,
                &OperandsParameters[0].rOperands[0]);

    clmGEN_CODE_ELSE(Compiler,  /*IF_0 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);
    /*Not Nan case */
   intermIOperands[0].dataType.elementType = clvTYPE_FLOAT;
   intermROperands[0].dataType.elementType = clvTYPE_FLOAT;

   clmGEN_CODE_IF(Compiler,  /*IF_1 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &intermROperands[0],
             clvCONDITION_GREATER_THAN_EQUAL,
             &fourROperand);
   /*|x| >= 4, efr(x) = 1.0, since single float cannot distinguish the very close to 1 value */

    IOperand->dataType.elementType = clvTYPE_INT;
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_OR_BITWISE,
                        IOperand,
                        &oneROperand,
                        &intermROperands[1]);
    IOperand->dataType.elementType = clvTYPE_FLOAT;

   clmGEN_CODE_ELSE(Compiler,  /*IF_1 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_IF(Compiler,  /*IF_2 */
             CodeGenerator,
             PolynaryExpr->exprBase.base.lineNo,
             PolynaryExpr->exprBase.base.stringNo,
             &intermROperands[0],
             clvCONDITION_LESS_THAN_EQUAL,
             &twoROperand);
   /*|x|<2.0 efrc(x)/x approximated with 1, x^2.... */

   /*Get x^2 */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[4],
                &OperandsParameters[0].rOperands[0],
                &OperandsParameters[0].rOperands[0]);

    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[2],
                &coef0To2ROperands[8],
                &intermROperands[4]);
    for(i = 7; i>=0; i--){
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[3],
                    &coef0To2ROperands[i],
                    &intermROperands[2]);
        /*i == 0, multiply x, not x^2 */
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    i == 0? IOperand : &intermIOperands[2],
                    &intermROperands[3],
                    i == 0? &OperandsParameters[0].rOperands[0]: &intermROperands[4]);
    }


   clmGEN_CODE_ELSE(Compiler,  /*IF_2 */
                   CodeGenerator,
                   PolynaryExpr->exprBase.base.lineNo,
                   PolynaryExpr->exprBase.base.stringNo);

   /*Now we have 2<|x|<4 */
   /*Get |x| - 3 */
    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_SUB_RTZ,
                &intermIOperands[4],
                &intermROperands[0],
                &threeROperand);


    status = clGenArithmeticExprCode(Compiler,
                PolynaryExpr->exprBase.base.lineNo,
                PolynaryExpr->exprBase.base.stringNo,
                clvOPCODE_MUL_RTZ,
                &intermIOperands[2],
                &coefOutsideROperands[8],
                &intermROperands[4]);
    for(i = 7; i>=0; i--){
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_ADD_RTZ,
                    &intermIOperands[3],
                    &coefOutsideROperands[i],
                    &intermROperands[2]);
        if(i > 0)
        status = clGenArithmeticExprCode(Compiler,
                    PolynaryExpr->exprBase.base.lineNo,
                    PolynaryExpr->exprBase.base.stringNo,
                    clvOPCODE_MUL_RTZ,
                    &intermIOperands[2],
                    &intermROperands[3],
                    &intermROperands[4]);
    }

    IOperand->dataType.elementType = clvTYPE_INT;
    /*Set the sign, use r3, the last add result */
    status = clGenArithmeticExprCode(Compiler,
                        PolynaryExpr->exprBase.base.lineNo,
                        PolynaryExpr->exprBase.base.stringNo,
                        clvOPCODE_OR_BITWISE,
                        IOperand,
                        &intermROperands[3],
                        &intermROperands[1]);
    IOperand->dataType.elementType = clvTYPE_FLOAT;


   clmGEN_CODE_ENDIF(Compiler,  /*IF_2 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);


   clmGEN_CODE_ENDIF(Compiler,  /*IF_1 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

   clmGEN_CODE_ENDIF(Compiler,  /*IF_0 */
                 CodeGenerator,
                 PolynaryExpr->exprBase.base.lineNo,
                 PolynaryExpr->exprBase.base.stringNo);

OnError:
   return status;

}
#endif /* __gc_cl_built_ins_math_h_ */
