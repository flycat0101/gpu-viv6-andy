/****************************************************************************
*
*    Copyright (c) 2005 - 2018 by Vivante Corp.  All rights reserved.
*
*    The material in this file is confidential and contains trade secrets
*    of Vivante Corporation. This is proprietary information owned by
*    Vivante Corporation. No part of this work may be disclosed,
*    reproduced, copied, transmitted, or used in any way for any purpose,
*    without the express written permission of Vivante Corporation.
*
*****************************************************************************/


/*
**  Common gcSL compiler module.
*/

#include "gc_vsc.h"

#if gcdENABLE_3D

/* Zone used for header/footer. */
#define _GC_OBJ_ZONE    gcvZONE_COMPILER
#define MAX_BLOCK_SIZE   0x20000     /* max block size 128 KB */
#define MAX_BLOCK_NUM    1000

gctGLSLCompiler gcGLSLCompiler = gcvNULL;
gctCLCompiler gcCLCompiler = gcvNULL;

extern gctUINT8
_Enable2SwizzleWShift(
    IN gctUINT32 Enable
    );

extern gcUNIFORM
_FindUniformBlockMember(
    IN gcSHADER Shader,
    IN gcUNIFORM BlockUniform,
    IN gctUINT BlockIndex,
    IN gctINT Offset,
    OUT gctUINT16 *Index,
    OUT gctINT *StartChannel
    );

extern gctBOOL
_isHWRegisterAllocated(
    IN gcSHADER     Shader
    );

const gcSL_OPCODE_ATTR gcvOpcodeAttr[] =
{
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_NOP, 0x00 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_MOV, 0x01 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_SAT, 0x02 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_DP3, 0x03 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_DP4, 0x04 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ABS, 0x05 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_JMP, 0x06 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_ADD, 0x07 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_MUL, 0x08 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_RCP, 0x09 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_SUB, 0x0A */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_KILL, 0x0B */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_TEXLD, 0x0C */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_CALL, 0x0D */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_RET, 0x0E */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_NORM, 0x0F */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_MAX, 0x10 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_MIN, 0x11 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_POW, 0x12 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_RSQ, 0x13 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_LOG, 0x14 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_FRAC, 0x15 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_FLOOR, 0x16 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_CEIL, 0x17 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_CROSS, 0x18 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_TEXLDPROJ, 0x19 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_TEXBIAS, 0x1A */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_TEXGRAD, 0x1B */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_TEXLOD, 0x1C */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_SIN, 0x1D */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_COS, 0x1E */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_TAN, 0x1F */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_EXP, 0x20 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_LP      }, /* gcSL_SIGN, 0x21 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_STEP, 0x22 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_SQRT, 0x23 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ACOS, 0x24 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ASIN, 0x25 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ATAN, 0x26 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_SET, 0x27 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_DSX, 0x28 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_DSY, 0x29 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_FWIDTH, 0x2A */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_DIV, 0x2B */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_MOD, 0x2C */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_AND_BITWISE, 0x2D */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_OR_BITWISE, 0x2E */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_XOR_BITWISE, 0x2F */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_NOT_BITWISE, 0x30 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_LSHIFT, 0x31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_RSHIFT, 0x32 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ROTATE, 0x33 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_BITSEL, 0x34 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_LEADZERO, 0x35 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_LOAD, 0x36 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_STORE, 0x37 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_BARRIER, 0x38 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_STORE1, 0x39 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ATOMADD, 0x3A */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ATOMSUB, 0x3B */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ATOMXCHG, 0x3C */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ATOMCMPXCHG, 0x3D */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ATOMMIN, 0x3E */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ATOMMAX, 0x3F */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ATOMOR, 0x40 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ATOMAND, 0x41 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_ATOMXOR, 0x42 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_TEXLDPCF, 0x43 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_TEXLDPCFPROJ, 0x44 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_TEXLODQ, 0x45  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_FLUSH, 0x46  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_JMP_ANY, 0x47  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_IGNORE  }, /* gcSL_BITRANGE, 0x48  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_IGNORE  }, /* gcSL_BITRANGE1, 0x49  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_BITEXTRACT, 0x4A  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_BITINSERT, 0x4B  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_LP      }, /* gcSL_FINDLSB, 0x4C  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_LP      }, /* gcSL_FINDMSB, 0x4D  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_IMAGE_OFFSET, 0x4E  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HP      }, /* gcSL_IMAGE_ADDR, 0x4F  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_SINPI, 0x50 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_COSPI, 0x51 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_TANPI, 0x52 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_ADDLO, 0x53  Float only. */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_MULLO, 0x54  Float only. */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_CONV, 0x55 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_GETEXP, 0x56 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_GETMANT, 0x57 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_MULHI, 0x58  Integer only. */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AS      }, /* gcSL_CMP, 0x59 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_I2F, 0x5A */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_F2I, 0x5B */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_ADDSAT, 0x5C  Integer only. */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_SUBSAT, 0x5D  Integer only. */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_MULSAT, 0x5E  Integer only. */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_DP2, 0x5F */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_UNPACK, 0x60 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_IMAGE_WR, 0x61 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_SAMPLER_ADD, 0x62 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_MOVA, 0x63, HW MOVAR/MOVF/MOVI, VIRCG only */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_IMAGE_RD, 0x64 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_IMAGE_SAMPLER, 0x65 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_NORM_MUL, 0x66  VIRCG only */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_NORM_DP2, 0x67  VIRCG only */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_NORM_DP3, 0x68  VIRCG only */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_NORM_DP4, 0x69  VIRCG only */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_PRE_DIV, 0x6A  VIRCG only */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_PRE_LOG2, 0x6B  VIRCG only */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_TEXGATHER, 0x6C  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_TEXFETCH_MS, 0x6D  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_LP      }, /* gcSL_POPCOUNT, 0x6E  ES31(OCL1.2)*/
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_BIT_REVERSAL, 0x6F  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_BYTE_REVERSAL, 0x70  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_TEXPCF, 0x71  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_UCARRY, 0x72  ES31 UCARRY is a condition op, while gcSL
                                                                                                                         has not enough bits to represent more */

    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_TEXU, 0x73  paired with gcSL_TEXLD to implement HW texld_u_plain */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_TEXU_LOD, 0x74  paired with gcSL_TEXLD to implement HW texld_u_lod */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_MEM_BARRIER, 0x75  Memory Barrier. */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_SAMPLER_ASSIGN, 0x76  Sampler assignment as a parameter, only exist on FE. */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_GET_SAMPLER_IDX,0x77  Get Image/Sampler index */

    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_IMAGE_RD_3D, 0x78 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_IMAGE_WR_3D, 0x79 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_CLAMP0MAX, 0x7A clamp0max dest, value, max */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_FMA_MUL, 0x7B FMA first part: MUL */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_FMA_ADD, 0x7C FMA second part: ADD */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_ATTR_ST, 0x7D ATTR_ST attribute(0+temp(1).x), InvocationIndex, val */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_ATTR_LD, 0x7E ATTR_LD dest, attribute(0+temp(1).x), InvocationIndex */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_EMIT_VERTEX, 0x7F For function "EmitVertex" */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_INVALID }, /* gcSL_END_PRIMITIVE, 0x80 For function "EndPrimitive" */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HP      }, /* gcSL_ARCTRIG0, 0x81 For triangle functions */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HP      }, /* gcSL_ARCTRIG1, 0x82 For triangle functions */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_MUL_Z, 0x83 special mul, resulting in 0 from inf * 0 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_NEG, 0x84 neg(a) is similar to (0 - (a)) */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_LONGLO, 0x85 get the lower 4 bytes of a long/ulong integer */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_LONGHI, 0x86 get the upper 4 bytes of a long/ulong integer */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_MOV_LONG, 0x87 mov two 4 byte integers to the lower/upper 4 bytes of a long/ulong integer */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HIA     }, /* gcSL_MADSAT, 0x88 mad with saturation for integer only */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_COPY, 0x89 copy register contents */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HP      }, /* gcSL_LOAD_L, 0x8A  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HP      }, /* gcSL_STORE_L, 0x8B  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_HP      }, /* gcSL_IMAGE_ADDR_3D, 0x8C  ES31 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_MP      }, /* gcSL_GET_SAMPLER_LMM,0x8D Get sampler's lodminmax */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_MP      }, /* gcSL_GET_SAMPLER_LBS,0x8E Get sampler's levelbasesize */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_TEXLD_U, 0x8F */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_PARAM_CHAIN, 0x90 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_INTRINSIC, 0x91 */
    {_gcSL_OPCODE_ATTR_RESULT_PRECISION_AF      }, /* gcSL_INTRINSIC_ST, 0x92 */
};
char _checkOpAttr_size[sizeof(gcvOpcodeAttr)/sizeof(gcvOpcodeAttr[0]) == gcSL_MAXOPCODE];

const gcSHADER_TYPEINFO gcvShaderTypeInfo[] =
{
    /*  type        components  packedComponents rows  rowType          componentType          kind           name  */
    { gcSHADER_FLOAT_X1, 1, 1, 1, gcSHADER_FLOAT_X1, gcSHADER_FLOAT_X1, gceTK_FLOAT, "float", gcvFALSE},
    { gcSHADER_FLOAT_X2, 2, 2, 1, gcSHADER_FLOAT_X2, gcSHADER_FLOAT_X1, gceTK_FLOAT, "float2", gcvFALSE},
    { gcSHADER_FLOAT_X3, 3, 3, 1, gcSHADER_FLOAT_X3, gcSHADER_FLOAT_X1, gceTK_FLOAT, "float3", gcvFALSE},
    { gcSHADER_FLOAT_X4, 4, 4, 1, gcSHADER_FLOAT_X4, gcSHADER_FLOAT_X1, gceTK_FLOAT, "float4", gcvFALSE},
    { gcSHADER_FLOAT_2X2, 2, 2, 2, gcSHADER_FLOAT_X2, gcSHADER_FLOAT_X1, gceTK_FLOAT, "matrix2x2", gcvFALSE},
    { gcSHADER_FLOAT_3X3, 3, 3, 3, gcSHADER_FLOAT_X3, gcSHADER_FLOAT_X1, gceTK_FLOAT, "matrix3x3", gcvFALSE},
    { gcSHADER_FLOAT_4X4, 4, 4, 4, gcSHADER_FLOAT_X4, gcSHADER_FLOAT_X1, gceTK_FLOAT, "matrix4x4", gcvFALSE},
    { gcSHADER_BOOLEAN_X1, 1, 1, 1, gcSHADER_BOOLEAN_X1, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool", gcvFALSE},
    { gcSHADER_BOOLEAN_X2, 2, 2, 1, gcSHADER_BOOLEAN_X2, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool2", gcvFALSE},
    { gcSHADER_BOOLEAN_X3, 3, 3, 1, gcSHADER_BOOLEAN_X3, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool3", gcvFALSE},
    { gcSHADER_BOOLEAN_X4, 4, 4, 1, gcSHADER_BOOLEAN_X4, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool4", gcvFALSE},
    { gcSHADER_INTEGER_X1, 1, 1, 1, gcSHADER_INTEGER_X1, gcSHADER_INTEGER_X1, gceTK_INT, "int", gcvFALSE},
    { gcSHADER_INTEGER_X2, 2, 2, 1, gcSHADER_INTEGER_X2, gcSHADER_INTEGER_X1, gceTK_INT, "int2", gcvFALSE},
    { gcSHADER_INTEGER_X3, 3, 3, 1, gcSHADER_INTEGER_X3, gcSHADER_INTEGER_X1, gceTK_INT, "int3", gcvFALSE},
    { gcSHADER_INTEGER_X4, 4, 4, 1, gcSHADER_INTEGER_X4, gcSHADER_INTEGER_X1, gceTK_INT, "int4", gcvFALSE},
    { gcSHADER_SAMPLER_1D, 1, 1, 1, gcSHADER_SAMPLER_1D, gcSHADER_SAMPLER_1D, gceTK_SAMPLER, "sampler1D", gcvFALSE},
    { gcSHADER_SAMPLER_2D, 1, 1, 1, gcSHADER_SAMPLER_2D, gcSHADER_SAMPLER_2D, gceTK_SAMPLER, "sampler2D", gcvFALSE},
    { gcSHADER_SAMPLER_3D, 1, 1, 1, gcSHADER_SAMPLER_3D, gcSHADER_SAMPLER_3D, gceTK_SAMPLER, "sampler3D", gcvFALSE},
    { gcSHADER_SAMPLER_CUBIC, 1, 1, 1, gcSHADER_SAMPLER_CUBIC,gcSHADER_SAMPLER_CUBIC, gceTK_SAMPLER, "samplerCubic", gcvFALSE},
    { gcSHADER_FIXED_X1, 1, 1, 1, gcSHADER_FIXED_X1, gcSHADER_FIXED_X1, gceTK_FIXED, "fixed", gcvFALSE},
    { gcSHADER_FIXED_X2, 2, 2, 1, gcSHADER_FIXED_X2, gcSHADER_FIXED_X1, gceTK_FIXED, "fixed2", gcvFALSE},
    { gcSHADER_FIXED_X3, 3, 3, 1, gcSHADER_FIXED_X3, gcSHADER_FIXED_X1, gceTK_FIXED, "fixed3", gcvFALSE},
    { gcSHADER_FIXED_X4, 4, 4, 1, gcSHADER_FIXED_X4, gcSHADER_FIXED_X1, gceTK_FIXED, "fixed4", gcvFALSE},
    { gcSHADER_IMAGE_2D, 4, 4, 1, gcSHADER_IMAGE_2D, gcSHADER_IMAGE_2D, gceTK_IMAGE, "image2d_t", gcvFALSE},
    { gcSHADER_IMAGE_3D, 4, 4, 1, gcSHADER_IMAGE_3D, gcSHADER_IMAGE_3D, gceTK_IMAGE, "image3d_t", gcvFALSE},
    { gcSHADER_SAMPLER, 1, 1, 1, gcSHADER_SAMPLER, gcSHADER_SAMPLER, gceTK_SAMPLER, "sampler_t", gcvFALSE},
    { gcSHADER_FLOAT_2X3, 3, 3, 2, gcSHADER_FLOAT_X3, gcSHADER_FLOAT_X1, gceTK_FLOAT, "matrix2x3", gcvFALSE},
    { gcSHADER_FLOAT_2X4, 4, 4, 2, gcSHADER_FLOAT_X4, gcSHADER_FLOAT_X1, gceTK_FLOAT, "matrix2x4", gcvFALSE},
    { gcSHADER_FLOAT_3X2, 2, 2, 3, gcSHADER_FLOAT_X2, gcSHADER_FLOAT_X1, gceTK_FLOAT, "matrix3x2", gcvFALSE},
    { gcSHADER_FLOAT_3X4, 4, 4, 3, gcSHADER_FLOAT_X4, gcSHADER_FLOAT_X1, gceTK_FLOAT, "matrix3x4", gcvFALSE},
    { gcSHADER_FLOAT_4X2, 2, 2, 4, gcSHADER_FLOAT_X2, gcSHADER_FLOAT_X1, gceTK_FLOAT, "matrix4x2", gcvFALSE},
    { gcSHADER_FLOAT_4X3, 3, 3, 4, gcSHADER_FLOAT_X3, gcSHADER_FLOAT_X1, gceTK_FLOAT, "matrix4x3", gcvFALSE},
    { gcSHADER_ISAMPLER_2D, 1, 1, 1, gcSHADER_ISAMPLER_2D, gcSHADER_ISAMPLER_2D, gceTK_SAMPLER, "isampler2D", gcvFALSE},
    { gcSHADER_ISAMPLER_3D, 1, 1, 1, gcSHADER_ISAMPLER_3D, gcSHADER_ISAMPLER_3D, gceTK_SAMPLER, "isampler3D", gcvFALSE},
    { gcSHADER_ISAMPLER_CUBIC, 1, 1, 1, gcSHADER_ISAMPLER_CUBIC,gcSHADER_ISAMPLER_CUBIC,gceTK_SAMPLER, "isamplerCubic", gcvFALSE},
    { gcSHADER_USAMPLER_2D, 1, 1, 1, gcSHADER_USAMPLER_2D, gcSHADER_USAMPLER_2D, gceTK_SAMPLER, "usampler2D", gcvFALSE},
    { gcSHADER_USAMPLER_3D, 1, 1, 1, gcSHADER_USAMPLER_3D, gcSHADER_USAMPLER_3D, gceTK_SAMPLER, "usampler3D", gcvFALSE},
    { gcSHADER_USAMPLER_CUBIC, 1, 1, 1, gcSHADER_USAMPLER_CUBIC, gcSHADER_USAMPLER_CUBIC,
                                                           gceTK_SAMPLER, "usamplerCubic", gcvFALSE},
    { gcSHADER_SAMPLER_EXTERNAL_OES, 1, 1, 1, gcSHADER_SAMPLER_EXTERNAL_OES, gcSHADER_SAMPLER_EXTERNAL_OES,
                                                           gceTK_SAMPLER, "samplerExternalOES", gcvFALSE},
    { gcSHADER_UINT_X1, 1, 1, 1, gcSHADER_UINT_X1, gcSHADER_UINT_X1, gceTK_UINT, "uint", gcvFALSE},
    { gcSHADER_UINT_X2, 2, 2, 1, gcSHADER_UINT_X2, gcSHADER_UINT_X1, gceTK_UINT, "uint2", gcvFALSE},
    { gcSHADER_UINT_X3, 3, 3, 1, gcSHADER_UINT_X3, gcSHADER_UINT_X1, gceTK_UINT, "uint3", gcvFALSE},
    { gcSHADER_UINT_X4, 4, 4, 1, gcSHADER_UINT_X4, gcSHADER_UINT_X1, gceTK_UINT, "uint4", gcvFALSE},
    { gcSHADER_SAMPLER_2D_SHADOW, 1, 1, 1, gcSHADER_SAMPLER_2D_SHADOW,gcSHADER_SAMPLER_2D_SHADOW,gceTK_SAMPLER, "sampler2DShadow", gcvFALSE},
    { gcSHADER_SAMPLER_CUBE_SHADOW, 1, 1, 1, gcSHADER_SAMPLER_CUBE_SHADOW,gcSHADER_SAMPLER_CUBE_SHADOW,gceTK_SAMPLER, "samplerCubeShadow", gcvFALSE},

    { gcSHADER_SAMPLER_1D_ARRAY, 1, 1, 1, gcSHADER_SAMPLER_1D_ARRAY, gcSHADER_SAMPLER_1D_ARRAY, gceTK_SAMPLER, "sampler1DArray", gcvFALSE},
    { gcSHADER_SAMPLER_1D_ARRAY_SHADOW, 1, 1, 1, gcSHADER_SAMPLER_1D_ARRAY_SHADOW, gcSHADER_SAMPLER_1D_ARRAY_SHADOW, gceTK_SAMPLER, "sampler1DArrayShadow", gcvFALSE},
    { gcSHADER_SAMPLER_2D_ARRAY, 1, 1, 1, gcSHADER_SAMPLER_2D_ARRAY, gcSHADER_SAMPLER_2D_ARRAY, gceTK_SAMPLER, "sampler2DArray", gcvFALSE},
    { gcSHADER_ISAMPLER_2D_ARRAY, 1, 1, 1, gcSHADER_ISAMPLER_2D_ARRAY, gcSHADER_ISAMPLER_2D_ARRAY, gceTK_SAMPLER, "isampler2DArray", gcvFALSE},
    { gcSHADER_USAMPLER_2D_ARRAY, 1, 1, 1, gcSHADER_USAMPLER_2D_ARRAY, gcSHADER_USAMPLER_2D_ARRAY, gceTK_SAMPLER, "usampler2DArray", gcvFALSE},
    { gcSHADER_SAMPLER_2D_ARRAY_SHADOW, 1, 1, 1, gcSHADER_SAMPLER_2D_ARRAY_SHADOW, gcSHADER_SAMPLER_2D_ARRAY_SHADOW, gceTK_SAMPLER, "sampler2DArrayShadow", gcvFALSE},

    { gcSHADER_SAMPLER_2D_MS, 1, 1, 1, gcSHADER_SAMPLER_2D_MS, gcSHADER_SAMPLER_2D_MS, gceTK_SAMPLER, "sampler2DMS", gcvFALSE},
    { gcSHADER_ISAMPLER_2D_MS, 1, 1, 1, gcSHADER_ISAMPLER_2D_MS, gcSHADER_ISAMPLER_2D_MS, gceTK_SAMPLER, "isampler2DMS", gcvFALSE},
    { gcSHADER_USAMPLER_2D_MS, 1, 1, 1, gcSHADER_USAMPLER_2D_MS, gcSHADER_USAMPLER_2D_MS, gceTK_SAMPLER, "usampler2DMS", gcvFALSE},
    { gcSHADER_SAMPLER_2D_MS_ARRAY, 1, 1, 1, gcSHADER_SAMPLER_2D_MS_ARRAY, gcSHADER_SAMPLER_2D_MS_ARRAY, gceTK_SAMPLER, "sampler2DMSArray", gcvFALSE},
    { gcSHADER_ISAMPLER_2D_MS_ARRAY, 1, 1, 1, gcSHADER_ISAMPLER_2D_MS_ARRAY, gcSHADER_ISAMPLER_2D_MS_ARRAY, gceTK_SAMPLER, "isampler2DMSArray", gcvFALSE},
    { gcSHADER_USAMPLER_2D_MS_ARRAY, 1, 1, 1, gcSHADER_USAMPLER_2D_MS_ARRAY, gcSHADER_USAMPLER_2D_MS_ARRAY, gceTK_SAMPLER, "usampler2DMSArray", gcvFALSE},

    { gcSHADER_IIMAGE_2D, 4, 4, 1, gcSHADER_IIMAGE_2D, gcSHADER_IIMAGE_2D, gceTK_IMAGE, "iimage2D", gcvFALSE},
    { gcSHADER_UIMAGE_2D, 4, 4, 1, gcSHADER_UIMAGE_2D, gcSHADER_UIMAGE_2D, gceTK_IMAGE, "uimage2D", gcvFALSE},
    { gcSHADER_IIMAGE_3D, 4, 4, 1, gcSHADER_IIMAGE_3D, gcSHADER_IIMAGE_3D, gceTK_IMAGE, "iimage3D", gcvFALSE},
    { gcSHADER_UIMAGE_3D, 4, 4, 1, gcSHADER_UIMAGE_3D, gcSHADER_UIMAGE_3D, gceTK_IMAGE, "uimage3D", gcvFALSE},
    { gcSHADER_IMAGE_CUBE, 4, 4, 1, gcSHADER_IMAGE_CUBE, gcSHADER_IMAGE_CUBE, gceTK_IMAGE, "imageCube", gcvFALSE},
    { gcSHADER_IIMAGE_CUBE, 4, 4, 1, gcSHADER_IIMAGE_CUBE, gcSHADER_IIMAGE_CUBE, gceTK_IMAGE, "iimageCube", gcvFALSE},
    { gcSHADER_UIMAGE_CUBE, 4, 4, 1, gcSHADER_UIMAGE_CUBE, gcSHADER_UIMAGE_CUBE, gceTK_IMAGE, "uimageCube", gcvFALSE},
    { gcSHADER_IMAGE_2D_ARRAY, 4, 4, 1, gcSHADER_IMAGE_2D_ARRAY, gcSHADER_IMAGE_2D_ARRAY, gceTK_IMAGE, "image2dArray", gcvFALSE},
    { gcSHADER_IIMAGE_2D_ARRAY, 4, 4, 1, gcSHADER_IIMAGE_2D_ARRAY, gcSHADER_IIMAGE_2D_ARRAY, gceTK_IMAGE, "iimage2dArray", gcvFALSE},
    { gcSHADER_UIMAGE_2D_ARRAY, 4, 4, 1, gcSHADER_UIMAGE_2D_ARRAY, gcSHADER_UIMAGE_2D_ARRAY, gceTK_IMAGE, "uimage2dArray", gcvFALSE},

    { gcSHADER_ATOMIC_UINT, 1, 1, 1, gcSHADER_ATOMIC_UINT, gcSHADER_ATOMIC_UINT, gceTK_ATOMIC, "atomic_uint", gcvFALSE},

    { gcSHADER_IMAGE_1D, 4, 4, 1, gcSHADER_IMAGE_1D, gcSHADER_IMAGE_1D, gceTK_IMAGE, "image1d_t", gcvFALSE},
    { gcSHADER_IMAGE_1D_ARRAY, 4, 4, 1, gcSHADER_IMAGE_1D_ARRAY, gcSHADER_IMAGE_1D_ARRAY, gceTK_IMAGE, "image1d_array_t", gcvFALSE},
    { gcSHADER_IMAGE_1D_BUFFER, 4, 4, 1, gcSHADER_IMAGE_1D_BUFFER, gcSHADER_IMAGE_1D_BUFFER, gceTK_IMAGE, "image1d_buffer_t", gcvFALSE},

    { gcSHADER_SAMPLER_CUBEMAP_ARRAY, 1, 1, 1, gcSHADER_SAMPLER_CUBEMAP_ARRAY, gcSHADER_SAMPLER_CUBEMAP_ARRAY, gceTK_SAMPLER, "samplerCubeArray", gcvFALSE},
    { gcSHADER_SAMPLER_CUBEMAP_ARRAY_SHADOW, 1, 1, 1, gcSHADER_SAMPLER_CUBEMAP_ARRAY_SHADOW, gcSHADER_SAMPLER_CUBEMAP_ARRAY_SHADOW, gceTK_SAMPLER, "samplerCubeArrayShadow", gcvFALSE},
    { gcSHADER_ISAMPLER_CUBEMAP_ARRAY, 1, 1, 1, gcSHADER_ISAMPLER_CUBEMAP_ARRAY, gcSHADER_ISAMPLER_CUBEMAP_ARRAY, gceTK_SAMPLER, "isamplerCubeArray", gcvFALSE},
    { gcSHADER_USAMPLER_CUBEMAP_ARRAY, 1, 1, 1, gcSHADER_USAMPLER_CUBEMAP_ARRAY, gcSHADER_USAMPLER_CUBEMAP_ARRAY, gceTK_SAMPLER, "usamplerCubeArray", gcvFALSE},
    { gcSHADER_IMAGE_CUBEMAP_ARRAY, 4, 4, 1, gcSHADER_IMAGE_CUBEMAP_ARRAY, gcSHADER_IMAGE_CUBEMAP_ARRAY, gceTK_IMAGE, "imageCubeArray", gcvFALSE},
    { gcSHADER_IIMAGE_CUBEMAP_ARRAY, 4, 4, 1, gcSHADER_IIMAGE_CUBEMAP_ARRAY, gcSHADER_IIMAGE_CUBEMAP_ARRAY, gceTK_IMAGE, "iimageCubeArray", gcvFALSE},
    { gcSHADER_UIMAGE_CUBEMAP_ARRAY, 4, 4, 1, gcSHADER_UIMAGE_CUBEMAP_ARRAY, gcSHADER_UIMAGE_CUBEMAP_ARRAY, gceTK_IMAGE, "uimageCubeArray", gcvFALSE},

    { gcSHADER_INT64_X1, 1, 1, 2, gcSHADER_INT64_X1, gcSHADER_INT64_X1, gceTK_INT64, "long", gcvFALSE},
    { gcSHADER_INT64_X2, 2, 2, 2, gcSHADER_INT64_X2, gcSHADER_INT64_X1, gceTK_INT64, "long2", gcvFALSE},
    { gcSHADER_INT64_X3, 3, 3, 2, gcSHADER_INT64_X3, gcSHADER_INT64_X1, gceTK_INT64, "long3", gcvFALSE},
    { gcSHADER_INT64_X4, 4, 4, 2, gcSHADER_INT64_X4, gcSHADER_INT64_X1, gceTK_INT64, "long4", gcvFALSE},

    { gcSHADER_UINT64_X1, 1, 1, 2, gcSHADER_UINT64_X1, gcSHADER_UINT64_X1, gceTK_UINT64, "ulong", gcvFALSE},
    { gcSHADER_UINT64_X2, 2, 2, 2, gcSHADER_UINT64_X2, gcSHADER_UINT64_X1, gceTK_UINT64, "ulong2", gcvFALSE},
    { gcSHADER_UINT64_X3, 3, 3, 2, gcSHADER_UINT64_X3, gcSHADER_UINT64_X1, gceTK_UINT64, "ulong3", gcvFALSE},
    { gcSHADER_UINT64_X4, 4, 4, 2, gcSHADER_UINT64_X4, gcSHADER_UINT64_X1, gceTK_UINT64, "ulong4", gcvFALSE},

    { gcSHADER_SAMPLER_BUFFER, 4, 4, 1, gcSHADER_SAMPLER_BUFFER, gcSHADER_SAMPLER_BUFFER, gceTK_SAMPLER, "samplerBuffer", gcvFALSE},
    { gcSHADER_ISAMPLER_BUFFER, 4, 4, 1, gcSHADER_ISAMPLER_BUFFER, gcSHADER_ISAMPLER_BUFFER, gceTK_SAMPLER, "isamplerBuffer", gcvFALSE},
    { gcSHADER_USAMPLER_BUFFER, 4, 4, 1, gcSHADER_USAMPLER_BUFFER, gcSHADER_USAMPLER_BUFFER, gceTK_SAMPLER, "usamplerBuffer", gcvFALSE},
    { gcSHADER_IMAGE_BUFFER, 4, 4, 1, gcSHADER_IMAGE_BUFFER, gcSHADER_IMAGE_BUFFER, gceTK_IMAGE, "imageBuffer", gcvFALSE},
    { gcSHADER_IIMAGE_BUFFER, 4, 4, 1, gcSHADER_IIMAGE_BUFFER, gcSHADER_IIMAGE_BUFFER, gceTK_IMAGE, "iimageBuffer", gcvFALSE},
    { gcSHADER_UIMAGE_BUFFER, 4, 4, 1, gcSHADER_UIMAGE_BUFFER, gcSHADER_UIMAGE_BUFFER, gceTK_IMAGE, "uimageBuffer", gcvFALSE},
    /* float16 */
    { gcSHADER_FLOAT16_X1, 1, 1, 1, gcSHADER_FLOAT16_X1, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half", gcvFALSE},
    { gcSHADER_FLOAT16_X2, 2, 2, 1, gcSHADER_FLOAT16_X2, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half2", gcvFALSE},
    { gcSHADER_FLOAT16_X3, 3, 3, 1, gcSHADER_FLOAT16_X3, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half3", gcvFALSE},
    { gcSHADER_FLOAT16_X4, 4, 4, 1, gcSHADER_FLOAT16_X4, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half4", gcvFALSE},
    { gcSHADER_FLOAT16_X8, 4, 4, 2, gcSHADER_FLOAT16_X8, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half8", gcvFALSE},
    { gcSHADER_FLOAT16_X16, 4, 4, 4, gcSHADER_FLOAT16_X16, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half16", gcvFALSE},
    { gcSHADER_FLOAT16_X32, 4, 4, 8, gcSHADER_FLOAT16_X32, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half32", gcvFALSE},

    /*  boolean  */
    { gcSHADER_BOOLEAN_X8, 4, 4, 2, gcSHADER_BOOLEAN_X8, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool8", gcvFALSE},
    { gcSHADER_BOOLEAN_X16, 4, 4, 4, gcSHADER_BOOLEAN_X16, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool16", gcvFALSE},
    { gcSHADER_BOOLEAN_X32, 4, 4, 8, gcSHADER_BOOLEAN_X16, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool32", gcvFALSE},

    /* uchar vectors  */
    { gcSHADER_UINT8_X1, 1, 1, 1, gcSHADER_UINT8_X1, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar", gcvFALSE},
    { gcSHADER_UINT8_X2, 2, 2, 1, gcSHADER_UINT8_X2, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar2", gcvFALSE},
    { gcSHADER_UINT8_X3, 3, 3, 1, gcSHADER_UINT8_X3, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar3", gcvFALSE},
    { gcSHADER_UINT8_X4, 4, 4, 1, gcSHADER_UINT8_X4, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar4", gcvFALSE},
    { gcSHADER_UINT8_X8, 4, 4, 2, gcSHADER_UINT8_X8, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar8", gcvFALSE},
    { gcSHADER_UINT8_X16, 4, 4, 4, gcSHADER_UINT8_X16, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar16", gcvFALSE},
    { gcSHADER_UINT8_X32, 4, 4, 8, gcSHADER_UINT8_X32, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar32", gcvFALSE},

    /* char vectors  */
    { gcSHADER_INT8_X1, 1, 1, 1, gcSHADER_INT8_X1, gcSHADER_INT8_X1, gceTK_CHAR, "char", gcvFALSE},
    { gcSHADER_INT8_X2, 2, 2, 1, gcSHADER_INT8_X2, gcSHADER_INT8_X1, gceTK_CHAR, "char2", gcvFALSE},
    { gcSHADER_INT8_X3, 3, 3, 1, gcSHADER_INT8_X3, gcSHADER_INT8_X1, gceTK_CHAR, "char3", gcvFALSE},
    { gcSHADER_INT8_X4, 4, 4, 1, gcSHADER_INT8_X4, gcSHADER_INT8_X1, gceTK_CHAR, "char4", gcvFALSE},
    { gcSHADER_INT8_X8, 4, 4, 2, gcSHADER_INT8_X8, gcSHADER_INT8_X1, gceTK_CHAR, "char8", gcvFALSE},
    { gcSHADER_INT8_X16, 4, 4, 4, gcSHADER_INT8_X16, gcSHADER_INT8_X1, gceTK_CHAR, "char16", gcvFALSE},
    { gcSHADER_INT8_X32, 4, 4, 8, gcSHADER_INT8_X32, gcSHADER_INT8_X1, gceTK_CHAR, "char32", gcvFALSE},


    /* ushort vectors */
    { gcSHADER_UINT16_X1, 1, 1, 1, gcSHADER_UINT16_X1, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort", gcvFALSE},
    { gcSHADER_UINT16_X2, 2, 2, 1, gcSHADER_UINT16_X2, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort2", gcvFALSE},
    { gcSHADER_UINT16_X3, 3, 3, 1, gcSHADER_UINT16_X3, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort3", gcvFALSE},
    { gcSHADER_UINT16_X4, 4, 4, 1, gcSHADER_UINT16_X4, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort4", gcvFALSE},
    { gcSHADER_UINT16_X8, 4, 4, 2, gcSHADER_UINT16_X8, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort8", gcvFALSE},
    { gcSHADER_UINT16_X16, 4, 4, 4, gcSHADER_UINT16_X16, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort16", gcvFALSE},
    { gcSHADER_UINT16_X32, 4, 4, 8, gcSHADER_UINT16_X32, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort32", gcvFALSE},

    /* short vectors */
    { gcSHADER_INT16_X1, 1, 1, 1, gcSHADER_INT16_X1, gcSHADER_INT16_X1, gceTK_SHORT, "short", gcvFALSE},
    { gcSHADER_INT16_X2, 2, 2, 1, gcSHADER_INT16_X2, gcSHADER_INT16_X1, gceTK_SHORT, "short2", gcvFALSE},
    { gcSHADER_INT16_X3, 3, 3, 1, gcSHADER_INT16_X3, gcSHADER_INT16_X1, gceTK_SHORT, "short3", gcvFALSE},
    { gcSHADER_INT16_X4, 4, 4, 1, gcSHADER_INT16_X4, gcSHADER_INT16_X1, gceTK_SHORT, "short4", gcvFALSE},
    { gcSHADER_INT16_X8, 4, 4, 2, gcSHADER_INT16_X8, gcSHADER_INT16_X1, gceTK_SHORT, "short8", gcvFALSE},
    { gcSHADER_INT16_X16, 4, 4, 4, gcSHADER_INT16_X16, gcSHADER_INT16_X1, gceTK_SHORT, "short16", gcvFALSE},
    { gcSHADER_INT16_X32, 4, 4, 8, gcSHADER_INT16_X32, gcSHADER_INT16_X1, gceTK_SHORT, "short32", gcvFALSE},


    /* packed data type */
    /* packed float16 (2 bytes per element) */
    { gcSHADER_FLOAT16_P2, 1, 2, 1, gcSHADER_FLOAT16_P2, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half2_packed", gcvTRUE},
    { gcSHADER_FLOAT16_P3, 2, 3, 1, gcSHADER_FLOAT16_P3, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half3_packed", gcvTRUE},
    { gcSHADER_FLOAT16_P4, 2, 4, 1, gcSHADER_FLOAT16_P4, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half4_packed", gcvTRUE},
    { gcSHADER_FLOAT16_P8, 4, 8, 1, gcSHADER_FLOAT16_P8, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half8_packed", gcvTRUE},
    { gcSHADER_FLOAT16_P16, 4, 8, 2, gcSHADER_FLOAT16_P16, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half16_packed", gcvTRUE},
    { gcSHADER_FLOAT16_P32, 4, 8, 4, gcSHADER_FLOAT16_P32, gcSHADER_FLOAT16_X1, gceTK_FLOAT16, "half32_packed", gcvTRUE},

    /* packed boolean (1 byte per element) */
    { gcSHADER_BOOLEAN_P2, 1, 2, 1, gcSHADER_BOOLEAN_P2, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool8_packed", gcvTRUE},
    { gcSHADER_BOOLEAN_P3, 1, 3, 1, gcSHADER_BOOLEAN_P3, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool16_packed", gcvTRUE},
    { gcSHADER_BOOLEAN_P4, 1, 4, 1, gcSHADER_BOOLEAN_P4, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool32_packed", gcvTRUE},
    { gcSHADER_BOOLEAN_P8, 2, 8, 1, gcSHADER_BOOLEAN_P8, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool8_packed", gcvTRUE},
    { gcSHADER_BOOLEAN_P16, 4, 16, 1, gcSHADER_BOOLEAN_P16, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool16_packed", gcvTRUE},
    { gcSHADER_BOOLEAN_P32, 4, 16, 2, gcSHADER_BOOLEAN_P16, gcSHADER_BOOLEAN_X1, gceTK_BOOL, "bool32_packed", gcvTRUE},

    /* uchar vectors (1 byte per element) */
    { gcSHADER_UINT8_P2, 1, 2, 1, gcSHADER_UINT8_P2, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar2_packed", gcvTRUE},
    { gcSHADER_UINT8_P3, 1, 3, 1, gcSHADER_UINT8_P3, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar3_packed", gcvTRUE},
    { gcSHADER_UINT8_P4, 1, 4, 1, gcSHADER_UINT8_P4, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar4_packed", gcvTRUE},
    { gcSHADER_UINT8_P8, 2, 8, 1, gcSHADER_UINT8_P8, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar8_packed", gcvTRUE},
    { gcSHADER_UINT8_P16, 4, 16, 1, gcSHADER_UINT8_P16, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar16_packed", gcvTRUE},
    { gcSHADER_UINT8_P32, 4, 16, 2, gcSHADER_UINT8_P32, gcSHADER_UINT8_X1, gceTK_UCHAR, "uchar32_packed", gcvTRUE},

    /* char vectors (1 byte per element) */
    { gcSHADER_INT8_P2, 1, 2, 1, gcSHADER_INT8_P2, gcSHADER_INT8_X1, gceTK_CHAR, "char2_packed", gcvTRUE},
    { gcSHADER_INT8_P3, 1, 3, 1, gcSHADER_INT8_P3, gcSHADER_INT8_X1, gceTK_CHAR, "char3_packed", gcvTRUE},
    { gcSHADER_INT8_P4, 1, 4, 1, gcSHADER_INT8_P4, gcSHADER_INT8_X1, gceTK_CHAR, "char4_packed", gcvTRUE},
    { gcSHADER_INT8_P8, 2, 8, 1, gcSHADER_INT8_P8, gcSHADER_INT8_X1, gceTK_CHAR, "char8_packed", gcvTRUE},
    { gcSHADER_INT8_P16, 4, 16, 1, gcSHADER_INT8_P16, gcSHADER_INT8_X1, gceTK_CHAR, "char16_packed", gcvTRUE},
    { gcSHADER_INT8_P32, 4, 16, 2, gcSHADER_INT8_P32, gcSHADER_INT8_X1, gceTK_CHAR, "char32_packed", gcvTRUE},

    /* ushort vectors (2 bytes per element) */
    { gcSHADER_UINT16_P2, 1, 2, 1, gcSHADER_UINT16_P2, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort2_packed", gcvTRUE},
    { gcSHADER_UINT16_P3, 2, 3, 1, gcSHADER_UINT16_P3, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort3_packed", gcvTRUE},
    { gcSHADER_UINT16_P4, 2, 4, 1, gcSHADER_UINT16_P4, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort4_packed", gcvTRUE},
    { gcSHADER_UINT16_P8, 4, 8, 1, gcSHADER_UINT16_P8, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort8_packed", gcvTRUE},
    { gcSHADER_UINT16_P16, 4, 8, 2, gcSHADER_UINT16_P16, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort16_packed", gcvTRUE},
    { gcSHADER_UINT16_P32, 4, 8, 4, gcSHADER_UINT16_P32, gcSHADER_UINT16_X1, gceTK_USHORT, "ushort32_packed", gcvTRUE},

    /* short vectors (2 bytes per element) */
    { gcSHADER_INT16_P2, 1, 2, 1, gcSHADER_INT16_P2, gcSHADER_INT16_X1, gceTK_SHORT, "short2_packed", gcvTRUE},
    { gcSHADER_INT16_P3, 2, 3, 1, gcSHADER_INT16_P3, gcSHADER_INT16_X1, gceTK_SHORT, "short3_packed", gcvTRUE},
    { gcSHADER_INT16_P4, 2, 4, 1, gcSHADER_INT16_P4, gcSHADER_INT16_X1, gceTK_SHORT, "short4_packed", gcvTRUE},
    { gcSHADER_INT16_P8, 4, 8, 1, gcSHADER_INT16_P8, gcSHADER_INT16_X1, gceTK_SHORT, "short8_packed", gcvTRUE},
    { gcSHADER_INT16_P16, 4, 8, 2, gcSHADER_INT16_P16, gcSHADER_INT16_X1, gceTK_SHORT, "short16_packed", gcvTRUE},
    { gcSHADER_INT16_P32, 4, 8, 4, gcSHADER_INT16_P32, gcSHADER_INT16_X1, gceTK_SHORT, "short32_packed", gcvTRUE},

    { gcSHADER_INTEGER_X8, 4, 4, 2, gcSHADER_INTEGER_X8, gcSHADER_INTEGER_X1, gceTK_INT, "int8", gcvFALSE},
    { gcSHADER_INTEGER_X16, 4, 4, 4, gcSHADER_INTEGER_X16, gcSHADER_INTEGER_X1, gceTK_INT, "int16", gcvFALSE},
    { gcSHADER_UINT_X8, 4, 4, 2, gcSHADER_UINT_X8, gcSHADER_UINT_X1, gceTK_UINT, "uint8", gcvFALSE},
    { gcSHADER_UINT_X16, 4, 4, 4, gcSHADER_UINT_X16, gcSHADER_UINT_X1, gceTK_UINT, "uint16", gcvFALSE},
    { gcSHADER_FLOAT_X8, 4, 4, 2, gcSHADER_FLOAT_X8, gcSHADER_FLOAT_X1, gceTK_FLOAT, "float8", gcvFALSE},
    { gcSHADER_FLOAT_X16, 4, 4, 4, gcSHADER_FLOAT_X16, gcSHADER_FLOAT_X1, gceTK_FLOAT, "float16", gcvFALSE},
    { gcSHADER_INT64_X8, 4, 4, 4, gcSHADER_INT64_X8, gcSHADER_INT64_X1, gceTK_INT64, "long8", gcvFALSE},
    { gcSHADER_INT64_X16, 4, 4, 8, gcSHADER_INT64_X16, gcSHADER_INT64_X1, gceTK_INT64, "long16", gcvFALSE},
    { gcSHADER_UINT64_X8, 4, 4, 4, gcSHADER_UINT64_X8, gcSHADER_UINT64_X1, gceTK_UINT64, "ulong8", gcvFALSE},
    { gcSHADER_UINT64_X16, 4, 4, 8, gcSHADER_UINT64_X16, gcSHADER_UINT64_X1, gceTK_UINT64, "ulong16", gcvFALSE},

    { gcSHADER_FLOAT64_X1, 1, 1, 1, gcSHADER_FLOAT_X1, gcSHADER_FLOAT_X1, gceTK_FLOAT, "double", gcvFALSE},
    { gcSHADER_FLOAT64_X2, 2, 2, 1, gcSHADER_FLOAT_X2, gcSHADER_FLOAT_X1, gceTK_FLOAT, "double2", gcvFALSE},
    { gcSHADER_FLOAT64_X3, 3, 3, 1, gcSHADER_FLOAT_X3, gcSHADER_FLOAT_X1, gceTK_FLOAT, "double3", gcvFALSE},
    { gcSHADER_FLOAT64_X4, 4, 4, 1, gcSHADER_FLOAT_X4, gcSHADER_FLOAT_X1, gceTK_FLOAT, "double4", gcvFALSE},
    { gcSHADER_FLOAT64_2X2, 2, 2, 2, gcSHADER_FLOAT_X2, gcSHADER_FLOAT_X1, gceTK_FLOAT, "dmat2", gcvFALSE},
    { gcSHADER_FLOAT64_3X3, 3, 3, 3, gcSHADER_FLOAT_X3, gcSHADER_FLOAT_X1, gceTK_FLOAT, "dmat3", gcvFALSE},
    { gcSHADER_FLOAT64_4X4, 4, 4, 4, gcSHADER_FLOAT_X4, gcSHADER_FLOAT_X1, gceTK_FLOAT, "dmat4", gcvFALSE},
    { gcSHADER_FLOAT64_2X3, 3, 3, 2, gcSHADER_FLOAT_X3, gcSHADER_FLOAT_X1, gceTK_FLOAT, "dmat2x3", gcvFALSE},
    { gcSHADER_FLOAT64_2X4, 4, 4, 2, gcSHADER_FLOAT_X4, gcSHADER_FLOAT_X1, gceTK_FLOAT, "dmat2x4", gcvFALSE},
    { gcSHADER_FLOAT64_3X2, 2, 2, 3, gcSHADER_FLOAT_X2, gcSHADER_FLOAT_X1, gceTK_FLOAT, "dmat3x2", gcvFALSE},
    { gcSHADER_FLOAT64_3X4, 4, 4, 3, gcSHADER_FLOAT_X4, gcSHADER_FLOAT_X1, gceTK_FLOAT, "dmat3x4", gcvFALSE},
    { gcSHADER_FLOAT64_4X2, 2, 2, 4, gcSHADER_FLOAT_X2, gcSHADER_FLOAT_X1, gceTK_FLOAT, "dmat4x2", gcvFALSE},
    { gcSHADER_FLOAT64_4X3, 3, 3, 4, gcSHADER_FLOAT_X3, gcSHADER_FLOAT_X1, gceTK_FLOAT, "dmat4x3", gcvFALSE},
    { gcSHADER_FLOAT64_X8, 4, 4, 2, gcSHADER_FLOAT_X8, gcSHADER_FLOAT_X1, gceTK_FLOAT, "double8", gcvFALSE},
    { gcSHADER_FLOAT64_X16, 4, 4, 4, gcSHADER_FLOAT_X16,gcSHADER_FLOAT_X1, gceTK_FLOAT, "double16", gcvFALSE},

    /* OpenGL 4.0 types */
    { gcSHADER_SAMPLER_2D_RECT, 1, 1, 1, gcSHADER_SAMPLER_2D_RECT, gcSHADER_SAMPLER_2D_RECT, gceTK_SAMPLER, "sampler2DRect", gcvFALSE},
    { gcSHADER_ISAMPLER_2D_RECT, 1, 1, 1, gcSHADER_ISAMPLER_2D_RECT, gcSHADER_ISAMPLER_2D_RECT, gceTK_SAMPLER, "isampler2DRect", gcvFALSE},
    { gcSHADER_USAMPLER_2D_RECT, 1, 1, 1, gcSHADER_USAMPLER_2D_RECT, gcSHADER_USAMPLER_2D_RECT, gceTK_SAMPLER, "usampler2DRect", gcvFALSE},
    { gcSHADER_SAMPLER_2D_RECT_SHADOW, 1, 1, 1, gcSHADER_SAMPLER_2D_RECT_SHADOW, gcSHADER_SAMPLER_2D_RECT_SHADOW, gceTK_SAMPLER, "sampler2DRectShadow", gcvFALSE},
    { gcSHADER_ISAMPLER_1D_ARRAY, 1, 1, 1, gcSHADER_ISAMPLER_1D_ARRAY, gcSHADER_ISAMPLER_1D_ARRAY, gceTK_SAMPLER, "isampler1DArray", gcvFALSE},
    { gcSHADER_USAMPLER_1D_ARRAY, 1, 1, 1, gcSHADER_USAMPLER_1D_ARRAY, gcSHADER_USAMPLER_1D_ARRAY, gceTK_SAMPLER, "usampler1DArray", gcvFALSE},
    { gcSHADER_ISAMPLER_1D, 1, 1, 1, gcSHADER_ISAMPLER_1D, gcSHADER_ISAMPLER_1D, gceTK_SAMPLER, "isampler1D", gcvFALSE},
    { gcSHADER_USAMPLER_1D, 1, 1, 1, gcSHADER_USAMPLER_1D, gcSHADER_USAMPLER_1D, gceTK_SAMPLER, "usampler1D", gcvFALSE},
    { gcSHADER_SAMPLER_1D_SHADOW, 1, 1, 1, gcSHADER_SAMPLER_1D_SHADOW, gcSHADER_SAMPLER_1D_SHADOW, gceTK_SAMPLER, "sampler1DShadow", gcvFALSE},


    { gcSHADER_UNKONWN_TYPE, 0, 0, 0, gcSHADER_UNKONWN_TYPE, gcSHADER_UNKONWN_TYPE, gceTK_UNKOWN, "UNKONWN_TYPE", gcvFALSE},
};

/* compile-time assertion if the gcvShaderTypeInfo is not the same length as gcSHADER_TYPE_COUNT */
const gctINT _verifyTypeInfo[sizeof(gcvShaderTypeInfo)/sizeof(gcSHADER_TYPEINFO) == gcSHADER_TYPE_COUNT] = { 0 };

/* forward declarations */
gctINT
_insertNOP2Main(
    IN OUT gcSHADER          Shader,
    IN     gctUINT            Num
    );

gceSTATUS
_ExpandCode(
    IN gcSHADER Shader,
    IN gctUINT  CodeCount
    );

void
gcTYPE_GetTypeInfo(
    IN gcSHADER_TYPE      Type,
    OUT gctUINT32 *       Components,
    OUT gctUINT32 *       Rows,
    OUT gctCONST_STRING * Name
    )
{
    gcmASSERT(Type < gcSHADER_TYPE_COUNT && Type >= gcSHADER_FLOAT_X1);
    if (Components)
        *Components = gcvShaderTypeInfo[Type].components;

    if (Rows)
        *Rows = gcvShaderTypeInfo[Type].rows;

    if (Name)
        *Name = gcvShaderTypeInfo[Type].name;
}

gctBOOL
gcTYPE_IsTypePacked(
    IN gcSHADER_TYPE      Type
    )
{
    gcmASSERT(Type < gcSHADER_TYPE_COUNT && Type >= gcSHADER_FLOAT_X1);
    return  gcvShaderTypeInfo[Type].isPacked;
}

/* get gcShaderType from format and component number */
gcSHADER_TYPE
gcGetShaderTypeFromFormatAndComponentCount(
    IN gcSL_FORMAT  ElemFormat,
    IN gctINT       ComponentCount,
    IN gctINT       RowCount
    )
{

    switch (ElemFormat)
    {
    case gcSL_BOOLEAN:
        switch (ComponentCount)
        {
        case 1: return gcSHADER_BOOLEAN_X1;
        case 2: return gcSHADER_BOOLEAN_X2;
        case 3: return gcSHADER_BOOLEAN_X3;
        case 4: return gcSHADER_BOOLEAN_X4;

        default:
            gcmASSERT(0);
            return gcSHADER_BOOLEAN_X4;
        }

    case gcSL_INTEGER:
    case gcSL_INT16:
    case gcSL_INT8:
        switch (ComponentCount)
        {
        case 1: return gcSHADER_INTEGER_X1;
        case 2: return gcSHADER_INTEGER_X2;
        case 3: return gcSHADER_INTEGER_X3;
        case 4: return gcSHADER_INTEGER_X4;

        default:
            gcmASSERT(0);
            return gcSHADER_INTEGER_X4;
        }

    case gcSL_INT64:
        switch (ComponentCount)
        {
        case 1: return gcSHADER_INT64_X1;
        case 2: return gcSHADER_INT64_X2;
        case 3: return gcSHADER_INT64_X3;
        case 4: return gcSHADER_INT64_X4;

        default:
            gcmASSERT(0);
            return gcSHADER_INT64_X4;
        }

    case gcSL_UINT32:
    case gcSL_UINT16:
    case gcSL_UINT8:
        switch (ComponentCount)
        {
        case 1: return gcSHADER_UINT_X1;
        case 2: return gcSHADER_UINT_X2;
        case 3: return gcSHADER_UINT_X3;
        case 4: return gcSHADER_UINT_X4;

        default:
            gcmASSERT(0);
            return gcSHADER_UINT_X4;
        }

    case gcSL_UINT64:
        switch (ComponentCount)
        {
        case 1: return gcSHADER_UINT64_X1;
        case 2: return gcSHADER_UINT64_X2;
        case 3: return gcSHADER_UINT64_X3;
        case 4: return gcSHADER_UINT64_X4;

        default:
            gcmASSERT(0);
            return gcSHADER_UINT64_X4;
        }

    case gcSL_FLOAT:
        switch (RowCount)
        {
        case 0:
        case 1:
            switch (ComponentCount)
            {
            case 1: return gcSHADER_FLOAT_X1;
            case 2: return gcSHADER_FLOAT_X2;
            case 3: return gcSHADER_FLOAT_X3;
            case 4: return gcSHADER_FLOAT_X4;

            default:
                gcmASSERT(0);
                return gcSHADER_FLOAT_X4;
            }

        case 2:
            switch (ComponentCount) {
            case 2:
                return gcSHADER_FLOAT_2X2;

            case 3:
                return gcSHADER_FLOAT_3X2;

            case 4:
                return gcSHADER_FLOAT_4X2;

            default:
                gcmASSERT(0);
                return gcSHADER_FLOAT_2X2;
            }

        case 3:
            switch (ComponentCount) {
            case 2:
                return gcSHADER_FLOAT_2X3;

            case 3:
                return gcSHADER_FLOAT_3X3;

            case 4:
                return gcSHADER_FLOAT_4X3;

            default:
                gcmASSERT(0);
                return gcSHADER_FLOAT_3X3;
            }

        case 4:
            switch (ComponentCount) {
            case 2:
                return gcSHADER_FLOAT_2X4;

            case 3:
                return gcSHADER_FLOAT_3X4;

            case 4:
                return gcSHADER_FLOAT_4X4;

            default:
                gcmASSERT(0);
                return gcSHADER_FLOAT_4X4;
            }

        default:
            gcmASSERT(0);
            return gcSHADER_FLOAT_4X4;
        }

    case gcSL_FLOAT16:
        switch (ComponentCount)
        {
        case 1: return gcSHADER_FLOAT_X1;
        case 2: return gcSHADER_FLOAT_X2;
        case 3: return gcSHADER_FLOAT_X3;
        case 4: return gcSHADER_FLOAT_X4;

        default:
            gcmASSERT(0);
            return gcSHADER_FLOAT_X4;
        }

    default:
        gcmASSERT(0);
        return gcSHADER_FLOAT_X4;
    }
}

void
gcTYPE_GetFormatInfo(
    IN  gcSL_FORMAT       ElemFormat,
    IN  gctUINT32         Components,
    OUT gctUINT32 *       Rows,
    OUT gcSHADER_TYPE *   Type
    )
{
    gcSHADER_TYPE type;

    gcmASSERT(ElemFormat < gcSL_INVALID);
    type =  gcGetShaderTypeFromFormatAndComponentCount(ElemFormat,
                                                       Components,
                                                       1);

    gcTYPE_GetTypeInfo(type,
                       gcvNULL,
                       Rows,
                       gcvNULL);
    if(Type)
        *Type = type;
}

/* initialize the block table */
gceSTATUS
gcBLOCKTABLE_Init(
    IN gcsBlockTable Tbl,
    IN gctUINT32     BlockSize,
    IN gctUINT32     NumBlocks,
    IN gctUINT32     Align
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctPOINTER pointer;
    gctUINT i;

    gcmHEADER_ARG("Tbl=0x%x, BlockSize=%d, NumBlocks=%d, Align=%d ",
                  Tbl, BlockSize, NumBlocks, Align);

    gcmASSERT(Tbl != gcvNULL &&
               BlockSize > 0 && BlockSize <= MAX_BLOCK_SIZE &&
               NumBlocks > 0 && NumBlocks <= MAX_BLOCK_NUM );
    gcmASSERT(Align == 1 || Align == 2 ||
               Align == 4 || Align == 8 ||
               Align == 16 );
    /* Allocate a new buffer to store the constants */
    status = gcoOS_Allocate(gcvNULL,
                           gcmSIZEOF(struct _gcsBlockNode) * NumBlocks,
                           &pointer);

    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcInitBlockTable: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    Tbl->blocks = pointer;
    Tbl->blockSize = BlockSize;
    Tbl->numOfBlocks = NumBlocks;
    Tbl->elementAlignment = Align;

    /* initialize block node to NULL */
    for (i = 0; i < Tbl->numOfBlocks; i++) {
        Tbl->blocks[i].data = gcvNULL;
        Tbl->blocks[i].availableSize = 0;
            }

    /* allocate the first block and reserve id (0) (as null id) */
    status = gcoOS_Allocate(gcvNULL, Tbl->blockSize, &pointer);

    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcInitBlockTable: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
        }

    Tbl->blocks[0].data = pointer;
    Tbl->blocks[0].availableSize = Tbl->blockSize - Align; /* first ID start from Align */

    gcmFOOTER();
    return status;
}

/* copy the Data in length Len to Tbl->blocks[BlockIdx]'s first avaliable space.
   return the data ID in whole BlockTable */
static gctDATA_ID
_gcEnterDataToBlock(
    IN  gcsBlockTable       Tbl,
    IN  gctUINT32           BlockIdx,
    IN  const void *        Data,
    IN  gctUINT32           Len
                 )
{
    gctDATA_ID   id     = gcmGetBlockId(Tbl, BlockIdx);
    gctUINT32    usedSz = gcmBlockUsedSize(Tbl, BlockIdx);

    /* copy the data to block */
    gcoOS_MemCopy((gctSTRING)Tbl->blocks[BlockIdx].data + usedSz,
                  Data, Len);
    /* update and align used size */
    usedSz = gcmALIGN(usedSz + Len,Tbl->elementAlignment);

    /* update the available size */
    Tbl->blocks[BlockIdx].availableSize = Tbl->blockSize - usedSz;

    return id;
}

/* add Data of length Len to the Tbl and return the data index Id */
gceSTATUS
gcBLOCKTABLE_AddData(
    IN  gcsBlockTable       Tbl,
    IN  const void *        Data,
    IN  gctUINT32           Len,
    OUT gctDATA_ID*         Id)
{
    gceSTATUS status = gcvSTATUS_OK;
    gctPOINTER pointer;
    gctUINT i, block_idx;

    gcmHEADER_ARG("Tbl=0x%x, Data=0x%x, Len=%d ", Tbl, Data, Len);

    gcmASSERT(Tbl != gcvNULL && Data != gcvNULL &&
               Len  > 0 && Len <= Tbl->blockSize );

    /* check if there is block which has enough space for the data */
    for (block_idx = 0; block_idx < Tbl->numOfBlocks; ++block_idx) {
        gctUINT32 availableSize = Tbl->blocks[block_idx].availableSize;
        if (availableSize >= Len) {
            *Id = _gcEnterDataToBlock(Tbl, block_idx, Data, Len);
            return gcvSTATUS_OK;
        }
        else if (Tbl->blocks[block_idx].data == gcvNULL)
            break;
        }

    /* no enough space left, check if blocktable are full */
    if (block_idx == Tbl->numOfBlocks) {
        /* increase blocks */
        const gctUINT32 newNumOfBlocks = Tbl->numOfBlocks * 2;
        /* Allocate a new block list */
        status = gcoOS_Allocate(gcvNULL,
                           gcmSIZEOF(struct _gcsBlockNode) * newNumOfBlocks,
                           &pointer);
        if (gcmIS_ERROR(status)) {
            /* Error. */
            gcmFATAL("gcAddDataToBlockTable: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
            gcmFOOTER();
            return status;
        }
        gcoOS_MemCopy(pointer,
                      Tbl->blocks,
                      gcmSIZEOF(struct _gcsBlockNode) * Tbl->numOfBlocks);
        Tbl->blocks = pointer;
        Tbl->numOfBlocks = newNumOfBlocks;
        /* initialize rest of block node to NULL */
        for (i = block_idx; i < newNumOfBlocks; i++) {
            Tbl->blocks[i].data = gcvNULL;
            Tbl->blocks[i].availableSize = 0;
        }
        }

    gcmASSERT(block_idx < Tbl->numOfBlocks && Tbl->blocks[block_idx].data == gcvNULL);
    /* Allocate a new block to store the data */
    status = gcoOS_Allocate(gcvNULL, Tbl->blockSize, &pointer);

    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcInitBlockTable: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
            }

    Tbl->blocks[block_idx].data = pointer;
    Tbl->blocks[block_idx].availableSize = Tbl->blockSize;

    /* */
    *Id = _gcEnterDataToBlock(Tbl, block_idx, Data, Len);

    gcmFOOTER();
    return status;
}

/* for given data index Id in Tbl, return the data address in Addr */
gceSTATUS
gcBLOCKTABLE_GetAddress(
    IN  const gcsBlockTable Tbl,
    IN  gctDATA_ID Id,
    OUT gctPOINTER * Addr)
{
    gcmASSERT(Id < Tbl->blockSize * Tbl->numOfBlocks);

    * Addr = (gctSTRING)Tbl->blocks[Id / Tbl->blockSize].data + Id % Tbl->blockSize;
    return gcvSTATUS_OK;
}

gceSTATUS
gcBLOCKTABLE_Destory(gcsBlockTable Tbl)
{
    gctUINT i;
    gcmASSERT(Tbl != gcvNULL);

    /* free blocks */
    for (i = 0; i < Tbl->numOfBlocks; i++) {
        if (Tbl->blocks[i].data != gcvNULL)
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Tbl->blocks[i].data));
    }

    /* free the block list */
    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Tbl->blocks));
    return gcvSTATUS_OK;
}

static gctCONST_STRING _FindString(
    IN gctCONST_STRING String,
    IN gctCONST_STRING Search,
    OUT gctINT_PTR SearchIndex
    )
{
    gctCONST_STRING source;
    gctINT          sourceIndex;
    gctCONST_STRING search;

    /* Start from the beginning of the source string. */
    source = String;

    /* Reset search index. */
    sourceIndex = 0;
    search      = Search;

    /* Loop until the end of the source string. */
    while (source[sourceIndex] != '\0')
    {
        /* Check if we match the current search character. */
        if (source[sourceIndex] == *search)
        {
            /* Increment the source index. */
            sourceIndex ++;

            /* Increment the search index and test for end of string. */
            if (*++search == '\0')
            {
                /* Return the current index. */
                *SearchIndex = sourceIndex;

                /* Return the location of the searcg string. */
                return source;
            }
        }

        /* Skip any white space in the source string. */
        else if ((source[sourceIndex] == ' ')
                 ||
                 (source[sourceIndex] == '\t')
                 ||
                 (source[sourceIndex] == '\r')
                 ||
                 (source[sourceIndex] == '\n')
                 ||
                 (source[sourceIndex] == '\\')
                 )
        {
            /* Increment the source index. */
            sourceIndex++;
        }

        /* No match. */
        else
        {
            /* Next source character. */
            source++;

            /* Reset search index. */
            sourceIndex = 0;
            search      = Search;
        }
    }

    /* No match. */
    return gcvNULL;
}

gceSTATUS
gcSHADER_CheckClipW(
    IN gctCONST_STRING VertexSource,
    IN gctCONST_STRING FragmentSource,
    OUT gctBOOL * clipW
    )
{
    gctCONST_STRING     searchVS;
    gctINT              searchVSIndex = 0;
    gctCONST_STRING     searchFS;
    gctINT              searchFSIndex = 0;

    gctCONST_STRING fromVertex = {
        "void main()"
        "{"
            "gl_Position=mvp*vec4(in_position,1.0);"
            "gl_Position.z=gl_Position.w;"
            "out_texcoord0=in_texcoord0;"
        "}"
    };

    gctCONST_STRING fromFragment = {
        /* Fragment shader. */
        "void main()"
        "{"
            "gl_FragColor=texture2D(texture_unit0,out_texcoord0);"
        "}"
    };

    do
    {
        /* Check if there is a vertex shader search string. */
        if ((VertexSource != gcvNULL)
            &&
            (fromVertex != gcvNULL)
            )
        {
            /* Find the search string in the vertex shader. */
            searchVS = _FindString(VertexSource,
                                      fromVertex,
                                      &searchVSIndex);
        }
        else
        {
            /* No vertex shader search string */
            searchVS = gcvNULL;
        }
        /* Check if there is a fragment shader search string. */
        if ((FragmentSource != gcvNULL)
            &&
            (fromFragment != gcvNULL)
            )
        {
            /* Find the search string in the fragment shader. */
            searchFS = _FindString(FragmentSource,
                                      fromFragment,
                                      &searchFSIndex);
        }
        else
        {
            /* No fragment shader search string */
            searchFS = gcvNULL;
        }

        /* Check if we need a search string from both shaders. */
        if ((fromVertex != gcvNULL)
            &&
            (fromFragment != gcvNULL)
            )
        {
            /* If any search turned up nothing, abort. */
            if ((searchVS == gcvNULL) || (searchFS == gcvNULL))
            {
                break;
            }
        }

        /* Check if we need a search string from the vertex shader. */
        else if (fromVertex != gcvNULL)
        {
            /* If the search turned up nothing, abort. */
            if (searchVS == gcvNULL)
            {
                break;
            }
        }

        /* Check if we need a search string from the fragment shader. */
        else if (fromFragment != gcvNULL)
        {
            /* If the search turned up nothing, abort. */
            if (searchFS == gcvNULL)
            {
                break;
            }
        }

        *clipW      = gcvTRUE;

    }while(gcvFALSE);

    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_SetDefaultUBO
**
**  Set the compiler enable/disable default UBO.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to gcSHADER object
**
**      gctBOOL Enabled
**          Pointer to enable/disable default UBO
*/
gceSTATUS
gcSHADER_SetDefaultUBO(
    IN gcSHADER Shader,
    IN gctBOOL Enabled
    )
{
    gcmHEADER_ARG("Shader=0x%x Enabled=0x%x", Shader, Enabled);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    Shader->enableDefaultUBO = Enabled;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_SetCompilerVersion
**
**  Set the compiler version of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctINT *Version
**          Pointer to a two word version
*/
gceSTATUS
gcSHADER_SetCompilerVersion(
    IN gcSHADER Shader,
    IN gctUINT32 *Version
    )
{
    gcmHEADER_ARG("Shader=0x%x Version=0x%x", Shader, Version);

/* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(Version != gcvNULL);

    Shader->compilerVersion[0] = Version[0];
    Shader->compilerVersion[1] = Version[1];

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_SetClientApiVersion
**
**  Set the client API version of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gceAPI API
**          Client API version.
*/
gceSTATUS
gcSHADER_SetClientApiVersion(
    IN gcSHADER Shader,
    IN gceAPI Api
    )
{
    gcmHEADER_ARG("Shader=0x%x ApiVersion=0x%x", Shader, Api);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    Shader->clientApiVersion = Api;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_SetShaderID
**
**  Set a unique id for this shader base on shader source string.
**
**  INPUT:
**
**      gcSHADER  Shader
**          Pointer to an shader object.
**
**      gctUINT32 ID
**          The value of shader id.
*/
gceSTATUS
gcSHADER_SetShaderID(
    IN gcSHADER  Shader,
    IN gctUINT32 ID
    )
{
    gcmHEADER_ARG("Shader=0x%x, ID = 0x%x", Shader, ID);

    gcmASSERT(Shader);
    Shader->_stringId = ID;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetShaderID
**
**  Get the unique id of this shader.
**
**  INPUT:
**
**      gcSHADER  Shader
**          Pointer to an shader object.
**
**      gctUINT32 * ID
**          The value of shader id.
*/
gceSTATUS
gcSHADER_GetShaderID(
    IN gcSHADER  Shader,
    IN gctUINT32 * ID
    )
{
    gcmHEADER_ARG("Shader=0x%x, ID = 0x%x", Shader, ID);

    gcmASSERT(Shader);
    if (ID)
    {
        *ID = Shader->_stringId;
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_SetDisableEZ
**
**  Set disable EZ for this shader.
**
**  INPUT:
**
**      gcSHADER  Shader
**          Pointer to an shader object.
**
**      gctBOOL Disabled
**          Disable or not.
*/
gceSTATUS
gcSHADER_SetDisableEZ(
    IN gcSHADER  Shader,
    IN gctBOOL Disabled
    )
{
    gcmHEADER_ARG("Shader=0x%x, Disabled = %d", Shader, Disabled);

    gcmASSERT(Shader);
    Shader->disableEarlyZ = Disabled;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetDisableEZ
**
**  Get disable EZ of this shader.
**
**  INPUT:
**
**      gcSHADER  Shader
**          Pointer to an shader object.
**
**      gctBOOL * Disabled
**          The value of Disable EZ.
*/
gceSTATUS
gcSHADER_GetDisableEZ(
    IN gcSHADER  Shader,
    IN gctBOOL * Disabled
    )
{
    gcmHEADER_ARG("Shader=0x%x, Disable = 0x%x", Shader, Disabled);

    gcmASSERT(Shader);
    if (Disabled)
    {
        *Disabled = Shader->disableEarlyZ;
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_CheckValidity
**
**  Check validity for a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
*/
gceSTATUS
gcSHADER_CheckValidity(
    IN gcSHADER Shader
    )
{
    gctUINT32 instIdx;
    gcSL_INSTRUCTION code;
    gceSTATUS status = gcvSTATUS_OK;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    for (instIdx = 0; instIdx < Shader->codeCount; instIdx ++)
    {
        code = &Shader->code[instIdx];

        /* Dst index can not be equal to source index */
        if ((((code->source0Index == code->tempIndex) && (gcmSL_SOURCE_GET(code->source0,Type) == gcSL_TEMP)) ||
            ((code->source1Index == code->tempIndex) && (gcmSL_SOURCE_GET(code->source1,Type) == gcSL_TEMP))) &&
            (code->opcode != gcSL_JMP))
        {
            status = gcvSTATUS_INVALID_ARGUMENT;
            break;
        }
    }

    gcmFOOTER();
    return status;
}

/*******************************************************************************
**  gcSHADER_GetCompilerVersion
**
**  Get the compiler version of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32_PTR *CompilerVersion.
**          Pointer to a variable for the returned compilerVersion pointer
*/
gceSTATUS
gcSHADER_GetCompilerVersion(
    IN gcSHADER Shader,
    OUT gctUINT32_PTR *CompilerVersion
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    *CompilerVersion = Shader->compilerVersion;
    gcmFOOTER_ARG("*CompilerVersion=0x%x", *CompilerVersion);
    return gcvSTATUS_OK;
}

gctBOOL
gcShader_IsESCompiler(
    IN gcSHADER Shader
    )
{
    gctBOOL isESCompiler;

    isESCompiler = (Shader->compilerVersion[0] & 0xFFFF) == _SHADER_GL_LANGUAGE_TYPE;

    return isESCompiler;
}

gctBOOL
gcShader_IsES11Compiler(
    IN gcSHADER Shader
    )
{
    gctBOOL isES11Compiler;

    isES11Compiler = ((Shader->compilerVersion[0] & 0xFFFF) == _SHADER_GL_LANGUAGE_TYPE &&
                    Shader->compilerVersion[1] == _SHADER_ES11_VERSION);

    return isES11Compiler;
}

gctBOOL
gcShader_IsES30Compiler(
    IN gcSHADER Shader
    )
{
    gctBOOL isES30Compiler;

    isES30Compiler = ((Shader->compilerVersion[0] & 0xFFFF) == _SHADER_GL_LANGUAGE_TYPE &&
                    Shader->compilerVersion[1] == _SHADER_HALTI_VERSION);

    return isES30Compiler;
}

gctBOOL
gcShader_IsES31Compiler(
    IN gcSHADER Shader
    )
{
    gctBOOL isES31Compiler;

    isES31Compiler = ((Shader->compilerVersion[0] & 0xFFFF) == _SHADER_GL_LANGUAGE_TYPE &&
                    Shader->compilerVersion[1] == _SHADER_ES31_VERSION);

    return isES31Compiler;
}


/*******************************************************************************
**  gcSHADER_AddTypeNameBuffer
**
**  add buffer containing all non basic type names of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 TypeNameBufferSize
**          Type name buffer size in bytes
**
**      gctCHAR *TypeNameBuffer
**          Non basic type names
*/
gceSTATUS
gcSHADER_AddTypeNameBuffer(
    IN gcSHADER Shader,
    IN gctUINT32 TypeNameBufferSize,
    IN gctCHAR * TypeNameBuffer
    )
{
    gceSTATUS status;
    gcmHEADER_ARG("Shader=0x%x TypeNameBufferSize=%u TypeNameBuffer=0x%x",
                  Shader, TypeNameBufferSize, TypeNameBuffer);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    Shader->typeNameBufferSize = TypeNameBufferSize;
    if(Shader->typeNameBuffer) {
        gcmOS_SAFE_FREE(gcvNULL, Shader->typeNameBuffer);
    }

    if(Shader->typeNameBufferSize) {
       gctPOINTER pointer;

       /* Allocate a new buffer to store the names */
       status = gcoOS_Allocate(gcvNULL,
                               gcmSIZEOF(gctCHAR) * Shader->typeNameBufferSize,
                               &pointer);
       if (gcmIS_ERROR(status)) {
          /* Error. */
          gcmFATAL("gcSHADER_AddTypeNameBuffer: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
          gcmFOOTER();
          return status;
       }
       Shader->typeNameBuffer = pointer;
       gcmASSERT(TypeNameBuffer);
       gcoOS_MemCopy(Shader->typeNameBuffer,
                     TypeNameBuffer,
                     Shader->typeNameBufferSize);
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_SetConstantMemorySize
**
**  Set the constant memory address space size of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 ConstantMemorySize
**          Constant memory size in bytes
**
**      gctCHAR *ConstantMemoryBuffer
**          Constant memory buffer
*/
gceSTATUS
gcSHADER_SetConstantMemorySize(
    IN gcSHADER Shader,
    IN gctUINT32 ConstantMemorySize,
    IN gctCHAR * ConstantMemoryBuffer
    )
{
    gceSTATUS status;
    gcmHEADER_ARG("Shader=0x%x ConstantMemorySize=%u ConstantMemoryBuffer=0x%x",
                  Shader, ConstantMemorySize, ConstantMemoryBuffer);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    Shader->constantMemorySize = ConstantMemorySize;
    if(Shader->constantMemorySize) {
       gctPOINTER pointer;

       if(Shader->constantMemoryBuffer) {
          gcmOS_SAFE_FREE(gcvNULL, Shader->constantMemoryBuffer);
       }
       /* Allocate a new buffer to store the constants */
       status = gcoOS_Allocate(gcvNULL,
                               gcmSIZEOF(gctCHAR) * ConstantMemorySize,
                               &pointer);

       if (gcmIS_ERROR(status)) {
          /* Error. */
          gcmFATAL("gcSHADER_SetConstantMemorySize: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
          gcmFOOTER();
          return status;
       }
       Shader->constantMemoryBuffer = pointer;
       gcoOS_MemCopy(Shader->constantMemoryBuffer,
                     ConstantMemoryBuffer,
                     ConstantMemorySize);
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetConstantMemorySize
**
**  Get the gcSHADER object's constant memory size.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 *ConstantMemorySize.
**          Pointer to a returned shader constant memory size.
**
**      gctCHAR **ConstantMemoryBuffer.
**          Pointer to a variable for returned shader constant memory buffer.
*/
gceSTATUS
gcSHADER_GetConstantMemorySize(
    IN gcSHADER Shader,
    OUT gctUINT32 *ConstantMemorySize,
    OUT gctCHAR **ConstantMemoryBuffer
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    *ConstantMemorySize = Shader->constantMemorySize;
    *ConstantMemoryBuffer = Shader->constantMemoryBuffer;
    gcmFOOTER_ARG("*ConstantMemorySize=%d *ConstantMemoryBuffer=0x%x",
                  *ConstantMemorySize, *ConstantMemoryBuffer);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_SetPrivateMemorySize
**
**  Set the private memory address space size of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 PrivateMemorySize
**          Private memory size in bytes
*/
gceSTATUS
gcSHADER_SetPrivateMemorySize(
    IN gcSHADER Shader,
    IN gctUINT32 PrivateMemorySize
    )
{
    gcmHEADER_ARG("Shader=0x%x PrivateMemorySize=%u", Shader, PrivateMemorySize);

/* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    Shader->privateMemorySize = PrivateMemorySize;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetPrivateMemorySize
**
**  Get the gcSHADER object's private memory size.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 *PrivateMemorySize.
**          Pointer to a returned shader private memory size.
*/
gceSTATUS
gcSHADER_GetPrivateMemorySize(
    IN gcSHADER Shader,
    OUT gctUINT32 *PrivateMemorySize
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    *PrivateMemorySize = Shader->privateMemorySize;
    gcmFOOTER_ARG("*PrivateMemorySize=%d", *PrivateMemorySize);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_SetLocalMemorySize
**
**  Set the local memory address space size of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 LocalMemorySize
**          Local memory size in bytes
*/
gceSTATUS
gcSHADER_SetLocalMemorySize(
    IN gcSHADER Shader,
    IN gctUINT32 LocalMemorySize
    )
{
    gcmHEADER_ARG("Shader=0x%x LocalMemorySize=%u", Shader, LocalMemorySize);

/* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    Shader->localMemorySize = LocalMemorySize;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetLocalMemorySize
**
**  Get the gcSHADER object's local memory size.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * LocalMemorySize.
**          Pointer to a returned shader local memory size.
*/
gceSTATUS
gcSHADER_GetLocalMemorySize(
    IN gcSHADER Shader,
    OUT gctUINT32 *LocalMemorySize
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    *LocalMemorySize = Shader->localMemorySize;
    gcmFOOTER_ARG("*LocalMemorySize=%d", *LocalMemorySize);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetWorkGroupSize
**
**  Get the workGroupSize of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * WorkGroupSize
**          Pointer to a variable receiving workGroupSize
*/
gceSTATUS
gcSHADER_GetWorkGroupSize(
    IN gcSHADER Shader,
    OUT gctUINT * WorkGroupSize
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctUINT workGroupSize = 0;

    gcmHEADER_ARG("Shader=0x%x, WorkGroupSize=0x%x", Shader, WorkGroupSize);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (GetShaderType(Shader) == gcSHADER_TYPE_COMPUTE)
    {
        workGroupSize = Shader->shaderLayout.compute.workGroupSize[0] *
                        Shader->shaderLayout.compute.workGroupSize[1] *
                        Shader->shaderLayout.compute.workGroupSize[2];
    }
    else
    {
        gcmASSERT(GetShaderType(Shader) == gcSHADER_TYPE_CL);

        if (Shader->shaderLayout.compute.isWorkGroupSizeFixed)
        {
            workGroupSize = Shader->shaderLayout.compute.workGroupSize[0] *
                            Shader->shaderLayout.compute.workGroupSize[1] *
                            Shader->shaderLayout.compute.workGroupSize[2];
        }
        else
        {
            workGroupSize = Shader->shaderLayout.compute.adjustedWorkGroupSize;
        }
    }

    if (workGroupSize == 0)
    {
        workGroupSize = 1;
    }

    if (WorkGroupSize)
    {
        *WorkGroupSize = workGroupSize;
    }

    /* Success. */
    gcmFOOTER_NO();
    return status;
}

/*******************************************************************************
**  gcSHADER_SetMaxKernelFunctionArgs
**
**  Set the maximum number of kernel function arguments of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 MaxKernelFunctionArgs
**          Maximum number of kernel function arguments
*/
gceSTATUS
gcSHADER_SetMaxKernelFunctionArgs(
    IN gcSHADER Shader,
    IN gctUINT32 MaxKernelFunctionArgs
    )
{
    gcmHEADER_ARG("Shader=0x%x MaxKernelFunctionArgs=%u", Shader, MaxKernelFunctionArgs);

/* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    Shader->maxKernelFunctionArgs = MaxKernelFunctionArgs;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetType
**
**  Get the gcSHADER object's type.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctINT *Type.
**          Pointer to a returned shader type.
*/
gceSTATUS
gcSHADER_GetType(
    IN gcSHADER Shader,
    OUT gcSHADER_KIND *Type
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    *Type = Shader->type;
    gcmFOOTER_ARG("*Type=%d", *Type);
    return gcvSTATUS_OK;
}

static gctUINT _shaderId = 1;

gctUINT
gcSHADER_NextId(void)
{
    return _shaderId;
}

void
gcSHADER_AlignId(void)
{
    if((_shaderId & 0xf) - 1)
    {
        _shaderId = ((_shaderId + 16) & 0xfffffff0) + 1;
    }
}

static gctBOOL
_AllowUpdateTempRegCount(
    IN gcSHADER Shader,
    IN gctUINT  RegNum
    )
{
    if (!_isHWRegisterAllocated(Shader))
    {
        return gcvTRUE;
    }

    if(RegNum < VIR_SR_Begin)
    {
        return gcvTRUE;
    }

    return gcvFALSE;
}

gctUINT32
gcSHADER_UpdateTempRegCount(
    IN gcSHADER       Shader,
    IN gctUINT        RegNum
    )
{
    if(_AllowUpdateTempRegCount(Shader, RegNum) &&
        Shader->_tempRegCount <= RegNum)
    {
        Shader->_tempRegCount = RegNum + 1;
    }
    return Shader->_tempRegCount;
}

gctUINT32
gcSHADER_EndInst(
    IN gcSHADER Shader
    )
{
    Shader->instrIndex = gcSHADER_OPCODE;
    Shader->lastInstruction++;
    return Shader->lastInstruction;
}

/*******************************************************************************
**  gcSHADER_Construct
**
**  Construct a new gcSHADER object.
**
**  INPUT:
**
**      gctINT ShaderType
**          Type of gcSHADER object to cerate.  'ShaderType' can be one of the
**          following:
**
**              gcSHADER_TYPE_VERTEX    Vertex shader.
**              gcSHADER_TYPE_FRAGMENT  Fragment shader.
**              gcSHADER_TYPE_CL  OpenCL shader.
**        gcSHADER_TYPE_PRECOMPILED
**
**  OUTPUT:
**
**      gcSHADER * Shader
**          Pointer to a variable receiving the gcSHADER object pointer.
*/
gceSTATUS
gcSHADER_Construct(
    IN gctINT ShaderType,
    OUT gcSHADER * Shader
    )
{
    gcSHADER shader;
    gceSTATUS status;
    gctINT vertexBase = 0, fragmentBase = 0;
    gctPOINTER pointer = gcvNULL;
    gceAPI apiVersion = gcvAPI_OPENGL_ES20;

    gcmHEADER_ARG("ShaderType=%d", ShaderType);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    if (ShaderType != gcSHADER_TYPE_CL)
    {
        /* will be updated later by compiler */
    }
    else
    {
        apiVersion = gcvAPI_OPENCL;
    }

#if !MIN_COMPILER
    vertexBase = GetHWHasSamplerBaseOffset() ? 0 : GetHWVertexSamplerBase();
    fragmentBase = GetHWFragmentSamplerBase();
#else
    /* TODO: use configuration data to get the sampler base */

#endif  /* MIN_COMPILER */

    /* Allocate the gcSTATUS object structure. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(struct _gcSHADER),
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFATAL("gcSHADER_Construct: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    shader = pointer;
    /* Zero the memory. */
    gcoOS_ZeroMemory(shader,
                     gcmSIZEOF(struct _gcSHADER));

    /* Initialize gcSHADER object. */
    shader->object.type = gcvOBJ_SHADER;
    shader->clientApiVersion = apiVersion;
    shader->_id = _shaderId++;
    shader->_tempRegCount = 1; /* start from 1, temp(0) is reserved for store1 dest */
    shader->_maxLocalTempRegCount = 0;

    shader->enableDefaultUBO = gcvFALSE;
    shader->_defaultUniformBlockIndex = -1;
    shader->constUniformBlockIndex = -1;

    shader->compilerVersion[0] = _SHADER_GL_LANGUAGE_TYPE | (ShaderType << 16);
    shader->compilerVersion[1] = _SHADER_ES11_VERSION;

    /* Reset all atributes, uniforms, outputs, and code. */
    shader->type                = ShaderType;
    shader->samplerIndex        = (ShaderType == gcSHADER_TYPE_VERTEX)
                                  ? vertexBase
                                  : fragmentBase;

    shader->samplerAllocStrategy = gcSHADER_ALLOC_STRATEGY_FIXED_ADDR_OFFSET;
    shader->instrIndex          = gcSHADER_OPCODE;

#if gcdUSE_WCLIP_PATCH
    shader->vsPositionZDependsOnW  = gcvFALSE;
#endif

    /* Full optimization by default */
    shader->optimizationOption  = gcvOPTIMIZATION_FULL;

#if gcdSHADER_SRC_BY_MACHINECODE
    shader->replaceIndex            = gcvMACHINECODE_COUNT;
#endif
    shader->isDual16Shader              = gcvFALSE;

    shader->RAHighestPriority                  = 0;

    /* halti extras */

    /* transform feedback supporting field members */
    shader->transformFeedback.bufferMode      = gcvFEEDBACK_INTERLEAVED;
    shader->transformFeedback.shaderTempCount = -1;

    /* 3.1 storage block */

    shader->enableDefaultStorageBlock = gcvFALSE;
    shader->_defaultStorageBlock      = (gctUINT16)-1;

    /* Source code string */
    shader->sourceLength   = 0;
    shader->source         = gcvNULL;

    /* shader RA watermark */
    shader->disableEarlyZ                   = gcvFALSE;
    shader->outputBlends                    = gcvLAYOUT_QUALIFIER_NONE;
    shader->useEarlyFragTest                = gcvFALSE;
    shader->useLastFragData                 = gcvFALSE;
    shader->useDriverTcsPatchInputVertices  = gcvFALSE;
    shader->hasNotStagesRelatedLinkError    = gcvSTATUS_OK;

#if _SUPPORT_LONG_ULONG_DATA_TYPE
    shader->InsertCount                     = 0;
    shader->InstNum                         = 0;
#endif

    /* initialize the default workGroupSize. */
    if (shader->type == gcSHADER_TYPE_COMPUTE || shader->type == gcSHADER_TYPE_CL)
    {
        /* Use the maxWorkGroupSize as the initialized value. */
        shader->shaderLayout.compute.adjustedWorkGroupSize = GetHWMaxWorkGroupSize();

        /* Default, for CS, WorkGroupSize is fixed, for OCL, it is floating. */
        if (shader->type == gcSHADER_TYPE_COMPUTE)
        {
            shader->shaderLayout.compute.isWorkGroupSizeFixed = gcvTRUE;
        }
        else
        {
            shader->shaderLayout.compute.isWorkGroupSizeFixed = gcvFALSE;
        }
    }

    /* Return gcSHADER object pointer. */
    *Shader = shader;

    /* Success. */
    gcmFOOTER_ARG("*Shader=0x%x", *Shader);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_Clean
**
**  Clean up memory used in a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      Nothing.
*/
static gceSTATUS
_gcSHADER_Clean(
    IN gcSHADER Shader
    )
{
    gctUINT i, j;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    Shader->maxKernelFunctionArgs = 0;

    if(Shader->constantMemoryBuffer) {
        gcmASSERT(Shader->constantMemorySize);
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->constantMemoryBuffer));
        Shader->constantMemorySize = 0;
    }

    Shader->privateMemorySize = 0;
    Shader->localMemorySize = 0;

    if(Shader->typeNameBuffer) {
        gcmASSERT(Shader->typeNameBufferSize);
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->typeNameBuffer));
        Shader->typeNameBufferSize = 0;
    }

    /* Free any attributes. */
    if (Shader->attributes != gcvNULL)
    {
        for (i = 0; i < Shader->attributeCount; i++)
        {
            /* Free the gcSHADER_ATTRIBUTE structure. */
            if (Shader->attributes[i] != gcvNULL)
            {
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->attributes[i]));
            }
        }

        /* Free the array of gcSHADER_ATTRIBUTE pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->attributes));
        Shader->attributeArraySize = 0;
        Shader->attributeCount = 0;
    }
    if (Shader->builtinAttributeCount > 0)
    {
        gcmASSERT(Shader->builtinAttributeCount <= 2);
        for (i = 0; i < Shader->builtinAttributeCount; i++)
        {
            /* Free the gcSHADER_ATTRIBUTE structure. */
            if (Shader->builtinAttributes[i] != gcvNULL)
            {
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->builtinAttributes[i]));
            }
        }

        Shader->builtinAttributeCount = 0;
    }

    /* Free any uniforms. */
    if (Shader->uniforms != gcvNULL)
    {
        for (i = 0; i < Shader->uniformCount; i++)
        {
            if(!Shader->uniforms[i]) continue;

            if (hasUniformKernelArgKind(Shader->uniforms[i]))
            {
                Shader->uniforms[i] = gcvNULL;
                continue;
            }

            if (Shader->uniforms[i]->arrayLengthList != gcvNULL)
            {
                gcmASSERT(Shader->uniforms[i]->arrayLengthCount > 0);
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->uniforms[i]->arrayLengthList));
            }

            /* Free the gcSHADER_UNIFORM structure. */
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->uniforms[i]));
        }

        /* Free the array of gcSHADER_UNIFORM pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->uniforms));
        Shader->uniformArraySize = 0;
        Shader->uniformCount = 0;
        Shader->uniformVectorCount  = 0;
    }

    /* Free any variables. */
    if (Shader->variables != gcvNULL)
    {
        for (i = 0; i < Shader->variableCount; i++)
        {
            if (Shader->variables[i] != gcvNULL)
            {
                if (Shader->variables[i]->arrayLengthList != gcvNULL)
                {
                    gcmASSERT(Shader->variables[i]->arrayLengthCount > 0);
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->variables[i]->arrayLengthList));
                }
                /* Free the gcVARIABLE structure. */
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->variables[i]));
            }
        }

        /* Free the array of gcVARIABLE pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->variables));
        Shader->variableArraySize = 0;
        Shader->variableCount = 0;
    }

    /* Free any outputs. */
    if (Shader->outputs != gcvNULL)
    {
        for (i = 0; i < Shader->outputCount; i++)
        {
            if (Shader->outputs[i] != gcvNULL)
            {
                /* Free the gcSHADER_OUTPUT structure. */
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->outputs[i]));
            }
        }

        /* Free the array of gcSHADER_OUTPUT pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->outputs));
        Shader->outputArraySize = 0;
        Shader->outputCount = 0;
    }

    /* Free any locations. */
    if (Shader->inputLocations != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->inputLocations));
        Shader->inputLocationArraySize = 0;
        Shader->inputLocationCount = 0;
    }

    if (Shader->outputLocations != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->outputLocations));
        Shader->outputLocationArraySize = 0;
        Shader->outputLocationCount = 0;
    }

    /* Free any uniform blocks. */
    if (Shader->uniformBlocks != gcvNULL)
    {
        for (i = 0; i < Shader->uniformBlockCount; i++)
        {
            if (Shader->uniformBlocks[i] != gcvNULL)
            {
                if(Shader->uniformBlocks[i]->uniformCount &&
                   Shader->uniformBlocks[i]->uniforms)
                {
                    /* Free the uniform block's array of uniforms. */
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->uniformBlocks[i]->uniforms));
                }

                /* Free the gcsUNIFORM_BLOCK structure. */
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->uniformBlocks[i]));
            }
        }

        /* Free the array of gcsSHADER_UNIFORM_BLOCK pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->uniformBlocks));
        Shader->uniformBlockArraySize = 0;
        Shader->uniformBlockCount = 0;
    }
    Shader->_defaultUniformBlockIndex = -1;
    Shader->constUniformBlockIndex = -1;
    Shader->constUBOSize = 0;
    if (Shader->constUBOData != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->constUBOData));
    }

    /* Free any transform feedback. */
    if (Shader->transformFeedback.varyings)
    {
        if (Shader->transformFeedback.feedbackBuffer.separateBufUniforms &&
            Shader->transformFeedback.bufferMode == gcvFEEDBACK_SEPARATE)
        {
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL,
                               Shader->transformFeedback.feedbackBuffer.separateBufUniforms));
        }
        else
        {
            Shader->transformFeedback.feedbackBuffer.interleavedBufUniform = gcvNULL;
        }
        /* free varRegInfos */
        if (Shader->transformFeedback.varRegInfos != gcvNULL)
        {
            for (i = 0; i < Shader->transformFeedback.varyingCount; i ++)
            {
                if (Shader->transformFeedback.varRegInfos[i].tempRegTypes != gcvNULL)
                {
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL,
                                    Shader->transformFeedback.varRegInfos[i].tempRegTypes));
                }
            }
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL,
                                Shader->transformFeedback.varRegInfos));
        }

        for (i = 0; i < Shader->transformFeedback.varyingCount; ++i)
        {
            if (Shader->transformFeedback.varyings[i].name)
            {
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->transformFeedback.varyings[i].name));
            }
        }
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->transformFeedback.varyings));
        Shader->transformFeedback.varyings = gcvNULL;
        Shader->transformFeedback.varyingCount = 0;
        Shader->transformFeedback.bufferMode = gcvFEEDBACK_INTERLEAVED;
        Shader->transformFeedback.stateUniform   = gcvNULL;
        Shader->transformFeedback.shaderTempCount = -1;
        Shader->transformFeedback.totalSize      = 0;
    }

    /* Free any functions. */
    if (Shader->functions != gcvNULL)
    {
        for (i = 0; i < Shader->functionCount; i++)
        {
            if (Shader->functions[i] != gcvNULL)
            {
                if (Shader->functions[i]->arguments != gcvNULL)
                {
                    /* Free the gcSHADER_FUNCTION_ARGUMENT structure. */
                    gcmVERIFY_OK(
                        gcmOS_SAFE_FREE(gcvNULL, Shader->functions[i]->arguments));
                }

                /* Free the gcSHADER_FUNCTION structure. */
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->functions[i]));
            }
        }

        /* Free the array of gcSHADER_FUNCTION pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->functions));
        Shader->functionArraySize = 0;
        Shader->functionCount = 0;
    }

    /* Free any kernel functions. */
    if (Shader->kernelFunctions != gcvNULL)
    {
        for (i = 0; i < Shader->kernelFunctionCount; i++)
        {
            if (Shader->kernelFunctions[i] != gcvNULL)
            {
                if (Shader->kernelFunctions[i]->arguments != gcvNULL)
                {
                    /* Free the gcSHADER_FUNCTION_ARGUMENT structure. */
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions[i]->arguments));
                    Shader->kernelFunctions[i]->argumentArrayCount = 0;
                    Shader->kernelFunctions[i]->argumentCount = 0;
                }

                /* Free any uniforms. */
                if (Shader->kernelFunctions[i]->uniformArguments != gcvNULL)
                {
                    for (j = 0; j < Shader->kernelFunctions[i]->uniformArgumentCount; j++)
                    {
                        /* Free the gcUNIFORM structure. */
                        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions[i]->uniformArguments[j]));
                    }

                    /* Free the array of gcUNIFORM pointers. */
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions[i]->uniformArguments));
                    Shader->kernelFunctions[i]->uniformArgumentArrayCount = 0;
                    Shader->kernelFunctions[i]->uniformArgumentCount = 0;
                }

                /* Free any variables. */
                if (Shader->kernelFunctions[i]->localVariables != gcvNULL)
                {
                    for (j = 0; j < Shader->kernelFunctions[j]->localVariableCount; j++)
                    {
                        /* Free the gcVARIABLE structure. */
                        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions[i]->localVariables[j]));
                    }

                    /* Free the array of gcVARIABLE pointers. */
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions[i]->localVariables));
                    Shader->kernelFunctions[i]->localVariableCount = 0;
                }

                /* Free any image samplers. */
                if (Shader->kernelFunctions[i]->imageSamplers != gcvNULL)
                {
                     /* Free the array of gcsIMAGE_SAMPLER pointers. */
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions[i]->imageSamplers));
                    Shader->kernelFunctions[i]->imageSamplerArrayCount = 0;
                    Shader->kernelFunctions[i]->imageSamplerCount = 0;
                }

                /* Free any properties. */
                if (Shader->kernelFunctions[i]->properties != gcvNULL)
                {
                    /* Free the gcKERNEL_FUNCTION_PROPERTY structure. */
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions[i]->properties));
                    Shader->kernelFunctions[i]->propertyArrayCount = 0;
                    Shader->kernelFunctions[i]->propertyCount = 0;
                }

                /* Free any property values. */
                if (Shader->kernelFunctions[i]->propertyValues != gcvNULL)
                {
                    /* Free the gctUINT array. */
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions[i]->propertyValues));
                    Shader->kernelFunctions[i]->propertyValueArrayCount = 0;
                    Shader->kernelFunctions[i]->propertyValueCount = 0;
                }

                /* Free the gcSHADER_FUNCTION structure. */
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions[i]));
            }
        }

        /* Free the array of gcSHADER_FUNCTION pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions));
        Shader->kernelFunctionArraySize = 0;
        Shader->kernelFunctionCount = 0;
    }

    /* Free any labels. */
    if (Shader->labels != gcvNULL)
    {
        while (Shader->labels != gcvNULL)
        {
            gcSHADER_LABEL label = Shader->labels;
            Shader->labels = label->next;

            while (label->referenced != gcvNULL)
            {
                /* Remove gcSHADER_LINK structure from head of list. */
                gcSHADER_LINK link = label->referenced;
                label->referenced = link->next;

                /* Free the gcSHADER_LINK structure. */
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, link));
            }

            /* Free the gcSHADER_LABEL structure. */
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, label));
        }
    }

    gcoOS_ZeroMemory(Shader->shaderLayout.compute.workGroupSize,
                     gcmSIZEOF(Shader->shaderLayout.compute.workGroupSize));
    Shader->shaderLayout.compute.isWorkGroupSizeFixed = gcvFALSE;
    Shader->shaderLayout.compute.isWorkGroupSizeAdjusted = gcvFALSE;
    Shader->shaderLayout.compute.adjustedWorkGroupSize = gcvFALSE;

    /* Free any storage blocks. */
    if (Shader->storageBlocks != gcvNULL)
    {
        for (i = 0; i < Shader->storageBlockCount; i++)
        {
            if (Shader->storageBlocks[i] != gcvNULL)
            {
                if (Shader->storageBlocks[i]->variables)
                {
                    /* NOTE variables have been destroyed above when destroying all variables */
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->storageBlocks[i]->variables));
                }

                /* Free the gcsSTORAGE_BLOCK structure. */
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->storageBlocks[i]));
            }
        }

        /* Free the array of gcsSHADER_STORAGE_BLOCK pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->storageBlocks));
        Shader->storageBlockArraySize = 0;
        Shader->storageBlockCount = 0;
    }

    Shader->enableDefaultStorageBlock = gcvFALSE;
    Shader->_defaultStorageBlock = (gctUINT16)-1;

    /* Free any io blocks. */
    if (Shader->ioBlocks != gcvNULL)
    {
        for (i = 0; i < Shader->ioBlockCount; i++)
        {
            if (Shader->ioBlocks[i] != gcvNULL)
            {
                gcsSHADER_VAR_INFO *blockInfo = GetSBShaderVarInfo(Shader->ioBlocks[i]);

                if (blockInfo && blockInfo->arraySizeList != gcvNULL)
                {
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, blockInfo->arraySizeList));
                }

                /* Free the gcsIO_BLOCK structure. */
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->ioBlocks[i]));
            }
        }

        /* Free the array of gcsSHADER_IO_BLOCK pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->ioBlocks));
        Shader->ioBlockArraySize = 0;
        Shader->ioBlockCount = 0;
    }

    /* Free the code buffer. */
    if (Shader->code != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->code));
    }

    /* Free the load users. */
    if (Shader->loadUsers != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->loadUsers));
    }

    /* Free Loadtime Optimization related data */

    /* LTC uniform index */
    if (Shader->ltcCodeUniformIndex != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->ltcCodeUniformIndex));
    }

    /* LTC expressions */
    if (Shader->ltcExpressions != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->ltcExpressions));
    }

    /* LTC values. */
    if (Shader->ltcUniformValues != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->ltcUniformValues));
    }

    /* Free source code string */
    if (Shader->source != gcvNULL)
    {
        gcmASSERT(Shader->sourceLength > 0);
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->source));
        Shader->sourceLength = 0;
    }

    /* Free library list */
    if (Shader->libraryList != gcvNULL)
    {
        gcLibraryList *libList = Shader->libraryList;
        gcLibraryList *nextList;
        while (libList != gcvNULL)
        {
            nextList = libList->next;
            if(libList->tempMappingTable)
            {
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, libList->tempMappingTable));
            }
            if(libList->uniformMappingTable)
            {
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, libList->uniformMappingTable));
            }
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, libList));
            libList = nextList;
        }
        Shader->libraryList = gcvNULL;
    }

    if (Shader->debugInfo)
    {
        vscDIDestroyContext((VSC_DIContext *)Shader->debugInfo);
        Shader->debugInfo = gcvNULL;
    }

#if gcdUSE_WCLIP_PATCH
    if (Shader->wClipTempIndexList)
    {
        gcSHADER_LIST list, deleteList;

        list = Shader->wClipTempIndexList;

        while (list)
        {
            deleteList = list;
            list = list->next;
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, deleteList));
        }

        Shader->wClipTempIndexList = gcvNULL;
    }

    if (Shader->wClipUniformIndexList)
    {
        gcSHADER_LIST list, deleteList;

        list = Shader->wClipUniformIndexList;

        while (list)
        {
            deleteList = list;
            list = list->next;
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, deleteList));
        }

        Shader->wClipUniformIndexList = gcvNULL;
    }
#endif

    Shader->useEarlyFragTest = gcvFALSE;
    Shader->useLastFragData = gcvFALSE;
    Shader->hasNotStagesRelatedLinkError = gcvSTATUS_OK;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_Destroy
**
**  Destroy a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_Destroy(
    IN gcSHADER Shader
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    _gcSHADER_Clean(Shader);

    /* Mark the gcSHADER object as unknown. */
    Shader->object.type = gcvOBJ_UNKNOWN;

    /* Free the gcSHADER object structure. */
    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader));

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gctINT
gcSHADER_GetOutputDefaultLocation(
    IN gcSHADER Shader
    )
{
    gctINT defaultLocation = -1;

    if (gcUseFullNewLinker(GetHWHasHalti2()))
    {
        defaultLocation = -1;
    }
    else
    {
        defaultLocation = (gctINT)GetShaderOutputCount(Shader);
    }

    return defaultLocation;
}

gctBOOL
gcSHADER_IsESCompiler(
    IN gcSHADER Shader
    )
{
    gctBOOL esCompiler;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    esCompiler = (Shader->compilerVersion[0] & 0xFFFF) == _SHADER_GL_LANGUAGE_TYPE;

    gcmFOOTER_ARG("esCompiler=%d", esCompiler);
    return esCompiler;
}

gctBOOL
gcSHADER_IsHaltiCompiler(
    IN gcSHADER Shader
    )
{
    gctBOOL haltiCompiler;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    haltiCompiler = ((Shader->compilerVersion[0] & 0xFFFF) == _SHADER_GL_LANGUAGE_TYPE &&
                     (Shader->compilerVersion[1] == _SHADER_HALTI_VERSION || Shader->compilerVersion[1] == _SHADER_ES31_VERSION || Shader->compilerVersion[1] == _SHADER_ES32_VERSION))
                    || ((Shader->compilerVersion[0] & 0xFFFF) == _SHADER_DX_LANGUAGE_TYPE);

    gcmFOOTER_ARG("haltiCompiler=%d", haltiCompiler);
    return haltiCompiler;
}

gctBOOL
gcSHADER_IsES31Compiler(
    IN gcSHADER Shader
    )
{
    gctBOOL isES31Compiler;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    isES31Compiler = ((Shader->compilerVersion[0] & 0xFFFF) == _SHADER_GL_LANGUAGE_TYPE &&
                    Shader->compilerVersion[1] == _SHADER_ES31_VERSION);

    gcmFOOTER_ARG("isES31Compiler=%d", isES31Compiler);
    return isES31Compiler;
}

gctBOOL
gcSHADER_IsES32Compiler(
    IN gcSHADER Shader
    )
{
    gctBOOL isES32Compiler;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    isES32Compiler = ((Shader->compilerVersion[0] & 0xFFFF) == _SHADER_GL_LANGUAGE_TYPE &&
                    Shader->compilerVersion[1] == _SHADER_ES32_VERSION);

    gcmFOOTER_ARG("isES32Compiler=%d", isES32Compiler);
    return isES32Compiler;
}

/** SHADER binary file header format: -
       Word 1:  gcmCC('S', 'H', 'D', 'R') shader binary file signature
       Word 2:  ('\od' '\od' '\od' '\od') od = octal digits; binary file version
       Word 3: chipModel
       Word 4: chipRevision
       Word 5:  ('\E' '\S' '\0' '\0') | gcSHADER_TYPE_VERTEX << 16   or
                ('E' 'S' '\0' '\0') | gcSHADER_TYPE_FRAGMENT << 16 or
                ('C' 'L' '\0' '\0') | gcSHADER_TYPE_CL << 16
       Word 6: ('\od' '\od' '\od' '\od') od = octal digits; compiler version
       Word 7: flags of shader
       Word 8: client api version.
       Word 9: size of shader binary file in bytes excluding this header */
#define _gcdShaderBinaryHeaderSize   (9 * 4)  /*Shader binary file header size in bytes*/

static gctUINT32 _getShaderBinaryHeaderSize(gctUINT32 shaderVersion)
{
    if (shaderVersion > gcdSL_SHADER_BINARY_VERSION_9_19_2013)
    {
        return _gcdShaderBinaryHeaderSize;
    }
    else
    {
        return _gcdShaderBinaryHeaderSize - 4;
    }
}

gceSTATUS
gcSHADER_Copy(
    IN gcSHADER Shader,
    IN gcSHADER Source
    )
{
    gceSTATUS status;
    gctUINT32 i, bytes;
    gcSHADER_LABEL srcLabel, label;
    gcSHADER_LINK srcReference, reference;

    gcmHEADER_ARG("Shader=0x%x Source=0x%x", Shader, Source);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(Source, gcvOBJ_SHADER);

    /* Free the resources. */
    gcmONERROR(_gcSHADER_Clean(Shader));

    /* copy the original id */
    Shader->_id = Source->_id;
    Shader->_stringId = Source->_stringId;
    Shader->_constVectorId = Source->_constVectorId;
    Shader->_dummyUniformCount = Source->_dummyUniformCount;
    Shader->_tempRegCount = Source->_tempRegCount;
    Shader->_maxLocalTempRegCount = Source->_maxLocalTempRegCount;
    Shader->enableDefaultUBO = Source->enableDefaultUBO;
    Shader->_defaultUniformBlockIndex = Source->_defaultUniformBlockIndex;
    Shader->enableDefaultStorageBlock = Source->enableDefaultStorageBlock;
    Shader->_defaultStorageBlock = Source->_defaultStorageBlock;
    Shader->constUniformBlockIndex = Source->constUniformBlockIndex;
    Shader->constUBOSize = 0;
    Shader->constUBOData = gcvNULL;

    Shader->maxKernelFunctionArgs = Source->maxKernelFunctionArgs;
    Shader->constantMemorySize = Source->constantMemorySize;
    if(Source->constantMemorySize)
    {
        gctPOINTER pointer;

        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  gcmSIZEOF(gctCHAR) * Source->constantMemorySize,
                                  &pointer));
        Shader->constantMemoryBuffer = pointer;

        gcoOS_MemCopy(Shader->constantMemoryBuffer,
                      Source->constantMemoryBuffer,
                      Source->constantMemorySize);
    }
    else Shader->constantMemoryBuffer = gcvNULL;

    Shader->privateMemorySize = Source->privateMemorySize;
    Shader->localMemorySize = Source->localMemorySize;

    Shader->typeNameBufferSize = Source->typeNameBufferSize;
    if(Source->typeNameBufferSize)
    {
        gctPOINTER pointer;

        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  gcmSIZEOF(gctCHAR) * Source->typeNameBufferSize,
                                  &pointer));
        Shader->typeNameBuffer = pointer;

        gcoOS_MemCopy(Shader->typeNameBuffer,
                      Source->typeNameBuffer,
                      Source->typeNameBufferSize);
    }
    else Shader->typeNameBuffer = gcvNULL;

    /* Copy the shader type. */
    Shader->type               = Source->type;
    Shader->flags              = Source->flags;
    Shader->optimizationOption = Source->optimizationOption;
    Shader->compilerVersion[0] = Source->compilerVersion[0];
    Shader->compilerVersion[1] = Source->compilerVersion[1];
    Shader->clientApiVersion   = Source->clientApiVersion;
    Shader->useDriverTcsPatchInputVertices = Source->useDriverTcsPatchInputVertices;
    Shader->hasNotStagesRelatedLinkError   = Source->hasNotStagesRelatedLinkError;

    /* Copy the shaderLayout */
    switch (Shader->type)
    {
    case gcSHADER_TYPE_COMPUTE:
        Shader->shaderLayout.compute.workGroupSize[0] = Source->shaderLayout.compute.workGroupSize[0];
        Shader->shaderLayout.compute.workGroupSize[1] = Source->shaderLayout.compute.workGroupSize[1];
        Shader->shaderLayout.compute.workGroupSize[2] = Source->shaderLayout.compute.workGroupSize[2];

        Shader->shaderLayout.compute.isWorkGroupSizeFixed = Source->shaderLayout.compute.isWorkGroupSizeFixed;
        Shader->shaderLayout.compute.isWorkGroupSizeAdjusted = Source->shaderLayout.compute.isWorkGroupSizeAdjusted;
        Shader->shaderLayout.compute.adjustedWorkGroupSize = Source->shaderLayout.compute.adjustedWorkGroupSize;
        break;

    case gcSHADER_TYPE_TES:
        Shader->shaderLayout.tes.tessOrdering = Source->shaderLayout.tes.tessOrdering;
        Shader->shaderLayout.tes.tessPointMode = Source->shaderLayout.tes.tessPointMode;
        Shader->shaderLayout.tes.tessPatchInputVertices = Source->shaderLayout.tes.tessPatchInputVertices;
        Shader->shaderLayout.tes.tessPrimitiveMode = Source->shaderLayout.tes.tessPrimitiveMode;
        Shader->shaderLayout.tes.tessVertexSpacing = Source->shaderLayout.tes.tessVertexSpacing;
        break;

    case gcSHADER_TYPE_TCS:
        Shader->shaderLayout.tcs.tcsPatchInputVertices = Source->shaderLayout.tcs.tcsPatchInputVertices;
        Shader->shaderLayout.tcs.tcsInputVerticesUniform = Source->shaderLayout.tcs.tcsInputVerticesUniform;
        Shader->shaderLayout.tcs.tcsPatchOutputVertices = Source->shaderLayout.tcs.tcsPatchOutputVertices;
        break;

    case gcSHADER_TYPE_GEOMETRY:
        Shader->shaderLayout.geo.geoInvocations = Source->shaderLayout.geo.geoInvocations;
        Shader->shaderLayout.geo.geoMaxVertices = Source->shaderLayout.geo.geoMaxVertices;
        Shader->shaderLayout.geo.geoInPrimitive = Source->shaderLayout.geo.geoInPrimitive;
        Shader->shaderLayout.geo.geoOutPrimitive = Source->shaderLayout.geo.geoOutPrimitive;
        break;

    default:
        break;
    }

#if gcdUSE_WCLIP_PATCH
    Shader->vsPositionZDependsOnW = Source->vsPositionZDependsOnW;
#endif

    /***** Attributes *********************************************************/

    if (Source->attributeCount > 0)
    {
        /* Allocate the attribute array. */
        gcmONERROR(gcoOS_Allocate(
            gcvNULL,
            Source->attributeCount * gcmSIZEOF(gcATTRIBUTE),
            (gctPOINTER *) &Shader->attributes));

        /* Zero the memory. */
        gcoOS_ZeroMemory(
            Shader->attributes,
            Source->attributeCount * gcmSIZEOF(gcATTRIBUTE));

        /* Copy all attributes. */
        for (i = 0; i < Source->attributeCount; i++)
        {
            /* CHeck if we have a valid source attribute. */
            if (Source->attributes[i] != gcvNULL)
            {
                /* Get the number of bytes for this attribute, based on the
                ** name. */
                if ((gctINT) Source->attributes[i]->nameLength < 0)
                {
                    /* Predefined name. */
                    bytes = gcmOFFSETOF(_gcATTRIBUTE, name);
                }
                else
                {
                    /* User name. */
                    bytes = gcmOFFSETOF(_gcATTRIBUTE, name)
                          + Source->attributes[i]->nameLength
                          + 1;
                }

                /* Allocate the attribute. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          bytes,
                                          (gctPOINTER *) &Shader->attributes[i]));

                /* Copy the attribute. */
                gcoOS_MemCopy(Shader->attributes[i],
                              Source->attributes[i],
                              bytes);
            }
        }
    }

    /* Copy the attribute count. */
    Shader->attributeArraySize = Source->attributeCount;
    Shader->attributeCount      = Source->attributeCount;

    /***** Uniforms ***********************************************************/

    if (Source->uniformCount > 0)
    {
        /* Allocate the uniform array. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  Source->uniformCount * gcmSIZEOF(gcUNIFORM),
                                  (gctPOINTER *) &Shader->uniforms));

        /* Zero the memory. */
        gcoOS_ZeroMemory(
            Shader->uniforms,
            Source->uniformCount * gcmSIZEOF(gcUNIFORM));

        /* Copy all uniforms. */
        for (i = 0; i < Source->uniformCount; i++)
        {
            /* CHeck if we have a valid source uniform. */
            if (Source->uniforms[i] != gcvNULL)
            {
                /* Get the number of bytes for this uniform. */
                bytes = gcmOFFSETOF(_gcUNIFORM, name)
                      + Source->uniforms[i]->nameLength
                      + 1;

                /* Allocate the uniform. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          bytes,
                                          (gctPOINTER *) &Shader->uniforms[i]));

                /* Copy the uniform. */
                gcoOS_MemCopy(Shader->uniforms[i],
                              Source->uniforms[i],
                              bytes);

                if (Source->uniforms[i]->arrayLengthCount > 0)
                {
                    gctPOINTER pointer;
                    gctUINT32 j;

                    gcmONERROR(gcoOS_Allocate(gcvNULL, gcmSIZEOF(gctINT) * Source->uniforms[i]->arrayLengthCount, &pointer));
                    gcoOS_ZeroMemory(pointer, gcmSIZEOF(gctINT) * Source->uniforms[i]->arrayLengthCount);
                    Shader->uniforms[i]->arrayLengthList= pointer;

                    for (j = 0; j < (gctUINT32)(Source->uniforms[i]->arrayLengthCount); j++)
                    {
                        Shader->uniforms[i]->arrayLengthList[j] = Source->uniforms[i]->arrayLengthList[j];
                    }
                }
                else
                {
                    Shader->uniforms[i]->arrayLengthList = gcvNULL;
                }
            }
            else
            {
                /* Not a valid uniform. */
                Shader->uniforms[i] = gcvNULL;
            }
        }
    }

    /* Copy the uniform count. */
    Shader->uniformArraySize    = Source->uniformCount;
    Shader->uniformCount        = Source->uniformCount;
    Shader->samplerIndex        = Source->samplerIndex;

    /***** Uniform blocks ***********************************************************/

    if (Source->uniformBlockCount > 0)
    {
        /* Allocate the uniform block array. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  Source->uniformBlockCount * gcmSIZEOF(gcsUNIFORM_BLOCK),
                                  (gctPOINTER *) &Shader->uniformBlocks));

        /* Zero the memory. */
        gcoOS_ZeroMemory(
            Shader->uniformBlocks,
            Source->uniformBlockCount * gcmSIZEOF(gcsUNIFORM_BLOCK));

        /* Copy all uniform blocks. */
        for (i = 0; i < Source->uniformBlockCount; i++)
        {
            /* CHeck if we have a valid source uniform block. */
            if (Source->uniformBlocks[i] != gcvNULL)
            {
                /* Get the number of bytes for this uniform. */
                bytes = gcmOFFSETOF(_gcsUNIFORM_BLOCK, name)
                      + Source->uniformBlocks[i]->nameLength
                      + 1;

                /* Allocate the uniform. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          bytes,
                                          (gctPOINTER *) &Shader->uniformBlocks[i]));

                /* Copy the uniform block. */
                gcoOS_MemCopy(Shader->uniformBlocks[i],
                              Source->uniformBlocks[i],
                              bytes);

                /* Reset local data */
                /*Shader->uniformBlocks[i]->uniformCount = 0;
                Shader->uniformBlocks[i]->uniforms = gcvNULL;*/
                Shader->uniformBlocks[i]->uniformCount = Source->uniformBlocks[i]->uniformCount;
                if(Shader->uniformBlocks[i]->uniformCount)
                {
                    gctUINT j;
                    gcmONERROR(gcoOS_Allocate(gcvNULL,
                                              Shader->uniformBlocks[i]->uniformCount * gcmSIZEOF(gcUNIFORM),
                                              (gctPOINTER *) &Shader->uniformBlocks[i]->uniforms));
                    for(j = 0; j < Shader->uniformBlocks[i]->uniformCount; j++)
                    {
                        gctUINT k;
                        for(k = 0; k < Shader->uniformCount; k++)
                        {
                            if(Shader->uniforms[k]->index == Source->uniformBlocks[i]->uniforms[j]->index)
                            {
                                Shader->uniformBlocks[i]->uniforms[j] = Shader->uniforms[k];
                                break;
                            }
                        }
                    }
                }
                else
                {
                    Shader->uniformBlocks[i]->uniforms = gcvNULL;
                }

            }
            else
            {
                /* Not a valid uniform block. */
                Shader->uniformBlocks[i] = gcvNULL;
            }
        }
    }

    /* Copy the uniform block count. */
    Shader->uniformBlockArraySize = Source->uniformBlockCount;
    Shader->uniformBlockCount = Source->uniformBlockCount;

    /***** Outputs ************************************************************/

    if (Source->outputCount > 0)
    {
        /* Allocate the output array. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  Source->outputCount * gcmSIZEOF(gcOUTPUT),
                                  (gctPOINTER *) &Shader->outputs));

        /* Zero the memory. */
        gcoOS_ZeroMemory(
            Shader->outputs,
            Source->outputCount * gcmSIZEOF(gcOUTPUT));

        /* Copy all outputs. */
        for (i = 0; i < Source->outputCount; i++)
        {
            /* CHeck if we have a valid source output. */
            if (Source->outputs[i] != gcvNULL)
            {
                /* Get the number of bytes for this output, based on the
                ** name. */
                if ((gctINT) Source->outputs[i]->nameLength < 0)
                {
                    /* Predefined name. */
                    bytes = gcmOFFSETOF(_gcOUTPUT, name);
                }
                else
                {
                    /* User name. */
                    bytes = gcmOFFSETOF(_gcOUTPUT, name)
                          + Source->outputs[i]->nameLength
                          + 1;
                }

                /* Allocate the output. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          bytes,
                                          (gctPOINTER *) &Shader->outputs[i]));

                /* Copy the output. */
                gcoOS_MemCopy(Shader->outputs[i],
                              Source->outputs[i],
                              bytes);
            }
            else
            {
                /* Not a valid output. */
                Shader->outputs[i] = gcvNULL;
            }
        }
    }

    /* Copy the output count. */
    Shader->outputArraySize = Source->outputCount;
    Shader->outputCount      = Source->outputCount;

    /***** Locations ************************************************************/

    if (Source->inputLocationCount > 0)
    {
        /* Allocate the location array. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  Source->inputLocationCount * gcmSIZEOF(gctINT),
                                  (gctPOINTER *) &Shader->inputLocations));

        /* Zero the memory. */
        gcoOS_ZeroMemory(
            Shader->inputLocations,
            Source->inputLocationCount * gcmSIZEOF(gctINT));

        /* Copy all locations. */
        for (i = 0; i < Source->inputLocationCount; i++)
        {
            Shader->inputLocations[i] = Source->inputLocations[i];
        }
    }

    /* Copy the location count. */
    Shader->inputLocationArraySize = Source->inputLocationCount;
    Shader->inputLocationCount = Source->inputLocationCount;

    if (Source->outputLocationCount > 0)
    {
        /* Allocate the location array. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  Source->outputLocationCount * gcmSIZEOF(gctINT),
                                  (gctPOINTER *) &Shader->outputLocations));

        /* Zero the memory. */
        gcoOS_ZeroMemory(
            Shader->outputLocations,
            Source->outputLocationCount * gcmSIZEOF(gctINT));

        /* Copy all locations. */
        for (i = 0; i < Source->outputLocationCount; i++)
        {
            Shader->outputLocations[i] = Source->outputLocations[i];
        }
    }

    /* Copy the location count. */
    Shader->outputLocationArraySize = Source->outputLocationCount;
    Shader->outputLocationCount = Source->outputLocationCount;

    /***** Variables **********************************************************/

    if (Source->variableCount > 0)
    {
        /* Allocate the variable array. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  Source->variableCount * gcmSIZEOF(gcVARIABLE),
                                  (gctPOINTER *) &Shader->variables));

        /* Zero the memory. */
        gcoOS_ZeroMemory(
            Shader->variables,
            Source->variableCount * gcmSIZEOF(gcVARIABLE));

        /* Copy all variables. */
        for (i = 0; i < Source->variableCount; i++)
        {
            /* CHeck if we have a valid source variable. */
            if (Source->variables[i] != gcvNULL)
            {
                /* Get the number of bytes for this variable. */
                if ((gctINT) Source->variables[i]->nameLength < 0)
                {
                    /* Predefined name. */
                    bytes = gcmOFFSETOF(_gcVARIABLE, name);
                }
                else
                {
                    /* User name. */
                    bytes = gcmOFFSETOF(_gcVARIABLE, name)
                          + Source->variables[i]->nameLength
                          + 1;
                }

                /* Allocate the variable. */
                gcmONERROR(gcoOS_Allocate(
                    gcvNULL,
                    bytes,
                    (gctPOINTER *) &Shader->variables[i]));

                /* Copy the variable. */
                gcoOS_MemCopy(Shader->variables[i],
                              Source->variables[i],
                              bytes);

                if (Source->variables[i]->arrayLengthCount > 0)
                {
                    gctPOINTER pointer;
                    gctUINT32 j;

                    gcmONERROR(gcoOS_Allocate(gcvNULL, gcmSIZEOF(gctINT) * Source->variables[i]->arrayLengthCount, &pointer));
                    gcoOS_ZeroMemory(pointer, gcmSIZEOF(gctINT) * Source->variables[i]->arrayLengthCount);
                    Shader->variables[i]->arrayLengthList= pointer;

                    for (j = 0; j < (gctUINT32)(Source->variables[i]->arrayLengthCount); j++)
                    {
                        Shader->variables[i]->arrayLengthList[j] = Source->variables[i]->arrayLengthList[j];
                    }
                }
                else
                {
                    Shader->variables[i]->arrayLengthList = gcvNULL;
                }
            }
            else
            {
                /* Not a valid variable. */
                Shader->variables[i] = gcvNULL;
            }
        }
    }

    /* Copy the variable count. */
    Shader->variableArraySize = Source->variableCount;
    Shader->variableCount      = Source->variableCount;

    /***** Functions **********************************************************/

    if (Source->functionCount > 0)
    {
        /* Allocate the function array. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  Source->functionCount * gcmSIZEOF(gcFUNCTION),
                                  (gctPOINTER *) &Shader->functions));

        /* Zero the memory. */
        gcoOS_ZeroMemory(
            Shader->functions,
            Source->functionCount * gcmSIZEOF(gcFUNCTION));

        /* Copy all functions. */
        for (i = 0; i < Source->functionCount; i++)
        {
            /* CHeck if we have a valid source function. */
            if (Source->functions[i] != gcvNULL)
            {
                /* Get the number of bytes for this function. */
                bytes = gcmOFFSETOF(_gcsFUNCTION, name)
                      + Source->functions[i]->nameLength
                      + 1;

                /* Allocate the function. */
                gcmONERROR(gcoOS_Allocate(
                    gcvNULL,
                    bytes,
                    (gctPOINTER *) &Shader->functions[i]));

                /* Copy the function. */
                gcoOS_MemCopy(Shader->functions[i],
                              Source->functions[i],
                              bytes);

                /* Copy flags */
                Shader->functions[i]->flags = Source->functions[i]->flags;

                /* Copy the argument count. */
                Shader->functions[i]->argumentArrayCount =
                    Source->functions[i]->argumentCount;
                Shader->functions[i]->argumentCount      =
                    Source->functions[i]->argumentCount;
                Shader->functions[i]->packedAwayArgNo      =
                    Source->functions[i]->packedAwayArgNo;

                /* Copy temp register start index, end index and count. */
                Shader->functions[i]->tempIndexStart =
                    Source->functions[i]->tempIndexStart;
                Shader->functions[i]->tempIndexEnd =
                    Source->functions[i]->tempIndexEnd;
                Shader->functions[i]->tempIndexCount      =
                    Source->functions[i]->tempIndexCount;
                Shader->functions[i]->die =
                    Source->functions[i]->die;

                /* Allocate the arguments. */
                if (Shader->functions[i]->argumentCount > 0)
                {
                    /* Get the number of bytes for the arguments. */
                    bytes = Shader->functions[i]->argumentCount
                          * gcmSIZEOF(gcsFUNCTION_ARGUMENT);

                    /* Allocate the arguments. */
                    gcmONERROR(gcoOS_Allocate(
                        gcvNULL,
                        bytes,
                        (gctPOINTER *) &Shader->functions[i]->arguments));

                    /* Copy the arguments. */
                    gcoOS_MemCopy(Shader->functions[i]->arguments,
                                  Source->functions[i]->arguments,
                                  bytes);
                }
                else
                {
                    /* No arguments. */
                    Shader->functions[i]->arguments = gcvNULL;
                }

                /* Determine the current function. */
                if (Source->currentFunction == Source->functions[i])
                {
                    Shader->currentFunction = Shader->functions[i];
                }
            }
            else
            {
                /* Not a valid variable. */
                Shader->variables[i] = gcvNULL;
            }
        }
    }
    /* Copy the function count. */
    Shader->functionArraySize = Source->functionCount;
    Shader->functionCount      = Source->functionCount;
    Shader->currentFunction    = Source->currentFunction;

    /***** Labels *************************************************************/

    /* Copy all labels. */
    for (srcLabel = Source->labels;
         srcLabel != gcvNULL;
         srcLabel = srcLabel->next
    )
    {
        /* Allocate the label. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  gcmSIZEOF(struct _gcSHADER_LABEL),
                                  (gctPOINTER *) &label));

        /* Copy the label. */
        label->next       = Shader->labels;
        label->label      = srcLabel->label;
        label->defined    = srcLabel->defined;
        label->referenced = gcvNULL;
        Shader->labels    = label;

        /* Copy all references. */
        for (srcReference = srcLabel->referenced;
             srcReference != gcvNULL;
             srcReference = srcReference->next
        )
        {
            /* Allocate the reference. */
            gcmONERROR(gcoOS_Allocate(gcvNULL,
                                      gcmSIZEOF(struct _gcSHADER_LINK),
                                      (gctPOINTER *) &reference));

            /* Copy the reference. */
            reference->next       = label->referenced;
            reference->referenced = srcReference->referenced;
            label->referenced     = reference;
        }
    }

    /***** Storage blocks ***********************************************************/

    if (Source->storageBlockCount > 0)
    {
        /* Allocate the storage block array. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  Source->storageBlockCount * gcmSIZEOF(gcsSTORAGE_BLOCK),
                                  (gctPOINTER *) &Shader->storageBlocks));

        /* Zero the memory. */
        gcoOS_ZeroMemory(Shader->storageBlocks,
                         Source->storageBlockCount * gcmSIZEOF(gcsSTORAGE_BLOCK));

        /* Copy all storage blocks. */
        for (i = 0; i < Source->storageBlockCount; i++)
        {
            /* CHeck if we have a valid source storage block. */
            if (Source->storageBlocks[i] != gcvNULL)
            {
                /* Get the number of bytes for this storage block. */
                bytes = gcmOFFSETOF(_gcsSTORAGE_IO_BLOCK, name)
                      + Source->storageBlocks[i]->nameLength
                      + 1;

                /* Allocate the storage block. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          bytes,
                                          (gctPOINTER *) &Shader->storageBlocks[i]));

                /* Copy the storage block. */
                gcoOS_MemCopy(Shader->storageBlocks[i],
                              Source->storageBlocks[i],
                              bytes);

                /* Variables within SSB are created-on-demand. */
                Shader->storageBlocks[i]->variableCount = 0;
                Shader->storageBlocks[i]->variables = gcvNULL;
            }
            else
            {
                /* Not a valid storage block. */
                Shader->storageBlocks[i] = gcvNULL;
            }
        }
        /* Copy the uniform block count. */
        Shader->storageBlockArraySize = Source->storageBlockArraySize;
        Shader->storageBlockCount = Source->storageBlockCount;
    }

    /***** io blocks ***********************************************************/

    if (Source->ioBlockCount > 0)
    {
        /* Allocate the io block array. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  Source->ioBlockCount * gcmSIZEOF(gcsIO_BLOCK),
                                  (gctPOINTER *) &Shader->ioBlocks));

        /* Zero the memory. */
        gcoOS_ZeroMemory(Shader->ioBlocks,
                         Source->ioBlockCount * gcmSIZEOF(gcsIO_BLOCK));

        /* Copy all io blocks. */
        for (i = 0; i < Source->ioBlockCount; i++)
        {
            /* CHeck if we have a valid source io block. */
            if (Source->ioBlocks[i] != gcvNULL)
            {
                gcsSHADER_VAR_INFO *blockInfo = GetSBShaderVarInfo(Source->ioBlocks[i]);
                gcsSHADER_VAR_INFO *newBlockInfo;

                /* Get the number of bytes for this io block */
                if (Source->ioBlocks[i]->nameLength > 0)
                {
                bytes = gcmOFFSETOF(_gcsSTORAGE_IO_BLOCK, name)
                      + Source->ioBlocks[i]->nameLength
                      + Source->ioBlocks[i]->instanceNameLength
                      + 1;

                if (Source->ioBlocks[i]->instanceNameLength > 0)
                {
                    bytes++;
                }
                }
                else
                {
                    bytes = gcmOFFSETOF(_gcsSTORAGE_IO_BLOCK, name);
                }

                /* Allocate the io block. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          bytes,
                                          (gctPOINTER *) &Shader->ioBlocks[i]));

                /* Copy the io block. */
                gcoOS_MemCopy(Shader->ioBlocks[i],
                              Source->ioBlocks[i],
                              bytes);

                if (blockInfo && blockInfo->arraySizeList != gcvNULL)
                {
                    newBlockInfo = GetSBShaderVarInfo(Shader->ioBlocks[i]);
                    gcmONERROR(gcoOS_Allocate(gcvNULL,
                                              gcmSIZEOF(gctINT32),
                                              (gctPOINTER *) &newBlockInfo->arraySizeList));
                    newBlockInfo->arraySizeList[0] = blockInfo->arraySizeList[0];
                }
            }
            else
            {
                /* Not a valid io block. */
                Shader->ioBlocks[i] = gcvNULL;
            }
        }
        /* Copy the uniform block count. */
        Shader->ioBlockArraySize = Source->ioBlockArraySize;
        Shader->ioBlockCount = Source->ioBlockCount;
    }


    /***** Code ***************************************************************/

    /* Copy the code count. */
    Shader->codeCount       = Source->codeCount;
    Shader->lastInstruction = Source->lastInstruction;
    Shader->instrIndex      = Source->instrIndex;

    /* Copy the instructions. */
    if (Shader->codeCount > 0)
    {
        /* Get the number of bytes for all the instructions. */
        bytes = Shader->codeCount * gcmSIZEOF(struct _gcSL_INSTRUCTION);

        /* Allocate the instructions. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  bytes,
                                  (gctPOINTER *) &Shader->code));

        /* Copy the instructions. */
        gcoOS_MemCopy(Shader->code, Source->code, bytes);
    }

    /* Loadtime Optimization related data */

    /* LTC uniform index */
    Shader->ltcUniformCount = Source->ltcUniformCount;

    Shader->ltcUniformBegin = Source->ltcUniformBegin;

    /* LTC expressions */
    Shader->ltcInstructionCount = Source->ltcInstructionCount;

    if (Shader->ltcInstructionCount > 0)
    {
        bytes = sizeof(*Shader->ltcCodeUniformIndex) * Shader->ltcInstructionCount;

        /* Allocate memory for  ltcCodeUniformIndex inside the gcSHADER object. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  bytes,
                                  (gctPOINTER *) &Shader->ltcCodeUniformIndex));

        /* Copy the ltcCodeUniformIndex. */
        gcoOS_MemCopy(Shader->ltcCodeUniformIndex,
                      Source->ltcCodeUniformIndex,
                      bytes);
        bytes = sizeof(*Shader->ltcExpressions) * Shader->ltcInstructionCount;
        /* Allocate memory for  ltcExpressions inside the gcSHADER object. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  bytes,
                                  (gctPOINTER *) &Shader->ltcExpressions));

        /* Copy the ltcExpressions. */
        gcoOS_MemCopy(Shader->ltcExpressions,
                      Source->ltcExpressions,
                      bytes);
    }

    /* LTC values. */
    if (Source->ltcUniformValues != gcvNULL)
    {
        bytes = GetShaderLtcUniformCount(Shader) * sizeof(LTCValue);
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  bytes,
                                  (gctPOINTER *) &Shader->ltcUniformValues));
        /* Copy the ltcExpressions. */
        gcoOS_MemCopy(Shader->ltcUniformValues,
                      Source->ltcUniformValues,
                      bytes);
    }

#if gcdUSE_WCLIP_PATCH
    if (Source->wClipTempIndexList)
    {
        gcSHADER_LIST list;

        for (list = Source->wClipTempIndexList; list; list = list->next)
        {
            gcmONERROR(gcSHADER_InsertList(Shader, &Shader->wClipTempIndexList, list->index, list->data0, list->data1));
        }
    }

    if (Source->wClipUniformIndexList)
    {
        gcSHADER_LIST list;

        for (list = Source->wClipUniformIndexList; list; list = list->next)
        {
            gcmONERROR(gcSHADER_InsertList(Shader, &Shader->wClipUniformIndexList, list->index, list->data0, list->data1));
        }
    }
#endif

    /* Source code string */
    Shader->sourceLength = Source->sourceLength;
    if (Shader->sourceLength > 0)
    {
        bytes = Source->sourceLength;
        /* Allocate memory for source inside the gcSHADER object. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  bytes,
                                  (gctPOINTER *) &Shader->source));

        /* Copy the source code string. */
        gcoOS_MemCopy(Shader->source, Source->source, bytes);
    }
    else
    {
        Shader->source = gcvNULL;
    }

    Shader->libraryList           = gcvNULL;

    Shader->RARegWaterMark        = Source->RARegWaterMark;
    Shader->RATempReg             = Source->RARegWaterMark;
    Shader->RAHighestPriority     = Source->RAHighestPriority;

    Shader->disableEarlyZ         = Source->disableEarlyZ;
    Shader->outputBlends          = Source->outputBlends;
    Shader->useEarlyFragTest      = Source->useEarlyFragTest;
    Shader->useLastFragData       = Source->useLastFragData;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;

OnError:
    /* Return the status. */
    gcmFOOTER();
    return status;
}

/*******************************************************************************
**  gcSHADER_LoadHeader
**
**  Load a gcSHADER object from a binary buffer.  The binary buffer is layed out
**  as follows:
**      // Six word header
**      // Signature, must be 'S','H','D','R'.
**      gctINT8             signature[4];
**      gctUINT32           binFileVersion;
**      gctUINT32           compilerVersion[2];
**      gctUINT32           gcSLVersion;
**      gctUINT32           binarySize;
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**          Shader type will be returned if type in shader object is not gcSHADER_TYPE_PRECOMPILED
**
**      gctPOINTER Buffer
**          Pointer to a binary buffer containing the shader data to load.
**
**      gctUINT32 BufferSize
**          Number of bytes inside the binary buffer pointed to by 'Buffer'.
**
**  OUTPUT:
**      nothing
**
*/
gceSTATUS
gcSHADER_LoadHeader(
    IN gcSHADER     Shader,
    IN gctPOINTER   Buffer,
    IN gctUINT32    BufferSize,
    OUT gctUINT32 * ShaderVersion
    )
{
    gceOBJECT_TYPE * signature;
    gctUINT32 bytes;
    gctUINT32 *version;
    gctUINT32 *chipModel;
    gctUINT32 *chipRevision;
    gctUINT32 *flags;
    gctUINT32 *size;
    gctUINT32 *apiVersion;
    gctUINT8 *bytePtr;

    gcmHEADER_ARG("Shader=0x%x Buffer=0x%x BufferSize=%lu",
                  Shader, Buffer, BufferSize);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Buffer != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(BufferSize > 0);

    /* Load the Header */
    bytes = BufferSize;
    if(bytes < _gcdShaderBinaryHeaderSize) {
        /* Invalid file format */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Verify the signature. */
    signature = (gceOBJECT_TYPE *) Buffer;
    if (*signature != gcvOBJ_SHADER) {
        /* Signature mismatch. */
        gcoOS_Print("gcSHADER_LoadHeader: Signature does not match with 'SHDR'");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Word 2: binary file version # */
    version = (gctUINT32 *) (signature + 1);
    *ShaderVersion = *version;
    /* we may need to check if the major version is changed, we should be able to
     * break backward compatibility between major versions */
    if(*version != gcdSL_SHADER_BINARY_FILE_VERSION) {
        /* for now, we don't support shader file format forward compatibility */
        gctUINT8 *inputVerPtr, *curVerPtr;
        gctUINT32 curVer[1] = {gcdSL_SHADER_BINARY_FILE_VERSION};

        inputVerPtr = (gctUINT8 *) version;
        curVerPtr = (gctUINT8 *) curVer;
        gcoOS_Print("gcSHADER_LoadHeader: shader binary file's version of %u.%u.%u:%u "
                 "is not compatible with current version %u.%u.%u:%u\n"
                 "Please recompile source.",
                 inputVerPtr[0], inputVerPtr[1], inputVerPtr[2], inputVerPtr[3],
                 curVerPtr[0], curVerPtr[1], curVerPtr[2], curVerPtr[3]);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_VERSION_MISMATCH);
        return gcvSTATUS_VERSION_MISMATCH;
    }

    /* Word 3: chipModel */
    chipModel = (gctUINT32 *) (version + 1);
    if(*chipModel != gcGetHWCaps()->chipModel) {
        gcoOS_Print("gcSHADER_LoadHeader: shader binary file's chipModel 0x%x doesn't match current chipModel 0x%x.",
                 *chipModel, gcGetHWCaps()->chipModel);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_VERSION_MISMATCH);
        return gcvSTATUS_VERSION_MISMATCH;
    }

    /* Word 4: chipRevision */
    chipRevision = (gctUINT32 *) (chipModel + 1);
    if(*chipRevision != gcGetHWCaps()->chipRevision) {
        gcoOS_Print("gcSHADER_LoadHeader: shader binary file's chipRevision 0x%x doesn't match current chipRevision 0x%x.",
                 *chipRevision, gcGetHWCaps()->chipRevision);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_VERSION_MISMATCH);
        return gcvSTATUS_VERSION_MISMATCH;
    }

    /* Word 5: language type and shader type */
    version = (gctUINT32 *) (chipRevision + 1);
    bytePtr = (gctUINT8 *) version;
    if (Shader->type == gcSHADER_TYPE_PRECOMPILED) {
        Shader->type = *version >> 16;
    }
    else {
        if ((gctUINT32)Shader->type != (*version >> 16)) {
           gcoOS_Print("gcSHADER_LoadHeader: expected \"%s\" shader type does not exist in binary",
                    Shader->type == gcSHADER_TYPE_VERTEX ? "vertex" :
                    (Shader->type == gcSHADER_TYPE_FRAGMENT ? "fragment" : "unknown"));
           gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
           return gcvSTATUS_INVALID_DATA;
        }
    }
    switch(Shader->type) {
    case gcSHADER_TYPE_VERTEX:
    case gcSHADER_TYPE_FRAGMENT:
    case gcSHADER_TYPE_LIBRARY:
        if (bytePtr[0] != 'E' || bytePtr[1] != 'S')
        {
            gcoOS_Print("gcSHADER_LoadHeader: Invalid compiler type \"%c%c\"", bytePtr[0], bytePtr[1]);
            gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
            return gcvSTATUS_INVALID_DATA;
        }
        break;

    case gcSHADER_TYPE_CL:
        if (bytePtr[0] != 'C' || bytePtr[1] != 'L')
        {
            gcoOS_Print("gcSHADER_LoadHeader: Invalid compiler type \"%c%c\"", bytePtr[0], bytePtr[1]);
            gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
            return gcvSTATUS_INVALID_DATA;
        }
        break;

    case gcSHADER_TYPE_COMPUTE:
        if (bytePtr[0] != 'C' || bytePtr[1] != 'S')
        {
            gcoOS_Print("gcSHADER_LoadHeader: Invalid compiler type \"%c%c\"", bytePtr[0], bytePtr[1]);
            gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
            return gcvSTATUS_INVALID_DATA;
        }
        break;

    default:
        gcoOS_Print("gcSHADER_LoadHeader: Invalid shader type %d", Shader->type);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }
    Shader->compilerVersion[0] = *version;

    /* Word 6: compiler version */
    version = (gctUINT32 *) (version + 1);

    if (Shader->type == gcSHADER_TYPE_VERTEX || Shader->type == gcSHADER_TYPE_FRAGMENT) {
       if(*version > _SHADER_HALTI_VERSION) {
           gctUINT8 *inputVerPtr, *curVerPtr;
           gctUINT32 curVer[1] = {_SHADER_HALTI_VERSION};

           inputVerPtr = (gctUINT8 *) version;
           curVerPtr = (gctUINT8 *)curVer;
           gcoOS_Print("gcSHADER_LoadHeader: shader binary file's compiler version of %u.%u.%u:%u "
                    "is newer than current version %u.%u.%u:%u\n",
                    inputVerPtr[0], inputVerPtr[1], inputVerPtr[2], inputVerPtr[3],
                    curVerPtr[0], curVerPtr[1], curVerPtr[2], curVerPtr[3]);
           gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
           return gcvSTATUS_INVALID_DATA;
       }
    }
    else {
       if (*version < Shader->compilerVersion[1])
       {
           gctUINT8 *inputVerPtr, *curVerPtr;

           inputVerPtr = (gctUINT8 *) version;
           curVerPtr = (gctUINT8 *)&Shader->compilerVersion[1];
           gcoOS_Print("gcSHADER_LoadHeader: shader binary file's compiler version of %u.%u.%u:%u "
                    "is older than current version %u.%u.%u:%u\n"
                    "Please recompile source",
                    inputVerPtr[0], inputVerPtr[1], inputVerPtr[2], inputVerPtr[3],
                    curVerPtr[0], curVerPtr[1], curVerPtr[2], curVerPtr[3]);
           gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
           return gcvSTATUS_INVALID_DATA;
       }
    }

    Shader->compilerVersion[1] = *version;

    /* Word 7: gcSL version for old shader, and flags for new shader */
    flags = (gctUINT32 *) (version + 1);
    Shader->flags = *flags;
    if ((*flags & gcSHADER_FLAG_OLDHEADER) != 0)
    {
        gcmASSERT((*flags & ~gcSHADER_FLAG_OLDHEADER) == 0);
    }

    if (*ShaderVersion > gcdSL_SHADER_BINARY_VERSION_9_19_2013)
    {
        /* Word 8: client api version. */
        apiVersion = (gctUINT32 *)(flags + 1);
        Shader->clientApiVersion = (gceAPI)(*apiVersion);

        /* Word 9: size of binary excluding header */
        size = (gctUINT32 *) (apiVersion + 1);
    }
    else
    {
        /* Word 8: size of binary excluding header */
        size = (gctUINT32 *) (flags + 1);
    }

    bytes -= _getShaderBinaryHeaderSize(*ShaderVersion);

    if (bytes != *size)
    {
        /* binary size mismatch. */
        gcoOS_Print("gcSHADER_LoadHeader: shader binary size %u does not match actual file size %u",
                 bytes, *size);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }
    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
gcCopyKernel(
    IN gcSHADER Source,
    IN OUT gcSHADER *Res
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcSHADER kernelBinary = gcvNULL;
    gctUINT binarySize;
    gctPOINTER pointer = gcvNULL;
    gcSHADER_LABEL srcLabel, label;
    gcSHADER_LINK srcReference, reference;

    gcmHEADER_ARG("Source=0x%x", Source);

    /* Save source kernel binary into buffer */
    gcmONERROR(gcSHADER_SaveEx(Source, gcvNULL, &binarySize));
    gcmONERROR(gcoOS_Allocate(gcvNULL, binarySize, &pointer));
    gcmONERROR(gcSHADER_SaveEx(Source, pointer, &binarySize));

    /* Construct kernel binary. */
    gcmONERROR(gcSHADER_Construct(gcSHADER_TYPE_CL, &kernelBinary));

    /* Load kernel binary from source */
    gcmONERROR(gcSHADER_LoadEx(kernelBinary, pointer, binarySize));

    /***** Labels *************************************************************/
    /* Copy all labels. */
    for (srcLabel = Source->labels;
         srcLabel != gcvNULL;
         srcLabel = srcLabel->next
    )
    {
        /* Allocate the label. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  gcmSIZEOF(struct _gcSHADER_LABEL),
                                  (gctPOINTER *) &label));

        /* Copy the label. */
        label->next       = kernelBinary->labels;
        label->label      = srcLabel->label;
        label->defined    = srcLabel->defined;
        label->referenced = gcvNULL;
        kernelBinary->labels    = label;

        /* Copy all references. */
        for (srcReference = srcLabel->referenced;
             srcReference != gcvNULL;
             srcReference = srcReference->next
        )
        {
            /* Allocate the reference. */
            gcmONERROR(gcoOS_Allocate(gcvNULL,
                                      gcmSIZEOF(struct _gcSHADER_LINK),
                                      (gctPOINTER *) &reference));

            /* Copy the reference. */
            reference->next       = label->referenced;
            reference->referenced = srcReference->referenced;
            label->referenced     = reference;
        }
    }

    kernelBinary->_maxLocalTempRegCount = Source->_maxLocalTempRegCount;

OnError:
    if(pointer) gcoOS_Free(gcvNULL, pointer);
    *Res = kernelBinary;
    gcmFOOTER();
    return status;
}

#define _gcd_OCL_BUFFER_MEMORY_ALIGNMENT   8
#define _gcd_OCL_NUM_BUILTIN_ATTRIBUTES  3
#define _gcd_OCL_NUM_BUILTIN_UNIFORMS    256

#define _gcmIsOrdinaryLabel(BuiltinIndex, Label)  ((Label) < (gctUINT32) (~0 - (BuiltinIndex)->totalAllFunctionCount))

typedef struct _gcsEXTERN_FUNCTION_ITEM {
    VSC_UNI_LIST_NODE node;
    gctSTRING    externSymbol;
    gctUINT32    label;
    gctBOOL      defined;
    gctBOOL      redefined;
    gctBOOL      isKernelFunction;
} _gcsExternFunctionItem;

typedef struct _gcsEXTERN_VARIABLE_ITEM {
    VSC_UNI_LIST_NODE node;
    gctSTRING    externSymbol;
    gctBOOL      redefined;
    gcSHADER     definedKernel;
    gcVARIABLE   definedVariable;
} _gcsExternVariableItem;

typedef struct _gcsLABEL_MAP {
    gctUINT        newLabel;
    gcSHADER_LABEL labelDesc;
    gcsFUNCTION_ARGUMENT_PTR arguments;
    gctUINT tempIndexOffset;
} _gcsLabelMap;

struct _gcsBUILTIN_INDEX {
    gctINT   uniform[_gcd_OCL_NUM_BUILTIN_UNIFORMS];
    gctSTRING attributeName[_gcd_OCL_NUM_BUILTIN_ATTRIBUTES];
    gctINT   attribute[_gcd_OCL_NUM_BUILTIN_ATTRIBUTES];
    gctINT   reservedTempReg;
    gctBOOL  *instInKernelFuncPrep;
    gctUINT  currentFunctionCount;
    gctUINT  totalAllFunctionCount;
    _gcsLabelMap  *labelMap;
    VSC_HASH_TABLE *externVariableHT;
};

static gctUINT
_FindMaxUsedLabel(
    IN gcSHADER Shader,
    IN struct _gcsBUILTIN_INDEX *BuiltinIndex
    )
{
    gcSHADER_LABEL label;
    gctUINT maxLabelId = 0;

    /* Walk all defines shader labels to find the requested label. */
    for (label = Shader->labels; label != gcvNULL; label = label->next)
    {
        if(_gcmIsOrdinaryLabel(BuiltinIndex, label->label) &&
           label->label > maxLabelId)
        {
            maxLabelId = label->label;
        }
    }

    return maxLabelId;
}

static gceSTATUS
_AdjustInstAttributes(
    IN gcSHADER Shader,
    IN gctUINT *IndexMap,
    IN gctUINT CodeStart
    )
{
    gctUINT32        instIdx;
    gcSL_INSTRUCTION code;
    gctINT           i;

    for (instIdx = CodeStart; instIdx < Shader->lastInstruction; ++instIdx)
    {
        code = &Shader->code[instIdx];

        /* check sources */
        for (i = 0; i < 2; i++)
        {
            gctSOURCE_t source = (i == 0) ? code->source0 : code->source1;

            if (gcmSL_SOURCE_GET(source, Type) == gcSL_ATTRIBUTE)
            {
                gctINT32  indexVal;
                gctINT    index;

                if(i == 0)
                {
                    indexVal = code->source0Index;
                    index    = gcmSL_INDEX_GET(indexVal, Index);

                    code->source0Index = gcmSL_INDEX_SET(code->source0Index, Index, IndexMap[index]);
                }
                else
                {
                    indexVal = code->source1Index;
                    index    = gcmSL_INDEX_GET(indexVal, Index);

                    code->source1Index = gcmSL_INDEX_SET(code->source1Index, Index, IndexMap[index]);
                }
            }
        }
    }

    return gcvSTATUS_OK;
}

static gceSTATUS
_AdjustInstUniforms(
    IN gcSHADER Shader,
    IN gctUINT *IndexMap,
    IN gctUINT CodeStart
    )
{
    gctUINT32        instIdx;
    gcSL_INSTRUCTION code;
    gctINT           i;

    for (instIdx = CodeStart; instIdx < Shader->lastInstruction; ++instIdx)
    {
        code = &Shader->code[instIdx];

        /* check sources */
        for (i = 0; i < 2; i++)
        {
            gctSOURCE_t source = (i == 0) ? code->source0 : code->source1;

            if (gcmSL_SOURCE_GET(source, Type) == gcSL_UNIFORM)
            {
                gctINT32  indexVal;
                gctINT    index;

                if(i == 0)
                {
                    indexVal = code->source0Index;
                    index    = gcmSL_INDEX_GET(indexVal, Index);

                    code->source0Index = gcmSL_INDEX_SET(code->source0Index, Index, IndexMap[index]);
                }
                else
                {
                    indexVal = code->source1Index;
                    index    = gcmSL_INDEX_GET(indexVal, Index);

                    code->source1Index = gcmSL_INDEX_SET(code->source1Index, Index, IndexMap[index]);
                }
            }
            else if (gcmSL_SOURCE_GET(source, Type) == gcSL_SAMPLER)
            {
/* KLC - need to adjust sampler indices */
                ;
            }
        }
    }

    return gcvSTATUS_OK;
}

static gceSTATUS
_AdjustInstTempRegs(
    IN gcSHADER Shader,
    IN gctUINT *IndexMap,
    IN gctBOOL *InstInKernelFuncPrep,
    IN gctBOOL HasMemoryAddr,
    IN gctUINT CodeStart
    )
{
    gctUINT32  instIdx;

    for (instIdx = CodeStart; instIdx < Shader->lastInstruction; ++instIdx)
    {
        gcSL_INSTRUCTION code;
        gctINT i;

        code = &Shader->code[instIdx];

        /* check destination */
        if (gcmSL_TARGET_GET(code->temp, Enable) != gcSL_ENABLE_NONE)
        {
            gcSL_OPCODE opcode = gcmSL_OPCODE_GET(code->opcode, Opcode);

            if (opcode != gcSL_STORE1 && opcode != gcSL_STORE)
            {
                if (!HasMemoryAddr ||
                    !InstInKernelFuncPrep || !InstInKernelFuncPrep[instIdx] ||
                    code->tempIndex >= _gcdOCL_NumMemoryAddressRegs)
                {
                    code->tempIndex =  IndexMap[code->tempIndex];
                }

                if (gcmSL_TARGET_GET(code->temp, Indexed) != gcSL_NOT_INDEXED &&
                    (!HasMemoryAddr ||
                     !InstInKernelFuncPrep || !InstInKernelFuncPrep[instIdx] ||
                     code->tempIndexed >= _gcdOCL_NumMemoryAddressRegs))
                {
                    code->tempIndexed = (gctUINT16) IndexMap[code->tempIndexed];
                }
            }
        }

        /* check sources */
        for (i = 0; i < 2; i++)
        {
            gctSOURCE_t source = (i == 0) ? code->source0 : code->source1;

            if (gcmSL_SOURCE_GET(source, Type) == gcSL_TEMP)
            {
                if (i == 0)
                {
                    if (!HasMemoryAddr ||
                        !InstInKernelFuncPrep || !InstInKernelFuncPrep[instIdx] ||
                        code->source0Index >= _gcdOCL_NumMemoryAddressRegs)
                    {
                        code->source0Index = IndexMap[code->source0Index];
                    }
                    if (gcmSL_SOURCE_GET(source, Indexed) != gcSL_NOT_INDEXED &&
                        (!HasMemoryAddr ||
                         !InstInKernelFuncPrep || !InstInKernelFuncPrep[instIdx] ||
                         code->source0Indexed >= _gcdOCL_NumMemoryAddressRegs))
                    {
                        code->source0Indexed = (gctUINT16) IndexMap[code->source0Indexed];
                    }
                }
                else
                {
                    if (!HasMemoryAddr ||
                        !InstInKernelFuncPrep || !InstInKernelFuncPrep[instIdx] ||
                        code->source1Index >= _gcdOCL_NumMemoryAddressRegs)
                    {
                        code->source1Index = IndexMap[code->source1Index];
                    }
                    if (gcmSL_SOURCE_GET(source, Indexed) != gcSL_NOT_INDEXED &&
                        (!HasMemoryAddr ||
                         !InstInKernelFuncPrep || !InstInKernelFuncPrep[instIdx] ||
                         code->source1Indexed >= _gcdOCL_NumMemoryAddressRegs))
                    {
                        code->source1Indexed = (gctUINT16) IndexMap[code->source1Indexed];
                    }
                }
            }
        }
    }

    return gcvSTATUS_OK;
}

static gceSTATUS
_MergeAttributes(
    IN gcSHADER To,
    IN gcSHADER From,
    IN gctBOOL BuiltinOnly,
    IN gctUINT32 OldCodeCount,
    IN OUT struct _gcsBUILTIN_INDEX *BuiltinIndex
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctUINT currIndex;
    gctUINT  *indexMap = gcvNULL;
    gcATTRIBUTE attribute;
    gctPOINTER pointer;
    gctUINT i, j;
    gctUINT32 length;
    gctUINT32 bytes;

    gcmHEADER_ARG("To=0x%x From=0x%x BuiltinOnly=%d OldCodeCount=%u",
                  To, From, BuiltinOnly, OldCodeCount);

    currIndex = To->attributeCount;
    gcmONERROR(gcoOS_Allocate(gcvNULL,
                              From->attributeCount * gcmSIZEOF(gctUINT),
                              &pointer));
    indexMap = pointer;
    for(i = 0; i < From->attributeCount; i++) {
        indexMap[i] = i;
    }

    /* Parse all attributes. */
    for (i = 0; i < From->attributeCount; i++)
    {
        gctCONST_STRING attributeName;
        gctBOOL builtinPrevDefined = gcvFALSE;
        gctBOOL isBuiltin = gcvFALSE;

        if(From->attributes[i] == gcvNULL) {
            continue;
        }
        gcmASSERT(From->attributes[i]->index == i);

        gcATTRIBUTE_GetName(From, From->attributes[i], gcvTRUE, gcvNULL, &attributeName);
        for (j = 0; j < _gcd_OCL_NUM_BUILTIN_ATTRIBUTES; j++)
        {
            if (gcmIS_SUCCESS(gcoOS_StrCmp(attributeName, BuiltinIndex->attributeName[j])))
            {
                if(BuiltinIndex->attribute[j] < 0)
                {
                    BuiltinIndex->attribute[j] = currIndex;
                }
                else
                {
                    gcmASSERT(i == From->attributes[i]->index);
                    indexMap[i] = BuiltinIndex->attribute[j];
                    builtinPrevDefined = gcvTRUE;
                }
                isBuiltin = gcvTRUE;
                break;
            }
        }
        if(builtinPrevDefined) continue;
        if(BuiltinOnly && !isBuiltin) continue; /* skip non-builtins */

        length = From->attributes[i]->nameLength;
        /* Test for special length. */
        if ((gctINT) length < 0)
        {
            length = 0;
        }

        bytes = gcmOFFSETOF(_gcATTRIBUTE, name) + length + 1;
        /* Allocate memory for the attribute inside the gcSHADER object. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  bytes,
                                  &pointer));

        attribute = pointer;
        To->attributes[To->attributeCount++] = attribute;

        /* Copy attribute to the gcSHADER object. */
        attribute->name[length]   = '\0';

        gcoOS_MemCopy(attribute,
                      From->attributes[i],
                      bytes);
        attribute->index = (gctUINT16)currIndex;
        indexMap[i] = currIndex++;
    }
    gcmONERROR(_AdjustInstAttributes(To,
                                     indexMap,
                                     OldCodeCount));
    gcmONERROR(gcmOS_SAFE_FREE(gcvNULL,
                          indexMap));
OnError:

    if (indexMap != gcvNULL)
    {
        gcoOS_Free(gcvNULL, indexMap);
    }
    gcmFOOTER();
    return status;
}

static gceSTATUS
_MergeUniforms(
    IN gcSHADER To,
    IN gcSHADER From,
    IN gctBOOL BuiltinOnly,
    IN gctUINT32 OldCodeCount,
    IN OUT struct _gcsBUILTIN_INDEX *BuiltinIndex
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctUINT32 oldCount;
    gctUINT currIndex;
    gctUINT  *indexMap = gcvNULL;
    gcUNIFORM uniform;
    gctPOINTER pointer;
    gctUINT i, j;
    gctUINT32 length;
    gctUINT32 bytes;
    gctINT fragmentBase=0;


    gcmHEADER_ARG("To=0x%x From=0x%x BuiltinOnly=%d OldCodeCount=%u",
                  To, From, BuiltinOnly, OldCodeCount);

    oldCount = To->uniformCount;
    currIndex = oldCount + To->maxKernelFunctionArgs;
    gcmONERROR(gcoOS_Allocate(gcvNULL,
                              (From->uniformCount + From->maxKernelFunctionArgs) * gcmSIZEOF(gctUINT),
                              &pointer));
    indexMap = pointer;
    for(i = 0; i < (From->uniformCount + From->maxKernelFunctionArgs); i++) {
        indexMap[i] = i;
    }

#if !MIN_COMPILER
    fragmentBase = gcHWCaps.psSamplerNoBaseInInstruction;
#else
/* TODO: use configuration data to get the sampler base */

#endif  /* MIN_COMPILER */

    /* Parse all uniforms. */
    for (i = 0, j = From->maxKernelFunctionArgs; i < From->uniformCount; i++, j++)
    {
        gceUNIFORM_FLAGS kind;
        gcUNIFORM fromUniform = From->uniforms[i];

        if(fromUniform == gcvNULL)
        {
            continue;
        }

        gcmASSERT(fromUniform->index == (From->maxKernelFunctionArgs + i));
        kind = GetUniformKind(fromUniform);
        if(isUniformKindBuiltin(kind))
        {
            if(BuiltinIndex->uniform[kind] < 0)
            {
                BuiltinIndex->uniform[kind] = currIndex;
            }
            else
            {
                gcmASSERT(j == fromUniform->index);
                indexMap[j] = BuiltinIndex->uniform[kind];
                continue;
            }
        }
        else if(BuiltinOnly) continue;  /* skip non-builtins */

        length = fromUniform->nameLength;
        /* Test for special length. */
        if ((gctINT) length < 0)
        {
            length = 0;
        }

        bytes = gcmOFFSETOF(_gcUNIFORM, name) + length + 1;
        /* Allocate memory for the uniform inside the gcSHADER object. */
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  bytes,
                                  &pointer));

        uniform = pointer;
        To->uniforms[To->uniformCount++] = uniform;

        /* Copy uniform to the gcSHADER object. */
        uniform->name[length]   = '\0';

        gcoOS_MemCopy(uniform,
                      fromUniform,
                      bytes);

        if (GetUniformTypeNameOffset(uniform) != -1)
        {
            SetUniformTypeNameOffset(uniform, GetUniformTypeNameOffset(uniform) + To->typeNameBufferSize);
        }

        if (uniform->arrayLengthCount > 0)
        {
            gcmONERROR(gcoOS_Allocate(gcvNULL,
                                      uniform->arrayLengthCount * gcmSIZEOF(gctINT),
                                      &pointer));

            gcoOS_ZeroMemory(pointer, uniform->arrayLengthCount * gcmSIZEOF(gctINT));
            uniform->arrayLengthList = pointer;

            gcoOS_MemCopy(uniform->arrayLengthList,
                          fromUniform->arrayLengthList,
                          uniform->arrayLengthCount * gcmSIZEOF(gctINT));
        }

        if(gcmType_Kind(uniform->u.type) == gceTK_SAMPLER)
        {
           uniform->physical += (To->samplerIndex > fragmentBase) ? To->samplerIndex - fragmentBase
                                                                  : 0;
        }

        uniform->index = (gctUINT16) currIndex;
        indexMap[j] = currIndex++;
    }
    To->samplerIndex += (From->samplerIndex > fragmentBase) ? From->samplerIndex - fragmentBase
                                                            : 0;

    /* update structure uniform indices */
    for (i = oldCount; i < To->uniformCount; i++)
    {
        uniform = To->uniforms[i];
        gcmASSERT(uniform);

        if(uniform->firstChild != -1)
        {
            gcmASSERT(uniform->firstChild < (gctINT)currIndex);
            uniform->firstChild = (gctINT16)indexMap[uniform->firstChild];
        }

        if(uniform->nextSibling != -1)
        {
            gcmASSERT(uniform->nextSibling < (gctINT)currIndex);
            uniform->nextSibling = (gctINT16)indexMap[uniform->nextSibling];
        }

        if(uniform->prevSibling != -1)
        {
            gcmASSERT(uniform->prevSibling < (gctINT)currIndex);
            uniform->prevSibling = (gctINT16)indexMap[uniform->prevSibling];
        }

        if(uniform->parent != -1)
        {
            gcmASSERT(uniform->parent < (gctINT)currIndex);
            uniform->parent = (gctINT16)indexMap[uniform->parent];
        }
    }

    gcmONERROR(_AdjustInstUniforms(To,
                                  indexMap,
                                  OldCodeCount));

OnError:
    if (indexMap != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, indexMap));
    }

    gcmFOOTER();
    return status;
}

#define _gcmEndInstruction(Shader) \
   do { \
       if ((Shader)->instrIndex != gcSHADER_OPCODE) \
       { \
           (Shader)->instrIndex       = gcSHADER_OPCODE; \
           (Shader)->lastInstruction += 1; \
       } \
   } while(gcvFALSE)

/*******************************************************************************
**  _MergeOneKernel
**
**  Merge a shader object to a shader object.
**
**  INPUT:
**
**      gcSHADER To
**          Pointer to a kernel gcSHADER object.
**
**      gcSHADER From
**          Pointer to a kernel gcSHADER object containing the shader data to merge.
**
**      struct _gcsBUIILTIN_INDEX *
**          Pointer to builtin variable struct keeping the indexes of builtin variables
**          currently defined.
**
**  OUTPUT:
**
**      Nothing.
*/
static gceSTATUS
_MergeOneKernel(
    IN gcSHADER To,
    IN gcSHADER From,
    IN OUT struct _gcsBUILTIN_INDEX *BuiltinIndex
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctUINT32 bytes;
    gctUINT32 oldCodeCount = 0;
    gctUINT32 oldCount;
    gctUINT i, j;
    gctUINT32 length;
    gcUNIFORM uniform;
    gcVARIABLE variable;
    gctUINT  *indexMap = gcvNULL;
    gctUINT  *tempIndexMap = gcvNULL;
    gctUINT tempIndexOffset;
    gctUINT tempIndex;
    gcKERNEL_FUNCTION kernelFunction = gcvNULL;
    gcFUNCTION function;
    gctUINT32 currentFunctionCount = BuiltinIndex->currentFunctionCount;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("To=0x%x From=0x%x",
                  To, From);

    gcmASSERT(To && From);
    /* Verify the arguments. */
    gcmVERIFY_OBJECT(To, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(From, gcvOBJ_SHADER);

    tempIndexOffset = GetShaderTempRegCount(To) - GetShaderMaxLocalTempRegCount(From);
    gcmONERROR(gcoOS_Allocate(gcvNULL,
                              (GetShaderTempRegCount(From) + 1) * gcmSIZEOF(gctUINT),
                              &pointer));

    tempIndexMap = pointer;
    for(i = 0; i < GetShaderTempRegCount(From); i++) {
        tempIndexMap[i] = i;
    }

    for(i = GetShaderMaxLocalTempRegCount(From); i < GetShaderTempRegCount(From); i++) {
        tempIndexMap[i] = i + tempIndexOffset;
    }

    /************************************************************************/
    /*      type name buffer size                                    */
    /************************************************************************/
    if(From->typeNameBufferSize)
    {
        gcmASSERT(From->typeNameBuffer);

        gcoOS_MemCopy(To->typeNameBuffer + To->typeNameBufferSize,
                      From->typeNameBuffer,
                      From->typeNameBufferSize);
    }

    /************************************************************************/
    /*      constant memory size                                    */
    /************************************************************************/
    if(From->constantMemorySize)
    {
        To->constantMemorySize = gcmALIGN(To->constantMemorySize, _gcd_OCL_BUFFER_MEMORY_ALIGNMENT);

        gcmASSERT(From->constantMemoryBuffer);

        gcoOS_MemCopy(To->constantMemoryBuffer + To->constantMemorySize,
                      From->constantMemoryBuffer,
                      From->constantMemorySize);
        if(To->constantMemorySize)
        {
            tempIndex = BuiltinIndex->reservedTempReg++;
            tempIndexMap[_gcdOCL_ConstantMemoryAddressRegIndex] = tempIndex;
        }
    }

    /************************************************************************/
    /*      private memory size                                    */
    /************************************************************************/
    if(To->privateMemorySize && From->privateMemorySize)
    {
        To->privateMemorySize = gcmALIGN(To->privateMemorySize, _gcd_OCL_BUFFER_MEMORY_ALIGNMENT);
        tempIndex = BuiltinIndex->reservedTempReg++;
        tempIndexMap[_gcdOCL_PrivateMemoryAddressRegIndex] = tempIndex;
    }
    To->privateMemorySize += From->privateMemorySize;

    oldCodeCount = To->lastInstruction;
    /* Copy the code into the merged gcSHADER object. */
    if(From->codeCount)
    {
        gcmASSERT(To->codeCount >= To->lastInstruction + From->lastInstruction);
        bytes = From->lastInstruction * sizeof(struct _gcSL_INSTRUCTION);
        gcoOS_MemCopy(To->code + oldCodeCount, From->code, bytes);
        To->lastInstruction += From->lastInstruction;
        To->instrIndex = gcSHADER_OPCODE;

        /* copy branch labels */
        {
            gceSTATUS status = gcvSTATUS_OK;
            gctUINT i;
            gcSHADER_LABEL srcLabel, label;
            gctUINT labelIndex, labelId;
            gctUINT labelOffset;
            gcSHADER_LINK srcReference, reference;

            labelOffset = _FindMaxUsedLabel(To, BuiltinIndex);

            for (i = oldCodeCount; i < To->lastInstruction; ++i)
            {
                /* fix up jmp/call. */
                if (gcmSL_OPCODE_GET(To->code[i].opcode, Opcode) == gcSL_JMP) {
                    To->code[i].tempIndex += labelOffset;
                }
                else if(gcmSL_OPCODE_GET(To->code[i].opcode, Opcode) == gcSL_CALL)
                {
                    if((gctINT32)To->code[i].tempIndex < 0)
                    {
                        labelIndex = ~0 - To->code[i].tempIndex + currentFunctionCount;
                        labelId = BuiltinIndex->labelMap[labelIndex].newLabel;
                        To->code[i].tempIndex = labelId;
                        labelIndex = ~0 - labelId;
                        label = BuiltinIndex->labelMap[labelIndex].labelDesc;

                        if(!label)
                        {
                            gcmONERROR(gcoOS_Allocate(gcvNULL,
                                                      gcmSIZEOF(struct _gcSHADER_LABEL),
                                                      (gctPOINTER *) &label));
                            BuiltinIndex->labelMap[labelIndex].labelDesc = label;

                            /* Copy the label. */
                            label->next       = To->labels;
                            label->label      = labelId;
                            label->defined    = ~0U;
                            label->referenced = gcvNULL;
                            To->labels    = label;
                        }
                        /* Allocate the reference. */
                        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                                  gcmSIZEOF(struct _gcSHADER_LINK),
                                                  (gctPOINTER *) &reference));

                        /* Copy the reference. */
                        reference->next       = label->referenced;
                        reference->referenced = i;
                        label->referenced     = reference;
                    }
                    else To->code[i].tempIndex += labelOffset;
                }
            } /* for */

            /* Copy all labels. */
            for (srcLabel = From->labels;
                 srcLabel != gcvNULL;
                 srcLabel = srcLabel->next)
            {
                label = gcvNULL;
                if(_gcmIsOrdinaryLabel(BuiltinIndex, srcLabel->label))
                {
                    gcmONERROR(gcoOS_Allocate(gcvNULL,
                                              gcmSIZEOF(struct _gcSHADER_LABEL),
                                              (gctPOINTER *) &label));

                    /* Copy the label. */
                    label->next       = To->labels;
                    label->label      = srcLabel->label + labelOffset;
                    label->defined    = srcLabel->defined + oldCodeCount;
                    label->referenced = gcvNULL;
                    To->labels    = label;
                }
                else
                {
                    gctUINT32 labelId;

                    labelIndex = (gctUINT32)~0 - srcLabel->label + currentFunctionCount;
                    labelId = (gctUINT32)BuiltinIndex->labelMap[labelIndex].newLabel;
                    labelIndex = (gctUINT32)~0 - labelId;
                    label = BuiltinIndex->labelMap[labelIndex].labelDesc;

                    if(!label)
                    {
                        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                                  gcmSIZEOF(struct _gcSHADER_LABEL),
                                                  (gctPOINTER *) &label));
                        BuiltinIndex->labelMap[labelIndex].labelDesc = label;

                        /* Copy the label. */
                        label->next       = To->labels;
                        label->label      = labelId;
                        label->defined    = srcLabel->defined + oldCodeCount;
                        label->referenced = gcvNULL;
                        To->labels    = label;
                    }
                }

                /* Copy all references. */
                for (srcReference = srcLabel->referenced;
                     srcReference != gcvNULL;
                     srcReference = srcReference->next)
                {
                    /* Allocate the reference. */
                    gcmONERROR(gcoOS_Allocate(gcvNULL,
                                              gcmSIZEOF(struct _gcSHADER_LINK),
                                              (gctPOINTER *) &reference));

                    /* Copy the reference. */
                    reference->next       = label->referenced;
                    reference->referenced = srcReference->referenced + oldCodeCount;
                    label->referenced     = reference;
                }
            }
        }
    }

    /************************************************************************/
    /*                              functions                               */
    /************************************************************************/

    if(From->functionCount)
    {
        gcFUNCTION fromFunction;
        gcSHADER_LABEL label;
        gctUINT labelIndex;
        gctUINT32 labelId;

        /* Check array count. */
        gcmASSERT(To->functionArraySize >= (To->functionCount + From->functionCount));

        /* Parse all functions. */
        for (i = 0; i < From->functionCount; i++)
        {
            fromFunction = From->functions[i];
            if(fromFunction == gcvNULL) continue;

            BuiltinIndex->currentFunctionCount++;
            if(GetFunctionFlags(fromFunction) & gcvFUNC_EXTERN) {
                gcsFUNCTION_ARGUMENT_PTR arguments;

                labelIndex = (gctUINT32)~0 - fromFunction->label + currentFunctionCount;
                labelIndex = (gctUINT32)~0 - (gctUINT32)BuiltinIndex->labelMap[labelIndex].newLabel;
                arguments = BuiltinIndex->labelMap[labelIndex].arguments;

                for (j = 0; j < fromFunction->argumentCount; j++)
                {
                    tempIndexMap[fromFunction->arguments[j].index] =
                        arguments[j].index + BuiltinIndex->labelMap[labelIndex].tempIndexOffset;
                }
                continue;
            }

            /* Compute the number of bytes required. */
            bytes = gcmOFFSETOF(_gcsFUNCTION, name) + fromFunction->nameLength + 1;

            /* Allocate memory for the kernel function inside the gcSHADER object. */
            gcmONERROR(gcoOS_Allocate(gcvNULL,
                                      bytes,
                                      &pointer));
            function = pointer;

            /* Copy function to shader. */
            gcoOS_MemCopy(function,
                          fromFunction,
                          bytes);

            function->tempIndexStart   = tempIndexMap[fromFunction->tempIndexStart];
            function->tempIndexEnd   = tempIndexMap[fromFunction->tempIndexEnd];
            function->tempIndexCount   = fromFunction->tempIndexCount;
            function->codeStart   += oldCodeCount;

            labelIndex = (gctUINT32)~0 - fromFunction->label + currentFunctionCount;
            labelId = (gctUINT32)BuiltinIndex->labelMap[labelIndex].newLabel;
            function->label = labelId;
            labelIndex = (gctUINT32)~0 - labelId;
            label = BuiltinIndex->labelMap[labelIndex].labelDesc;

            if(!label)
            {
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          gcmSIZEOF(struct _gcSHADER_LABEL),
                                          (gctPOINTER *) &label));
                BuiltinIndex->labelMap[labelIndex].labelDesc = label;

                /* Copy the label. */
                label->next       = To->labels;
                label->label      = labelId;
                label->referenced = gcvNULL;
                To->labels    = label;
            }

            if(label == gcvNULL) {
                status = gcvSTATUS_INVALID_DATA;
                gcmONERROR(gcvSTATUS_INVALID_DATA);
            }
            label->defined    = function->codeStart;

            function->name[fromFunction->nameLength] = '\0';

            /* Function arguments */
            if (function->argumentCount > 0) {
                bytes = function->argumentCount * sizeof(gcsFUNCTION_ARGUMENT);

                /* Allocate the array of gcsFUNCTION_ARGUMENT structures. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          bytes,
                                          &pointer));
                function->arguments = pointer;

                for (j = 0; j < function->argumentCount; j++) {
                    gcoOS_MemCopy(&function->arguments[j],
                                  &fromFunction->arguments[j],
                                  sizeof(gcsFUNCTION_ARGUMENT));
                    function->arguments[j].index = tempIndexMap[fromFunction->arguments[j].index];
                }
            }

            /* function local variables */
            if (function->localVariableCount > 0) {

                /* Allocate the array of gcVARIABLE structure pointers. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          function->localVariableCount * sizeof(gcVARIABLE),
                                          &pointer));
                function->localVariables = pointer;

                for (j = 0; j < function->localVariableCount; j++)
                {
                    /* Compute the number of bytes required. */
                    bytes = gcmOFFSETOF(_gcVARIABLE, name) + function->localVariables[j]->nameLength + 1;

                    /* Allocate memory for the variable inside the gcSHADER object. */
                    gcmONERROR(gcoOS_Allocate(gcvNULL,
                                              bytes,
                                              &pointer));
                    variable = pointer;

                    /* Copy variable to shader. */
                    function->localVariables[j] = variable;
                    gcoOS_MemCopy(variable,
                                  fromFunction->localVariables[j],
                                  bytes);

                    if (variable->arrayLengthCount > 0)
                    {
                        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                                  variable->arrayLengthCount * gcmSIZEOF(gctINT),
                                                  &pointer));

                        gcoOS_ZeroMemory(pointer, variable->arrayLengthCount * gcmSIZEOF(gctINT));
                        variable->arrayLengthList = pointer;

                        gcoOS_MemCopy(variable->arrayLengthList,
                                      fromFunction->localVariables[j]->arrayLengthList,
                                      variable->arrayLengthCount * gcmSIZEOF(gctINT));
                    }
                    variable->tempIndex += tempIndexOffset;
                }
            }
            To->functions[To->functionCount++] = function;
        }
    }

    /************************************************************************/
    /*                          kernel functions                            */
    /************************************************************************/
    if (From->kernelFunctionCount)
    {
        gcKERNEL_FUNCTION fromKernelFunction;
        gcSHADER_LABEL label;
        gctUINT labelIndex;
        gctUINT32 labelId;
        gcSL_INSTRUCTION code;

        /* Check array count. */
        gcmASSERT(To->kernelFunctionArraySize >= (To->kernelFunctionCount + From->kernelFunctionCount));

        /* Parse all kernel functions. */
        for (i = 0; i < From->kernelFunctionCount; i++)
        {
            fromKernelFunction = From->kernelFunctions[i];
            if (fromKernelFunction == gcvNULL) continue;
            BuiltinIndex->currentFunctionCount++;
            if (GetFunctionFlags(fromKernelFunction) & gcvFUNC_EXTERN)
            {
                gcsFUNCTION_ARGUMENT_PTR arguments;

                labelIndex = (gctUINT32)~0 - fromKernelFunction->label + currentFunctionCount;
                labelIndex = (gctUINT32)~0 - (gctUINT32)BuiltinIndex->labelMap[labelIndex].newLabel;
                arguments = BuiltinIndex->labelMap[labelIndex].arguments;

                for (j = 0; j < fromKernelFunction->argumentCount; j++)
                {
                    tempIndexMap[fromKernelFunction->arguments[j].index] =
                        arguments[j].index + BuiltinIndex->labelMap[labelIndex].tempIndexOffset;
                }
                continue;
            }

            /* Compute the number of bytes required. */
            bytes = gcmOFFSETOF(_gcsKERNEL_FUNCTION, name) + fromKernelFunction->nameLength + 1;

            /* Allocate memory for the kernel function inside the gcSHADER object. */
            gcmONERROR(gcoOS_Allocate(gcvNULL,
                                      bytes,
                                      &pointer));
            kernelFunction = pointer;

            /* Copy kernel function to shader. */
            gcoOS_MemCopy(kernelFunction,
                          fromKernelFunction,
                          bytes);

            kernelFunction->shader = To;

            kernelFunction->tempIndexStart    = tempIndexMap[fromKernelFunction->tempIndexStart];
            kernelFunction->tempIndexEnd      = tempIndexMap[fromKernelFunction->tempIndexEnd];
            kernelFunction->tempIndexCount    = fromKernelFunction->tempIndexCount;
            kernelFunction->codeStart         += oldCodeCount;
            kernelFunction->codeEnd           += oldCodeCount;

            /* Update the kernel function call. */
            code = &To->code[kernelFunction->codeStart + kernelFunction->codeCount - 1];
            gcmASSERT((gcSL_OPCODE)gcmSL_OPCODE_GET(code->opcode, Opcode) == gcSL_CALL);
            code->tempIndex = kernelFunction->codeStart;

            /* Update the labels. */
            labelIndex = (gctUINT32)~0 - fromKernelFunction->label + currentFunctionCount;
            labelId = (gctUINT32)BuiltinIndex->labelMap[labelIndex].newLabel;
            kernelFunction->label = labelId;
            labelIndex = (gctUINT32)~0 - labelId;
            label = BuiltinIndex->labelMap[labelIndex].labelDesc;

            if (!label)
            {
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          gcmSIZEOF(struct _gcSHADER_LABEL),
                                          (gctPOINTER *) &label));
                BuiltinIndex->labelMap[labelIndex].labelDesc = label;

                /* Copy the label. */
                label->next       = To->labels;
                label->label      = labelId;
                label->referenced = gcvNULL;
                To->labels    = label;
            }
            label->defined = kernelFunction->codeStart;

            kernelFunction->name[kernelFunction->nameLength] = '\0';

            for (j = kernelFunction->codeEnd;
                 j < kernelFunction->codeStart + kernelFunction->codeCount; j++)
            {
                BuiltinIndex->instInKernelFuncPrep[j] = gcvTRUE;
            }

            /* Kernel function arguments */
            if (kernelFunction->argumentCount > 0)
            {
                bytes = kernelFunction->argumentCount * sizeof(gcsFUNCTION_ARGUMENT);

                /* Allocate the array of gcsFUNCTION_ARGUMENT structures. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          bytes,
                                          &pointer));
                kernelFunction->arguments = pointer;

                for (j = 0; j < kernelFunction->argumentCount; j++)
                {
                    gcoOS_MemCopy(&kernelFunction->arguments[j],
                                  &fromKernelFunction->arguments[j],
                                  sizeof(gcsFUNCTION_ARGUMENT));
                    kernelFunction->arguments[j].index = tempIndexMap[fromKernelFunction->arguments[j].index];
                }
            }

            /* Kernel function uniform arguments */
            if (kernelFunction->uniformArgumentCount > 0)
            {
                /* Allocate the array of gcUNIFORM structure pointers. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          kernelFunction->uniformArgumentCount * sizeof(gcUNIFORM),
                                          &pointer));
                kernelFunction->uniformArguments = pointer;

                for (j = 0; j < kernelFunction->uniformArgumentCount; j++)
                {
                    bytes = gcmOFFSETOF(_gcUNIFORM, name) + fromKernelFunction->uniformArguments[j]->nameLength + 1;

                    /* Allocate memory for the uniform argument inside the gcSHADER object. */
                    gcmONERROR(gcoOS_Allocate(gcvNULL,
                                              bytes,
                                              &pointer));
                    uniform = pointer;
                    kernelFunction->uniformArguments[j] = uniform;

                    gcoOS_MemCopy(uniform,
                                  fromKernelFunction->uniformArguments[j],
                                  bytes);
                    if (GetUniformTypeNameOffset(uniform) != -1)
                    {
                        SetUniformTypeNameOffset(uniform, GetUniformTypeNameOffset(uniform) + To->typeNameBufferSize);
                    }
                }
            }

            /* Kernel function image samplers */
            if (kernelFunction->imageSamplerCount > 0)
            {
                /* Allocate the array of gcsIMAGE_SAMPLER_PTR structures. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          kernelFunction->imageSamplerCount * sizeof(struct _gcsIMAGE_SAMPLER),
                                          &pointer));
                kernelFunction->imageSamplers = pointer;

                for (j = 0; j < kernelFunction->imageSamplerCount; j++) {
                    gcoOS_MemCopy(&kernelFunction->imageSamplers[j],
                                  &fromKernelFunction->imageSamplers[j],
                                  sizeof(struct _gcsIMAGE_SAMPLER));
                }
            }

            /* Kernel function local variables */
            if (kernelFunction->localVariableCount > 0)
            {

                /* Allocate the array of gcVARIABLE structure pointers. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          kernelFunction->localVariableCount * sizeof(gcVARIABLE),
                                          &pointer));
                kernelFunction->localVariables = pointer;

                for (j = 0; j < kernelFunction->localVariableCount; j++)
                {
                    /* Compute the number of bytes required. */
                    bytes = gcmOFFSETOF(_gcVARIABLE, name) + kernelFunction->localVariables[j]->nameLength + 1;

                    /* Allocate memory for the variable inside the gcSHADER object. */
                    gcmONERROR(gcoOS_Allocate(gcvNULL,
                                              bytes,
                                              &pointer));
                    variable = pointer;

                    /* Copy variable to shader. */
                    kernelFunction->localVariables[j]   = variable;
                    gcoOS_MemCopy(variable,
                                  fromKernelFunction->localVariables[j],
                                  bytes);
                    if (variable->arrayLengthCount > 0)
                    {
                        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                                  variable->arrayLengthCount * gcmSIZEOF(gctINT),
                                                  &pointer));

                        gcoOS_ZeroMemory(pointer, variable->arrayLengthCount * gcmSIZEOF(gctINT));
                        variable->arrayLengthList = pointer;

                        gcoOS_MemCopy(variable->arrayLengthList,
                                      fromKernelFunction->localVariables[j]->arrayLengthList,
                                      variable->arrayLengthCount * gcmSIZEOF(gctINT));
                    }
                    variable->tempIndex += tempIndexOffset;
                }
            }

            /* Kernel function properties */
            if (kernelFunction->propertyCount > 0)
            {
                /* Allocate the array of gcsKERNEL_FUNCTION_PROPERTY_PTR structures. */
                bytes = kernelFunction->propertyCount * sizeof(gcsKERNEL_FUNCTION_PROPERTY);
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          bytes,
                                          &pointer));
                kernelFunction->properties = pointer;

                gcoOS_MemCopy(kernelFunction->properties,
                              fromKernelFunction->properties,
                              bytes);
            }

            /* Kernel function properties */
            if (kernelFunction->propertyValueCount > 0)
            {
                /* Allocate the array of property values */
                bytes = kernelFunction->propertyValueCount * sizeof(gctINT32);
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          bytes,
                                          &pointer));
                kernelFunction->propertyValues = pointer;

                gcoOS_MemCopy(kernelFunction->propertyValues,
                              fromKernelFunction->propertyValues,
                              bytes);
            }

            To->kernelFunctions[To->kernelFunctionCount++] = kernelFunction;
            kernelFunction = gcvNULL;
        }
    }

    /************************************************************************/
    /*                          global variables                            */
    /************************************************************************/

    /* Process variables. */
    if (From->variableCount > 0)
    {
        gctUINT currIndex;

        /* Check array count. */
        gcmASSERT(To->variableArraySize >= (To->variableCount + From->variableCount));

        oldCount = currIndex = To->variableCount;
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  From->variableCount * gcmSIZEOF(gctUINT),
                                  &pointer));
        indexMap = pointer;
        for(i = 0; i < From->variableCount; i++) {
            indexMap[i] = i;
        }

        /* Parse all variables. */
        for (i = 0; i < From->variableCount; i++)
        {
            if(From->variables[i] == gcvNULL) continue;

            gcmASSERT(From->variables[i]->index == i);
            length = From->variables[i]->nameLength;
            /* Test for special length. */
            if ((gctINT) length < 0)
            {
                length = 0;
            }

            bytes = gcmOFFSETOF(_gcVARIABLE, name) + length + 1;
            /* Allocate memory for the variable inside the gcSHADER object. */
            gcmONERROR(gcoOS_Allocate(gcvNULL,
                                      bytes,
                                      &pointer));

            variable = pointer;
            To->variables[To->variableCount++] = variable;

            /* Copy variable to the gcSHADER object. */
            variable->name[length]   = '\0';

            gcoOS_MemCopy(variable,
                          From->variables[i],
                          bytes);

            if(IsVariableExtern(variable))
            {
                gctBOOL found;
                gcVARIABLE definedVariable;
                _gcsExternVariableItem *variableSymbolItem;

                found = vscHTBL_DirectTestAndGet(BuiltinIndex->externVariableHT, variable->name, (void**)&variableSymbolItem);
                definedVariable = variableSymbolItem->definedVariable;
                gcmASSERT(found &&
                          definedVariable &&
                          variableSymbolItem->definedKernel);

                if(!found)
                {
                    status = gcvSTATUS_INVALID_DATA;
                    gcmONERROR(gcvSTATUS_INVALID_DATA);
                }

                if(definedVariable)
                {
                    if (GetVariableOffset(variable) >= 0)
                    {
                        gcmASSERT(GetVariableOffset(definedVariable) >= 0);
                        /* copy the variable's defined constant value to corresponding extern variable */
                        gcoOS_MemCopy(To->constantMemoryBuffer + GetVariableOffset(variable),
                                      variableSymbolItem->definedKernel->constantMemoryBuffer + GetVariableOffset(definedVariable),
                                      GetVariableArraySize(definedVariable) * GetVariableArrayStride(definedVariable));
                    }
                    else
                    {
                        tempIndexMap[variable->tempIndex] = definedVariable->tempIndex;
                    }
                }
            }

            if (variable->arrayLengthCount > 0)
            {
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          variable->arrayLengthCount * gcmSIZEOF(gctINT),
                                          &pointer));

                gcoOS_ZeroMemory(pointer, variable->arrayLengthCount * gcmSIZEOF(gctINT));
                variable->arrayLengthList = pointer;

                gcoOS_MemCopy(variable->arrayLengthList,
                              From->variables[i]->arrayLengthList,
                              variable->arrayLengthCount * gcmSIZEOF(gctINT));
            }
            variable->index = (gctUINT16)currIndex;
            indexMap[i] = currIndex++;
            variable->tempIndex = tempIndexMap[variable->tempIndex];
        }

        /* update structure variable indices */
        for (i = oldCount; i < To->variableCount; i++)
        {
            variable = To->variables[i];
            gcmASSERT(variable);

            if(variable->firstChild != -1)
            {
                gcmASSERT(variable->firstChild < (gctINT)currIndex);
                variable->firstChild = (gctINT16)indexMap[variable->firstChild];
            }

            if(variable->nextSibling != -1)
            {
                gcmASSERT(variable->nextSibling < (gctINT)currIndex);
                variable->nextSibling = (gctINT16)indexMap[variable->nextSibling];
            }

            if(variable->prevSibling != -1)
            {
                gcmASSERT(variable->prevSibling < (gctINT)currIndex);
                variable->prevSibling = (gctINT16)indexMap[variable->prevSibling];
            }

            if(variable->parent != -1)
            {
                gcmASSERT(variable->parent < (gctINT)currIndex);
                variable->parent = (gctINT16)indexMap[variable->parent];
            }
        }
    }

    _AdjustInstTempRegs(To,
                        tempIndexMap,
                        BuiltinIndex->instInKernelFuncPrep,
                        gcShaderHasBaseMemoryAddr(From),
                        oldCodeCount);

    SetShaderTempRegCount(To,
                          GetShaderTempRegCount(To) + GetShaderTempRegCount(From) - GetShaderMaxLocalTempRegCount(From));

/*may need to handle this */

    /************************************************************************/
    /*                              attributes                              */
    /************************************************************************/

    /* Process attributes. */
    if (From->attributeCount > 0)
    {
        /* Check array count. */
        gcmASSERT(To->attributeArraySize >= (To->attributeCount + From->attributeCount));

        gcmONERROR(_MergeAttributes(To,
                                    From,
                                    gcvFALSE,
                                    oldCodeCount,
                                    BuiltinIndex));
    }

    /************************************************************************/
    /*                                  uniforms                            */
    /************************************************************************/

    /* Process uniforms. */
    if (From->uniformCount > 0)
    {
        /* Check array count. */
        gcmASSERT(To->uniformArraySize >= (To->uniformCount + From->uniformCount));

        gcmONERROR(_MergeUniforms(To,
                                  From,
                                  gcvFALSE,
                                  oldCodeCount,
                                  BuiltinIndex));
    }

    To->typeNameBufferSize += From->typeNameBufferSize;
    To->constantMemorySize += From->constantMemorySize;

    To->optimizationOption |= From->optimizationOption;

    if(GetShaderHasIntrinsicBuiltin(From))
    {
        SetShaderHasIntrinsicBuiltin(To, gcvTRUE);
    }

/*klc*/
/* may need to reset the shader that it has extern functions and variables */
    SetShaderHasExternFunction(To, GetShaderHasExternFunction(From));
    SetShaderHasExternVariable(To, GetShaderHasExternVariable(From));

OnError:

    if (indexMap != gcvNULL)
    {
        gcoOS_Free(gcvNULL, indexMap);
    }

    if (kernelFunction != gcvNULL)
    {
        gcoOS_Free(gcvNULL, kernelFunction);
    }

    if (tempIndexMap != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, tempIndexMap));
    }

    gcmFOOTER();
    return status;
}

static gctUINT
_UsedReservedTempReg(
    IN gcSHADER Kernel,
    IN gcKERNEL_FUNCTION KernelFunction,
    IN gctUINT32 ReservedTempReg
    )
{
    gctUINT i;
    gcSL_INSTRUCTION code;
    gctINT codeEnd = 0;

    gcmASSERT(ReservedTempReg < _gcdOCL_NumMemoryAddressRegs);

    for(i = KernelFunction->codeStart + KernelFunction->codeCount - 1;
        i >= KernelFunction->codeEnd; i--)
    {
        code = &Kernel->code[i];
        if (gcmSL_TARGET_GET(code->temp, Enable) != gcSL_ENABLE_NONE &&
            code->tempIndex == ReservedTempReg)
        {
            codeEnd = i;
            break;
        }
    }
    return codeEnd;
}

#if !DX_SHADER
/*******************************************************************************
**                                gcMergeKernel
********************************************************************************
**
**    Merge a list of OpenCL kernel binaries and form a single consistent kernel
**    binary as if the original kernel source corresponding to each kernel binary
**    were concatenated together into one source and then compiled to create the
**    kernel binary.
**
**    INPUT:
**        gctINT KernelCount
**            number of gcSHADER object in the shader array
**
**        gcSHADER *KernelArray
**            Array of gcSHADER object holding information about the compiled
**            openCL kernel.
**
**    OUTPUT:
**
**        gcSHADER * MergedKernel
**            Pointer to a variable receiving the handle to the merged kernel
**
*/
gceSTATUS
gcSHADER_MergeKernel(
    IN gctINT         KernelCount,
    IN gcSHADER *     KernelArray,
    OUT gcSHADER *    MergedKernel
    )
{
    gceSTATUS   status = gcvSTATUS_OK;
    gcSHADER    mergedKernel = gcvNULL;
    gctUINT32   *compilerVersion = gcvNULL;
    gctUINT32   maxKernelArgs = 0;
    gctUINT     maxLocalTempRegCount = 0;
    struct _gcsBUILTIN_INDEX builtinIndex = {{-1},
                                             {"#global_id", "#group_id", "#local_id"},
                                             {-1, -1, -1},
                                             -1,
                                             gcvNULL,
                                             0,
                                             0,
                                             gcvNULL,
                                             gcvNULL
                                             };
    gctINT i;
    gctUINT totalCodeCount = 0;
    gctUINT totalUniformCount = 0;
    gctUINT totalAttributeCount = 0;
    gctUINT totalVariableCount = 0;
    gctUINT totalFunctionCount = 0;
    gctUINT totalKernelFunctionCount = 0;
    gctUINT totalConstantMemorySize = 0;
    gctUINT totalPrivateMemorySize = 0;
    gctUINT totalTypeNameBufferSize = 0;
    gctUINT totalAllSymbolCount = 0;
    gctUINT totalAllFunctionCount = 0;
    gctBOOL hasExternFunction = gcvFALSE;
    gctBOOL hasExternVariable = gcvFALSE;
    gctBOOL constantMemoryReqd, privateMemoryReqd;
    gctINT constantPrivateMemoryKernelIndex;
    gctINT constantMemoryKernelIndex, privateMemoryKernelIndex;
    gctPOINTER pointer;
    VSC_PRIMARY_MEM_POOL externSymbolPmp;
    VSC_HASH_TABLE *externVariableHT = gcvNULL;
    VSC_UNI_LIST variableSymbolList;

    gcmHEADER_ARG("KernelCount=%d KernelArray=0x%x", KernelCount, KernelArray);

    gcmASSERT(MergedKernel);

    for (i = 0; i < _gcd_OCL_NUM_BUILTIN_UNIFORMS; i++)
    {
        builtinIndex.uniform[i] = -1;
    }

    constantMemoryReqd = privateMemoryReqd = gcvFALSE;
    constantPrivateMemoryKernelIndex = constantMemoryKernelIndex = privateMemoryKernelIndex = -1;
    for (i = 0; i < KernelCount; i++)
    {
        if (KernelArray[i] == gcvNULL)
        {
            continue;
        }

        gcmASSERT(KernelArray[i]->object.type  == gcvOBJ_SHADER ||
                  KernelArray[i]->object.type  == gcvOBJ_VIR_SHADER);
        if (KernelArray[i]->object.type  == gcvOBJ_SHADER)
        {
            if (KernelArray[i]->type == gcSHADER_TYPE_CL)
            {
                if(!compilerVersion)
                {
                    gcmONERROR(gcSHADER_GetCompilerVersion(KernelArray[i],
                                                           &compilerVersion));
                }
                if(maxKernelArgs < KernelArray[i]->maxKernelFunctionArgs)
                    maxKernelArgs = KernelArray[i]->maxKernelFunctionArgs;
                if(maxLocalTempRegCount < GetShaderMaxLocalTempRegCount(KernelArray[i]))
                    maxLocalTempRegCount = GetShaderMaxLocalTempRegCount(KernelArray[i]);
                totalCodeCount += KernelArray[i]->lastInstruction;

                if(KernelArray[i]->constantMemorySize &&
                   KernelArray[i]->privateMemorySize)
                {
                    constantPrivateMemoryKernelIndex = i;
                }

                if(KernelArray[i]->constantMemorySize)
                {
                    if(constantMemoryReqd)
                    {
                        if(constantMemoryKernelIndex == -1)
                        {
                            constantMemoryKernelIndex = i;
                        }
                        totalCodeCount++;
                    }
                    else
                    {
                        constantMemoryReqd = gcvTRUE;
                    }
                }

                if(KernelArray[i]->privateMemorySize)
                {
                    if(privateMemoryReqd)
                    {
                        if(privateMemoryKernelIndex == -1)
                        {
                            privateMemoryKernelIndex = i;
                        }
                        totalCodeCount++;
                    }
                    else
                    {
                        privateMemoryReqd = gcvTRUE;
                    }
                }

                if(constantMemoryKernelIndex != -1 &&
                    privateMemoryKernelIndex != -1 &&
                    constantPrivateMemoryKernelIndex != -1)
                {
                    constantMemoryKernelIndex = privateMemoryKernelIndex
                                              = constantPrivateMemoryKernelIndex;
                }
            }
            else
            {
                status = gcvSTATUS_INVALID_DATA;
                gcmONERROR(status);
            }
            totalUniformCount += KernelArray[i]->uniformCount;
            totalAttributeCount += KernelArray[i]->attributeCount;
            totalVariableCount += KernelArray[i]->variableCount;
            totalFunctionCount += KernelArray[i]->functionCount;
            totalKernelFunctionCount += KernelArray[i]->kernelFunctionCount;
            totalConstantMemorySize = gcmALIGN(totalConstantMemorySize, _gcd_OCL_BUFFER_MEMORY_ALIGNMENT) +
                                       KernelArray[i]->constantMemorySize;
            totalPrivateMemorySize = gcmALIGN(totalPrivateMemorySize, _gcd_OCL_BUFFER_MEMORY_ALIGNMENT) +
                                       KernelArray[i]->privateMemorySize;
            totalTypeNameBufferSize += KernelArray[i]->typeNameBufferSize;

            if(gcShaderHasExternFunction(KernelArray[i]))
            {
                hasExternFunction = gcvTRUE;
            }
            if(gcShaderHasExternVariable(KernelArray[i]))
            {
                hasExternVariable = gcvTRUE;
            }
        }
        else if (KernelArray[i]->object.type  == gcvOBJ_VIR_SHADER)
        {
            /* TODO: handle vir shaders */
            status = gcvSTATUS_INVALID_DATA;
            gcmONERROR(status);
        }
    }

    totalAllFunctionCount = totalFunctionCount + totalKernelFunctionCount;
    totalAllSymbolCount = totalAllFunctionCount + totalVariableCount;
    if((KernelCount == 1 && (hasExternFunction || hasExternVariable)) ||
       (totalAllFunctionCount == 1 && hasExternFunction) ||
       (totalVariableCount == 1 && hasExternVariable))
    {
        /* output error messages */
        gcoOS_Print("ERROR: program has unresolved extern symbols\n");
        status = gcvSTATUS_INVALID_DATA;
        gcmONERROR(status);
    }

    if(KernelCount > 1 && totalAllSymbolCount > 1)
    {
        gctUINT j;
        VSC_HASH_TABLE *externFunctionHT = gcvNULL;
        VSC_UNI_LIST functionSymbolList;
        _gcsExternFunctionItem *functionSymbolItem;
        VSC_UL_ITERATOR iter;
        VSC_UNI_LIST_NODE* node;
        gctUINT allFunctionCount, currentFunctionCount;
        gctUINT32 currentFunctionLabel;
        gctUINT tempRegCount = maxLocalTempRegCount;
        gctUINT tempIndexOffset;
        gctBOOL hasError;

        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  (totalAllSymbolCount + 1) * gcmSIZEOF(_gcsLabelMap),
                                  &pointer));
        gcoOS_ZeroMemory(pointer, (totalAllSymbolCount + 1) * gcmSIZEOF(_gcsLabelMap));
        builtinIndex.labelMap = pointer;

        vscPMP_Intialize(&externSymbolPmp,
                         gcvNULL,
                         totalAllSymbolCount * 256,
                         sizeof(void *),
                         gcvTRUE);

        if(totalAllFunctionCount)
        {
            externFunctionHT = vscHTBL_Create(&externSymbolPmp.mmWrapper,
                                              vscHFUNC_String,
                                              vcsHKCMP_String,
                                              totalAllFunctionCount);
            vscUNILST_Initialize(&functionSymbolList, gcvFALSE);
        }

        if(totalVariableCount)
        {
            externVariableHT = vscHTBL_Create(&externSymbolPmp.mmWrapper,
                                              vscHFUNC_String,
                                              vcsHKCMP_String,
                                              totalVariableCount);
            vscUNILST_Initialize(&variableSymbolList, gcvFALSE);
        }

        allFunctionCount = 0;
        currentFunctionCount = 0;
        currentFunctionLabel = (gctUINT32)~0;
        for (i = 0; i < KernelCount; i++)
        {
            gcSHADER kernel = KernelArray[i];
            gctUINT labelIndex;

            if (kernel == gcvNULL) continue;

            if (kernel->object.type  == gcvOBJ_SHADER &&
                kernel->type == gcSHADER_TYPE_CL)
            {
                tempIndexOffset = tempRegCount - GetShaderMaxLocalTempRegCount(kernel);
                tempRegCount += GetShaderTempRegCount(kernel) - GetShaderMaxLocalTempRegCount(kernel);

                /*_gcsExternFunctionItem * */
                functionSymbolItem = gcvNULL;
                for (j = 0; j < kernel->kernelFunctionCount; j++)
                {
                    gcKERNEL_FUNCTION kernelFunction = kernel->kernelFunctions[j];

                    if(kernelFunction == gcvNULL) continue;
                    gcmASSERT(!(GetKFunctionFlags(kernelFunction) & gcvFUNC_STATIC));

                    if(vscHTBL_DirectTestAndGet(externFunctionHT, kernelFunction->name, (void**)&functionSymbolItem))
                    {
                        if(!(GetKFunctionFlags(kernelFunction) & gcvFUNC_EXTERN))
                        {
                            if(functionSymbolItem->defined)
                            {
                                functionSymbolItem->redefined = gcvTRUE;
                            }
                            else
                            {
                                functionSymbolItem->defined = gcvTRUE;
                                labelIndex = (gctUINT32)~0 - functionSymbolItem->label;
                                builtinIndex.labelMap[labelIndex].arguments = kernelFunction->arguments;
                                builtinIndex.labelMap[labelIndex].tempIndexOffset = tempIndexOffset;
                            }
                        }
                    }
                    else
                    {
                        functionSymbolItem = (_gcsExternFunctionItem *)vscMM_Alloc(&externSymbolPmp.mmWrapper,
                                                                         sizeof(_gcsExternFunctionItem));

                        functionSymbolItem->externSymbol = kernelFunction->name;
                        functionSymbolItem->isKernelFunction = gcvTRUE;
                        functionSymbolItem->defined = !(GetKFunctionFlags(kernelFunction) & gcvFUNC_EXTERN);
                        functionSymbolItem->redefined = gcvFALSE;
                        functionSymbolItem->label = --currentFunctionLabel;
                        if(functionSymbolItem->defined) {
                            labelIndex = (gctUINT32)~0 - functionSymbolItem->label;
                            builtinIndex.labelMap[labelIndex].arguments = kernelFunction->arguments;
                            builtinIndex.labelMap[labelIndex].tempIndexOffset = tempIndexOffset;
                        }

                        vscHTBL_DirectSet(externFunctionHT, kernelFunction->name, functionSymbolItem);
                        vscUNILST_Append(&functionSymbolList, (VSC_UNI_LIST_NODE*)functionSymbolItem);
                    }
                    labelIndex = (gctUINT32)~0 - kernelFunction->label + currentFunctionCount;
                    builtinIndex.labelMap[labelIndex].newLabel = functionSymbolItem->label;

                    allFunctionCount++;
                }

                for (j = 0; j < kernel->functionCount; j++)
                {
                    gcFUNCTION function = kernel->functions[j];
                    gctUINT newLabel;

                    if(function == gcvNULL) continue;
                    if(!(GetFunctionFlags(function) & gcvFUNC_STATIC))
                    {
                        if(vscHTBL_DirectTestAndGet(externFunctionHT, function->name, (void**)&functionSymbolItem))
                        {
                            if(!(GetFunctionFlags(function) & gcvFUNC_EXTERN))
                            {
                                if(functionSymbolItem->defined)
                                {
                                    functionSymbolItem->redefined = gcvTRUE;
                                }
                                else
                                {
                                    functionSymbolItem->defined = gcvTRUE;
                                    labelIndex = (gctUINT32)~0 - functionSymbolItem->label;
                                    builtinIndex.labelMap[labelIndex].arguments = function->arguments;
                                    builtinIndex.labelMap[labelIndex].tempIndexOffset = tempIndexOffset;
                                }
                            }
                        }
                        else
                        {
                            functionSymbolItem = (_gcsExternFunctionItem *)vscMM_Alloc(&externSymbolPmp.mmWrapper,
                                                                                       sizeof(_gcsExternFunctionItem));

                            functionSymbolItem->externSymbol = function->name;
                            functionSymbolItem->isKernelFunction = gcvFALSE;
                            functionSymbolItem->defined = !(GetFunctionFlags(function) & gcvFUNC_EXTERN);
                            functionSymbolItem->redefined = gcvFALSE;
                            functionSymbolItem->label = --currentFunctionLabel;
                            if(functionSymbolItem->defined) {
                                labelIndex = (gctUINT32)~0 - functionSymbolItem->label;
                                builtinIndex.labelMap[labelIndex].arguments = function->arguments;
                                builtinIndex.labelMap[labelIndex].tempIndexOffset = tempIndexOffset;
                            }

                            vscHTBL_DirectSet(externFunctionHT, function->name, functionSymbolItem);
                            vscUNILST_Append(&functionSymbolList, (VSC_UNI_LIST_NODE*)functionSymbolItem);
                        }
                        newLabel = functionSymbolItem->label;
                    }
                    else
                    {
                        newLabel = function->label - currentFunctionCount;
                    }

                    labelIndex = (gctUINT32)~0 - function->label + currentFunctionCount;
                    builtinIndex.labelMap[labelIndex].newLabel = newLabel;
                    allFunctionCount++;
                }
                currentFunctionCount = allFunctionCount;

                for (j = 0; j < kernel->variableCount; j++)
                {
                    _gcsExternVariableItem *variableSymbolItem;
                    gcVARIABLE variable = kernel->variables[j];

                    if(variable == gcvNULL) continue;
                    if((gctINT)variable->nameLength < 0) continue;

                    if(IsVariableGlobal(variable))
                    {
                        if(vscHTBL_DirectTestAndGet(externVariableHT, variable->name, (void**)&variableSymbolItem))
                        {
                            if(!IsVariableExtern(variable))
                            {
                                if(variableSymbolItem->definedKernel)
                                {
                                    variableSymbolItem->redefined = gcvTRUE;
                                }
                                else
                                {
                                    variableSymbolItem->definedKernel = kernel;
                                    variableSymbolItem->definedVariable = variable;
                                }
                            }
                        }
                        else
                        {
                            variableSymbolItem = (_gcsExternVariableItem *)vscMM_Alloc(&externSymbolPmp.mmWrapper,
                                                                                       sizeof(_gcsExternVariableItem));

                            variableSymbolItem->externSymbol = variable->name;
                            variableSymbolItem->redefined = gcvFALSE;
                            variableSymbolItem->definedKernel = kernel;
                            variableSymbolItem->definedVariable = variable;

                            vscHTBL_DirectSet(externVariableHT, variable->name, variableSymbolItem);
                            vscUNILST_Append(&variableSymbolList, (VSC_UNI_LIST_NODE*)variableSymbolItem);
                        }
                    }
                }
            }
        }
        builtinIndex.totalAllFunctionCount = allFunctionCount;

        hasError = gcvFALSE;
        if(externFunctionHT)
        {
            vscULIterator_Init(&iter, &functionSymbolList);
            for(node = vscULIterator_First(&iter);
                node != gcvNULL; node = vscULIterator_Next(&iter))
            {
/* Check for symbols undefined or multiply defined */
                functionSymbolItem = (_gcsExternFunctionItem *)node;
                if(functionSymbolItem->isKernelFunction) {
                   if(functionSymbolItem->redefined) {
                       gcoOS_Print("ERROR: kernel function \"%s\" multiply defined\n",
                                   functionSymbolItem->externSymbol);
                       hasError = gcvTRUE;
                   }
                   else if(!functionSymbolItem->defined) {
                       gcoOS_Print("ERROR: extern kernel function \"%s\" undefined\n",
                                   functionSymbolItem->externSymbol);
                       hasError = gcvTRUE;
                   }
                }
                else {
                   if(functionSymbolItem->redefined) {
                       gcoOS_Print("ERROR: function \"%s\" multiply defined\n",
                                   functionSymbolItem->externSymbol);
                       hasError = gcvTRUE;
                   }
                   else if(!functionSymbolItem->defined) {
                       gcoOS_Print("ERROR: extern function \"%s\" undefined\n",
                                   functionSymbolItem->externSymbol);
                       hasError = gcvTRUE;
                   }
                }
            }
        }

        if(externVariableHT)
        {
            vscULIterator_Init(&iter, &variableSymbolList);
            for(node = vscULIterator_First(&iter);
                node != gcvNULL; node = vscULIterator_Next(&iter))
            {
                _gcsExternVariableItem *variableSymbolItem;
/* Check for symbols undefined or multiply defined */
                variableSymbolItem = (_gcsExternVariableItem *)node;
                if(variableSymbolItem->redefined) {
                    gcoOS_Print("ERROR: variable \"%s\" multiply defined\n",
                                variableSymbolItem->externSymbol);
                    hasError = gcvTRUE;
                }
                else if(variableSymbolItem->definedKernel == gcvNULL) {
                    gcoOS_Print("ERROR: extern variable \"%s\" undefined\n",
                                variableSymbolItem->externSymbol);
                    hasError = gcvTRUE;
                }
            }
            builtinIndex.externVariableHT = externVariableHT;
        }
        else
        {
            vscPMP_Finalize(&externSymbolPmp);
        }

        if(hasError) {
            status = gcvSTATUS_INVALID_DATA;
            gcmONERROR(status);
        }
    }

    if((KernelCount > 1 && totalAllSymbolCount > 1) ||
       constantMemoryKernelIndex != -1 ||
       privateMemoryKernelIndex != -1)
    {
        gctUINT j;
        gcSHADER fromKernel;
        gcKERNEL_FUNCTION fromKernelFunction = gcvNULL;
        gcUNIFORM privateMemoryUniform, constantMemoryUniform;
        gctINT numInstruction = 0;
        gctUINT totalConstantMemorySize;
        gctUINT totalPrivateMemorySize;
        gctBOOL constantMemoryReqd, privateMemoryReqd;

        /* Construct kernel binary. */
        gcmONERROR(gcSHADER_Construct(gcSHADER_TYPE_CL, &mergedKernel));

        gcmASSERT(compilerVersion);
        gcmONERROR(gcSHADER_SetCompilerVersion(mergedKernel,
                                               compilerVersion));
        gcmONERROR(gcSHADER_SetMaxKernelFunctionArgs(mergedKernel,
                                                     maxKernelArgs));
        SetShaderTempRegCount(mergedKernel, maxLocalTempRegCount);

        totalCodeCount++;  /* possible extra instruction for constant memory base address */

        privateMemoryUniform = constantMemoryUniform = gcvNULL;
        totalUniformCount += (privateMemoryKernelIndex != -1 ? 1 : 0) +
                             (constantMemoryKernelIndex != -1 ? 1 : 0);
        gcmONERROR(gcSHADER_ReallocateUniforms(mergedKernel,
                                               totalUniformCount));

        fromKernel = gcvNULL;
        if(privateMemoryKernelIndex != -1)
        {
            gctINT codeEnd;

            fromKernel = KernelArray[privateMemoryKernelIndex];
            gcmASSERT(fromKernel);

            fromKernelFunction = gcvNULL;
            codeEnd = 0;
            for (j = 0; j < fromKernel->kernelFunctionCount; j++)
            {
                fromKernelFunction = fromKernel->kernelFunctions[j];
                if(fromKernelFunction == gcvNULL) continue;
                codeEnd = _UsedReservedTempReg(fromKernel,
                                               fromKernelFunction,
                                               _gcdOCL_PrivateMemoryAddressRegIndex);
                if(!codeEnd) continue;
                numInstruction = codeEnd - fromKernelFunction->codeEnd  + 1;
                totalCodeCount += numInstruction;
                break;
            }
            gcmASSERT(codeEnd);

            gcmONERROR(gcSHADER_AddUniform(mergedKernel,
                                           "#private_address",
                                           gcSHADER_UINT_X1,
                                           1,
                                           gcSHADER_PRECISION_HIGH,
                                           &privateMemoryUniform));
            gcmONERROR(gcUNIFORM_SetFlags(privateMemoryUniform, gcvUNIFORM_KIND_PRIVATE_ADDRESS_SPACE));
            gcmONERROR(gcUNIFORM_SetFormat(privateMemoryUniform, gcSL_INT8, gcvTRUE));
            builtinIndex.uniform[gcvUNIFORM_KIND_PRIVATE_ADDRESS_SPACE] = privateMemoryUniform->index;
        }

        _ExpandCode(mergedKernel,
                    totalCodeCount - mergedKernel->codeCount);

        if(constantMemoryKernelIndex != -1)
        {
            gcmONERROR(gcSHADER_AddUniform(mergedKernel,
                                           "#constant_address",
                                           gcSHADER_UINT_X1,
                                           1,
                                           gcSHADER_PRECISION_HIGH,
                                           &constantMemoryUniform));
            gcmONERROR(gcUNIFORM_SetFlags(constantMemoryUniform, gcvUNIFORM_KIND_CONSTANT_ADDRESS_SPACE));
            gcmONERROR(gcUNIFORM_SetFormat(constantMemoryUniform, gcSL_INT8, gcvTRUE));
            builtinIndex.uniform[gcvUNIFORM_KIND_CONSTANT_ADDRESS_SPACE] = constantMemoryUniform->index;

            /* Add mov of constant memory base address uniform to its corresponding reserved temp */
            gcSHADER_AddOpcode(mergedKernel,
                               gcSL_MOV,
                               (gctUINT32)_gcdOCL_ConstantMemoryAddressRegIndex,
                               gcSL_ENABLE_X,
                               gcSL_UINT32,
                               gcSHADER_PRECISION_HIGH,
                               0);

            gcSHADER_AddSourceUniformFormatted(mergedKernel,
                                               constantMemoryUniform,
                                               gcSL_SWIZZLE_XXXX,
                                               gcSL_NOT_INDEXED,
                                               gcSL_UINT32);
        }
        _gcmEndInstruction(mergedKernel);

        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  totalCodeCount* gcmSIZEOF(gctBOOL),
                                  &pointer));
        gcoOS_ZeroMemory(pointer, totalCodeCount * gcmSIZEOF(gctBOOL));
        builtinIndex.instInKernelFuncPrep = pointer;

        gcmONERROR(gcSHADER_ReallocateAttributes(mergedKernel,
                                                 totalAttributeCount));
        gcmONERROR(gcSHADER_ReallocateVariables(mergedKernel,
                                                totalVariableCount));
        gcmONERROR(gcSHADER_ReallocateFunctions(mergedKernel,
                                                totalFunctionCount));
        gcmONERROR(gcSHADER_ReallocateKernelFunctions(mergedKernel,
                                                      totalKernelFunctionCount));

        if(fromKernel)
        {
            gctUINT32 oldCodeCount;
            gctUINT32 bytes;

            gcmASSERT(fromKernelFunction);
            gcmASSERT(numInstruction);
            bytes = numInstruction * sizeof(struct _gcSL_INSTRUCTION);
            gcmASSERT(bytes);
            oldCodeCount = mergedKernel->lastInstruction;
            gcoOS_MemCopy(mergedKernel->code + oldCodeCount,
                          fromKernel->code + fromKernelFunction->codeEnd,
                          bytes);
            mergedKernel->lastInstruction += numInstruction;
            mergedKernel->instrIndex = gcSHADER_OPCODE;
            gcmONERROR(_MergeAttributes(mergedKernel,
                                        fromKernel,
                                        gcvTRUE,
                                        oldCodeCount,
                                        &builtinIndex));
            gcmONERROR(_MergeUniforms(mergedKernel,
                                      fromKernel,
                                      gcvTRUE,
                                      oldCodeCount,
                                      &builtinIndex));
        }

        constantMemoryReqd = privateMemoryReqd = gcvFALSE;
        totalConstantMemorySize = totalPrivateMemorySize = 0;
        builtinIndex.reservedTempReg = GetShaderTempRegCount(mergedKernel);

        for (i = 0; i < KernelCount; i++)
        {
            gctUINT tempIndex;

            fromKernel = KernelArray[i];
            if (fromKernel == gcvNULL)
            {
                continue;
            }

            gcmASSERT(fromKernel->object.type  == gcvOBJ_SHADER &&
                      fromKernel->type == gcSHADER_TYPE_CL);
            if(fromKernel->constantMemorySize)
            {
                if(constantMemoryReqd)
                {
                    tempIndex = GetShaderTempRegCount(mergedKernel);
                    gcmONERROR(gcSHADER_AddOpcode(mergedKernel,
                                                  gcSL_ADD,
                                                  tempIndex,
                                                  gcSL_ENABLE_X,
                                                  gcSL_UINT32,
                                                  gcSHADER_PRECISION_HIGH,
                                                  0));
                    gcmONERROR(gcSHADER_AddSource(mergedKernel,
                                                  gcSL_TEMP,
                                                  _gcdOCL_ConstantMemoryAddressRegIndex,
                                                  gcSL_SWIZZLE_XXXX,
                                                  gcSL_UINT32,
                                                  gcSHADER_PRECISION_HIGH));
                    gcmONERROR(gcSHADER_AddSourceConstantFormatted(mergedKernel,
                                                                   (void *)&totalConstantMemorySize,
                                                                   gcSL_UINT32));
                }
                else
                {
                    constantMemoryReqd = gcvTRUE;
                }
            }

            if(fromKernel->privateMemorySize)
            {
                if(privateMemoryReqd)
                {
                    tempIndex = GetShaderTempRegCount(mergedKernel);
                    gcmONERROR(gcSHADER_AddOpcode(mergedKernel,
                                                  gcSL_ADD,
                                                  tempIndex,
                                                  gcSL_ENABLE_X,
                                                  gcSL_UINT32,
                                                  gcSHADER_PRECISION_HIGH,
                                                  0));
                    gcmONERROR(gcSHADER_AddSource(mergedKernel,
                                                  gcSL_TEMP,
                                                  _gcdOCL_PrivateMemoryAddressRegIndex,
                                                  gcSL_SWIZZLE_XXXX,
                                                  gcSL_UINT32,
                                                  gcSHADER_PRECISION_HIGH));
                    gcmONERROR(gcSHADER_AddSourceConstantFormatted(mergedKernel,
                                                                   (void *)&totalPrivateMemorySize,
                                                                   gcSL_UINT32));
                }
                else
                {
                    privateMemoryReqd = gcvTRUE;
                }
            }
            totalConstantMemorySize = gcmALIGN(totalConstantMemorySize, _gcd_OCL_BUFFER_MEMORY_ALIGNMENT) +
                                               fromKernel->constantMemorySize;
            totalPrivateMemorySize = gcmALIGN(totalPrivateMemorySize, _gcd_OCL_BUFFER_MEMORY_ALIGNMENT) +
                                              fromKernel->privateMemorySize;
        }
        _gcmEndInstruction(mergedKernel);

        if(totalConstantMemorySize)
        {
            gctCHAR *constantMemoryBuffer;

            /* Allocate a new array of object pointers. */
            gcmONERROR(gcoOS_Allocate(gcvNULL,
                                      gcmSIZEOF(gctCHAR) * totalConstantMemorySize,
                                      &pointer));
            constantMemoryBuffer = pointer;
            gcoOS_ZeroMemory(constantMemoryBuffer, gcmSIZEOF(gctCHAR) * totalConstantMemorySize);

            mergedKernel->constantMemoryBuffer = constantMemoryBuffer;
        }

        if(totalTypeNameBufferSize)
        {
            gctCHAR *typeNameBuffer;

            /* Allocate a new array of object pointers. */
            gcmONERROR(gcoOS_Allocate(gcvNULL,
                                      gcmSIZEOF(gctCHAR) * totalTypeNameBufferSize,
                                      &pointer));
            typeNameBuffer = pointer;
            gcoOS_ZeroMemory(typeNameBuffer, gcmSIZEOF(gctCHAR) * totalTypeNameBufferSize);

            mergedKernel->typeNameBuffer = typeNameBuffer;
        }
    }

    for (i=0; i < KernelCount; i++)
    {
        gcSHADER fromKernel = KernelArray[i];

        if (fromKernel == gcvNULL)
        {
            continue;
        }

        gcmASSERT(fromKernel->object.type  == gcvOBJ_SHADER &&
                  fromKernel->type == gcSHADER_TYPE_CL);
        if(mergedKernel == gcvNULL)
        {
            gctUINT j, k;
            gctUINT *indexMap;
            gctUINT currIndex;

            gcmONERROR(gcCopyKernel(fromKernel, &mergedKernel));

            /* Record builtin attributes indices. */
            for (j = 0; j < fromKernel->attributeCount; j++)
            {
                gctCONST_STRING attributeName;

                if(fromKernel->attributes[j] == gcvNULL) {
                    continue;
                }
                gcmASSERT(fromKernel->attributes[j]->index == j);

                gcATTRIBUTE_GetName(fromKernel, fromKernel->attributes[j], gcvTRUE, gcvNULL, &attributeName);
                for (k = 0; k < _gcd_OCL_NUM_BUILTIN_ATTRIBUTES; k++)
                {
                    if (gcmIS_SUCCESS(gcoOS_StrCmp(attributeName, builtinIndex.attributeName[k])))
                    {
                        gcmASSERT(builtinIndex.attribute[k] < 0);
                        builtinIndex.attribute[k] = j;
                        break;
                    }
                }
            }

            /* adjust all uniforms */
            if(fromKernel->uniformCount + fromKernel->maxKernelFunctionArgs) {
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          (fromKernel->uniformCount + fromKernel->maxKernelFunctionArgs) * gcmSIZEOF(gctINT),
                                          &pointer));
                indexMap = pointer;
                for(j = 0; j < (fromKernel->uniformCount + fromKernel->maxKernelFunctionArgs); j++) {
                    indexMap[j] = j;
                }

                currIndex = maxKernelArgs;
                for(j = 0; j < mergedKernel->uniformCount; j++)
                {
                    gcUNIFORM uniform = mergedKernel->uniforms[j];

                    if(uniform)
                    {
                        gceUNIFORM_FLAGS kind;

                        gcmASSERT(uniform->index >= (fromKernel->maxKernelFunctionArgs + j));
                        kind = GetUniformKind(uniform);
                        if(isUniformKindBuiltin(kind))
                        {
                            gcmASSERT(builtinIndex.uniform[kind] < 0);
                            builtinIndex.uniform[kind] = currIndex;
                        }
                        indexMap[uniform->index] = currIndex;
                        uniform->index = (gctUINT16)currIndex;
                        currIndex++;
                    }
                }

                if(maxKernelArgs - fromKernel->maxKernelFunctionArgs)
                {
                    _AdjustInstUniforms(mergedKernel,
                                        indexMap,
                                        0);
                }

                gcmONERROR(gcoOS_Free(gcvNULL,
                                      indexMap));
            }

            gcmONERROR(gcSHADER_SetMaxKernelFunctionArgs(mergedKernel,
                                                         maxKernelArgs));

            /* Adjust all temp registers */
            if(maxLocalTempRegCount > GetShaderMaxLocalTempRegCount(fromKernel))
            {
                gctUINT fromKernelMaxLocalTempRegCount = GetShaderMaxLocalTempRegCount(fromKernel);
                gctUINT tempIndexOffset;

                tempIndexOffset = maxLocalTempRegCount - fromKernelMaxLocalTempRegCount;
                for(j = 0; j < mergedKernel->variableCount; j++)
                {
                    gcVARIABLE variable = mergedKernel->variables[j];

                    if(variable)
                    {
                        variable->tempIndex += tempIndexOffset;
                    }
                }

                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          GetShaderTempRegCount(fromKernel) * gcmSIZEOF(gctINT),
                                          &pointer));
                indexMap = pointer;

                for(j = 0; j < fromKernelMaxLocalTempRegCount; j++) {
                    indexMap[j] = j;
                }

                for(j = fromKernelMaxLocalTempRegCount; j < GetShaderTempRegCount(fromKernel); j++) {
                    indexMap[j] = j + tempIndexOffset;
                }

                _AdjustInstTempRegs(mergedKernel,
                                    indexMap,
                                    gcvNULL,
                                    gcvTRUE,
                                    0);

                gcmONERROR(gcoOS_Free(gcvNULL,
                                      indexMap));
                SetShaderMaxLocalTempRegCount(mergedKernel, maxLocalTempRegCount);
                SetShaderTempRegCount(mergedKernel, GetShaderTempRegCount(mergedKernel) + tempIndexOffset);
            }

            if(totalCodeCount > mergedKernel->codeCount)
            {
                 _ExpandCode(mergedKernel,
                             totalCodeCount - mergedKernel->codeCount);
            }

            if(builtinIndex.instInKernelFuncPrep == gcvNULL)
            {
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          totalCodeCount* gcmSIZEOF(gctBOOL),
                                          &pointer));
                gcoOS_ZeroMemory(pointer, totalCodeCount * gcmSIZEOF(gctBOOL));
                builtinIndex.instInKernelFuncPrep = pointer;
            }

            gcmONERROR(gcSHADER_ReallocateUniforms(mergedKernel,
                                                   totalUniformCount));
            gcmONERROR(gcSHADER_ReallocateAttributes(mergedKernel,
                                                     totalAttributeCount));
            gcmONERROR(gcSHADER_ReallocateVariables(mergedKernel,
                                                    totalVariableCount));
            gcmONERROR(gcSHADER_ReallocateFunctions(mergedKernel,
                                                    totalFunctionCount));
            gcmONERROR(gcSHADER_ReallocateKernelFunctions(mergedKernel,
                                                          totalKernelFunctionCount));

            if(totalConstantMemorySize > mergedKernel->constantMemorySize)
            {
                gctCHAR *constantMemoryBuffer;

                /* Allocate a new array of object pointers. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          gcmSIZEOF(gctCHAR) * totalConstantMemorySize,
                                          &pointer));
                constantMemoryBuffer = pointer;
                gcoOS_ZeroMemory(constantMemoryBuffer, gcmSIZEOF(gctCHAR) * totalConstantMemorySize);

                if (mergedKernel->constantMemorySize)
                {
                    /* Copy the current object pointers. */
                    gcoOS_MemCopy(constantMemoryBuffer,
                                  mergedKernel->constantMemoryBuffer,
                                  mergedKernel->constantMemorySize);

                    /* Free the current constant memory buffer. */
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, mergedKernel->constantMemoryBuffer));
                }
                mergedKernel->constantMemoryBuffer = constantMemoryBuffer;
            }

            if(totalTypeNameBufferSize > mergedKernel->typeNameBufferSize)
            {
                gctCHAR *typeNameBuffer;

                /* Allocate a new array of object pointers. */
                gcmONERROR(gcoOS_Allocate(gcvNULL,
                                          gcmSIZEOF(gctCHAR) * totalTypeNameBufferSize,
                                          &pointer));
                typeNameBuffer = pointer;
                gcoOS_ZeroMemory(typeNameBuffer, gcmSIZEOF(gctCHAR) * totalTypeNameBufferSize);

                if (mergedKernel->typeNameBufferSize)
                {
                    /* Copy the current object pointers. */
                    gcoOS_MemCopy(typeNameBuffer,
                                  mergedKernel->typeNameBuffer,
                                  mergedKernel->typeNameBufferSize);

                    /* Free the current type name buffer. */
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, mergedKernel->typeNameBuffer));
                }
                mergedKernel->typeNameBuffer = typeNameBuffer;
            }

            /* Clear source code string */
            mergedKernel->sourceLength = 0;
            mergedKernel->source = gcvNULL;

            mergedKernel->libraryList           = gcvNULL;
        }
        else
        {
            gcmONERROR(_MergeOneKernel(mergedKernel,
                                       fromKernel,
                                       &builtinIndex));
        }
    }

    if(mergedKernel)
    {
        gcmONERROR(gcSHADER_Pack(mergedKernel));
    }

OnError:
    if(builtinIndex.instInKernelFuncPrep)
    {
        gcmONERROR(gcoOS_Free(gcvNULL,
                              builtinIndex.instInKernelFuncPrep));
    }

    if(builtinIndex.labelMap)
    {
        gcmONERROR(gcoOS_Free(gcvNULL,
                              builtinIndex.labelMap));
    }

    if(externVariableHT)
    {
        vscPMP_Finalize(&externSymbolPmp);
    }

    *MergedKernel = mergedKernel;
    gcmFOOTER_ARG("*MergedKernel=0x%x", mergedKernel);
    return status;
}
#endif

/* go through the kernel function body to mark any kernel function be
 * called as CalledByEntryKernel */
void
_markUsedKernelFunction(gcKERNEL_FUNCTION KernelFunction)
{
    gctUINT   codeStart = KernelFunction->codeStart;
    gctUINT   codeEnd = KernelFunction->codeEnd;
    gctUINT   i;
    gcSHADER shader = KernelFunction->shader;

    for (i = codeStart; i < codeEnd; ++i)
    {
        if ((gcSL_OPCODE)gcmSL_OPCODE_GET(shader->code[i].opcode, Opcode) == gcSL_CALL)
        {
            gctBOOL   isKernelFunc = gcvFALSE;
            gctUINT funcIdx = gcSHADER_GetFunctionByCodeId(shader,
                                    shader->code[i].tempIndex, &isKernelFunc);
            if (isKernelFunc &&
                !shader->kernelFunctions[funcIdx]->isCalledByEntryKernel)
            {
                gcmASSERT(funcIdx < shader->kernelFunctionCount);
                shader->kernelFunctions[funcIdx]->isCalledByEntryKernel = gcvTRUE;
                _markUsedKernelFunction(shader->kernelFunctions[funcIdx]);
            }
        }
    }
}

static gceSTATUS
_MapKernelArgUniforms(
    IN gcSHADER Shader
    )
{
    gceSTATUS           status = gcvSTATUS_OK;
    gcKERNEL_FUNCTION   kernelFunction = GetShaderCurrentKernelFunction(Shader);
    gcUNIFORM           argUniform = gcvNULL, uniform = gcvNULL;
    gctUINT32           uniformArgCount, i;

    uniformArgCount = kernelFunction->uniformArgumentCount;

    gcmASSERT(uniformArgCount <= GetShaderUniformCount(Shader));

    /* We need to make sure that they are the same uniforms first. */
    for (i = 0; i < uniformArgCount; i++)
    {
        argUniform = kernelFunction->uniformArguments[i];
        uniform = Shader->uniforms[i];

        if (!hasUniformKernelArgKind(uniform))
        {
            return status;
        }

        if (argUniform->nameLength != uniform->nameLength)
        {
            return status;
        }
        if (argUniform->nameLength > 0 &&
            !(gcmIS_SUCCESS(gcoOS_StrNCmp(argUniform->name, uniform->name, argUniform->nameLength))))
        {
            return status;
        }
    }

    /* Now use the uniformArgument to replace the original uniform. */
    for (i = 0; i < uniformArgCount; i++)
    {
        if (Shader->uniforms[i] == kernelFunction->uniformArguments[i])
            continue;

        if (Shader->uniforms[i]->arrayLengthList != gcvNULL)
        {
            gcmASSERT(Shader->uniforms[i]->arrayLengthCount > 0);
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->uniforms[i]->arrayLengthList));
        }

        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->uniforms[i]));

        Shader->uniforms[i] = kernelFunction->uniformArguments[i];
    }

    return status;
}

/*******************************************************************************
**  gcSHADER_LoadKernel
**
**  Load a kernel function given by name into gcSHADER object
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctSTRING KernelName
**          Pointer to a kernel function name
**
**  OUTPUT:
**      nothing
**
*/
gceSTATUS
gcSHADER_LoadKernel(
    IN gcSHADER Shader,
    IN gctSTRING KernelName
    )
{
    gctUINT32 i, j;
    gctUINT32 maxKernelFunctionArgs;
    gcKERNEL_FUNCTION kernelFunction = gcvNULL;
    gctUINT begin, end;

    gcmHEADER_ARG("Shader=0x%x KernelName=%s", Shader, KernelName);

    if (Shader->kernelFunctionCount > 0) {

        for (i = 0; i < Shader->kernelFunctionCount; i++) {
            if (Shader->kernelFunctions[i] == gcvNULL) continue;

            if (gcmIS_SUCCESS(gcoOS_StrCmp(Shader->kernelFunctions[i]->name, KernelName)))
            {
                kernelFunction = Shader->kernelFunctions[i];
                break;
            }
        }
    }

    if (kernelFunction == gcvNULL) {
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    Shader->currentKernelFunction = kernelFunction;
    Shader->localMemorySize = kernelFunction->localMemorySize;
    maxKernelFunctionArgs = Shader->maxKernelFunctionArgs;

    Shader->globalUniformCount = Shader->uniformCount;

    /* Map the kernel function argument uniforms to the uniform list. */
    if (maxKernelFunctionArgs > 0)
    {
        /* Check array count */
        if (Shader->uniformArraySize <= Shader->uniformCount + maxKernelFunctionArgs) {
            /* Reallocate a new array of object pointers. */
            gcmVERIFY_OK(gcSHADER_ReallocateUniforms(Shader, Shader->uniformCount + maxKernelFunctionArgs));
        }

        /* Shift shader uniforms down */
        for (i = Shader->uniformCount; i > 0; i--) {
            Shader->uniforms[i+maxKernelFunctionArgs-1] = Shader->uniforms[i-1];
        }

        if (Shader->globalUniformCount == 0) {
            maxKernelFunctionArgs = kernelFunction->uniformArgumentCount;
        }

        Shader->uniformCount += maxKernelFunctionArgs;

        /* Load kernel uniforms arguments into shader uniforms */
        for (i = 0; i < kernelFunction->uniformArgumentCount; i++) {
            Shader->uniforms[i] = kernelFunction->uniformArguments[i];
        }

        /* Clean up unused uniforms */
        if (kernelFunction->uniformArgumentCount < maxKernelFunctionArgs) {
            for (i = kernelFunction->uniformArgumentCount; i < maxKernelFunctionArgs; i++) {
                Shader->uniforms[i] = gcvNULL;
            }
        }
    }
    else if (gcShaderAfterLink(Shader))
    {
        _MapKernelArgUniforms(Shader);
    }

    /* check if the entry kernel calling any other kernel:
     *  OpenCL 1.2 Spec 6.7.1: It is just a regular function call if a __kernel
     *  function is called by another kernel function. */
    if (Shader->currentKernelFunction)
    {
        _markUsedKernelFunction(Shader->currentKernelFunction);
    }

    /* Remove instructions for loading uniforms of other kernel functions */
    for (i = 0; i < Shader->kernelFunctionCount; i++) {

        kernelFunction = Shader->kernelFunctions[i];

        if (kernelFunction == gcvNULL||
            kernelFunction == Shader->currentKernelFunction )
        {
            continue;
        }

        /* codeEnd points to the end of kernel function body,
         * codeCount includes the load uniform and call to the kernel function
         */
        begin = kernelFunction->isCalledByEntryKernel ? kernelFunction->codeEnd : kernelFunction->codeStart;
        end   = kernelFunction->codeStart + kernelFunction->codeCount;

        for (j=begin; j<end; j++) {
            gcoOS_ZeroMemory(&Shader->code[j], sizeof(struct _gcSL_INSTRUCTION));
        }
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_Load
**
**  Load a gcSHADER object from a binary buffer.  The binary buffer is layed out
**  as follows:
**      // Six word header
**      // Signature, must be 'S','H','D','R'.
**      gctINT8             signature[4];
**      gctUINT32           binFileVersion;
**      gctUINT32           compilerVersion[2];
**      gctUINT32           gcSLVersion;
**      gctUINT32           binarySize;
**
**
**      // Number of attributes.  Can be 0, in which case the next field will be
**      // uniformCount.
**      gctUINT16                attributeCount;
**
**      // attributeCount structures.  Each structure is followed by the
**      // attribute name, without the trailing '\0'.  Each structure is
**      // optionally padded with 0x00 to align to a 16-bit boundary.
**      struct _GCSL_BINARY_ATTRIBUTE {
**          gctINT8         componentCount;
**          gctINT8         isTexture;
**          gctINT16            nameLength;
**          char            name[];
**      } attributes[];
**
**      // Number of uniforms.  Can be 0, in which case the next field will be
**      // outputCount which also implies no uniform blocks as a uniform block must
**      // have an associated uniform
**      gctUINT16                uniformCount
**
**      // uniformCount structures.  Each structure is followed by the uniform
**      // name, without the trailing '\0'.  Each structure is optionally padded
**      // with 0x00 to align to a 16-bit boundary.
**      struct _GCSL_BINARY_UNIFORM {
**          gctUINT16           index;
**          gctUINT8            type;
**          gctINT16            count;
**          gctINT16            nameLength;
**          char            name[];
**      } uniforms[];
**
**      // Number of uniform blocks.  Can be 0, in which case the next field will be
**      outputCount.
**      gctUINT16                uniformBlockCount
**
**      // uniformBlockCount structures.  Each structure is followed by the uniformBlock
**      // name, without the trailing '\0'.  Each structure is optionally padded
**      // with 0x00 to align to a 16-bit boundary.
**      struct _GCSL_BINARY_UNIFORM_BLOCK {
**          gctUINT16           memoryLayout;
**          gctUINT16           blockSize;
**          gctUINT16           numBlockElement;
**          gctINT16            firstChild;
**          gctINT16            nextSibling;
**          gctINT16            prevSibling;
**          gctUINT16           index;
**          gctINT16            nameLength;
**          char                name[];
**      } uniformBlocks[];
**
**      // Number of outputs.  Must be at least 1.
**      gctINT16                outputCount
**
**      // outputCount structures.  Each structure is followed by the output
**      // name, without the trailing '\0'.  Each structure is optionally padded
**      // with 0x00 to align to a 16-bit boundary.
**      struct _GCSL_BINARY_OUTPUT {
**          gctINT8         componentCount;
**          gctINT8         filler;     // align next field to 16-bit boundary
**          gctUINT16           tempIndex;
**          gctINT16            nameLength;
**          char            name[];
**      } outputs[];
**
**      // Number of input/output locations.  Can be 0, in which case the next field will be
**      // variableCount.
**      gctUINT16                locationCount;
**
**      // array of locations.  Each location is 16 bit signed integer
**      gctINT16  locations[];
**
**      // Number of instructions in code.
**      gctINT16                codeCount;
**
**      // The code buffer.
**      glSL_INSTRUCTION    code[];
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctPOINTER Buffer
**          Pointer to a binary buffer containing the shader data to load.
**
**      gctUINT32 BufferSize
**          Number of bytes inside the binary buffer pointed to by 'Buffer'.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_Load(
    IN gcSHADER Shader,
    IN gctPOINTER Buffer,
    IN gctUINT32 BufferSize
    )
{
    gctUINT32           bytes;
    gctUINT32           *codeCount;
    gctUINT16           *count;
    gctUINT16           *realCount;
    gceSTATUS           status;
    gcBINARY_ATTRIBUTE  binaryAttribute;
    gctUINT             i, psClrOutputLoc;
    gctUINT             j;
    gctUINT32           length, length2, binarySize;
    gctINT16            *locations;
    gcATTRIBUTE         attribute;
    gcBINARY_UNIFORM    binaryUniform;
    gcUNIFORM           uniform;
    gcBINARY_OUTPUT     binaryOutput;
    gcOUTPUT            output;
    gcOUTPUT            prevOutput = gcvNULL;
    gcBINARY_VARIABLE   binaryVariable;
    gcVARIABLE          variable;
    gcBINARY_FUNCTION   binaryFunction;
    gcFUNCTION          function;
    gcBINARY_ARGUMENT   binaryArgument;
    gcsFUNCTION_ARGUMENT_PTR argument;
    gcSL_INSTRUCTION    code;
    gctUINT8 *          curPos;
    gctPOINTER          pointer = gcvNULL;
    gctUINT32           shaderVersion;
#if gcdUSE_WCLIP_PATCH
    gctUINT16           wclipListCount = 0;
    struct _gcBINARY_LIST   binaryList;
#endif
    gctUINT32           allocBytes;
    gctINT32            hasNotStagesRelatedLinkError = 0;
    gcBINARY_TFBVarying binaryTfbVarying;

    gcmHEADER_ARG("Shader=0x%x Buffer=0x%x BufferSize=%lu",
                  Shader, Buffer, BufferSize);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Buffer != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(BufferSize > 0);

    if(!Shader) {
       gcmFATAL("gcSHADER_Load: null shader handle passed");
       gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
       return gcvSTATUS_INVALID_ARGUMENT;
    }

    _gcSHADER_Clean(Shader);

    /* Load the Header */
    status = gcSHADER_LoadHeader(Shader, Buffer, BufferSize, &shaderVersion);
    if(gcmIS_ERROR(status)) {
       gcmFOOTER();
       return status;
    }

    bytes = BufferSize - _getShaderBinaryHeaderSize(shaderVersion);

    /* Get the attribute count. */
    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_UNIFORM_PHYSICAL_ADDR)
    {
        count  = (gctUINT16 *) ((gctUINT8 *)Buffer + _getShaderBinaryHeaderSize(shaderVersion));
    }
    /* Get sampler index, then get attribute count. */
    else
    {
        Shader->samplerIndex = *(gctINT *)((gctUINT8 *)Buffer + _getShaderBinaryHeaderSize(shaderVersion));

        if (bytes < sizeof(gctINT))
        {
            /* Invalid sampler index. */
            gcmFATAL("gcSHADER_LoadEx: Invalid sampler index.");
            gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
            return gcvSTATUS_INVALID_DATA;
        }

        bytes -= sizeof(gctINT);
        count  = (gctUINT16 *) ((gctUINT8 *)Buffer + _getShaderBinaryHeaderSize(shaderVersion) + sizeof(gctINT));
    }

    /************************************************************************/
    /*                                  attributes                          */
    /************************************************************************/
    if (bytes < sizeof(gctUINT16))
    {
        /* Invalid attribute count. */
        gcmFATAL("gcSHADER_Load: Invalid attributeCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }
    bytes          -= sizeof(gctUINT16);

    /* Get the attribute count. */
    realCount  = (gctUINT16 *) (count + 1);

    if (bytes < sizeof(gctUINT16))
    {
        /* Invalid attribute count. */
        gcmFATAL("gcSHADER_Load: Invalid attributeCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }
    bytes          -= sizeof(gctUINT16);

    /* Save the attribute count. */
    Shader->attributeCount = *realCount;

    /* Point to the first attribute. */
    binaryAttribute = (gcBINARY_ATTRIBUTE) (realCount + 1);

    if (Shader->attributeCount > 0)
    {
        gctINT versionAdjustment = 0;

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
        {
            /* precision field which is not in the version */
            versionAdjustment += sizeof(binaryAttribute->precision);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_TYPE_NAME_VAR_INDEX)
        {
            /* precision field which is not in the version */
            versionAdjustment += sizeof(binaryAttribute->typeNameVarIndex);
        }

        /* Allocate the array of gcATTRIBUTE structure pointers. */
        allocBytes = Shader->attributeCount * sizeof(gcATTRIBUTE);
        status = gcoOS_Allocate(gcvNULL,
                               allocBytes,
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->attributeCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
            gcmFOOTER();
            return status;
        }

        gcoOS_ZeroMemory(pointer, allocBytes);
        Shader->attributes = pointer;

        /* Parse all attributes. */
        for (i = 0; i < *count; i++)
        {
            /* Get the length of the attribute name. */
            length = (bytes < sizeof(struct _gcBINARY_ATTRIBUTE))
                         ? 0
                         : binaryAttribute->nameLength;

            /* Test for special length. */
            if ((gctINT) length < 0)
            {
                length = 0;
            }

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_ATTRIBUTE, name) + length,
                                  2);

            if (bytes < (binarySize - versionAdjustment))
            {
                /* Roll back. */
                Shader->attributeCount = i;

                /* Invalid attribute. */
                gcmFATAL("gcSHADER_Load: Invalid attribute");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            allocBytes = gcmOFFSETOF(_gcATTRIBUTE, name) + length + 1;
            /* Allocate memory for the attribute inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                    allocBytes,
                                    &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->attributeCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_ZeroMemory(pointer, allocBytes);
            attribute = pointer;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
            {
                attribute->precision = gcSHADER_PRECISION_DEFAULT;
            }
            else
            {
                attribute->precision = (gcSHADER_PRECISION)binaryAttribute->precision;
            }

            /* Copy attribute to the gcSHADER object. */
            Shader->attributes[binaryAttribute->index]      = attribute;
            attribute->object.type                          = gcvOBJ_ATTRIBUTE;
            attribute->index                                = binaryAttribute->index;
            attribute->type                                 = (gcSHADER_TYPE) binaryAttribute->type;
            attribute->flags_                               = (gctUINT32)
                                                              (binaryAttribute->flags1 | (binaryAttribute->flags2 << 16));
            attribute->arraySize                            = binaryAttribute->arraySize;
            attribute->arrayLength                          = binaryAttribute->arrayLength;
            attribute->inputIndex                           = -1;
            attribute->shaderMode                           = gcSHADER_SHADER_DEFAULT;
            attribute->componentShadeMode[0]                = gcSHADER_SHADER_DEFAULT;
            attribute->componentShadeMode[1]                = gcSHADER_SHADER_DEFAULT;
            attribute->componentShadeMode[2]                = gcSHADER_SHADER_DEFAULT;
            attribute->componentShadeMode[3]                = gcSHADER_SHADER_DEFAULT;
            attribute->location                             = -1;
            attribute->ioBlockIndex                         = binaryAttribute->ioBlockIndex;
            attribute->ioBlockArrayIndex                    = binaryAttribute->ioBlockArrayIndex;
            attribute->nextSibling                          = binaryAttribute->nextSibling;
            attribute->prevSibling                          = binaryAttribute->prevSibling;
            attribute->shaderMode                           = (gcSHADER_SHADERMODE) binaryAttribute->shaderMode;
            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_TYPE_NAME_VAR_INDEX)
            {
                attribute->typeNameVarIndex                 = -1;
            }
            else
            {
                attribute->typeNameVarIndex                 = binaryAttribute->typeNameVarIndex;
            }
            attribute->nameLength                           = binaryAttribute->nameLength;
            attribute->name[length]                          = '\0';

            if (length > 0)
            {
               gcoOS_MemCopy(attribute->name,
                             binaryAttribute->name - versionAdjustment,
                             length);
            }

            /* substract fields which are not in the file version */
            binarySize -= versionAdjustment;

            /* Point to next attribute. */
            binaryAttribute = (gcBINARY_ATTRIBUTE)
                              ((gctINT8 *) binaryAttribute + binarySize);
            bytes          -= binarySize;
        }
    }

    /************************************************************************/
    /*                              uniforms                                */
    /************************************************************************/

    /* Get the uniform count. */
    count = (gctUINT16 *) binaryAttribute;

    if (bytes < sizeof(gctUINT16))
    {
        /* Invalid uniform count. */
        gcmFATAL("gcSHADER_Load: Invalid uniformCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Save the uniform count. */
    Shader->uniformCount = *count;

    /* Point to the first uniform. */
    binaryUniform = (gcBINARY_UNIFORM) (count + 1);
    bytes        -= sizeof(gctUINT16);

    if (Shader->uniformCount > 0)
    {
        gctINT   previousVersionAdjustment = 0;

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_LTC_FILE_VERSION)
        {
            /* fields which are not in the version */
            previousVersionAdjustment = sizeof(binaryUniform->flags)
                                     + sizeof(binaryUniform->glUniformIndex);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION)
        {
            /* fields which are not in the version */
            previousVersionAdjustment += (sizeof(binaryUniform->varCategory) +
                                          sizeof(binaryUniform->firstChild) +
                                          sizeof(binaryUniform->nextSibling) +
                                          sizeof(binaryUniform->prevSibling) +
                                          sizeof(binaryUniform->parent));
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
        {
            /* precision field which is not in the version */
            previousVersionAdjustment += sizeof(binaryUniform->precision);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_HALTI_FILE_VERSION)
        {
            /* fields which are not in the version */
            previousVersionAdjustment += (sizeof(binaryUniform->blockIndex) +
                                          sizeof(binaryUniform->arrayStride) +
                                          sizeof(binaryUniform->matrixStride) +
                                          sizeof(binaryUniform->isRowMajor) +
                                          sizeof(binaryUniform->offset)) +
                                          sizeof(binaryUniform->initializer);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
        {
            /* fields which are not in the version */
            previousVersionAdjustment += sizeof(binaryUniform->binding) +
                                         sizeof(binaryUniform->imageFormat) +
                                         sizeof(binaryUniform->usedArraySize);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_UNIFORM_LOCATION_VERSION)
        {
            /* fields which are not in the version */
            previousVersionAdjustment += sizeof(binaryUniform->location);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_UNIFORM_BASE_BINDING_VERSION)
        {
            /* fields which are not in the version */
            previousVersionAdjustment += sizeof(binaryUniform->baseBindingIdx);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_DUMMY_UNIFORM_INDEX_VERSION)
        {
            previousVersionAdjustment += sizeof(binaryUniform->dummyUniformIndex);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_UNIFORM_PHYSICAL_ADDR)
        {
            previousVersionAdjustment += sizeof(binaryUniform->physical);
            previousVersionAdjustment += sizeof(binaryUniform->samplerPhysical);
            previousVersionAdjustment += sizeof(binaryUniform->address);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_UNIFORM_RES_OP_FLAG)
        {
            previousVersionAdjustment += sizeof(binaryUniform->resOpFlag);
        }

        allocBytes = Shader->uniformCount * sizeof(gcUNIFORM);
        /* Allocate the array of gcUNIFORM structure pointers. */
        status = gcoOS_Allocate(gcvNULL,
                               allocBytes,
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->uniformCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
            gcmFOOTER();
            return status;
        }

        gcoOS_ZeroMemory(pointer, allocBytes);
        Shader->uniforms = pointer;

        /* Parse all uniforms. */
        for (i = 0; i < Shader->uniformCount; i++)
        {
            /* Get the length of the uniform name. */
            length = (bytes < sizeof(struct _gcBINARY_UNIFORM))
                         ? 0
                         : binaryUniform->nameLength;
            length2 = binaryUniform->arrayLengthCount * gcmSIZEOF(gctINT);

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_UNIFORM, memory) + length + length2,
                                 2);

            if (bytes < (binarySize - previousVersionAdjustment))
            {
                /* Roll back. */
                Shader->uniformCount = i;

                /* Invalid uniform. */
                gcmFATAL("gcSHADER_Load: Invalid uniform");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            allocBytes = gcmOFFSETOF(_gcUNIFORM, name) + length + 1;
            /* Allocate memory for the uniform inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                   allocBytes,
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->uniformCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_ZeroMemory(pointer, allocBytes);
            uniform = pointer;

            /* Copy uniform to the gcSHADER object. */
            Shader->uniforms[i]       = uniform;
            uniform->object.type      = gcvOBJ_UNIFORM;
            uniform->index            = (gctUINT16) i;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION)
            {
                SetUniformCategory(uniform, gcSHADER_VAR_CATEGORY_NORMAL);
                uniform->firstChild = -1;
                uniform->nextSibling = -1;
                uniform->prevSibling = -1;
                uniform->parent = -1;
                uniform->u.type = (gcSHADER_TYPE) binaryUniform->u.type;
            }
            else
            {
                SetUniformCategory(uniform, (gcSHADER_VAR_CATEGORY)binaryUniform->varCategory);
                uniform->firstChild = binaryUniform->firstChild;
                uniform->nextSibling = binaryUniform->nextSibling;
                uniform->prevSibling = binaryUniform->prevSibling;
                uniform->parent = binaryUniform->parent;
                if (binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_NORMAL                      ||
                    binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_BLOCK_ADDRESS               ||
                    binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_BLOCK_MEMBER                ||
                    binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_LOD_MIN_MAX                 ||
                    binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_LEVEL_BASE_SIZE             ||
                    binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_SAMPLE_LOCATION             ||
                    binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_ENABLE_MULTISAMPLE_BUFFERS  ||
                    binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_WORK_THREAD_COUNT           ||
                    binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_WORK_GROUP_COUNT)
                    uniform->u.type = (gcSHADER_TYPE) binaryUniform->u.type;
                else
                    uniform->u.numStructureElement = binaryUniform->u.numStructureElement;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
            {
                uniform->precision = gcSHADER_PRECISION_DEFAULT;
            }
            else
            {
                uniform->precision = (gcSHADER_PRECISION)binaryUniform->precision;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_HALTI_FILE_VERSION)
            {
                uniform->blockIndex = gcvBLOCK_INDEX_DEFAULT;
                uniform->arrayStride = -1;
                uniform->matrixStride = -1;
                uniform->isRowMajor = gcvFALSE;
                uniform->offset = -1;
                gcoOS_MemFill((gctPOINTER)uniform->initializer.f32_v16,
                              '\0',
                              sizeof(gcsValue));
            }
            else
            {
                uniform->blockIndex = binaryUniform->blockIndex;
                gcoOS_MemCopy((gctPOINTER)&uniform->arrayStride,
                              binaryUniform->arrayStride,
                              sizeof(gctINT32));
                uniform->matrixStride = binaryUniform->matrixStride;
                uniform->isRowMajor = (gctBOOL) binaryUniform->isRowMajor;
                gcoOS_MemCopy((gctPOINTER)&uniform->offset,
                              binaryUniform->offset,
                              sizeof(gctINT32));
                gcoOS_MemCopy((gctPOINTER)uniform->initializer.f32_v16,
                              binaryUniform->initializer,
                              sizeof(gcsValue));
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_LTC_FILE_VERSION)
            {
                uniform->_flags            = 0;
                uniform->glUniformIndex   = (gctINT16) -1;
            }
            else
            {
                gcoOS_MemCopy((gctPOINTER)&uniform->_flags,
                              binaryUniform->flags,
                              sizeof(gceUNIFORM_FLAGS));
                uniform->glUniformIndex   = binaryUniform->glUniformIndex;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
            {
                uniform->binding    = -1;
                uniform->imageFormat = gcIMAGE_FORMAT_DEFAULT;
                SetUniformUsedArraySize(uniform, binaryUniform->arraySize);
            }
            else
            {
                gcoOS_MemCopy((gctPOINTER)&uniform->binding,
                              binaryUniform->binding,
                              sizeof(gctINT32));
                uniform->imageFormat = binaryUniform->imageFormat;
                SetUniformUsedArraySize(uniform, binaryUniform->usedArraySize);
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_UNIFORM_LOCATION_VERSION)
            {
                uniform->location = -1;
            }
            else
            {
#if defined(UNDER_CE)
                gcoOS_MemCopy(&(uniform->location), &(binaryUniform->location), sizeof(gctINT));
#else
                uniform->location = binaryUniform->location;
#endif
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_UNIFORM_BASE_BINDING_VERSION)
            {
                uniform->baseBindingIdx = -1;
            }
            else
            {
                uniform->baseBindingIdx = binaryUniform->baseBindingIdx;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_DUMMY_UNIFORM_INDEX_VERSION)
            {
                uniform->dummyUniformIndex = -1;
            }
            else
            {
                uniform->dummyUniformIndex = binaryUniform->dummyUniformIndex;
            }

            uniform->modelViewProjection = 0;
            uniform->format       = 0;
            uniform->isPointer    = 0;
            uniform->arraySize    = binaryUniform->arraySize;
            uniform->arrayLengthCount = (gctINT)binaryUniform->arrayLengthCount;
            uniform->nameLength   = length;

            /* Copy name. */
            uniform->name[length] = '\0';

            if (length > 0)
            {
                gcoOS_MemCopy(uniform->name,
                              binaryUniform->memory - previousVersionAdjustment + length2,
                              length);
            }

            if (uniform->arrayLengthCount > 0)
            {
                status = gcoOS_Allocate(gcvNULL,
                                        length2,
                                        &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->uniformCount = i;

                    /* Error. */
                    gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                gcoOS_ZeroMemory(pointer, uniform->arrayLengthCount * gcmSIZEOF(gctINT));
                uniform->arrayLengthList = pointer;

                gcoOS_MemCopy(uniform->arrayLengthList,
                              binaryUniform->memory - previousVersionAdjustment,
                              length2);
            }
            else
            {
                uniform->arrayLengthList = gcvNULL;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_UNIFORM_PHYSICAL_ADDR)
            {
                uniform->physical     = -1;
                uniform->samplerPhysical    = -1;
                uniform->address      = ~0U;
                if (isUniformNormal(uniform) && gcmType_Kind(uniform->u.type) == gceTK_SAMPLER)
                {
                   uniform->physical = Shader->samplerIndex;
                   Shader->samplerIndex += uniform->arraySize > 1 ? uniform->arraySize : 1;
                }
            }
            else
            {
                uniform->physical           = binaryUniform->physical;
                uniform->samplerPhysical    = binaryUniform->samplerPhysical;
                uniform->address            = binaryUniform->address;
            }
            uniform->RAPriority         = 0;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_UNIFORM_RES_OP_FLAG)
            {
                uniform->resOpFlag = gcUNIFORM_RES_OP_FLAG_NONE;
            }
            else
            {
                gcoOS_MemCopy((gctPOINTER)&uniform->resOpFlag,
                              binaryUniform->resOpFlag,
                              sizeof(gctINT32));
            }

            /* substract fields which are not in the file version */
            binarySize -= previousVersionAdjustment;

            /* Point to next uniform. */
            binaryUniform = (gcBINARY_UNIFORM)
                            ((gctUINT8 *) binaryUniform + binarySize);
            bytes        -= binarySize;
        }

        /* check if there is any uniform block */
        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_HALTI_FILE_VERSION)
        {
            Shader->uniformBlockCount = 0;
        }
        else
        {
            gcsUNIFORM_BLOCK uniformBlock;
            gcBINARY_UNIFORM_BLOCK    binaryUniformBlock;

            count = (gctUINT16 *) binaryUniform;

            if (bytes < sizeof(gctUINT16))
            {
                /* Invalid uniform block count. */
                gcmFATAL("gcSHADER_Load: Invalid uniformBlockCount");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            /* Save the uniform count. */
            Shader->uniformBlockCount = *count;

            /* Point to the first uniform block. */
            binaryUniformBlock = (gcBINARY_UNIFORM_BLOCK) (count + 1);
            bytes        -= sizeof(gctUINT16);

            if (Shader->uniformBlockCount > 0)
            {
                previousVersionAdjustment = 0;

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
                {
                    /* fields which are not in the version */
                    previousVersionAdjustment += sizeof(binaryUniformBlock->binding);
                }

               /* Allocate the array of gcsUNIFORM_BLOCK structure pointers. */
               status = gcoOS_Allocate(gcvNULL,
                                       Shader->uniformBlockCount * sizeof(gcsUNIFORM_BLOCK),
                                       &pointer);

               if (gcmIS_ERROR(status))
               {
                   /* Roll back. */
                   Shader->uniformBlockCount = 0;

                   /* Error. */
                   gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                   gcmFOOTER();
                   return status;
               }

               Shader->uniformBlocks = pointer;

               /* Parse all uniform blocks. */
               for (i = 0; i < Shader->uniformBlockCount; i++)
               {
                   /* Get the length of the uniform block name. */

                   length = (bytes < sizeof(struct _gcBINARY_UNIFORM_BLOCK))
                                   ? 0
                                   : binaryUniformBlock->nameLength;

                   /* Test for special length. */
                   if ((gctINT) length < 0)
                   {
                       length = 0;
                   }

                   /* Compute the number of bytes required. */
                   binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_UNIFORM_BLOCK, name) + length, 2);

                   if (bytes < binarySize - previousVersionAdjustment)
                   {
                       /* Roll back. */
                       Shader->uniformBlockCount = i;

                       /* Invalid uniform block. */
                       gcmFATAL("gcSHADER_Load: Invalid uniform block");
                       gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                       return gcvSTATUS_INVALID_DATA;
                   }

                   allocBytes = gcmOFFSETOF(_gcsUNIFORM_BLOCK, name) + length + 1;
                   /* Allocate memory for the uniform block inside the gcSHADER object. */
                   status = gcoOS_Allocate(gcvNULL,
                                          allocBytes,
                                          &pointer);

                   if (gcmIS_ERROR(status))
                   {
                       /* Roll back. */
                       Shader->uniformBlockCount = i;

                       /* Error. */
                       gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                       gcmFOOTER();
                       return status;
                   }

                   gcoOS_ZeroMemory(pointer, allocBytes);
                   uniformBlock = pointer;

                   /* Copy uniform block to the gcSHADER object. */
                   Shader->uniformBlocks[i]  = uniformBlock;
                   GetUBObject(uniformBlock)->type = gcvOBJ_UNIFORM_BLOCK;
                   SetUBBlockIndex(uniformBlock, (gctINT16) i);
                   if(binaryUniformBlock->index != -1 && binaryUniformBlock->index >= (gctINT16) Shader->uniformCount) {
                       /* Roll back. */
                       Shader->uniformBlockCount = i;

                       /* Invalid uniform block. */
                       gcmFATAL("gcSHADER_Load: Invalid uniform block index");
                       gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                       return gcvSTATUS_INVALID_DATA;
                   }
                   SetUBIndex(uniformBlock, binaryUniformBlock->index);
                   SetUBMemoryLayout(uniformBlock, (gceINTERFACE_BLOCK_LAYOUT_ID)binaryUniformBlock->memoryLayout);
                   SetUBBlockSize(uniformBlock, binaryUniformBlock->blockSize);

                   gcoOS_ZeroMemory(GetUBShaderVarInfo(uniformBlock),
                                    sizeof(struct _gcsSHADER_VAR_INFO));

                   SetUBCategory(uniformBlock, gcSHADER_VAR_CATEGORY_BLOCK);
                   SetUBFirstChild(uniformBlock, binaryUniformBlock->firstChild);
                   SetUBNextSibling(uniformBlock, binaryUniformBlock->nextSibling);
                   SetUBPrevSibling(uniformBlock, binaryUniformBlock->prevSibling);
                   SetUBIsArray(uniformBlock, gcvFALSE);
                   SetUBArraySize(uniformBlock, 1);
                   SetUBNumBlockElement(uniformBlock, binaryUniformBlock->numBlockElement);

                   SetUBNameLength(uniformBlock, length);

                   if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
                   {
                       SetUBBinding(uniformBlock, -1);
                   }
                   else
                   {
                       gcoOS_MemCopy((gctPOINTER)&GetUBBinding(uniformBlock),
                                      binaryUniformBlock->binding,
                                      sizeof(gctINT32));
                   }

                   /* Copy name. */
                   GetUBName(uniformBlock)[length] = '\0';

                   if (length > 0)
                   {
                       gcoOS_MemCopy(GetUBName(uniformBlock),
                                     binaryUniformBlock->name - previousVersionAdjustment,
                                     length);
                   }

                   binarySize -= previousVersionAdjustment;

                   /* Point to next uniform block. */
                   binaryUniformBlock = (gcBINARY_UNIFORM_BLOCK)
                                        ((gctUINT8 *) binaryUniformBlock + binarySize);
                   bytes -= binarySize;
                }
            }
            binaryUniform = (gcBINARY_UNIFORM) binaryUniformBlock;
        }
    }

    /************************************************************************/
    /*                                  outputs                             */
    /************************************************************************/

    /* Get the output count. */
    count = (gctUINT16 *) binaryUniform;

    if (bytes < sizeof(gctUINT16))
    {
        /* Invalid output count. */
        gcmFATAL("gcSHADER_Load: Invalid outputCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Point to the first output. */
    binaryOutput = (gcBINARY_OUTPUT) (count + 1);
    bytes       -= sizeof(gctUINT16);

    /* Save the output count. */
    Shader->outputCount = *count;

    if (Shader->outputCount > 0)
    {
        gctINT versionAdjustment = 0;

        allocBytes =  Shader->outputCount * sizeof(gcOUTPUT);
        /* Allocate the array of gcOUTPUT structure pointers. */
        status = gcoOS_Allocate(gcvNULL,
                               allocBytes,
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->outputCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
            gcmFOOTER();
            return status;
        }

        gcoOS_ZeroMemory(pointer, allocBytes);
        Shader->outputs = pointer;

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
        {
            /* precision field which is not in the version */
            versionAdjustment += sizeof(binaryOutput->precision);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
        {
            /* layout field which is not in the version */
            versionAdjustment += sizeof(binaryOutput->layoutQualifier);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_TYPE_NAME_VAR_INDEX)
        {
            /* layout field which is not in the version */
            versionAdjustment += sizeof(binaryOutput->typeNameVarIndex);
        }

        /* Parse all outputs. */
        psClrOutputLoc = 0;
        for (i = 0; i < Shader->outputCount; i++)
        {
            /* Get the length of the output name. */
            length = (bytes < sizeof(struct _gcBINARY_OUTPUT))
                         ? 0
                         : binaryOutput->nameLength;

            /* Test for special length. */
            if ((gctINT) length < 0)
            {
                length = 0;
            }

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_OUTPUT, name) + length, 2);

            if (bytes < (binarySize - versionAdjustment))
            {
                /* Roll back. */
                Shader->outputCount = i;

                /* Invalid output. */
                gcmFATAL("gcSHADER_Load: Invalid output");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            allocBytes = gcmOFFSETOF(_gcOUTPUT, name) + length + 1;
            /* Allocate memory for the output inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                   allocBytes,
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->outputCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_ZeroMemory(pointer, allocBytes);
            output = pointer;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
            {
                output->precision = gcSHADER_PRECISION_DEFAULT;
            }
            else
            {
                output->precision = (gcSHADER_PRECISION)binaryOutput->precision;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
            {
                output->layoutQualifier = gcvLAYOUT_QUALIFIER_NONE;
            }
            else
            {
                gcoOS_MemCopy((gctPOINTER)&output->layoutQualifier,
                            binaryOutput->layoutQualifier,
                            sizeof(output->layoutQualifier));
            }

            /* Copy output to shader. */
            Shader->outputs[i]              = output;
            output->object.type             = gcvOBJ_OUTPUT;
            output->index                   = binaryOutput->index;
            output->type                    = (gcSHADER_TYPE) binaryOutput->type;
            output->origType                = (gcSHADER_TYPE) binaryOutput->origType;
            output->arraySize               = binaryOutput->arraySize;
            output->flags_                  = (gctUINT32)
                                              (binaryOutput->flags1 | (binaryOutput->flags2 << 16));
            gcoOS_MemCopy((gctPOINTER)&output->tempIndex,
                        (gctPOINTER)&binaryOutput->tempIndex,
                        sizeof(output->tempIndex));
            output->layoutQualifier         = gcvLAYOUT_QUALIFIER_NONE;
            output->ioBlockIndex            = binaryOutput->ioBlockIndex;
            output->ioBlockArrayIndex       = binaryOutput->ioBlockArrayIndex;
            output->nextSibling             = binaryOutput->nextSibling;
            output->prevSibling             = binaryOutput->prevSibling;
            output->shaderMode              = (gcSHADER_SHADERMODE) binaryOutput->shaderMode;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_TYPE_NAME_VAR_INDEX)
            {
                output->typeNameVarIndex    = -1;
            }
            else
            {
                output->typeNameVarIndex    = binaryOutput->typeNameVarIndex;
            }

            if (Shader->type == gcSHADER_TYPE_FRAGMENT &&
                binaryOutput->nameLength == gcSL_COLOR)
            {
                /* It has strong assumption that gl_fragdata array element was stored
                   into shader->output is in-order from 1 to maxDrawBuffers. If not, we
                   need store something in output binary structure to retrieve this info
                 */
                output->location     = psClrOutputLoc ++;
            }
            else
            {
                output->location     = -1;
            }

            output->nameLength   = binaryOutput->nameLength;
            output->name[length] = '\0';

            if (length > 0)
            {
                   gcoOS_MemCopy(output->name,
                                 binaryOutput->name - versionAdjustment,
                                 length);
            }

            /* derive arrayIndex from previous output */
            if (prevOutput && prevOutput->nameLength == output->nameLength &&
                 (((gctINT) output->nameLength < 0)   /* built-in name */
                 || gcmIS_SUCCESS(gcoOS_MemCmp(output->name,
                                               prevOutput->name,
                                               output->nameLength))) )
            {
                output->arrayIndex   = prevOutput->arrayIndex + 1;
            }
            else
            {
                output->arrayIndex   = 0;
            }
            prevOutput = output;

            /* substract fields which are not in the file version */
            binarySize -= versionAdjustment;

            /* Point to next output. */
            binaryOutput = (gcBINARY_OUTPUT)
                           ((gctUINT8 *) binaryOutput + binarySize);
            bytes       -= binarySize;
        }
    }

    /************************************************************************/
    /*                       input/output locations                         */
    /************************************************************************/

    if (shaderVersion > gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION ||
        (Shader->type == gcSHADER_TYPE_VERTEX && shaderVersion > gcdSL_SHADER_BINARY_BEFORE_HALTI_FILE_VERSION))
    {
        /* Get the location count. */
        count  = (gctUINT16 *) binaryOutput;
        if (bytes < sizeof(gctUINT16))
        {
            /* Invalid location count. */
            gcmFATAL("gcSHADER_Load: Invalid locationCount");
            gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
            return gcvSTATUS_INVALID_DATA;
        }

        Shader->inputLocationCount = *count;
        if(Shader->inputLocationCount)
        {
           if(Shader->inputLocationCount != Shader->attributeCount)
           {
               /* location count mismatch with attribute count. */
               gcmFATAL("gcSHADER_Load: location count mismatch with input count");
               gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
               return gcvSTATUS_INVALID_DATA;
           }
        }

        locations = (gctINT16 *) (count + 1);
        bytes     -= sizeof(gctUINT16);

        if (Shader->inputLocationCount > 0)
        {
            if (bytes < (Shader->inputLocationCount * sizeof(gctINT16)))
            {
                /* Roll back. */
                Shader->inputLocationCount = 0;

                /* Invalid location array. */
                gcmFATAL("gcSHADER_Load: Invalid locations");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            allocBytes = Shader->inputLocationCount * sizeof(gctINT);
            /* Allocate the array of locations. */
            status = gcoOS_Allocate(gcvNULL,
                                    allocBytes,
                                    &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->inputLocationCount = 0;

                /* Error. */
                gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_ZeroMemory(pointer, allocBytes);
            Shader->inputLocations = pointer;
            /* Get all locations. */
            for (i = 0; i < Shader->inputLocationCount; i++, locations++)
            {
                if (Shader->attributes[i])
                {
                    Shader->inputLocations[i] = *locations;
                    Shader->attributes[i]->location = *locations;
                }
            }

            bytes -= (Shader->inputLocationCount * sizeof(gctINT16));
        }
    }
    else
    {
        Shader->inputLocationCount = 0;
        Shader->inputLocations = gcvNULL;

        locations = (gctINT16 *) binaryOutput;
    }

    if (shaderVersion > gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION ||
        (Shader->type == gcSHADER_TYPE_FRAGMENT && shaderVersion > gcdSL_SHADER_BINARY_BEFORE_HALTI_FILE_VERSION))
    {
        /* Get the location count. */
        count  = (gctUINT16 *) locations;
        if (bytes < sizeof(gctUINT16))
        {
            /* Invalid location count. */
            gcmFATAL("gcSHADER_Load: Invalid locationCount");
            gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
            return gcvSTATUS_INVALID_DATA;
        }

        Shader->outputLocationCount = *count;
        if(Shader->outputLocationCount)
        {
           if(Shader->outputLocationCount != Shader->outputCount)
           {
               /* location count mismatch with output count. */
               gcmFATAL("gcSHADER_Load: location count mismatch with output count");
               gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
               return gcvSTATUS_INVALID_DATA;
           }
        }

        locations = (gctINT16 *) (count + 1);
        bytes     -= sizeof(gctUINT16);

        if (Shader->outputLocationCount > 0)
        {
            if (bytes < (Shader->outputLocationCount * sizeof(gctINT16)))
            {
                /* Roll back. */
                Shader->outputLocationCount = 0;

                /* Invalid location array. */
                gcmFATAL("gcSHADER_Load: Invalid locations");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            allocBytes = Shader->outputLocationCount * sizeof(gctINT);
            /* Allocate the array of locations. */
            status = gcoOS_Allocate(gcvNULL,
                                    allocBytes,
                                    &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->outputLocationCount = 0;

                /* Error. */
                gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_ZeroMemory(pointer, allocBytes);
            Shader->outputLocations = pointer;
            /* Get all locations. */
            for (i = 0; i < Shader->outputLocationCount; i++, locations++)
            {
                Shader->outputLocations[i] = *locations;
                Shader->outputs[i]->location = *locations;
            }

            bytes -= (Shader->outputLocationCount * sizeof(gctINT16));
        }
    }
    else
    {
        Shader->outputLocationCount = 0;
        Shader->outputLocations = gcvNULL;
    }

    /* Get the variable count. */
    count = (gctUINT16 *) locations;

    if (bytes < sizeof(gctUINT16))
    {
        /* Invalid variable count. */
        gcmFATAL("gcSHADER_Load: Invalid variableCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Point to the first variable. */
    binaryVariable = (gcBINARY_VARIABLE) (count + 1);
    bytes       -= sizeof(gctUINT16);

    /* Save the variable count. */
    Shader->variableCount = *count;

    if (Shader->variableCount > 0)
    {
        gctINT   previousVersionAdjustment = 0;
        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_VARIABLE_TYPE_QUALIFIER_FILE_VERSION)
        {
            /*add type qualifier adjustment */
            previousVersionAdjustment = sizeof(binaryVariable->qualifier);
            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION) {
               /* fields which are not in the version */
               previousVersionAdjustment += sizeof(binaryVariable->varCategory) +
                                           sizeof(binaryVariable->firstChild) +
                                           sizeof(binaryVariable->nextSibling) +
                                           sizeof(binaryVariable->prevSibling) +
                                           sizeof(binaryVariable->parent);
            }

        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
        {
            /* flags field which is not in the version */
            previousVersionAdjustment += sizeof(binaryVariable->flags);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
        {
            /* fields which are not in the version */
            previousVersionAdjustment += sizeof(binaryVariable->blockIndex);
        }

        allocBytes = Shader->variableCount * sizeof(gcVARIABLE);
        /* Allocate the array of gcVARIABLE structure pointers. */
        status = gcoOS_Allocate(gcvNULL,
                               allocBytes,
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->variableCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
            gcmFOOTER();
            return status;
        }

        gcoOS_ZeroMemory(pointer, allocBytes);
        Shader->variables = pointer;

        /* Parse all variables. */
        for (i = 0; i < Shader->variableCount; i++)
        {
            /* Get the length of the variable name. */
            length = (bytes < sizeof(struct _gcBINARY_VARIABLE))
                         ? 0
                         : binaryVariable->nameLength;

            length2 = binaryVariable->arrayLengthCount * gcmSIZEOF(gctINT);

            /* Test for special length. */
            if ((gctINT) length < 0)
            {
                length = 0;
            }

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_VARIABLE, memory) + length + length2, 2);

            if (bytes < binarySize - previousVersionAdjustment)
            {
                /* Roll back. */
                Shader->variableCount = i;

                /* Invalid variable. */
                gcmFATAL("gcSHADER_Load: Invalid variable");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            allocBytes = gcmOFFSETOF(_gcVARIABLE, name) + length + 1;
            /* Allocate memory for the variable inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                   allocBytes,
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->variableCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                gcmFOOTER();
                return status;
            }

            gcoOS_ZeroMemory(pointer, allocBytes);
            variable = pointer;

            /* Copy variable to shader. */
            Shader->variables[i]   = variable;
            variable->object.type  = gcvOBJ_VARIABLE;
            variable->index = (gctUINT16)i;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION)
            {
                SetVariableCategory(variable, gcSHADER_VAR_CATEGORY_NORMAL);
                variable->firstChild = -1;
                variable->nextSibling = -1;
                variable->prevSibling = -1;
                variable->parent = -1;
                variable->u.type = (gcSHADER_TYPE) binaryVariable->u.type;
                variable->qualifier = gcvTYPE_QUALIFIER_NONE;
            }
            else
            {
                SetVariableCategory(variable, (gcSHADER_VAR_CATEGORY)binaryVariable->varCategory);
                variable->firstChild = binaryVariable->firstChild;
                variable->nextSibling = binaryVariable->nextSibling;
                variable->prevSibling = binaryVariable->prevSibling;
                variable->parent = binaryVariable->parent;

                if (binaryVariable->varCategory == gcSHADER_VAR_CATEGORY_NORMAL ||
                    binaryVariable->varCategory == gcSHADER_VAR_CATEGORY_BLOCK_MEMBER)
                    variable->u.type = (gcSHADER_TYPE) binaryVariable->u.type;
                else
                    variable->u.numStructureElement = binaryVariable->u.numStructureElement;

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_VARIABLE_TYPE_QUALIFIER_FILE_VERSION)
                    variable->qualifier = gcvTYPE_QUALIFIER_NONE;
                else
                {
                    variable->qualifier = binaryVariable->qualifier;
                }
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
            {
                variable->precision = gcSHADER_PRECISION_DEFAULT;
            }
            else
            {
                variable->precision = binaryVariable->precision ;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
            {
                variable->blockIndex = gcvBLOCK_INDEX_DEFAULT;
            }
            else
            {
                variable->blockIndex = binaryVariable->blockIndex;
            }

            variable->flags    = binaryVariable->flags;
            variable->arraySize    = binaryVariable->arraySize;
            variable->arrayLengthCount = binaryVariable->arrayLengthCount;
            gcoOS_MemCopy((gctPOINTER)&variable->tempIndex,
                        (gctPOINTER)&binaryVariable->tempIndex,
                        sizeof(variable->tempIndex));
            variable->nameLength   = binaryVariable->nameLength;
            variable->name[length] = '\0';

            if (length > 0)
            {
                gcoOS_MemCopy(variable->name,
                              binaryVariable->memory - previousVersionAdjustment
                              + length2,
                              length);
            }

            if (variable->arrayLengthCount > 0)
            {
                status = gcoOS_Allocate(gcvNULL,
                                       variable->arrayLengthCount * gcmSIZEOF(gctINT),
                                       &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->variableCount = i;

                    /* Error. */
                    gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                gcoOS_ZeroMemory(pointer, variable->arrayLengthCount * gcmSIZEOF(gctINT));
                variable->arrayLengthList = pointer;

                gcoOS_MemCopy(variable->arrayLengthList,
                              binaryVariable->memory - previousVersionAdjustment,
                              variable->arrayLengthCount * gcmSIZEOF(gctINT));
            }
            else
            {
                variable->arrayLengthList = gcvNULL;
            }

            /* substract fields which are not in the file version */
            binarySize -= previousVersionAdjustment;

            /* Point to next variable. */
            binaryVariable = (gcBINARY_VARIABLE)
                           ((gctUINT8 *) binaryVariable + binarySize);
            bytes       -= binarySize;
        }

        /* check if there is any storage block */
        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
        {
            Shader->storageBlockCount = 0;
        }
        else
        {
            gcsSTORAGE_BLOCK storageBlock;
            gcBINARY_STORAGE_BLOCK    binaryStorageBlock;

            count = (gctUINT16 *) binaryVariable;

            if (bytes < sizeof(gctUINT16))
            {
                /* Invalid storage block count. */
                gcmFATAL("gcSHADER_Load: Invalid storageBlockCount");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            /* Save the storage count. */
            Shader->storageBlockCount = *count;

            /* Point to the first storage block. */
            binaryStorageBlock = (gcBINARY_STORAGE_BLOCK) (count + 1);
            bytes        -= sizeof(gctUINT16);

            if (Shader->storageBlockCount > 0)
            {
                allocBytes = Shader->storageBlockCount * sizeof(gcsSTORAGE_BLOCK);
               /* Allocate the array of gcsSTORAGE_BLOCK structure pointers. */
               status = gcoOS_Allocate(gcvNULL,
                                       allocBytes,
                                       &pointer);

               if (gcmIS_ERROR(status))
               {
                   /* Roll back. */
                   Shader->storageBlockCount = 0;

                   /* Error. */
                   gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                   gcmFOOTER();
                   return status;
               }

               gcoOS_ZeroMemory(pointer, allocBytes);
               Shader->storageBlocks = pointer;

               /* Parse all storage blocks. */
               for (i = 0; i < Shader->storageBlockCount; i++)
               {
                   /* Get the length of the storage block name. */

                   length = (bytes < sizeof(struct _gcBINARY_STORAGE_IO_BLOCK))
                                   ? 0
                                   : binaryStorageBlock->nameLength;

                   /* Test for special length. */
                   if ((gctINT) length < 0)
                   {
                       length = 0;
                   }

                   /* Compute the number of bytes required. */
                   binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_STORAGE_IO_BLOCK, name) + length, 2);

                   if (bytes < binarySize)
                   {
                       /* Roll back. */
                       Shader->storageBlockCount = i;

                       /* Invalid storage block. */
                       gcmFATAL("gcSHADER_Load: Invalid storage block");
                       gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                       return gcvSTATUS_INVALID_DATA;
                   }

                   allocBytes = gcmOFFSETOF(_gcsSTORAGE_IO_BLOCK, name) + length + 1;
                   /* Allocate memory for the storage block inside the gcSHADER object. */
                   status = gcoOS_Allocate(gcvNULL,
                                          allocBytes,
                                          &pointer);

                   if (gcmIS_ERROR(status))
                   {
                       /* Roll back. */
                       Shader->storageBlockCount = i;

                       /* Error. */
                       gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                       gcmFOOTER();
                       return status;
                   }

                   gcoOS_ZeroMemory(pointer, allocBytes);
                   storageBlock = pointer;

                   /* Copy storage block to the gcSHADER object. */
                   Shader->storageBlocks[i]  = storageBlock;
                   GetSBObject(storageBlock)->type = gcvOBJ_STORAGE_BLOCK;
                   SetSBBlockIndex(storageBlock, (gctINT16) i);
                   /* storage block is added by gcSHADER_AddUniform, thus need to less than Shader->uniformCount */
                   if(binaryStorageBlock->index != -1 && binaryStorageBlock->index >= (gctINT16) Shader->uniformCount) {
                       /* Roll back. */
                       Shader->storageBlockCount = i;

                       /* Invalid storage block. */
                       gcmFATAL("gcSHADER_Load: Invalid storageBlock index");
                       gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                       return gcvSTATUS_INVALID_DATA;
                   }
                   SetSBIndex(storageBlock, (gctINT16)binaryStorageBlock->index);
                   SetSBMemoryLayout(storageBlock, (gceINTERFACE_BLOCK_LAYOUT_ID)binaryStorageBlock->memoryLayout);
                   SetSBBlockSize(storageBlock, binaryStorageBlock->blockSize);
                   gcoOS_ZeroMemory(GetSBShaderVarInfo(storageBlock),
                                    sizeof(struct _gcsSHADER_VAR_INFO));

                   SetSBCategory(storageBlock, gcSHADER_VAR_CATEGORY_BLOCK);
                   SetSBFirstChild(storageBlock, binaryStorageBlock->firstChild);
                   SetSBNextSibling(storageBlock, binaryStorageBlock->nextSibling);
                   SetSBPrevSibling(storageBlock, binaryStorageBlock->prevSibling);
                   SetSBIsArray(storageBlock, gcvFALSE);
                   SetSBArraySize(storageBlock, 1);
                   SetSBNumBlockElement(storageBlock, binaryStorageBlock->numBlockElement);

                   SetSBNameLength(storageBlock, length);
                   SetSBFlag(storageBlock, binaryStorageBlock->flags);

                   gcoOS_MemCopy((gctPOINTER)&GetSBBinding(storageBlock),
                       binaryStorageBlock->binding,
                       sizeof(gctINT32));

                   /* Copy name. */
                   GetSBName(storageBlock)[length] = '\0';

                   if (length > 0)
                   {
                       gcoOS_MemCopy(GetSBName(storageBlock),
                                     binaryStorageBlock->name,
                                     length);
                   }

                   /* Point to next storage block. */
                   binaryStorageBlock = (gcBINARY_STORAGE_BLOCK)
                                        ((gctUINT8 *) binaryStorageBlock + binarySize);
                   bytes -= binarySize;
               }
            }

            binaryVariable = (gcBINARY_VARIABLE) binaryStorageBlock;
        }
    }

    /* Get default storage block. */
    count = (gctUINT16 *) binaryVariable;

    Shader->enableDefaultStorageBlock = (gctBOOL)(*(count));
    bytes -= sizeof(gctUINT16);
    Shader->_defaultStorageBlock = *(count + 1);
    bytes -= sizeof(gctUINT16);
    count += 2;

    if (Shader->variableCount > 0)
    {
        /* check if there is any io block */
        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
        {
            Shader->ioBlockCount = 0;
        }
        else
        {
            gcsIO_BLOCK ioBlock;
            gcBINARY_IO_BLOCK    binaryIoBlock;


            if (bytes < sizeof(gctUINT16))
            {
                /* Invalid io block count. */
                gcmFATAL("gcSHADER_Load: Invalid ioBlockCount");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            /* Save the storage count. */
            Shader->ioBlockCount = *count;

            /* Point to the first io block. */
            binaryIoBlock = (gcBINARY_IO_BLOCK) (count + 1);
            bytes        -= sizeof(gctUINT16);

            if (Shader->ioBlockCount > 0)
            {
                allocBytes = Shader->ioBlockCount * sizeof(gcsIO_BLOCK);
               /* Allocate the array of gcsIO_BLOCK structure pointers. */
               status = gcoOS_Allocate(gcvNULL,
                                       allocBytes,
                                       &pointer);

               if (gcmIS_ERROR(status))
               {
                   /* Roll back. */
                   Shader->ioBlockCount = 0;

                   /* Error. */
                   gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                   gcmFOOTER();
                   return status;
               }

               gcoOS_ZeroMemory(pointer, allocBytes);
               Shader->ioBlocks = pointer;

               /* Parse all io blocks. */
               for (i = 0; i < Shader->ioBlockCount; i++)
               {
                   /* Get the length of the io block name. */
                   length = binaryIoBlock->nameLength + binaryIoBlock->instanceNameLength;
                   if (binaryIoBlock->instanceNameLength > 0)
                   {
                       length++;
                   }

                   /* Compute the number of bytes required. */
                   binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_STORAGE_IO_BLOCK, name) + length, 2);

                   if (bytes < binarySize)
                   {
                       /* Roll back. */
                       Shader->ioBlockCount = i;

                       /* Invalid io block. */
                       gcmFATAL("gcSHADER_Load: Invalid io block");
                       gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                       return gcvSTATUS_INVALID_DATA;
                   }

                   allocBytes = gcmOFFSETOF(_gcsSTORAGE_IO_BLOCK, name) + length + 1;
                   /* Allocate memory for the io block inside the gcSHADER object. */
                   status = gcoOS_Allocate(gcvNULL,
                                          allocBytes,
                                          &pointer);

                   if (gcmIS_ERROR(status))
                   {
                       /* Roll back. */
                       Shader->ioBlockCount = i;

                       /* Error. */
                       gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                       gcmFOOTER();
                       return status;
                   }

                   gcoOS_ZeroMemory(pointer, allocBytes);
                   ioBlock = pointer;

                   /* Copy io block to the gcSHADER object. */
                   Shader->ioBlocks[i]  = ioBlock;
                   GetSBObject(ioBlock)->type = gcvOBJ_IO_BLOCK;
                   SetSBBlockIndex(ioBlock, (gctINT16) i);
                   /* io block is added by gcSHADER_AddUniform, thus need to less than Shader->uniformCount */
                   if(binaryIoBlock->index != -1 && binaryIoBlock->index >= (gctINT16) Shader->uniformCount) {
                       /* Roll back. */
                       Shader->ioBlockCount = i;

                       /* Invalid io block. */
                       gcmFATAL("gcSHADER_Load: Invalid ioBlock index");
                       gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                       return gcvSTATUS_INVALID_DATA;
                   }
                   SetSBIndex(ioBlock, (gctINT16)binaryIoBlock->index);
                   SetSBMemoryLayout(ioBlock, (gceINTERFACE_BLOCK_LAYOUT_ID)binaryIoBlock->memoryLayout);
                   SetSBBlockSize(ioBlock, binaryIoBlock->blockSize);
                   gcoOS_ZeroMemory(GetSBShaderVarInfo(ioBlock),
                                    sizeof(struct _gcsSHADER_VAR_INFO));

                   SetSBCategory(ioBlock, gcSHADER_VAR_CATEGORY_BLOCK);
                   SetSBFirstChild(ioBlock, binaryIoBlock->firstChild);
                   SetSBNextSibling(ioBlock, binaryIoBlock->nextSibling);
                   SetSBPrevSibling(ioBlock, binaryIoBlock->prevSibling);
                   SetSBIsArray(ioBlock, gcvFALSE);
                   SetSBArraySize(ioBlock, 1);
                   SetSBNumBlockElement(ioBlock, binaryIoBlock->numBlockElement);

                   SetSBNameLength(ioBlock, binaryIoBlock->nameLength);
                   SetSBInstanceNameLength(ioBlock, binaryIoBlock->instanceNameLength);
                   SetSBFlag(ioBlock, binaryIoBlock->flags);

                   gcoOS_MemCopy((gctPOINTER)&GetSBBinding(ioBlock),
                       binaryIoBlock->binding,
                       sizeof(gctINT32));

                   /* Copy name. */
                   GetSBName(ioBlock)[length] = '\0';

                   if (length > 0)
                   {
                       gcoOS_MemCopy(GetSBName(ioBlock),
                                     binaryIoBlock->name,
                                     length);
                   }

                   /* Point to next io block. */
                   binaryIoBlock = (gcBINARY_IO_BLOCK)
                                        ((gctUINT8 *) binaryIoBlock + binarySize);
                   bytes -= binarySize;
               }
            }

            count = (gctUINT16 *)binaryIoBlock;
        }
    }

    /************************************************************************/
    /*                              functions                               */
    /************************************************************************/

    if (bytes < sizeof(gctUINT16))
    {
        /* Invalid function count. */
        gcmFATAL("gcSHADER_Load: Invalid functionCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Point to the first function. */
    binaryFunction = (gcBINARY_FUNCTION) (count + 1);
    bytes       -= sizeof(gctUINT16);

    /* Get the function count. */
    Shader->functionCount = *count;

    if (*count > 0)
    {
        gctINT   previousVersionAdjustment = 0;

        allocBytes = Shader->functionCount * sizeof(gcFUNCTION);
        /* Allocate the array of gcFUNCTION structure pointers. */
        status = gcoOS_Allocate(gcvNULL,
                                allocBytes,
                                &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->functionCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
            gcmFOOTER();
            return status;
        }

        gcoOS_ZeroMemory(pointer, allocBytes);
        Shader->functions = pointer;

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
        {
            /* precision field which is not in the version */
            previousVersionAdjustment += sizeof(binaryFunction->flags) +
                                         sizeof(binaryFunction->intrinsicsKind);

        }

        /* Parse all functions. */
        for (i = 0; i < Shader->functionCount; i++)
        {
            /* Get the length of the function name. */
            length = (bytes < sizeof(struct _gcBINARY_FUNCTION))
                         ? 0
                         : binaryFunction->nameLength;

            /* Test for special length. */
            if ((gctINT) length < 0)
            {
                length = 0;
            }

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_FUNCTION, name) + length, 2);

            if (bytes < binarySize - previousVersionAdjustment)
            {
                /* Roll back. */
                Shader->functionCount = i;

                /* Invalid function. */
                gcmFATAL("gcSHADER_Load: Invalid function");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            allocBytes = gcmOFFSETOF(_gcsFUNCTION, name) + length + 1;
            /* Allocate memory for the function inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                   allocBytes,
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->functionCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                gcmFOOTER();
                return status;
            }

            gcoOS_ZeroMemory(pointer, allocBytes);
            function = pointer;

            /* Copy function to shader. */
            Shader->functions[i]   = function;
            function->object.type  = gcvOBJ_FUNCTION;

            function->argumentArrayCount =
            function->argumentCount = binaryFunction->argumentCount;
            function->packedAwayArgNo = binaryFunction->packedAwayArgNo;
            function->arguments     = gcvNULL;
            function->localVariableCount = binaryFunction->localVariableCount;
            function->localVariables     = gcvNULL;
            function->tempIndexStart     = binaryFunction->tempIndexStart;
            function->tempIndexEnd       = binaryFunction->tempIndexEnd;
            function->tempIndexCount     = binaryFunction->tempIndexCount;
            function->codeStart     = binaryFunction->codeStart;
            function->codeCount     = binaryFunction->codeCount;
            function->label         = (gctUINT32)binaryFunction->label;
            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
            {
                function->flags = gcvFUNC_NOATTR;
                function->intrinsicsKind = gceINTRIN_NONE;
            }
            else
            {
                gcoOS_MemCopy(&function->flags, &binaryFunction->flags, sizeof(gctUINT32));
                gcoOS_MemCopy(&function->intrinsicsKind, &binaryFunction->intrinsicsKind, sizeof(gctUINT32));
            }
            function->isRecursion   = gcvFALSE;
            function->nameLength    = binaryFunction->nameLength;
            function->name[length]  = '\0';

            if (length > 0)
            {
                gcoOS_MemCopy(function->name,
                              binaryFunction->name - previousVersionAdjustment,
                              length);
            }

            binarySize -= previousVersionAdjustment;

            /* Point to first argument. */
            binaryArgument = (gcBINARY_ARGUMENT)
                           ((gctUINT8 *) binaryFunction + binarySize);
            bytes         -= binarySize;

            /* Function arguments */
            if (function->argumentCount > 0)
            {
                binarySize = function->argumentCount * sizeof(gcsFUNCTION_ARGUMENT);

                if (bytes < binarySize)
                {
                    /* Roll back. */
                    Shader->functionCount = i;
                    function->argumentCount = 0;

                    /* Invalid argument. */
                    gcmFATAL("gcSHADER_Load: Invalid argument");
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                    return gcvSTATUS_INVALID_DATA;
                }

                /* Allocate the array of gcsFUNCTION_ARGUMENT structures. */
                status = gcoOS_Allocate(gcvNULL, binarySize, &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->functionCount = i;
                    function->argumentCount = 0;

                    /* Error. */
                    gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                function->arguments = pointer;

                for (j=0; j<function->argumentCount; j++)
                {
                    argument = &function->arguments[j];

                    gcoOS_MemCopy((gctPOINTER)&argument->index,
                                (gctPOINTER)&binaryArgument->index,
                                sizeof(argument->index));
                    argument->enable    = binaryArgument->enable;
                    argument->qualifier = binaryArgument->qualifier;
                    argument->precision = binaryArgument->precision;
                    argument->variableIndex = binaryArgument->variableIndex;
                    argument->flags     = binaryArgument->flags;

                    /* Point to next argument. */
                    binaryArgument++;
                    bytes -= sizeof(gcsFUNCTION_ARGUMENT);
                }
            }

            /* Point to first variable. */
            binaryVariable = (gcBINARY_VARIABLE) binaryArgument;

            /* Function variables */
            if (function->localVariableCount > 0)
            {
                gctINT   previousVersionAdjustment = 0;
                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_VARIABLE_TYPE_QUALIFIER_FILE_VERSION)
                {
                   /*add type qualifier adjustment */
                   previousVersionAdjustment = sizeof(binaryVariable->qualifier);
                   if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION) {
                      /* fields which are not in the version */
                      previousVersionAdjustment += sizeof(binaryVariable->varCategory) +
                                                  sizeof(binaryVariable->firstChild) +
                                                  sizeof(binaryVariable->nextSibling) +
                                                  sizeof(binaryVariable->prevSibling) +
                                                  sizeof(binaryVariable->parent);
                   }
                }

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
                {
                    /* flags field which is not in the version */
                    previousVersionAdjustment += sizeof(binaryVariable->flags);
                }

                allocBytes = function->localVariableCount * sizeof(gcVARIABLE);
                /* Allocate the array of gcVARIABLE structure pointers. */
                status = gcoOS_Allocate(gcvNULL,
                                       allocBytes,
                                       &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->functionCount = i;
                    function->localVariableCount = 0;

                    /* Error. */
                    gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                gcoOS_ZeroMemory(pointer, allocBytes);
                function->localVariables = pointer;

                /* Parse all variables. */
                for (j = 0; j < function->localVariableCount; j++)
                {
                    /* Get the length of the variable name. */
                    length = (bytes < sizeof(struct _gcBINARY_VARIABLE))
                                 ? 0
                                 : binaryVariable->nameLength;

                    /* Test for special length. */
                    if ((gctINT) length < 0)
                    {
                        length = 0;
                    }

                    /* Compute the number of bytes required. */
                    binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_VARIABLE, memory) + length, 2);

                    if (bytes < binarySize - previousVersionAdjustment)
                    {
                        /* Roll back. */
                        Shader->functionCount = i;
                        function->localVariableCount = j;

                        /* Invalid variable. */
                        gcmFATAL("gcSHADER_Load: Invalid variable");
                        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                        return gcvSTATUS_INVALID_DATA;
                    }

                    allocBytes = gcmOFFSETOF(_gcVARIABLE, name) + length + 1;
                    /* Allocate memory for the variable inside the gcSHADER object. */
                    status = gcoOS_Allocate(gcvNULL,
                                           allocBytes,
                                           &pointer);

                    if (gcmIS_ERROR(status))
                    {
                        /* Roll back. */
                        Shader->functionCount = i;
                        function->localVariableCount = j;

                        /* Error. */
                        gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                        gcmFOOTER();
                        return status;
                    }

                    gcoOS_ZeroMemory(pointer, allocBytes);
                    variable = pointer;

                    /* Copy variable to shader. */
                    function->localVariables[j]   = variable;
                    variable->object.type  = gcvOBJ_VARIABLE;

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION)
                    {
                        SetVariableCategory(variable, gcSHADER_VAR_CATEGORY_NORMAL);
                        variable->firstChild = -1;
                        variable->nextSibling = -1;
                        variable->prevSibling = -1;
                        variable->parent = -1;
                        variable->u.type = (gcSHADER_TYPE) binaryVariable->u.type;
                        variable->qualifier = gcvTYPE_QUALIFIER_NONE;
                    }
                    else
                    {
                        SetVariableCategory(variable, binaryVariable->varCategory);
                        variable->firstChild = binaryVariable->firstChild;
                        variable->nextSibling = binaryVariable->nextSibling;
                        variable->prevSibling = binaryVariable->prevSibling;
                        variable->parent = binaryVariable->parent;

                        if (binaryVariable->varCategory == gcSHADER_VAR_CATEGORY_NORMAL ||
                            binaryVariable->varCategory == gcSHADER_VAR_CATEGORY_BLOCK_MEMBER)
                            variable->u.type = (gcSHADER_TYPE) binaryVariable->u.type;
                        else
                            variable->u.numStructureElement = binaryVariable->u.numStructureElement;
                        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_VARIABLE_TYPE_QUALIFIER_FILE_VERSION)
                            variable->qualifier = gcvTYPE_QUALIFIER_NONE;
                        else
                        {
                            variable->qualifier = binaryVariable->qualifier;
                        }
                    }

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
                    {
                        variable->precision = gcSHADER_PRECISION_DEFAULT;
                    }
                    else
                    {
                        variable->precision = binaryVariable->precision ;
                   }
                    variable->flags        = binaryVariable->flags;
                    variable->arraySize    = binaryVariable->arraySize;
                    gcoOS_MemCopy((gctPOINTER)&variable->tempIndex,
                                (gctPOINTER)&binaryVariable->tempIndex,
                                sizeof(variable->tempIndex));
                    variable->nameLength   = binaryVariable->nameLength;
                    variable->name[length] = '\0';

                    if (length > 0)
                    {
                        gcoOS_MemCopy(variable->name,
                                      binaryVariable->memory - previousVersionAdjustment,
                                      length);
                    }

                    /* substract fields which are not in the file version */
                    binarySize -= previousVersionAdjustment;

                    /* Point to next variable. */
                    binaryVariable = (gcBINARY_VARIABLE)
                                   ((gctUINT8 *) binaryVariable + binarySize);
                    bytes       -= binarySize;
                }
            }

            /* Point to next function. */
            binaryFunction = (gcBINARY_FUNCTION) binaryVariable;
        }
    }

    /* _constVectorId */
    curPos = (gctUINT8 *)binaryFunction;
    Shader->_constVectorId  = *(gctUINT16 *) curPos;
    bytes -= sizeof(gctUINT16);

    /* _dummyUniformCount */
    curPos += sizeof(gctUINT16);
    Shader->_dummyUniformCount = *(gctUINT16 *) curPos;
    bytes -= sizeof(gctUINT16);

    /* _tempRegCount */
    curPos += sizeof(gctUINT16);
    gcoOS_MemCopy(&Shader->_tempRegCount,
                  curPos,
                  sizeof(gctUINT32));
    bytes -= sizeof(gctUINT32);

    /* _maxLocalTempRegCount */
    curPos += sizeof(gctUINT32);
    gcoOS_MemCopy(&Shader->_maxLocalTempRegCount,
                  curPos,
                  sizeof(gctUINT32));
    bytes -= sizeof(gctUINT32);

    /* constUniformBlockIndex */
    curPos += sizeof(gctUINT32);
    gcoOS_MemCopy(&Shader->constUniformBlockIndex,
                  curPos,
                  sizeof(gctINT));
    bytes -= sizeof(gctINT);

    /* early_fragment_tests. */
    curPos += sizeof(gctINT);
    gcoOS_MemCopy(&Shader->useEarlyFragTest,
                  curPos,
                  sizeof(gctINT));
    bytes -= sizeof(gctINT);

    /* useLastFragData. */
    curPos += sizeof(gctINT);
    gcoOS_MemCopy(&Shader->useLastFragData,
                  curPos,
                  sizeof(gctINT));
    bytes -= sizeof(gctINT);

    /* workgroupSize for compute shader */
    /* curPos should be added the previsou element size. */
    curPos += gcmSIZEOF(gctINT);
    if (Shader->type == gcSHADER_TYPE_COMPUTE)
    {
        gcoOS_MemCopy(&Shader->shaderLayout.compute.workGroupSize,
                      curPos,
                      gcmSIZEOF(Shader->shaderLayout.compute.workGroupSize));
        bytes -= gcmSIZEOF(Shader->shaderLayout.compute.workGroupSize);
        curPos += sizeof(Shader->shaderLayout.compute.workGroupSize);

        gcoOS_MemCopy(&Shader->shaderLayout.compute.isWorkGroupSizeFixed,
                      curPos,
                      gcmSIZEOF(Shader->shaderLayout.compute.isWorkGroupSizeFixed));
        bytes -= gcmSIZEOF(Shader->shaderLayout.compute.isWorkGroupSizeFixed);
        curPos += sizeof(Shader->shaderLayout.compute.isWorkGroupSizeFixed);

        gcoOS_MemCopy(&Shader->shaderLayout.compute.isWorkGroupSizeAdjusted,
                      curPos,
                      gcmSIZEOF(Shader->shaderLayout.compute.isWorkGroupSizeAdjusted));
        bytes -= gcmSIZEOF(Shader->shaderLayout.compute.isWorkGroupSizeAdjusted);
        curPos += sizeof(Shader->shaderLayout.compute.isWorkGroupSizeAdjusted);

        gcoOS_MemCopy(&Shader->shaderLayout.compute.adjustedWorkGroupSize,
                      curPos,
                      gcmSIZEOF(Shader->shaderLayout.compute.adjustedWorkGroupSize));
        bytes -= gcmSIZEOF(Shader->shaderLayout.compute.adjustedWorkGroupSize);
        curPos += sizeof(Shader->shaderLayout.compute.adjustedWorkGroupSize);
    }

    /* hasNotStagesRelatedLinkError. */
    gcoOS_MemCopy(&hasNotStagesRelatedLinkError,
                  curPos,
                  gcmSIZEOF(gctINT32));
    Shader->hasNotStagesRelatedLinkError = (gceSTATUS)(hasNotStagesRelatedLinkError);
    curPos += sizeof(gctINT32);
    bytes -= sizeof(gctINT32);

    /************************************************************************/
    /*                         transform feedback                           */
    /************************************************************************/
    /* Get the tfb varying count. */
    count = (gctUINT16 *) curPos;
    Shader->transformFeedback.varyingCount = *count;
    curPos += sizeof(gctUINT16);
    bytes -= sizeof(gctUINT16);

    Shader->transformFeedback.bufferMode = *(gctUINT16 *) curPos;
    curPos += sizeof(gctUINT16);
    bytes -= sizeof(gctUINT16);

    if (Shader->transformFeedback.varyingCount > 0)
    {
        /* Point to the first varying */
        binaryTfbVarying = (gcBINARY_TFBVarying) curPos;

        /* Allocate a new array of varying object */
        status = gcoOS_Allocate(gcvNULL,
                                gcmSIZEOF(gcsTFBVarying) * Shader->transformFeedback.varyingCount,
                                (gctPOINTER*)&Shader->transformFeedback.varyings);
        gcoOS_ZeroMemory(Shader->transformFeedback.varyings, gcmSIZEOF(gcsTFBVarying) * Shader->transformFeedback.varyingCount);

        if (gcmIS_ERROR(status))
        {
            gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
            gcmFOOTER();
            return status;
        }

        /* Parse all varyings. */
        for (i = 0; i < Shader->transformFeedback.varyingCount; i++)
        {
            /* Get the length of the varying name. */
            length = binaryTfbVarying->nameLength;

            if (length > 0)
            {
                gctSTRING s;
                gcoOS_Allocate(gcvNULL,
                               length + 1,
                               (gctPOINTER*)&s);
                Shader->transformFeedback.varyings[i].name = s;
                gcoOS_MemCopy(Shader->transformFeedback.varyings[i].name,
                              binaryTfbVarying->name,
                              length);
                Shader->transformFeedback.varyings[i].name[length] = '\0';
            }

            Shader->transformFeedback.varyings[i].arraySize = binaryTfbVarying->arraySize;
            Shader->transformFeedback.varyings[i].isWholeTFBed = binaryTfbVarying->isWholeTFBed;
            Shader->transformFeedback.varyings[i].isArray = binaryTfbVarying->isArray;
            Shader->transformFeedback.varyings[i].arraySize = binaryTfbVarying->arraySize;
            for (j = 0; j < Shader->outputCount; j++)
            {
                if (Shader->outputs[j]->index == binaryTfbVarying->outputIndex)
                {
                    Shader->transformFeedback.varyings[i].output = Shader->outputs[j];
                    break;
                }
            }

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_TFBVarying, name) + length, 2);

            /* Point to next varying. */
            binaryTfbVarying = (gcBINARY_TFBVarying)((gctUINT8 *) binaryTfbVarying + binarySize);
            curPos += binarySize;
            bytes -= binarySize;
        }
    }

    /************************************************************************/
    /*                                  code                                */
    /************************************************************************/

    /* Get the code count. */
    codeCount = (gctUINT32 *)curPos;

    if (bytes < sizeof(gctUINT32))
    {
        /* Invalid code count. */
        gcmFATAL("gcSHADER_Load: Invalid codeCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Point to the code. */
    code   = (gcSL_INSTRUCTION) (codeCount + 1);
    bytes -= sizeof(gctUINT32);

    /* Save the code count. */
    Shader->lastInstruction = Shader->codeCount = *codeCount;

    /* Compute the number of bytes. */
    binarySize = Shader->codeCount * sizeof(struct _gcSL_INSTRUCTION);

    if (bytes < binarySize)
    {
        /* Roll back. */
        Shader->lastInstruction = Shader->codeCount = 0;

        /* Invalid code count. */
        gcmFATAL("gcSHADER_Load: Invalid codeCount");
        gcmFOOTER();
        return gcvSTATUS_INVALID_DATA;
    }

    if (binarySize > 0)
    {
        /* Allocate memory for the code inside the gcSHADER object. */
        status = gcoOS_Allocate(gcvNULL,
                               binarySize,
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->lastInstruction = Shader->codeCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
            gcmFOOTER();
            return status;
        }

        Shader->code = pointer;

        /* Copy the code into the gcSHADER object. */
        gcoOS_MemCopy(Shader->code, code, binarySize);
    }

    curPos = (gctUINT8 *)code + binarySize;
    if (shaderVersion > gcdSL_SHADER_BINARY_BEFORE_LTC_FILE_VERSION)
    {
        /* Loadtime Optimization related data */

        /* LTC uniform index */
        bytes -= binarySize;  /* remaining bytes */
        /*Shader->ltcUniformCount = *(gctINT *)curPos;*/
        gcoOS_MemCopy(&Shader->ltcUniformCount, curPos, sizeof(gctINT));

        curPos += sizeof(Shader->ltcUniformCount);
        bytes -= sizeof(Shader->ltcUniformCount);  /* remaining bytes */
        /*Shader->ltcUniformBegin = *(gctUINT *) curPos;*/
        gcoOS_MemCopy(&Shader->ltcUniformBegin, curPos, sizeof(gctUINT));

        curPos += sizeof(Shader->ltcUniformBegin);
        bytes -= sizeof(Shader->ltcUniformBegin);
        /*Shader->ltcInstructionCount = *(gctUINT *) curPos;*/
        gcoOS_MemCopy(&Shader->ltcInstructionCount, curPos, sizeof(gctUINT));

        curPos += sizeof(Shader->ltcInstructionCount); /* points to ltcCodeUniformIndex */
        bytes -= sizeof(Shader->ltcInstructionCount);  /* remaining bytes */
        binarySize = sizeof(*Shader->ltcCodeUniformIndex) * Shader->ltcInstructionCount;

        if (binarySize > 0)
        {
            /* Allocate memory for  ltcCodeUniformIndex inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                   binarySize,
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->ltcUniformCount = 0;

                /* Error. */
                gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_MemCopy(pointer, curPos, binarySize);
            Shader->ltcCodeUniformIndex = (gctINT *)pointer;
        }
        else
        {
            Shader->ltcCodeUniformIndex = gcvNULL;
        }

        curPos += binarySize;                           /* points to ltcExpressions */
        bytes -= binarySize;                            /* remaining bytes */
        binarySize = sizeof(*Shader->ltcExpressions) * Shader->ltcInstructionCount;
        if (binarySize > 0)
        {
            /* Allocate memory for  ltcExpressions inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                   binarySize,
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->ltcUniformCount = 0;

                /* Error. */
                gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_MemCopy(pointer, curPos, binarySize);
            Shader->ltcExpressions = (gcSL_INSTRUCTION)pointer;
            curPos += binarySize;
        }
        else
        {
            Shader->ltcExpressions = gcvNULL;
        }
    }
    else
    {
        Shader->ltcUniformCount = 0;
        Shader->ltcExpressions = gcvNULL;
        Shader->ltcUniformBegin = 0;
        Shader->ltcInstructionCount = 0;
        Shader->ltcCodeUniformIndex = gcvNULL;
    }/* if */

    /* Source code string */
    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_HALTI_FILE_VERSION)
    {
        Shader->sourceLength = 0;
        Shader->source       = gcvNULL;
        locations = (gctINT16 *) binaryOutput;
    }
    else
    {
        /* curPos points to sourceLength */
        bytes -= binarySize;                            /* remaining bytes */
        /*Shader->sourceLength = *(gctUINT *)curPos;*/
        gcoOS_MemCopy(&Shader->sourceLength, curPos, sizeof(Shader->sourceLength));
        curPos += sizeof(Shader->sourceLength);
        bytes  -= sizeof(Shader->sourceLength);         /* remaining bytes */

        binarySize = Shader->sourceLength;              /* the NULL terminated string length */

        if (binarySize > 0)
        {
            gctUINT    i;

            /* Allocate memory for  ltcExpressions inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                   binarySize,
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->sourceLength = 0;

                /* Error. */
                gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_MemCopy(pointer, curPos, binarySize);
            Shader->source = (gctSTRING)pointer;
            /* decode source string */
            for (i = 0; i < binarySize; i++)
            {
                Shader->source[i] ^= SOURCE_ENCODE_CHAR;
            }
        }
        else
        {
            Shader->source = gcvNULL;
        }

        /* curPos point to the next item. */
        curPos += binarySize;
    }

    if ((gctUINT32)(curPos - (gctUINT8*)Buffer) >= BufferSize)
    {
        gcmFATAL("gcSHADER_Load: missing bytes in the binary file.");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

#if gcdUSE_WCLIP_PATCH
    /* Load the wclip temp index list. */
    gcoOS_MemCopy(&wclipListCount, curPos, gcmSIZEOF(gctUINT16));
    curPos += gcmSIZEOF(gctUINT16);
    bytes  -= gcmSIZEOF(gctUINT16);
    Shader->wClipTempIndexList = gcvNULL;

    while (wclipListCount > 0)
    {
        gctINT index, data0, data1;
        gcoOS_MemCopy(&binaryList, curPos, sizeof(binaryList));
        gcoOS_MemCopy(&index, (gctPOINTER)&binaryList.index, gcmSIZEOF(gctINT));
        gcoOS_MemCopy(&data0, (gctPOINTER)&binaryList.data0, gcmSIZEOF(gctINT));
        gcoOS_MemCopy(&data1, (gctPOINTER)&binaryList.data1, gcmSIZEOF(gctINT));

        gcSHADER_InsertList(Shader, &Shader->wClipTempIndexList, index, data0, data1);

        curPos += gcmSIZEOF(struct _gcBINARY_LIST);
        bytes  -= gcmSIZEOF(struct _gcBINARY_LIST);
        wclipListCount--;
    }

    /* Load the wclip uniform index list. */
    gcoOS_MemCopy(&wclipListCount, curPos, gcmSIZEOF(gctUINT16));
    curPos += gcmSIZEOF(gctUINT16);
    bytes  -= gcmSIZEOF(gctUINT16);
    Shader->wClipUniformIndexList = gcvNULL;

    while (wclipListCount > 0)
    {
        gctINT index, data0, data1;
        gcoOS_MemCopy(&binaryList, curPos, sizeof(binaryList));
        gcoOS_MemCopy(&index, (gctPOINTER)&binaryList.index, gcmSIZEOF(gctINT));
        gcoOS_MemCopy(&data0, (gctPOINTER)&binaryList.data0, gcmSIZEOF(gctINT));
        gcoOS_MemCopy(&data1, (gctPOINTER)&binaryList.data1, gcmSIZEOF(gctINT));

        gcSHADER_InsertList(Shader, &Shader->wClipUniformIndexList, index, data0, data1);

        curPos += gcmSIZEOF(struct _gcBINARY_LIST);
        bytes  -= gcmSIZEOF(struct _gcBINARY_LIST);
        wclipListCount--;
    }
#endif

    /* Src code signature */
    gcoOS_MemCopy(&Shader->_stringId, curPos, sizeof(gctUINT));
    curPos += gcmSIZEOF(gctUINT);
    bytes  -= gcmSIZEOF(gctUINT);

    if (bytes > binarySize)
    {
        /* Error. */
        gcmFATAL("gcSHADER_Load: %u extraneous bytes in the binary file.",
              bytes - binarySize);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_Save
**
**  Save a gcSHADER object including header information to a binary buffer.
**  SHADER binary header format: -
**     Word 1:  ('S' 'H' 'D' 'R') : signature
**     Word 2:  ('\od' '\od' '\od' '\od') od = octal digits; binary file version
**     Word 3:  ('E' 'S' '\0' '\0') | gcSHADER_TYPE_VERTEX   or
**              ('E' 'S' '\0' '\0') | gcSHADER_TYPE_FRAGMENT or
**              ('C' 'L' '\0' '\0') | gcSHADER_TYPE_CL
**     Word 4: ('\od' '\od' '\od' '\od') od = octal digits; compiler version
**     Word 5: ('\1' '\0' '\0' '\0') gcSL version
**     Word 6: size of shader binary file in bytes excluding this header
**
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctPOINTER Buffer
**          Pointer to a binary buffer to be used as storage for the gcSHADER
**          object.  If 'Buffer' is gcvNULL, the gcSHADER object will not be saved,
**          but the number of bytes required to hold the binary output for the
**          gcSHADER object will be returned.
**
**      gctUINT32 * BufferSize
**          Pointer to a variable holding the number of bytes allocated in
**          'Buffer'.  Only valid if 'Buffer' is not gcvNULL.
**
**  OUTPUT:
**
**      gctUINT32 * BufferSize
**          Pointer to a variable receiving the number of bytes required to hold
**          the binary form of the gcSHADER object.
*/
gceSTATUS
gcSHADER_Save(
    IN gcSHADER Shader,
    IN gctPOINTER Buffer,
    IN OUT gctUINT32 * BufferSize
    )
{
    gctUINT32   bytes, bytes2, i, j;
    gctINT      nameLength;
    gctUINT8    *buffer;
    gctUINT32   outputCount     = 0;
    gctUINT32   attributeCount  = 0;
    gctUINT32   uniformCount    = 0;
    gctUINT32   uniformBlockCount    = 0;
    gctUINT32   variableCount   = 0;
    gctUINT32   storageBlockCount    = 0;
    gctUINT32   ioBlockCount    = 0;
    gctUINT32   functionCount   = 0;
    gctUINT32   inputLocationCount   = 0;
    gctUINT32   outputLocationCount   = 0;
    gctINT32    tempValue = 0;
    gctUINT32   tfbVaryingCount = 0;

#if gcdUSE_WCLIP_PATCH
    gctUINT32   wclipListCount1 = 0, wclipListCount2 = 0;
    gcSHADER_LIST list = gcvNULL;
#endif

    gcmHEADER_ARG("Shader=0x%x Buffer=0x%x BufferSize=0x%x", Shader, Buffer, BufferSize);

    if (Shader == gcvNULL)
    {
    /* Return required number of bytes. */
        *BufferSize = 0;
        gcmFOOTER_ARG("*BufferSize=%d", *BufferSize);
        return gcvSTATUS_OK;
    }

    /************************************************************************/
    /*                  Compute size of binary buffer.                      */
    /************************************************************************/

    /* File Header. */
    bytes = _gcdShaderBinaryHeaderSize;

    /* shader sampler index. */
    bytes += sizeof(gctINT);

    /* Attribute count. */
    bytes += sizeof(gctUINT16);

    /* Real attribute count */
    bytes += sizeof(gctUINT16);

    /* Attributes. */
    for (i = 0; i < Shader->attributeCount; i++)
    {
        if (Shader->attributes[i] == gcvNULL) continue;

        attributeCount ++;

        nameLength = Shader->attributes[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_ATTRIBUTE, name) + gcmALIGN(nameLength, 2);
    }

    /* Uniforms. */
    bytes += sizeof(gctUINT16);

    for (i = 0; i < Shader->uniformCount; i++)
    {
        if (Shader->uniforms[i] == gcvNULL) continue;

        uniformCount ++;

        nameLength = Shader->uniforms[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_UNIFORM, memory) + gcmALIGN(nameLength, 2);

        if (Shader->uniforms[i]->arrayLengthCount > 0)
        {
            bytes += Shader->uniforms[i]->arrayLengthCount * gcmSIZEOF(gctINT);
        }
    }

    gcmASSERT(uniformCount ||
              (!uniformCount && !Shader->uniformBlockCount));

    if (uniformCount)
    {
        /* Uniform blocks. */
        bytes += sizeof(gctUINT16);

        for (i = 0; i < Shader->uniformBlockCount; i++)
        {
            if (Shader->uniformBlocks[i] == gcvNULL)
            {
                continue;
            }

            uniformBlockCount ++;

            nameLength = Shader->uniformBlocks[i]->nameLength;

            if (nameLength < 0)
            {
                nameLength = 0;
            }

            bytes += gcmOFFSETOF(_gcBINARY_UNIFORM_BLOCK, name) + gcmALIGN(nameLength, 2);
        }
    }

    /* Outputs. */
    bytes += sizeof(gctUINT16);

    for (i = 0; i < Shader->outputCount; i++)
    {
        if (Shader->outputs[i] == gcvNULL) continue;

        outputCount ++;

        nameLength = Shader->outputs[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_OUTPUT, name) + gcmALIGN(nameLength, 2);
    }

    /* Locations. */
    bytes += sizeof(gctUINT16);

    if(Shader->inputLocationCount)
    {
        inputLocationCount = Shader->inputLocationCount;
    }

    bytes += inputLocationCount * sizeof(gctINT16);

    bytes += sizeof(gctUINT16);

    if(Shader->outputLocationCount)
    {
        outputLocationCount = outputCount;
    }

    bytes += outputLocationCount * sizeof(gctINT16);

    /* Global Variables. */
    bytes += sizeof(gctUINT16);

    for (i = 0; i < Shader->variableCount; i++)
    {
        if (Shader->variables[i] == gcvNULL) continue;

        variableCount ++;

        if (Shader->variables[i]->arrayLengthCount > 0)
        {
            bytes += Shader->variables[i]->arrayLengthCount * gcmSIZEOF(gctINT);
        }

        nameLength = Shader->variables[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_VARIABLE, memory) + gcmALIGN(nameLength, 2);
    }


    gcmASSERT(variableCount ||
              (!variableCount && !Shader->storageBlockCount));

    if (variableCount)
    {
        /* storage blocks. */
        bytes += sizeof(gctUINT16);

        for (i = 0; i < Shader->storageBlockCount; i++)
        {
            if (Shader->storageBlocks[i] == gcvNULL)
            {
                continue;
            }

            storageBlockCount ++;

            nameLength = Shader->storageBlocks[i]->nameLength;

            if (nameLength < 0)
            {
                nameLength = 0;
            }

            bytes += gcmOFFSETOF(_gcBINARY_STORAGE_IO_BLOCK, name) + gcmALIGN(nameLength, 2);
        }
    }

    /* Enable default storage block or not. */
    bytes += sizeof(gctUINT16);

    /* Default storage block index. */
    bytes += sizeof(gctUINT16);

    if (variableCount)
    {
        /* io blocks. */
        bytes += sizeof(gctUINT16);

        for (i = 0; i < Shader->ioBlockCount; i++)
        {
            if (Shader->ioBlocks[i] == gcvNULL)
            {
                continue;
            }

            ioBlockCount ++;

            if (Shader->ioBlocks[i]->nameLength < 0)
            {
                nameLength = 0;
            }
            else
            {
            nameLength = Shader->ioBlocks[i]->nameLength + Shader->ioBlocks[i]->instanceNameLength;
            if (Shader->ioBlocks[i]->instanceNameLength > 0)
            {
                nameLength++;
            }
            }

            bytes += gcmOFFSETOF(_gcBINARY_STORAGE_IO_BLOCK, name) + gcmALIGN(nameLength, 2);
        }
    }


    /* Functions. */
    bytes += sizeof(gctUINT16);

    for (i = 0; i < Shader->functionCount; i++)
    {
        if (Shader->functions[i] == gcvNULL) continue;

        functionCount ++;

        nameLength = Shader->functions[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_FUNCTION, name) + gcmALIGN(nameLength, 2);

        /* Function arguments */
        bytes += Shader->functions[i]->argumentCount * sizeof(struct _gcBINARY_ARGUMENT);

        /* Function variables */
        for (j=0; j<Shader->functions[i]->localVariableCount; j++)
        {
            if (Shader->functions[i]->localVariables[j] == gcvNULL) continue;

            nameLength = Shader->functions[i]->localVariables[j]->nameLength;

            if (nameLength < 0)
            {
                nameLength = 0;
            }

            bytes += gcmOFFSETOF(_gcBINARY_VARIABLE, memory) + gcmALIGN(nameLength, 2);
        }
    }

    /* _constVectorId */
    bytes += sizeof(gctUINT16);

    /* _dummyUniformCount */
    bytes += sizeof(gctUINT16);

    /* _tempRegCount */
    bytes += sizeof(gctUINT32);

    /* _maxLocalTempRegCount */
    bytes += sizeof(gctUINT32);

    /* constUniformBlockIndex */
    bytes += sizeof(gctINT);

    /* early_fragment_tests. */
    bytes += sizeof(gctINT);

    /* useLastFragData. */
    bytes += sizeof(gctINT);

    /* workGroupSize for compute shader*/
    if (Shader->type == gcSHADER_TYPE_COMPUTE)
    {
        bytes += gcmSIZEOF(Shader->shaderLayout.compute.workGroupSize);
        bytes += gcmSIZEOF(Shader->shaderLayout.compute.isWorkGroupSizeFixed);
        bytes += gcmSIZEOF(Shader->shaderLayout.compute.isWorkGroupSizeAdjusted);
        bytes += gcmSIZEOF(Shader->shaderLayout.compute.adjustedWorkGroupSize);
    }

    /* hasNotStagesRelatedLinkError. */
    bytes += sizeof(gctINT32);

    /* Transform feedback. */
    bytes += gcmSIZEOF(gctUINT16);
    bytes += gcmSIZEOF(gctUINT16);
    for (i = 0; i < Shader->transformFeedback.varyingCount; i++)
    {
        if (Shader->transformFeedback.varyings[i].name == gcvNULL) continue;
        tfbVaryingCount++;
        nameLength = gcoOS_StrLen(Shader->transformFeedback.varyings[i].name, gcvNULL);
        bytes += gcmOFFSETOF(_gcBINARY_TFBVarying, name) + gcmALIGN(nameLength, 2);
    }

    /* Code. */
    bytes += sizeof(gctUINT32);
    bytes += Shader->codeCount * sizeof(struct _gcSL_INSTRUCTION);

    /* Loadtime Optimization related data */

    bytes += sizeof(Shader->ltcUniformCount) +
             sizeof(Shader->ltcUniformBegin) +
             sizeof(*Shader->ltcCodeUniformIndex) * Shader->ltcInstructionCount +
             sizeof(Shader->ltcInstructionCount) +
             sizeof(*Shader->ltcExpressions) * Shader->ltcInstructionCount;

    /* Source code string */
    bytes += sizeof(Shader->sourceLength) + Shader->sourceLength;

#if gcdUSE_WCLIP_PATCH
    /* Wclip list. */
    bytes += gcmSIZEOF(gctUINT16);
    if (Shader->wClipTempIndexList != gcvNULL)
    {
        list = Shader->wClipTempIndexList;

        while (list)
        {
            wclipListCount1++;
            list = list->next;
            bytes += gcmSIZEOF(struct _gcBINARY_LIST);
        }
    }

    bytes += gcmSIZEOF(gctUINT16);
    if (Shader->wClipUniformIndexList != gcvNULL)
    {
        list = Shader->wClipUniformIndexList;

        while (list)
        {
            wclipListCount2++;
            list = list->next;
            bytes += gcmSIZEOF(struct _gcBINARY_LIST);
        }
    }
#endif

    /* Return required number of bytes if Buffer is gcvNULL. */
    bytes += gcmSIZEOF(gctUINT);

    /* Return required number of bytes if Buffer is gcvNULL. */
    if (Buffer == gcvNULL)
    {
        *BufferSize = bytes;
        gcmFOOTER_ARG("*BufferSize=%d", *BufferSize);
        return gcvSTATUS_OK;
    }

    /* Make sure the buffer is large enough. */
    if (*BufferSize < bytes)
    {
        *BufferSize = bytes;
        gcmFOOTER_ARG("*BufferSize=%d status=%d",
                        *BufferSize, gcvSTATUS_BUFFER_TOO_SMALL);
        return gcvSTATUS_BUFFER_TOO_SMALL;
    }

    /* Store number of bytes returned. */
    *BufferSize = bytes;

    /************************************************************************/
    /*                      Fill the binary buffer.                         */
    /************************************************************************/

    buffer = Buffer;

    gcoOS_ZeroMemory(buffer, *BufferSize);

    /* Header */
    /* Word 1: signature 'S' 'H' 'D' 'R' */
    *(gceOBJECT_TYPE *) buffer = gcvOBJ_SHADER;
    buffer += sizeof(gceOBJECT_TYPE);
    gcmASSERT(sizeof(gceOBJECT_TYPE) == 4);

    /* Word 2: binary file version # */
    *(gctUINT32 *) buffer = gcdSL_SHADER_BINARY_FILE_VERSION;
    buffer += sizeof(gctUINT32);

    /* Word 3: chipModel */
    *(gctUINT32 *) buffer = gcGetHWCaps()->chipModel;
    buffer += sizeof(gctUINT32);

    /* Word 4: chipRevision */
    *(gctUINT32 *) buffer = gcGetHWCaps()->chipRevision;
    buffer += sizeof(gctUINT32);

    /* Word 5: language type and shader type */
    *(gctUINT32 *) buffer = Shader->compilerVersion[0];
    buffer += sizeof(gctUINT32);

    /* Word 6: compiler version */
    *(gctUINT32 *) buffer = Shader->compilerVersion[1];
    buffer += sizeof(gctUINT32);

    /* Word 7: flags */
    *(gctUINT32 *) buffer = Shader->flags;
    buffer += sizeof(gctUINT32);

    /* Word 8: client api version. */
    *(gctUINT32 *) buffer = Shader->clientApiVersion;
    buffer += sizeof(gctUINT32);

    /* Word 9: size of binary excluding header */
    *(gctUINT32 *) buffer = bytes - _gcdShaderBinaryHeaderSize;
    buffer += sizeof(gctUINT32);

    /* Sampler index. */
    gcoOS_MemCopy(buffer, &Shader->samplerIndex, sizeof(gctINT));
    buffer += sizeof(gctINT);

    /* Attribute count. */
    *(gctUINT16 *) buffer = (gctUINT16) attributeCount;
    buffer += sizeof(gctUINT16);

    /* Real attribute count */
    *(gctUINT16 *) buffer = (gctUINT16) Shader->attributeCount;
    buffer += sizeof(gctUINT16);

    /* Attributes. */
    for (i = 0; i < Shader->attributeCount; i++)
    {
        gcATTRIBUTE attribute;
        gcBINARY_ATTRIBUTE binary;

        if (Shader->attributes[i] == gcvNULL) continue;

        /* Point to source and binary attributes. */
        attribute = Shader->attributes[i];
        binary    = (gcBINARY_ATTRIBUTE) buffer;

        /* Fill in binary attribute. */
        binary->type                = attribute->type;
        binary->flags1              = (gctUINT16)(attribute->flags_ & 0xFFFF);
        binary->flags2              = (gctUINT16)((attribute->flags_ >> 16) & 0xFFFF);
        binary->arraySize           = (gctINT16) attribute->arraySize;
        binary->arrayLength         = (gctINT16) attribute->arrayLength;
        binary->nameLength          = (gctINT16) attribute->nameLength;
        binary->precision           = (gctINT16) attribute->precision;
        binary->index               = (gctINT16) attribute->index;
        binary->ioBlockIndex        = (gctINT16) attribute->ioBlockIndex;
        binary->ioBlockArrayIndex   = (gctINT16) attribute->ioBlockArrayIndex;
        binary->shaderMode          = (gctINT16) attribute->shaderMode;
        binary->nextSibling         = attribute->nextSibling;
        binary->prevSibling         = attribute->prevSibling;
        binary->typeNameVarIndex    = attribute->typeNameVarIndex;

        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->name, attribute->name, bytes);
        }
        else
        {
            bytes = 0;
        }

        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_ATTRIBUTE, name) + bytes;
    }

    /* Uniform count. */
    *(gctUINT16 *) buffer = (gctUINT16) uniformCount;
    buffer += sizeof(gctUINT16);

    /* Uniforms. */
    for (i = 0; i < Shader->uniformCount; i++)
    {
        gcUNIFORM uniform;
        gcBINARY_UNIFORM binary;

        if (Shader->uniforms[i] == gcvNULL) continue;

        /* Point to source and binary uniforms. */
        uniform = Shader->uniforms[i];
        binary  = (gcBINARY_UNIFORM) buffer;

        /* Fill in binary uniform. */
        binary->varCategory = GetUniformCategory(uniform);
        binary->firstChild = uniform->firstChild;
        binary->nextSibling = uniform->nextSibling;
        binary->prevSibling = uniform->prevSibling;
        binary->parent = uniform->parent;

        if (isUniformNormal(uniform)
        ||  isUniformLodMinMax(uniform)
        ||  isUniformLevelBaseSize(uniform)
        ||  isUniformBlockMember(uniform)
        ||  isUniformBlockAddress(uniform)
        ||  isUniformSampleLocation(uniform)
        ||  isUniformMultiSampleBuffers(uniform)
           )
            binary->u.type = (gcSHADER_TYPE) uniform->u.type;
        else
            binary->u.numStructureElement = uniform->u.numStructureElement;

        binary->arraySize  = (gctINT16) uniform->arraySize;
        binary->arrayLengthCount = (gctUINT16)uniform->arrayLengthCount;
        binary->nameLength = (gctINT16) uniform->nameLength;
        binary->physical = uniform->physical;
        binary->samplerPhysical = uniform->samplerPhysical;
        binary->address = uniform->address;
        gcoOS_MemCopy(binary->flags,
                      (gctPOINTER)&uniform->_flags,
                      sizeof(gceUNIFORM_FLAGS));

        gcoOS_MemCopy(binary->resOpFlag,
                      (gctPOINTER)&uniform->resOpFlag,
                      sizeof(gctUINT32));
        /* HALTI extras */
        binary->blockIndex = uniform->blockIndex;
        gcoOS_MemCopy(binary->arrayStride,
                      (gctPOINTER)&uniform->arrayStride,
                      sizeof(gctINT32));
        binary->matrixStride = uniform->matrixStride;
        binary->isRowMajor = (gctINT16) uniform->isRowMajor;
        gcoOS_MemCopy(binary->offset,
                      (gctPOINTER)&uniform->offset,
                      sizeof(gctINT32));
        binary->glUniformIndex   = uniform->glUniformIndex;
        binary->precision   = (gctINT16) uniform->precision;
#if defined(UNDER_CE)
        gcoOS_MemCopy(&(binary->location), &(uniform->location), sizeof(gctINT));
#else
        binary->location    = uniform->location;
#endif
        binary->baseBindingIdx = uniform->baseBindingIdx;

        gcoOS_MemCopy(binary->binding,
                      (gctPOINTER)&GetUniformBinding(uniform),
                      sizeof(gctINT32));

        gcoOS_MemCopy(binary->initializer,
                      (gctPOINTER)uniform->initializer.f32_v16,
                      sizeof(gcsValue));
        binary->dummyUniformIndex = uniform->dummyUniformIndex;
        binary->imageFormat = uniform->imageFormat;
        SetUniformUsedArraySize(binary, (gctINT16) uniform->usedArraySize);

        if (binary->arrayLengthCount > 0)
        {
            /* Compute number of bytes to copy. */
            bytes2 = binary->arrayLengthCount * gcmSIZEOF(gctINT);

            /* Copy name. */
            gcoOS_MemCopy(binary->memory, uniform->arrayLengthList, bytes2);
        }
        else
        {
            bytes2 = 0;
        }

        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->memory + bytes2, uniform->name, bytes);
        }
        else
        {
            bytes = 0;
        }

        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_UNIFORM, memory) + bytes + bytes2;
    }

    gcmASSERT(uniformCount ||
              (!uniformCount && !uniformBlockCount));

    if (uniformCount)
    {
        /* Uniform block count. */
        *(gctUINT16 *) buffer = (gctUINT16) uniformBlockCount;
        buffer += sizeof(gctUINT16);

        /* Uniform blocks. */
        for (i = 0; i < Shader->uniformBlockCount; i++)
        {
            gcsUNIFORM_BLOCK uniformBlock;
            gcBINARY_UNIFORM_BLOCK binary;

            if (Shader->uniformBlocks[i] == gcvNULL) continue;

            /* Point to source and binary uniform blocks. */
            uniformBlock = Shader->uniformBlocks[i];
            binary  = (gcBINARY_UNIFORM_BLOCK) buffer;

            /* Fill in binary uniform block. */
            binary->memoryLayout = (gctUINT16)GetUBMemoryLayout(uniformBlock);
            binary->blockSize = (gctUINT16)GetUBBlockSize(uniformBlock);
            binary->numBlockElement = (gctUINT16)GetUBNumBlockElement(uniformBlock);
            binary->firstChild = GetUBFirstChild(uniformBlock);
            binary->nextSibling = GetUBNextSibling(uniformBlock);
            binary->prevSibling = GetUBPrevSibling(uniformBlock);
            binary->index = GetUBIndex(uniformBlock);

            binary->nameLength = (gctINT16) uniformBlock->nameLength;

            gcoOS_MemCopy(binary->binding,
                      (gctPOINTER)&GetUBBinding(uniformBlock),
                      sizeof(gctINT32));

            if (binary->nameLength > 0)
            {
                /* Compute number of bytes to copy. */
                bytes = gcmALIGN(binary->nameLength, 2);

                /* Copy name. */
                gcoOS_MemCopy(binary->name, uniformBlock->name, bytes);
            }
            else
            {
                bytes = 0;
            }

            /* Adjust buffer pointer. */
            buffer += gcmOFFSETOF(_gcBINARY_UNIFORM_BLOCK, name) + bytes;
        }
    }

    /* Output count. */
    *(gctUINT16 *) buffer = (gctUINT16) outputCount;
    buffer += sizeof(gctUINT16);

    /* Outputs. */
    for (i = 0; i < Shader->outputCount; i++)
    {
        gcOUTPUT output;
        gcBINARY_OUTPUT binary;

        if (Shader->outputs[i] == gcvNULL) continue;

        /* Point to source and binary outputs. */
        output = Shader->outputs[i];
        binary = (gcBINARY_OUTPUT) buffer;

        /* Fill in binary output. */
        binary->index               = output->index;
        binary->origType            = output->origType;
        binary->type                = output->type;
        binary->flags1              = (gctUINT16)(output->flags_ & 0xFFFF);
        binary->flags2              = (gctUINT16)((output->flags_ >> 16) & 0xFFFF);
        binary->arraySize           = (gctINT8) output->arraySize;
        gcoOS_MemCopy((gctPOINTER)&binary->tempIndex,
                      (gctPOINTER)&output->tempIndex,
                      sizeof(output->tempIndex));
        binary->precision           = (gctINT16) output->precision;
        binary->nameLength          = (gctINT16) output->nameLength;
        binary->ioBlockIndex        = (gctINT16) output->ioBlockIndex;
        binary->ioBlockArrayIndex   = (gctINT16) output->ioBlockArrayIndex;
        binary->nextSibling         = output->nextSibling;
        binary->prevSibling         = output->prevSibling;
        binary->typeNameVarIndex    = output->typeNameVarIndex;
        binary->shaderMode          = (gctINT16) output->shaderMode;

        gcoOS_MemCopy(binary->layoutQualifier,
                      (gctPOINTER)&output->layoutQualifier,
                      sizeof(output->layoutQualifier));

        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->name, output->name, bytes);
        }
        else
        {
            bytes = 0;
        }

        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_OUTPUT, name) + bytes;
    }

    /* Location count. */
    *(gctUINT16 *) buffer = (gctUINT16) inputLocationCount;
    buffer += sizeof(gctUINT16);

    if(inputLocationCount)
    {
        gctINT16 *location;

        location =  (gctINT16 *)buffer;
        for (i = 0; i < Shader->attributeCount; i++, location++) {
            if (Shader->attributes[i] == gcvNULL) continue;
            *location = (gctINT16) Shader->inputLocations[i];
        }
        buffer = (gctUINT8 *)location;
    }

    *(gctUINT16 *) buffer = (gctUINT16) outputLocationCount;
    buffer += sizeof(gctUINT16);

    if (outputLocationCount)
    {
        gctINT16 *location;

        location =  (gctINT16 *)buffer;
        for (i = 0; i < Shader->outputCount; i++, location++) {
            if (Shader->outputs[i] == gcvNULL) continue;
            *location = (gctINT16)Shader->outputLocations[i];
        }
        buffer = (gctUINT8 *)location;
    }

    /* Global variable count. */
    *(gctUINT16 *) buffer = (gctUINT16) variableCount;
    buffer += sizeof(gctUINT16);

    /* Global variables. */
    for (i = 0; i < Shader->variableCount; i++)
    {
        gcVARIABLE variable;
        gcBINARY_VARIABLE binary;

        if (Shader->variables[i] == gcvNULL) continue;

        /* Point to source and binary variables. */
        variable = Shader->variables[i];
        binary = (gcBINARY_VARIABLE) buffer;

        /* Fill in binary variable. */
        binary->blockIndex = GetVariableBlockID(variable);
        binary->varCategory = GetVariableCategory(variable);
        binary->firstChild = variable->firstChild;
        binary->nextSibling = variable->nextSibling;
        binary->prevSibling = variable->prevSibling;
        binary->parent = variable->parent;

        if (isVariableSimple(variable))
            binary->u.type = (gcSHADER_TYPE) variable->u.type;
        else
            binary->u.numStructureElement = (gctUINT8)variable->u.numStructureElement;

        binary->arraySize  = (gctINT8) variable->arraySize;
        binary->arrayLengthCount = (gctUINT16) variable->arrayLengthCount;
        gcoOS_MemCopy((gctPOINTER)&binary->tempIndex,
                      (gctPOINTER)&variable->tempIndex,
                      sizeof(variable->tempIndex));
        binary->nameLength = (gctINT16) variable->nameLength;
        binary->precision  = variable->precision;
        binary->flags      = variable->flags;

        if (binary->arrayLengthCount > 0)
        {
            /* Compute number of bytes to copy. */
            bytes2 = binary->arrayLengthCount * gcmSIZEOF(gctINT);

            /* Copy name. */
            gcoOS_MemCopy(binary->memory, variable->arrayLengthList, bytes2);
        }
        else
        {
            bytes2 = 0;
        }

        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->memory + bytes2, variable->name, bytes);
        }
        else
        {
            bytes = 0;
        }
        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_VARIABLE, memory) + bytes + bytes2;
    }

    if (variableCount)
    {
        /* storage block count. */
        *(gctUINT16 *) buffer = (gctUINT16) storageBlockCount;
        buffer += sizeof(gctUINT16);

        /* storage blocks. */
        for (i = 0; i < Shader->storageBlockCount; i++)
        {
            gcsSTORAGE_BLOCK storageBlock;
            gcBINARY_STORAGE_BLOCK binary;

            if (Shader->storageBlocks[i] == gcvNULL) continue;

            /* Point to source and binary storage blocks. */
            storageBlock = Shader->storageBlocks[i];
            binary  = (gcBINARY_STORAGE_BLOCK) buffer;

            /* Fill in binary storage block. */
            binary->memoryLayout = (gctUINT16)GetSBMemoryLayout(storageBlock);
            binary->flags        = (gctUINT16)GetSBFlag(storageBlock);
            binary->blockSize = (gctUINT16)GetSBBlockSize(storageBlock);
            binary->numBlockElement = (gctUINT16)GetSBNumBlockElement(storageBlock);
            binary->firstChild = GetSBFirstChild(storageBlock);
            binary->nextSibling = GetSBNextSibling(storageBlock);
            binary->prevSibling = GetSBPrevSibling(storageBlock);
            binary->index = GetSBIndex(storageBlock);

            binary->nameLength = (gctINT16) GetSBNameLength(storageBlock);

            /* Copy binding */
            gcoOS_MemCopy(binary->binding,
                      (gctPOINTER)&GetSBBinding(storageBlock),
                      sizeof(gctINT32));

            if (binary->nameLength > 0)
            {
                /* Compute number of bytes to copy. */
                bytes = gcmALIGN(binary->nameLength, 2);

                /* Copy name. */
                gcoOS_MemCopy(binary->name, GetSBName(storageBlock), bytes);
            }
            else
            {
                bytes = 0;
            }

            /* Adjust buffer pointer. */
            buffer += gcmOFFSETOF(_gcBINARY_STORAGE_IO_BLOCK, name) + bytes;
        }
    }

    /* Enable default storage block or not. */
    *(gctUINT16 *)buffer = (gctUINT16)Shader->enableDefaultStorageBlock;
    buffer += sizeof(gctUINT16);

    /* Default storage block index. */
    *(gctUINT16 *)buffer = Shader->_defaultStorageBlock;
    buffer += sizeof(gctUINT16);

    if (variableCount)
    {
        /* io block count. */
        *(gctUINT16 *) buffer = (gctUINT16) ioBlockCount;
        buffer += sizeof(gctUINT16);

        /* io blocks. */
        for (i = 0; i < Shader->ioBlockCount; i++)
        {
            gcsIO_BLOCK ioBlock;
            gcBINARY_IO_BLOCK binary;

            if (Shader->ioBlocks[i] == gcvNULL) continue;

            /* Point to source and binary io blocks. */
            ioBlock = Shader->ioBlocks[i];
            binary  = (gcBINARY_IO_BLOCK) buffer;

            /* Fill in binary io block. */
            binary->memoryLayout = (gctUINT16)GetSBMemoryLayout(ioBlock);
            binary->flags        = (gctUINT16)GetSBFlag(ioBlock);
            binary->blockSize = (gctUINT16)GetSBBlockSize(ioBlock);
            binary->numBlockElement = (gctUINT16)GetSBNumBlockElement(ioBlock);
            binary->firstChild = GetSBFirstChild(ioBlock);
            binary->nextSibling = GetSBNextSibling(ioBlock);
            binary->prevSibling = GetSBPrevSibling(ioBlock);
            binary->index = GetSBIndex(ioBlock);

            binary->nameLength = (gctINT16) GetSBNameLength(ioBlock);
            binary->instanceNameLength = (gctINT16) GetSBInstanceNameLength(ioBlock);

            /* Copy binding */
            gcoOS_MemCopy(binary->binding,
                      (gctPOINTER)&GetSBBinding(ioBlock),
                      sizeof(gctINT32));

            if (binary->nameLength > 0)
            {
            bytes = binary->nameLength + binary->instanceNameLength;
            if (binary->instanceNameLength > 0)
            {
                bytes++;
            }
            bytes = gcmALIGN(bytes, 2);
            /* Copy name. */
            gcoOS_MemCopy(binary->name, GetSBName(ioBlock), bytes);
            }
            else
            {
                bytes = 0;
            }

            /* Adjust buffer pointer. */
            buffer += gcmOFFSETOF(_gcBINARY_STORAGE_IO_BLOCK, name) + bytes;
        }
    }

    /* Function count. */
    *(gctUINT16 *) buffer = (gctUINT16) functionCount;
    buffer += sizeof(gctUINT16);

    /* Functions. */
    for (i = 0; i < Shader->functionCount; i++)
    {
        gcFUNCTION function;
        gcBINARY_FUNCTION binary;

        if (Shader->functions[i] == gcvNULL) continue;

        /* Point to source and binary functions. */
        function = Shader->functions[i];
        binary = (gcBINARY_FUNCTION) buffer;

        /* Fill in binary function. */
        binary->argumentCount       = (gctINT16) function->argumentCount;
        binary->packedAwayArgNo     = (gctINT16) function->packedAwayArgNo;
        binary->localVariableCount  = (gctINT16) function->localVariableCount;
        gcoOS_MemCopy(&binary->flags, &function->flags, sizeof(gctUINT32));
        gcoOS_MemCopy(&binary->intrinsicsKind, &function->intrinsicsKind, sizeof(gctUINT32));
        binary->tempIndexStart      = function->tempIndexStart;
        binary->tempIndexEnd        = function->tempIndexEnd;
        binary->tempIndexCount      = function->tempIndexCount;
        binary->codeStart           = function->codeStart;
        binary->codeCount           = function->codeCount;
        binary->label               = (gctINT16)function->label;
        binary->nameLength          = (gctINT16) function->nameLength;

        gcmASSERT((gctUINT32)binary->tempIndexStart == function->tempIndexStart);

        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->name, function->name, bytes);
        }
        else
        {
            bytes = 0;
        }

        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_FUNCTION, name) + bytes;

        /* Function arguments */
        for (j = 0; j < function->argumentCount; j++)
        {
            gcsFUNCTION_ARGUMENT *argument;
            gcBINARY_ARGUMENT binary;

            /* Point to source and binary arguments. */
            argument = &function->arguments[j];
            binary = (gcBINARY_ARGUMENT) buffer;

            /* Fill in binary argument. */
            gcoOS_MemCopy((gctPOINTER)&binary->index,
                          (gctPOINTER)&argument->index,
                          sizeof(argument->index));
            binary->enable     = argument->enable;
            binary->qualifier  = argument->qualifier;
            binary->precision  = argument->precision;
            binary->variableIndex = argument->variableIndex;
            binary->flags      = argument->flags;

            /* Adjust buffer pointer. */
            buffer += sizeof(struct _gcBINARY_ARGUMENT);
        }

        /* Function variables */
        for (j = 0; j < function->localVariableCount; j++)
        {
            gcVARIABLE variable;
            gcBINARY_VARIABLE binary;

            if (function->localVariables[j] == gcvNULL) continue;

            /* Point to source and binary variables. */
            variable = function->localVariables[j];
            binary = (gcBINARY_VARIABLE) buffer;

            /* Fill in binary variable. */
            binary->varCategory = GetVariableCategory(variable);
            binary->firstChild = variable->firstChild;
            binary->nextSibling = variable->nextSibling;
            binary->prevSibling = variable->prevSibling;
            binary->parent = variable->parent;

            if (isVariableSimple(variable))
                binary->u.type = (gcSHADER_TYPE) variable->u.type;
            else
                binary->u.numStructureElement = (gctUINT8)variable->u.numStructureElement;

            binary->arraySize  = (gctINT8) variable->arraySize;
            gcoOS_MemCopy((gctPOINTER)&binary->tempIndex,
                          (gctPOINTER)&variable->tempIndex,
                          sizeof(variable->tempIndex));
            binary->nameLength = (gctINT16) variable->nameLength;
            binary->precision  = variable->precision;
            binary->flags      = variable->flags;

            if (binary->nameLength > 0)
            {
                /* Compute number of bytes to copy. */
                bytes = gcmALIGN(binary->nameLength, 2);

                /* Copy name. */
                gcoOS_MemCopy(binary->memory, variable->name, bytes);
            }
            else
            {
                bytes = 0;
            }

            /* Adjust buffer pointer. */
            buffer += gcmOFFSETOF(_gcBINARY_VARIABLE, memory) + bytes;
        }
    }

    /* _constVectorId */
    *(gctUINT16 *) buffer = (gctUINT16) Shader->_constVectorId;
    buffer += sizeof(gctUINT16);

    /* _dummyUniformCount */
    *(gctUINT16 *) buffer = (gctUINT16) Shader->_dummyUniformCount;
    buffer += sizeof(gctUINT16);

    /* _tempRegCount */
    gcoOS_MemCopy(buffer, &Shader->_tempRegCount, sizeof(gctUINT32));
    buffer += sizeof(gctUINT32);

    /* _maxLocalTempRegCount */
    gcoOS_MemCopy(buffer, &Shader->_maxLocalTempRegCount, sizeof(gctUINT32));
    buffer += sizeof(gctUINT32);

    /* constUniformBlockIndex */
    gcoOS_MemCopy(buffer, &Shader->constUniformBlockIndex, sizeof(Shader->constUniformBlockIndex));
    buffer += sizeof(gctINT);

    /* early_fragment_tests. */
    gcoOS_MemCopy(buffer, &Shader->useEarlyFragTest, sizeof(Shader->useEarlyFragTest));
    buffer += sizeof(gctINT);

    /* useLastFragData. */
    gcoOS_MemCopy(buffer, &Shader->useLastFragData, sizeof(Shader->useLastFragData));
    buffer += sizeof(gctINT);

    /* workgroup size for compute shader*/
    if (Shader->type == gcSHADER_TYPE_COMPUTE)
    {
        gcoOS_MemCopy(buffer, &Shader->shaderLayout.compute.workGroupSize, gcmSIZEOF(Shader->shaderLayout.compute.workGroupSize));
        buffer += gcmSIZEOF(Shader->shaderLayout.compute.workGroupSize);

        gcoOS_MemCopy(buffer, &Shader->shaderLayout.compute.isWorkGroupSizeFixed, gcmSIZEOF(Shader->shaderLayout.compute.isWorkGroupSizeFixed));
        buffer += gcmSIZEOF(Shader->shaderLayout.compute.isWorkGroupSizeFixed);

        gcoOS_MemCopy(buffer, &Shader->shaderLayout.compute.isWorkGroupSizeAdjusted, gcmSIZEOF(Shader->shaderLayout.compute.isWorkGroupSizeAdjusted));
        buffer += gcmSIZEOF(Shader->shaderLayout.compute.isWorkGroupSizeAdjusted);

        gcoOS_MemCopy(buffer, &Shader->shaderLayout.compute.adjustedWorkGroupSize, gcmSIZEOF(Shader->shaderLayout.compute.adjustedWorkGroupSize));
        buffer += gcmSIZEOF(Shader->shaderLayout.compute.adjustedWorkGroupSize);
    }

    /* hasNotStagesRelatedLinkError. */
    tempValue = (gctINT32)Shader->hasNotStagesRelatedLinkError;
    gcoOS_MemCopy(buffer, &tempValue, sizeof(gctINT32));
    buffer += sizeof(gctINT32);

    /* transform feedback */
    *(gctUINT16 *) buffer = (gctUINT16) tfbVaryingCount;
    buffer += sizeof(gctUINT16);
    *(gctUINT16 *) buffer = (gctUINT16) Shader->transformFeedback.bufferMode;
    buffer += sizeof(gctUINT16);
    /* transform feedback varyings */
    for (i = 0; i < tfbVaryingCount; i++)
    {
        gcBINARY_TFBVarying binary;

        if (Shader->transformFeedback.varyings[i].name == gcvNULL) continue;
        binary = (gcBINARY_TFBVarying) buffer;

        /* Fill in binary tfb varying. */
        binary->outputIndex = (gctUINT16) Shader->transformFeedback.varyings[i].output->index;
        binary->arraySize = (gctINT16) Shader->transformFeedback.varyings[i].arraySize;
        binary->isWholeTFBed = (gctINT16) Shader->transformFeedback.varyings[i].isWholeTFBed;
        binary->isArray = (gctINT16) Shader->transformFeedback.varyings[i].isArray;
        binary->nameLength = (gctINT16) gcoOS_StrLen(Shader->transformFeedback.varyings[i].name, gcvNULL);
        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);
            /* Copy name. */
            gcoOS_MemCopy(binary->name, Shader->transformFeedback.varyings[i].name, bytes);
        }
        else
        {
            bytes = 0;
        }
        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_TFBVarying, name) + bytes;
    }

    /* Code count. */
    gcoOS_MemCopy(buffer, &Shader->codeCount, sizeof(gctUINT32));
    buffer += sizeof(gctUINT32);

    /* Copy the code. */
    bytes = Shader->codeCount * sizeof(struct _gcSL_INSTRUCTION);
    if (bytes > 0) gcoOS_MemCopy(buffer, Shader->code, bytes);
    buffer += bytes;

    /* Loadtime Optimization related data */

    /* LTC uniform index */
    /**(gctINT *) buffer = Shader->ltcUniformCount;*/
    gcoOS_MemCopy(buffer, &Shader->ltcUniformCount, sizeof(Shader->ltcUniformCount));
    buffer += sizeof(Shader->ltcUniformCount);

    /**(gctUINT *) buffer = Shader->ltcUniformBegin;*/
    gcoOS_MemCopy(buffer, &Shader->ltcUniformBegin, sizeof(Shader->ltcUniformBegin));
    buffer += sizeof(Shader->ltcUniformBegin);

    /**(gctUINT *) buffer = Shader->ltcInstructionCount;*/
    gcoOS_MemCopy(buffer, &Shader->ltcInstructionCount, sizeof(Shader->ltcInstructionCount));
    buffer += sizeof(Shader->ltcInstructionCount);

    bytes = sizeof(*Shader->ltcCodeUniformIndex) * Shader->ltcInstructionCount;
    if (bytes > 0) gcoOS_MemCopy(buffer, Shader->ltcCodeUniformIndex, bytes);
    buffer += bytes;

    /* LTC expressions */
    bytes = sizeof(*Shader->ltcExpressions) * Shader->ltcInstructionCount;
    if (bytes > 0) gcoOS_MemCopy(buffer, Shader->ltcExpressions, bytes);
    buffer += bytes;

    /* Source code string */
    /**(gctUINT *) buffer = Shader->sourceLength;*/
    gcoOS_MemCopy(buffer, &Shader->sourceLength, sizeof(Shader->sourceLength));
    buffer += sizeof(Shader->sourceLength);

    bytes = Shader->sourceLength;
    if (bytes > 0)
    {
        gctUINT i;
        gcoOS_MemCopy(buffer, Shader->source, bytes);
        /* encode source string */
        for (i = 0; i < bytes; i++)
        {
            buffer[i] ^= SOURCE_ENCODE_CHAR;
        }
    }
    buffer += bytes;

#if gcdUSE_WCLIP_PATCH
    /* Wclip list. */
    gcoOS_MemCopy(buffer, &wclipListCount1, sizeof(gctUINT16));

    buffer += gcmSIZEOF(gctUINT16);
    if (wclipListCount1 > 0)
    {
        list = Shader->wClipTempIndexList;

        while (list)
        {
            struct _gcBINARY_LIST binary_list;

            gcoOS_MemCopy((gctPOINTER)&binary_list.index, (gctPOINTER)&list->index, sizeof(list->index));
            gcoOS_MemCopy((gctPOINTER)&binary_list.data0, (gctPOINTER)&list->data0, sizeof(list->data0));
            gcoOS_MemCopy((gctPOINTER)&binary_list.data1, (gctPOINTER)&list->data1, sizeof(list->data1));

            gcoOS_MemCopy(buffer, &binary_list, sizeof(binary_list));

            list = list->next;

            buffer += gcmSIZEOF(struct _gcBINARY_LIST);
        }
    }

    gcoOS_MemCopy(buffer, &wclipListCount2, sizeof(gctUINT16));

    buffer += gcmSIZEOF(gctUINT16);
    if (wclipListCount2 > 0)
    {
        list = Shader->wClipUniformIndexList;

        while (list)
        {
            struct _gcBINARY_LIST binary_list;

            gcoOS_MemCopy((gctPOINTER)&binary_list.index, (gctPOINTER)&list->index, sizeof(list->index));
            gcoOS_MemCopy((gctPOINTER)&binary_list.data0, (gctPOINTER)&list->data0, sizeof(list->data0));
            gcoOS_MemCopy((gctPOINTER)&binary_list.data1, (gctPOINTER)&list->data1, sizeof(list->data1));

            gcoOS_MemCopy(buffer, &binary_list, sizeof(binary_list));

            list = list->next;

            buffer += gcmSIZEOF(struct _gcBINARY_LIST);
        }
    }
#endif

    /* Source code signature */
    gcoOS_MemCopy(buffer, &Shader->_stringId, sizeof(gctUINT));
    buffer += gcmSIZEOF(gctUINT);

    /* Success. */
    gcmFOOTER_ARG("*BufferSize=%lu", *BufferSize);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_LoadEx
**
**  Load a gcSHADER object from a binary buffer.  The binary buffer is layed out
**  as follows:
**      // Six word header
**      // Signature, must be 'S','H','D','R'.
**      gctINT8             signature[4];
**      gctUINT32           binFileVersion;
**      gctUINT32           compilerVersion[2];
**      gctUINT32           gcSLVersion;
**      gctUINT32           binarySize;
**
**
**      // Number of attributes.  Can be 0, in which case the next field will be
**      // uniformCount.
**      gctINT16                attributeCount;
**
**      // attributeCount structures.  Each structure is followed by the
**      // attribute name, without the trailing '\0'.  Each structure is
**      // optionally padded with 0x00 to align to a 16-bit boundary.
**      struct _GCSL_BINARY_ATTRIBUTE {
**          gctINT8         componentCount;
**          gctINT8         isTexture;
**          gctINT16            nameLength;
**          char            name[];
**      } attributes[];
**
**      // Number of uniforms.  Can be 0, in which case the next field will be
**      outputCount.
**      gctINT16                uniformCount
**
**      // uniformCount structures.  Each structure is followed by the uniform
**      // name, without the trailing '\0'.  Each structure is optionally padded
**      // with 0x00 to align to a 16-bit boundary.
**      struct _GCSL_BINARY_UNIFORM {
**          gctUINT16           index;
**          gctUINT16           imageSamplerIndex;
**          gctUINT8            type;
**          gctINT16            count;
**          gctINT16            nameLength;
**          char            name[];
**      } uniforms[];
**
**      // Number of outputs.  Can be zero.
**      gctINT16                outputCount
**
**      // outputCount structures.  Each structure is followed by the output
**      // name, without the trailing '\0'.  Each structure is optionally padded
**      // with 0x00 to align to a 16-bit boundary.
**      struct _GCSL_BINARY_OUTPUT {
**          gctINT8         type;
**          gctINT8         arraySize;
**          gctUINT16       tempIndex;
**          gctINT16        nameLength;
**          char            name[];
**      } outputs[];
**
**      // Number of variables.  Can be zero.
**      gctINT16                variableCount
**
**      // variableCount structures.  Each structure is followed by the variable
**      // name, without the trailing '\0'.  Each structure is optionally padded
**      // with 0x00 to align to a 16-bit boundary.
**      struct _GCSL_BINARY_VARIABLE {
**          gctINT8         type;
**          gctINT8         arraySize;
**          gctUINT16       tempIndex;
**          gctINT16        nameLength;
**          char            name[];
**      } variables[];
**
**      // Number of functions.  Can be zero.
**      gctINT16                functionCount
**
**      // functionCount structures.  Each structure is followed by the function
**      // name, without the trailing '\0'.  Each structure is optionally padded
**      // with 0x00 to align to a 16-bit boundary.
**      // Next follows function arguments and variables for the function
**      // followed by the next function
**      struct _gcBINARY_FUNCTION {
**          gctINT16                    argumentCount;
**          gctINT16                    variableCount;
**          gctUINT16                    codeStart;
**          gctUINT16                    codeCount;
**            gctUINT16                    label;
**            gctINT16                    nameLength;
**            char                        name[1];
**        }
**        functions[];
**
**      struct _gcBINARY_ARGUMENT
**        {
**            gctUINT16                    index;
**            gctUINT8                    enable;
**            gctUINT8                    qualifier;
**        }
**        arguments;
**
**      // kernelFunctionCount structures.  Each structure is followed by the kernel function
**      // name, without the trailing '\0'.  Each structure is optionally padded
**      // with 0x00 to align to a 16-bit boundary.
**      // Next follows:
**      //       arguments       gcBINARY_ARGUMENT
**      //       uniforms        gcBINARY_UNIFORM_EX
**      //       image samplers  gcBINARY_IMAGE_SAMPLER
**      //       variables       gcBINARY_VARIABLE
**      //       properties      gcBINARY_KERNEL_FUNCTION_PROPERTY
**      //       property values gctINT32
**      // for the kernel function followed by the next kernel function
**
**      struct _gcBINARY_KERNEL_FUNCTION {
**            gctINT16                argumentCount;
**            gctUINT16               label;
**            gctUINT32               localMemorySize;
**            gctINT16                uniformArgumentCount;
**            gctINT16                samplerIndex;
**            gctINT16                imageSamplerCount;
**            gctINT16                variableCount;
**            gctINT16                propertyCount;
**            gctINT16                propertyValueCount;
**            gctUINT16               codeStart;
**            gctUINT16               codeCount;
**            gctUINT16               codeEnd;
**            gctINT16                nameLength;
**            char                    name[1];
**        }
**        kernelFunctions[];
**
**      // Number of instructions in code.
**      gctINT16                codeCount;
**
**      // The code buffer.
**      glSL_INSTRUCTION    code[];
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctPOINTER Buffer
**          Pointer to a binary buffer containing the shader data to load.
**
**      gctUINT32 BufferSize
**          Number of bytes inside the binary buffer pointed to by 'Buffer'.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_LoadEx(
    IN gcSHADER Shader,
    IN gctPOINTER Buffer,
    IN gctUINT32 BufferSize
    )
{
    gctUINT32 bytes;
    gctUINT32 * codeCount;
    gctUINT16 * count;
    gctUINT16 * privateMemorySize;
    gctUINT16 * constantMemorySize;
    gctUINT   * optimizationOption;
    gctUINT16 * maxKernelFunctionArgs;
    gceSTATUS status;
    gcBINARY_ATTRIBUTE binaryAttribute;
    gctUINT i, j;
    gctUINT32 length, binarySize;
    gcATTRIBUTE attribute;
    gcBINARY_UNIFORM_EX binaryUniform;
    gcUNIFORM uniform;
    gcBINARY_OUTPUT binaryOutput;
    gcOUTPUT output;
    gcOUTPUT prevOutput = gcvNULL;
    gcBINARY_VARIABLE_EX binaryVariable;
    gcVARIABLE variable;
    gcBINARY_FUNCTION binaryFunction;
    gcFUNCTION function;
    gcBINARY_ARGUMENT binaryArgument;
    gcsFUNCTION_ARGUMENT_PTR argument;
    gcBINARY_KERNEL_FUNCTION binaryKernelFunc;
    gcKERNEL_FUNCTION kernelFunction;
    gcBINARY_KERNEL_FUNCTION_PROPERTY binaryKernelFuncProp;
    gcsKERNEL_FUNCTION_PROPERTY_PTR kernelFuncProp;
    gcBINARY_IMAGE_SAMPLER binaryImageSampler;
    gcsIMAGE_SAMPLER_PTR imageSampler;
    gctINT_PTR binaryPropertyValue;

    gcSL_INSTRUCTION code;
    gctUINT8 *       curPos;
    gctPOINTER pointer = gcvNULL;
    gctUINT32           shaderVersion;
    gctUINT32           allocBytes;
    gctUINT8            debugInfo;

    gcmHEADER_ARG("Shader=0x%x Buffer=0x%x BufferSize=%lu",
                  Shader, Buffer, BufferSize);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Buffer != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(BufferSize > 0);

    if(!Shader) {
       gcmFATAL("gcSHADER_LoadEx: null shader handle passed");
       gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
       return gcvSTATUS_INVALID_ARGUMENT;
    }

    _gcSHADER_Clean(Shader);

    /* Load the Header */
    status = gcSHADER_LoadHeader(Shader, Buffer, BufferSize, &shaderVersion);
    if(gcmIS_ERROR(status)) {
       gcmFOOTER();
       return status;
    }

    bytes = BufferSize - _getShaderBinaryHeaderSize(shaderVersion);

    /* Get the attribute count. */
    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_UNIFORM_PHYSICAL_ADDR)
    {
        count  = (gctUINT16 *) ((gctUINT8 *)Buffer + _getShaderBinaryHeaderSize(shaderVersion));
    }
    /* Get sampler index, then get attribute count. */
    else
    {
        Shader->samplerIndex = *(gctINT *)((gctUINT8 *)Buffer + _getShaderBinaryHeaderSize(shaderVersion));

        if (bytes < sizeof(gctINT))
        {
            /* Invalid sampler index. */
            gcmFATAL("gcSHADER_LoadEx: Invalid sampler index.");
            gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
            return gcvSTATUS_INVALID_DATA;
        }

        bytes -= sizeof(gctINT);
        count  = (gctUINT16 *) ((gctUINT8 *)Buffer + _getShaderBinaryHeaderSize(shaderVersion) + sizeof(gctINT));
    }

    /************************************************************************/
    /*                              attributes                              */
    /************************************************************************/
    if (bytes < sizeof(gctUINT16))
    {
        /* Invalid attribute count. */
        gcmFATAL("gcSHADER_LoadEx: Invalid attributeCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Save the attribute count. */
    Shader->attributeArraySize =
    Shader->attributeCount = *count;

    /* Point to the first attribute. */
    binaryAttribute = (gcBINARY_ATTRIBUTE) (count + 1);
    bytes          -= sizeof(gctUINT16);

    if (Shader->attributeCount > 0)
    {
        gctINT previousVersionAdjustment = 0;

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
        {
            /* precision field which is not in the version */
            previousVersionAdjustment += sizeof(binaryAttribute->precision);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_TYPE_NAME_VAR_INDEX)
        {
            /* precision field which is not in the version */
            previousVersionAdjustment += sizeof(binaryAttribute->typeNameVarIndex);
        }

        /* Allocate the array of gcATTRIBUTE structure pointers. */
        status = gcoOS_Allocate(gcvNULL,
                               Shader->attributeCount * sizeof(gcATTRIBUTE),
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->attributeArraySize =
            Shader->attributeCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
            gcmFOOTER();
            return status;
        }

        Shader->attributes = pointer;

        /* Parse all attributes. */
        for (i = 0; i < Shader->attributeCount; i++)
        {
            /* Get the length of the attribute name. */
            length = (bytes < sizeof(struct _gcBINARY_ATTRIBUTE))
                         ? 0
                         : binaryAttribute->nameLength;

            /* Test for special length. */
            if ((gctINT) length < 0)
            {
                length = 0;
            }

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_ATTRIBUTE, name) + length,
                                  2);

            if (bytes < binarySize)
            {
                /* Roll back. */
                Shader->attributeCount = i;

                /* Invalid attribute. */
                gcmFATAL("gcSHADER_LoadEx: Invalid attribute");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            /* Allocate memory for the attribute inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                    gcmOFFSETOF(_gcATTRIBUTE, name) + length + 1,
                                    &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->attributeCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                gcmFOOTER();
                return status;
            }

            attribute = pointer;

            gcoOS_ZeroMemory(attribute, gcmOFFSETOF(_gcATTRIBUTE, name) + length + 1);

            /* Copy attribute to the gcSHADER object. */
            Shader->attributes[i]     = attribute;
            attribute->object.type    = gcvOBJ_ATTRIBUTE;
            attribute->index          = (gctUINT16) i;
            attribute->type           = (gcSHADER_TYPE) binaryAttribute->type;
            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
            {
                attribute->precision = gcSHADER_PRECISION_DEFAULT;
            }
            else
            {
                attribute->precision = (gcSHADER_PRECISION)binaryAttribute->precision;
            }
            attribute->flags_         = (gctUINT32)(binaryAttribute->flags1 | (binaryAttribute->flags2 << 16));
            attribute->arraySize      = binaryAttribute->arraySize;
            attribute->arrayLength    = binaryAttribute->arrayLength;
            attribute->inputIndex     = -1;
            attribute->location       = -1;
            attribute->nextSibling    = binaryAttribute->nextSibling;
            attribute->prevSibling    = binaryAttribute->prevSibling;
            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_TYPE_NAME_VAR_INDEX)
            {
                attribute->typeNameVarIndex = -1;
            }
            else
            {
                attribute->typeNameVarIndex = binaryAttribute->typeNameVarIndex;
            }
            attribute->nameLength     = binaryAttribute->nameLength;
            attribute->name[length]   = '\0';

            if (length > 0)
            {
                gcoOS_MemCopy(attribute->name,
                              binaryAttribute->name,
                              length);
            }

            /* Point to next attribute. */
            binaryAttribute = (gcBINARY_ATTRIBUTE)
                              ((gctINT8 *) binaryAttribute + binarySize);
            bytes          -= binarySize;
        }
    }

    /************************************************************************/
    /*                                  uniforms                            */
    /************************************************************************/

    /* Get the uniform count. */
    count = (gctUINT16 *) binaryAttribute;

    if (bytes < sizeof(gctUINT16))
    {
        /* Invalid uniform count. */
        gcmFATAL("gcSHADER_LoadEx: Invalid uniformCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Save the uniform count. */
    Shader->uniformArraySize =
    Shader->uniformCount = *count;

    /* Point to the first uniform. */
    binaryUniform = (gcBINARY_UNIFORM_EX) (count + 1);
    bytes        -= sizeof(gctUINT16);

    if (Shader->uniformCount > 0)
    {
        gctINT   previousVersionAdjustment = 0;
        gctUINT32 oldUniformCount = 0;

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_HALTI_FILE_VERSION)
        {
            /* initializer not in the version */
            previousVersionAdjustment += sizeof(binaryUniform->initializer);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_LTC_FILE_VERSION)
        {
            /* fields which are not in the version */
            previousVersionAdjustment += sizeof(binaryUniform->glUniformIndex);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_OPENCL_IMAGE_SAMPLER_BY_TEXLD_FILE_VERSION)
        {
            /* image sampler index field which is not in the version */
            previousVersionAdjustment += sizeof(binaryUniform->imageSamplerIndex);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
        {
            /* type qualifier which is not in the version */
            previousVersionAdjustment += sizeof(binaryUniform->qualifier) +
                                         sizeof(binaryUniform->vectorSize)+
                                         sizeof(binaryUniform->typeNameOffset);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_OCL_UNIFORM_BLOCK_VERSION)
        {
            /* variable category varCategory,
               struct element indices,
               uniform block index,
               array stride and
               offset to uniform block base address not in the version */
            previousVersionAdjustment += sizeof(binaryUniform->varCategory)+
                                         sizeof(binaryUniform->firstChild)+
                                         sizeof(binaryUniform->nextSibling)+
                                         sizeof(binaryUniform->prevSibling)+
                                         sizeof(binaryUniform->parent)+
                                         sizeof(binaryUniform->blockIndex)+
                                         sizeof(binaryUniform->arrayStride)+
                                         sizeof(binaryUniform->offset);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_DUMMY_UNIFORM_INDEX_VERSION)
        {
            previousVersionAdjustment += sizeof(binaryUniform->dummyUniformIndex);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_UNIFORM_PHYSICAL_ADDR)
        {
            previousVersionAdjustment += sizeof(binaryUniform->physical);
            previousVersionAdjustment += sizeof(binaryUniform->samplerPhysical);
            previousVersionAdjustment += sizeof(binaryUniform->address);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_UNIFORM_RES_OP_FLAG)
        {
            previousVersionAdjustment += sizeof(binaryUniform->resOpFlag);
        }

        /* Allocate the array of gcUNIFORM structure pointers. */
        status = gcoOS_Allocate(gcvNULL,
                               Shader->uniformCount * sizeof(gcUNIFORM),
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->uniformArraySize =
            Shader->uniformCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
            gcmFOOTER();
            return status;
        }

        Shader->uniforms = pointer;

        /* Parse all uniforms. */
        for (i = 0; i < Shader->uniformCount; i++)
        {
            /* Get the length of the uniform name. */
            length = (bytes < sizeof(struct _gcBINARY_UNIFORM_EX))
                         ? 0
                         : binaryUniform->nameLength + binaryUniform->arrayLengthCount * gcmSIZEOF(gctINT);

            /* Compute the number of bytes required for current version of the struct. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_UNIFORM_EX, memory) + length,
                                  2);

            if (bytes < (binarySize - previousVersionAdjustment) )
            {
                /* Roll back. */
                Shader->uniformCount = i;

                /* Invalid uniform. */
                gcmFATAL("gcSHADER_LoadEx: Invalid uniform");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            allocBytes = gcmOFFSETOF(_gcUNIFORM, name) + binaryUniform->nameLength + 1;
            /* Allocate memory for the uniform inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                    allocBytes,
                                    &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->uniformCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_ZeroMemory(pointer, allocBytes);
            uniform = pointer;

            /* Copy uniform to the gcSHADER object. */
            Shader->uniforms[i]         = uniform;
            uniform->object.type        = gcvOBJ_UNIFORM;
            uniform->index              = binaryUniform->index;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_OPENCL_IMAGE_SAMPLER_BY_TEXLD_FILE_VERSION)
            {
                uniform->imageSamplerIndex = 0;
            }
            else
            {
                uniform->imageSamplerIndex = binaryUniform->imageSamplerIndex;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_OCL_UNIFORM_BLOCK_VERSION)
            {
                SetUniformCategory(uniform, gcSHADER_VAR_CATEGORY_NORMAL);
                uniform->firstChild = -1;
                uniform->nextSibling = -1;
                uniform->prevSibling = -1;
                uniform->parent = -1;
                uniform->u.type = (gcSHADER_TYPE) binaryUniform->u.type;

                uniform->blockIndex = -1;
                uniform->arrayStride = -1;
                uniform->offset = -1;
            }
            else
            {
                SetUniformCategory(uniform, (gcSHADER_VAR_CATEGORY)binaryUniform->varCategory);
                uniform->firstChild = binaryUniform->firstChild;
                uniform->nextSibling = binaryUniform->nextSibling;
                uniform->prevSibling = binaryUniform->prevSibling;
                uniform->parent = binaryUniform->parent;
                if (binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_NORMAL ||
                    binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_BLOCK_ADDRESS ||
                    binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_BLOCK_MEMBER)
                    uniform->u.type = (gcSHADER_TYPE) binaryUniform->u.type;
                else
                    uniform->u.numStructureElement = binaryUniform->u.numStructureElement;

                uniform->blockIndex = binaryUniform->blockIndex;
                gcoOS_MemCopy((gctPOINTER)&uniform->arrayStride,
                              binaryUniform->arrayStride,
                              sizeof(gctINT32));
                gcoOS_MemCopy((gctPOINTER)&uniform->offset,
                              binaryUniform->offset,
                              sizeof(gctINT32));
            }

            uniform->modelViewProjection = 0;

            gcoOS_MemCopy((gctPOINTER)&uniform->_flags,
                          binaryUniform->flags,
                          sizeof(gceUNIFORM_FLAGS));
            uniform->format       = binaryUniform->format;
            uniform->isPointer    = binaryUniform->isPointer;
            uniform->arraySize    = binaryUniform->arraySize;
            uniform->precision    = binaryUniform->precision;
            uniform->arrayLengthCount = (gctINT)binaryUniform->arrayLengthCount;

            /*halti extras */
            uniform->matrixStride = -1;
            uniform->isRowMajor = gcvFALSE;

            /* Considering LoadEx/SaveEx only be called by OCL and imageFormat will be used in dumper but not used in CL, so just set it to the default value. */
            uniform->imageFormat = gcIMAGE_FORMAT_DEFAULT;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_HALTI_FILE_VERSION)
            {
                uniform->initializer.f32_v4[0] =
                    uniform->initializer.f32_v4[1] =
                    uniform->initializer.f32_v4[2] =
                    uniform->initializer.f32_v4[3] = 0.0;
            }
            else
            {
                gcoOS_MemCopy((gctPOINTER)uniform->initializer.f32_v16,
                              binaryUniform->initializer,
                              sizeof(gcsValue));
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
            {
                uniform->qualifier = gcvTYPE_QUALIFIER_NONE;
                SetUniformVectorSize(uniform, 0);
                SetUniformTypeNameOffset(uniform, -1);
            }
            else
            {
                uniform->qualifier = binaryUniform->qualifier;
                SetUniformVectorSize(uniform, binaryUniform->vectorSize);
                gcoOS_MemCopy(&uniform->typeNameOffset,
                              &binaryUniform->typeNameOffset,
                              sizeof(binaryUniform->typeNameOffset));
            }

            uniform->nameLength   = binaryUniform->nameLength;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_LTC_FILE_VERSION)
            {
                uniform->glUniformIndex   = (gctINT16) -1;
            }
            else
            {
                uniform->glUniformIndex   = binaryUniform->glUniformIndex;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_DUMMY_UNIFORM_INDEX_VERSION)
            {
                uniform->dummyUniformIndex = -1;
            }
            else
            {
                uniform->dummyUniformIndex = binaryUniform->dummyUniformIndex;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_UNIFORM_RES_OP_FLAG)
            {
                uniform->resOpFlag = gcUNIFORM_RES_OP_FLAG_NONE;
            }
            else
            {
                gcoOS_MemCopy((gctPOINTER)&uniform->resOpFlag,
                              binaryUniform->resOpFlag,
                              sizeof(gctINT32));
            }

            /* Copy name. */
            uniform->name[uniform->nameLength] = '\0';

            if (binaryUniform->nameLength > 0)
            {
                gcoOS_MemCopy(uniform->name,
                              binaryUniform->memory - previousVersionAdjustment
                              + binaryUniform->arrayLengthCount * gcmSIZEOF(gctINT),
                              binaryUniform->nameLength);
            }

            if (uniform->arrayLengthCount > 0)
            {
                status = gcoOS_Allocate(gcvNULL,
                                        uniform->arrayLengthCount * gcmSIZEOF(gctINT),
                                        &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->uniformCount = i;

                    /* Error. */
                    gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                gcoOS_ZeroMemory(pointer, uniform->arrayLengthCount * gcmSIZEOF(gctINT));
                uniform->arrayLengthList = pointer;

                gcoOS_MemCopy(uniform->arrayLengthList,
                              binaryUniform->memory - previousVersionAdjustment,
                              uniform->arrayLengthCount * gcmSIZEOF(gctINT));
            }
            else
            {
                uniform->arrayLengthList = gcvNULL;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_UNIFORM_PHYSICAL_ADDR)
            {
                uniform->physical     = -1;
                uniform->samplerPhysical    = -1;
                uniform->address      = ~0U;
                if (isUniformNormal(uniform) && gcmType_Kind(uniform->u.type) == gceTK_SAMPLER)
                {
                   uniform->physical = Shader->samplerIndex;
                   Shader->samplerIndex += uniform->arraySize > 1 ? uniform->arraySize : 1;
                }
            }
            else
            {
                gcoOS_MemCopy((gctPOINTER)&uniform->physical,
                              binaryUniform->physical,
                              sizeof(gctINT16));
                gcoOS_MemCopy((gctPOINTER)&uniform->samplerPhysical,
                              binaryUniform->samplerPhysical,
                              sizeof(gctINT16));
                gcoOS_MemCopy((gctPOINTER)&uniform->address,
                              binaryUniform->address,
                              sizeof(gctUINT32));
            }
            uniform->RAPriority         = 0;

            /* substract fields which are not in the file version */
            binarySize -= previousVersionAdjustment;

            /* Point to next uniform. */
            binaryUniform = (gcBINARY_UNIFORM_EX)
                            ((gctUINT8 *) binaryUniform + binarySize);
            bytes        -= binarySize;
        }

        /* adjust the uniform array map to match the original map */
        oldUniformCount = Shader->uniforms[Shader->uniformCount - 1]->index + 1;

        if ((oldUniformCount > Shader->uniformCount) && (Shader->uniforms[0]->index == 0))
        {
            /* Allocate the array of gcUNIFORM structure pointers. */
            status = gcoOS_Allocate(gcvNULL,
                                   oldUniformCount * sizeof(gcUNIFORM),
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->uniformArraySize =
                Shader->uniformCount = 0;

                /* Error. */
                gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                gcmFOOTER();
                return status;
            }

            gcoOS_MemFill(pointer, 0, oldUniformCount * sizeof(gcUNIFORM));

            for (i = 0; i < Shader->uniformCount; i++)
            {
                ((gcUNIFORM *)pointer)[Shader->uniforms[i]->index] = Shader->uniforms[i];
            }

            Shader->uniformArraySize = Shader->uniformCount = oldUniformCount;

            gcmOS_SAFE_FREE(gcvNULL, Shader->uniforms);

            Shader->uniforms = pointer;
        }

        /* check if there is any uniform block */
        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_OCL_UNIFORM_BLOCK_VERSION)
        {
            Shader->uniformBlockCount = 0;
        }
        else
        {
            gcsUNIFORM_BLOCK uniformBlock;
            gcBINARY_UNIFORM_BLOCK    binaryUniformBlock;

            count = (gctUINT16 *) binaryUniform;

            if (bytes < sizeof(gctUINT16))
            {
                /* Invalid uniform block count. */
                gcmFATAL("gcSHADER_Loadex: Invalid uniformBlockCount");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            /* Save the uniform count. */
            Shader->uniformBlockCount = *count;

            /* Point to the first uniform block. */
            binaryUniformBlock = (gcBINARY_UNIFORM_BLOCK) (count + 1);
            bytes        -= sizeof(gctUINT16);

            if (Shader->uniformBlockCount > 0)
            {
                previousVersionAdjustment = 0;

               /* Allocate the array of gcsUNIFORM_BLOCK structure pointers. */
               status = gcoOS_Allocate(gcvNULL,
                                       Shader->uniformBlockCount * sizeof(gcsUNIFORM_BLOCK),
                                       &pointer);

               if (gcmIS_ERROR(status))
               {
                   /* Roll back. */
                   Shader->uniformBlockCount = 0;

                   /* Error. */
                   gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                   gcmFOOTER();
                   return status;
               }

               Shader->uniformBlocks = pointer;

               /* Parse all uniform blocks. */
               for (i = 0; i < Shader->uniformBlockCount; i++)
               {
                   gctUINT32 allocBytes;

                   /* Get the length of the uniform block name. */

                   length = (bytes < sizeof(struct _gcBINARY_UNIFORM_BLOCK))
                                   ? 0
                                   : binaryUniformBlock->nameLength;

                   /* Test for special length. */
                   if ((gctINT) length < 0)
                   {
                       length = 0;
                   }

                   /* Compute the number of bytes required. */
                   binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_UNIFORM_BLOCK, name) + length, 2);

                   if (bytes < binarySize - previousVersionAdjustment)
                   {
                       /* Roll back. */
                       Shader->uniformBlockCount = i;

                       /* Invalid uniform block. */
                       gcmFATAL("gcSHADER_Load: Invalid uniform block");
                       gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                       return gcvSTATUS_INVALID_DATA;
                   }

                   allocBytes = gcmOFFSETOF(_gcsUNIFORM_BLOCK, name) + length + 1;
                   /* Allocate memory for the uniform block inside the gcSHADER object. */
                   status = gcoOS_Allocate(gcvNULL,
                                           allocBytes,
                                           &pointer);

                   if (gcmIS_ERROR(status))
                   {
                       /* Roll back. */
                       Shader->uniformBlockCount = i;

                       /* Error. */
                       gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                       gcmFOOTER();
                       return status;
                   }

                   gcoOS_ZeroMemory(pointer, allocBytes);
                   uniformBlock = pointer;

                   /* Copy uniform block to the gcSHADER object. */
                   Shader->uniformBlocks[i]  = uniformBlock;
                   GetUBObject(uniformBlock)->type = gcvOBJ_UNIFORM_BLOCK;
                   SetUBBlockIndex(uniformBlock, (gctINT16) i);
                   SetUBIndex(uniformBlock, binaryUniformBlock->index);
                   SetUBMemoryLayout(uniformBlock, (gceINTERFACE_BLOCK_LAYOUT_ID)binaryUniformBlock->memoryLayout);
                   SetUBBlockSize(uniformBlock, binaryUniformBlock->blockSize);

                   gcoOS_ZeroMemory(GetUBShaderVarInfo(uniformBlock),
                                    sizeof(struct _gcsSHADER_VAR_INFO));

                   SetUBCategory(uniformBlock, gcSHADER_VAR_CATEGORY_BLOCK);
                   SetUBFirstChild(uniformBlock, binaryUniformBlock->firstChild);
                   SetUBNextSibling(uniformBlock, binaryUniformBlock->nextSibling);
                   SetUBPrevSibling(uniformBlock, binaryUniformBlock->prevSibling);
                   SetUBIsArray(uniformBlock, gcvFALSE);
                   SetUBArraySize(uniformBlock, 1);
                   SetUBNumBlockElement(uniformBlock, binaryUniformBlock->numBlockElement);

                   SetUBNameLength(uniformBlock, length);

                   gcoOS_MemCopy((gctPOINTER)&GetUBBinding(uniformBlock),
                                 binaryUniformBlock->binding,
                                 sizeof(gctINT32));

                   /* Copy name. */
                   GetUBName(uniformBlock)[length] = '\0';

                   if (length > 0)
                   {
                       gcoOS_MemCopy(GetUBName(uniformBlock),
                                     binaryUniformBlock->name - previousVersionAdjustment,
                                     length);
                   }

                   binarySize -= previousVersionAdjustment;

                   /* Point to next uniform block. */
                   binaryUniformBlock = (gcBINARY_UNIFORM_BLOCK)
                                        ((gctUINT8 *) binaryUniformBlock + binarySize);
                   bytes -= binarySize;
                }
            }
            binaryUniform = (gcBINARY_UNIFORM_EX) binaryUniformBlock;
        }
    }

    /************************************************************************/
    /*                                  outputs                             */
    /************************************************************************/

    /* Get the output count. */
    count = (gctUINT16 *) binaryUniform;

    if ((bytes < sizeof(gctUINT16)) ||
         ((*count <= 0) && (Shader->type != gcSHADER_TYPE_CL)))
    {
        /* Invalid output count. */
        gcmFATAL("gcSHADER_LoadEx: Invalid outputCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Point to the first output. */
    binaryOutput = (gcBINARY_OUTPUT) (count + 1);
    bytes       -= sizeof(gctUINT16);

    /* Save the output count. */
    Shader->outputArraySize =
    Shader->outputCount = *count;

    if (*count > 0) {

        gctINT previousVersionAdjustment = 0;

        /* Allocate the array of gcOUTPUT structure pointers. */
        status = gcoOS_Allocate(gcvNULL,
                               Shader->outputCount * sizeof(gcOUTPUT),
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->outputArraySize =
            Shader->outputCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
            gcmFOOTER();
            return status;
        }

        Shader->outputs = pointer;

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
        {
            /* precision field which is not in the version */
            previousVersionAdjustment += sizeof(binaryOutput->precision);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
        {
            /* precision field which is not in the version */
            previousVersionAdjustment += sizeof(binaryOutput->layoutQualifier);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_TYPE_NAME_VAR_INDEX)
        {
            /* precision field which is not in the version */
            previousVersionAdjustment += sizeof(binaryOutput->typeNameVarIndex);
        }

        /* Parse all outputs. */
        for (i = 0; i < Shader->outputCount; i++)
        {
            /* Get the length of the output name. */
            length = (bytes < sizeof(struct _gcBINARY_OUTPUT))
                         ? 0
                         : binaryOutput->nameLength;

            /* Test for special length. */
            if ((gctINT) length < 0)
            {
                length = 0;
            }

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_OUTPUT, name) + length, 2);

            if (bytes < binarySize - previousVersionAdjustment)
            {
                /* Roll back. */
                Shader->outputCount = i;

                /* Invalid output. */
                gcmFATAL("gcSHADER_LoadEx: Invalid output");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            /* Allocate memory for the output inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                   gcmOFFSETOF(_gcOUTPUT, name) + length + 1,
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->outputCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                gcmFOOTER();
                return status;
            }

            output = pointer;

            gcoOS_ZeroMemory(output, gcmOFFSETOF(_gcOUTPUT, name) + length + 1);

            /* Copy output to shader. */
            Shader->outputs[i]   = output;
            output->object.type  = gcvOBJ_OUTPUT;
            output->index        = binaryOutput->index;
            output->type         = (gcSHADER_TYPE) binaryOutput->type;
            output->origType     = (gcSHADER_TYPE) binaryOutput->origType;
            output->arraySize    = binaryOutput->arraySize;
            gcoOS_MemCopy((gctPOINTER)&output->tempIndex, (gctPOINTER)&binaryOutput->tempIndex, sizeof(gctINT32));
            output->flags_       = (gctUINT32)(binaryOutput->flags1 | (binaryOutput->flags2 << 16));
            output->location     = -1;
            output->nextSibling  = binaryOutput->nextSibling;
            output->prevSibling  = binaryOutput->prevSibling;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_SAVEING_TYPE_NAME_VAR_INDEX)
            {
                output->typeNameVarIndex = -1;
            }
            else
            {
                output->typeNameVarIndex = binaryOutput->typeNameVarIndex;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
            {
                output->precision = gcSHADER_PRECISION_DEFAULT;
            }
            else
            {
                output->precision = (gcSHADER_PRECISION)binaryOutput->precision;
            }
            output->nameLength   = binaryOutput->nameLength;
            output->name[length] = '\0';

            if (length > 0)
            {
                gcoOS_MemCopy(output->name, binaryOutput->name, length);
            }

            /* derive arrayIndex from previous output */
            if (prevOutput && prevOutput->nameLength == output->nameLength &&
                 (((gctINT) output->nameLength < 0)   /* built-in name */
                 || gcmIS_SUCCESS(gcoOS_MemCmp(output->name,
                                               prevOutput->name,
                                               output->nameLength))) )
            {
                output->arrayIndex   = prevOutput->arrayIndex + 1;
            }
            else
            {
                output->arrayIndex   = 0;
            }
            prevOutput = output;

             /* substract fields which are not in the file version */
            binarySize -= previousVersionAdjustment;

            /* Point to next output. */
            binaryOutput = (gcBINARY_OUTPUT)
                           ((gctUINT8 *) binaryOutput + binarySize);
            bytes       -= binarySize;
        }
    }

    /************************************************************************/
    /*                          global variables                            */
    /************************************************************************/

    /* Get the variable count. */
    count = (gctUINT16 *) binaryOutput;

    if ((bytes < sizeof(gctUINT16)) ||
         ((*count <= 0) && (Shader->type != gcSHADER_TYPE_CL)))
    {
        /* Invalid variable count. */
        gcmFATAL("gcSHADER_LoadEx: Invalid variableCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Point to the first variable. */
    binaryVariable = (gcBINARY_VARIABLE_EX) (count + 1);
    bytes       -= sizeof(gctUINT16);

    /* Save the variable count. */
    Shader->variableArraySize =
    Shader->variableCount = *count;

    if (*count > 0) {

        gctINT   previousVersionAdjustment = 0;
        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_VARIABLE_TYPE_QUALIFIER_FILE_VERSION)
        {
            /*add type qualifier adjustment */
            previousVersionAdjustment = sizeof(binaryVariable->qualifier);
            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION) {
                /* fields which are not in the version */
                previousVersionAdjustment += sizeof(binaryVariable->varCategory) +
                                             sizeof(binaryVariable->firstChild) +
                                             sizeof(binaryVariable->nextSibling) +
                                             sizeof(binaryVariable->prevSibling) +
                                             sizeof(binaryVariable->parent);
            }
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
        {
            /* flags field which is not in the version */
            previousVersionAdjustment += sizeof(binaryVariable->flags);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
        {
            /* fields which are not in the version */
            previousVersionAdjustment += sizeof(binaryVariable->blockIndex);
        }

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
        {
            /* arrayStride and offset fields which are not in the version */
            previousVersionAdjustment += sizeof(binaryVariable->arrayStride) +
                                         sizeof(binaryVariable->offset);
        }

        /* Allocate the array of gcVARIABLE structure pointers. */
        status = gcoOS_Allocate(gcvNULL,
                               Shader->variableCount * sizeof(gcVARIABLE),
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->variableArraySize =
            Shader->variableCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
            gcmFOOTER();
            return status;
        }

        Shader->variables = pointer;

        /* Parse all variables. */
        for (i = 0; i < Shader->variableCount; i++)
        {
            /* Get the length of the variable name. */
            length = (bytes < sizeof(struct _gcBINARY_VARIABLE_EX))
                         ? 0
                         : binaryVariable->nameLength + binaryVariable->arrayLengthCount * gcmSIZEOF(gctINT);

            /* Test for special length. */
            if ((gctINT) length < 0)
            {
                length = 0;
            }

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_VARIABLE_EX, memory) + length, 2);

            if (bytes < binarySize - previousVersionAdjustment)
            {
                /* Roll back. */
                Shader->variableCount = i;

                /* Invalid variable. */
                gcmFATAL("gcSHADER_LoadEx: Invalid variable");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            /* Allocate memory for the variable inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                    gcmOFFSETOF(_gcVARIABLE, name) + length + 1,
                                    &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->variableCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                gcmFOOTER();
                return status;
            }

            variable = pointer;

            /* Copy variable to shader. */
            Shader->variables[i]   = variable;
            variable->index = (gctUINT16)i;
            variable->object.type  = gcvOBJ_VARIABLE;

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION)
            {
                SetVariableCategory(variable, gcSHADER_VAR_CATEGORY_NORMAL);
                variable->firstChild = -1;
                variable->nextSibling = -1;
                variable->prevSibling = -1;
                variable->parent = -1;
                variable->u.type = (gcSHADER_TYPE) binaryVariable->u.type;
                variable->qualifier = gcvTYPE_QUALIFIER_NONE;
            }
            else
            {
                SetVariableCategory(variable, binaryVariable->varCategory);
                variable->firstChild = binaryVariable->firstChild;
                variable->nextSibling = binaryVariable->nextSibling;
                variable->prevSibling = binaryVariable->prevSibling;
                variable->parent = binaryVariable->parent;

                if (isVariableSimple(variable))
                {
                    variable->u.type = (gcSHADER_TYPE) binaryVariable->u.type;
                }
                else
                {
                    variable->u.numStructureElement = binaryVariable->u.numStructureElement;
                }

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_VARIABLE_TYPE_QUALIFIER_FILE_VERSION)
                {
                    variable->qualifier = gcvTYPE_QUALIFIER_NONE;
                }
                else
                {
                    variable->qualifier = binaryVariable->qualifier;
                }
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
            {
                variable->precision = gcSHADER_PRECISION_DEFAULT;
            }
            else
            {
                variable->precision = binaryVariable->precision ;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_ES31_VERSION)
            {
                variable->blockIndex = gcvBLOCK_INDEX_DEFAULT;
            }
            else
            {
                variable->blockIndex = binaryVariable->blockIndex;
            }

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
            {
                variable->arrayStride = -1;
                variable->offset = -1;
            }
            else
            {
                gcoOS_MemCopy(&variable->arrayStride,
                              &binaryVariable->arrayStride,
                              sizeof(binaryVariable->arrayStride));

                gcoOS_MemCopy(&variable->offset,
                              &binaryVariable->offset,
                              sizeof(binaryVariable->offset));
            }

            variable->flags        = binaryVariable->flags;
            variable->arraySize    = binaryVariable->arraySize;
            variable->arrayLengthCount = binaryVariable->arrayLengthCount;
            gcoOS_MemCopy((gctPOINTER)&variable->tempIndex, (gctPOINTER)&binaryVariable->tempIndex, sizeof(variable->tempIndex));
            variable->nameLength   = binaryVariable->nameLength;
            variable->name[length] = '\0';

            if (length > 0)
            {
                gcoOS_MemCopy(variable->name, binaryVariable->memory - previousVersionAdjustment
                              + binaryVariable->arrayLengthCount * gcmSIZEOF(gctINT), length);
            }

            if (variable->arrayLengthCount > 0)
            {
                gctINT arraySize = 1;
                gctINT k;

                status = gcoOS_Allocate(gcvNULL,
                                       variable->arrayLengthCount * gcmSIZEOF(gctINT),
                                       &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->variableCount = i;

                    /* Error. */
                    gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                gcoOS_ZeroMemory(pointer, variable->arrayLengthCount * gcmSIZEOF(gctINT));
                variable->arrayLengthList = pointer;

                gcoOS_MemCopy(variable->arrayLengthList,
                              binaryVariable->memory - previousVersionAdjustment,
                              variable->arrayLengthCount * gcmSIZEOF(gctINT));

                /* Recalculate the array size as arraySize field of gcBINARY_VARIABLE_EX
                   might be of insufficient size (gctINT8) */
                for (k = 0; k < variable->arrayLengthCount; k++)
                {
                    gcmASSERT(variable->arrayLengthList[k] > 0);
                    arraySize *= variable->arrayLengthList[k];
                }

                SetVariableArraySize(variable, arraySize);
            }
            else
            {
                variable->arrayLengthList = gcvNULL;
            }

            /* substract fields which are not in the file version */
            binarySize -= previousVersionAdjustment;

            /* Point to next variable. */
            binaryVariable = (gcBINARY_VARIABLE_EX)
                           ((gctUINT8 *) binaryVariable + binarySize);
            bytes       -= binarySize;
        }
    }

    /************************************************************************/
    /*                              functions                               */
    /************************************************************************/

    /* Get the function count. */
    count = (gctUINT16 *) binaryVariable;

    if ((bytes < sizeof(gctUINT16)) ||
         ((*count <= 0) && (Shader->type != gcSHADER_TYPE_CL)))
    {
        /* Invalid function count. */
        gcmFATAL("gcSHADER_LoadEx: Invalid functionCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Point to the first function. */
    binaryFunction = (gcBINARY_FUNCTION) (count + 1);
    bytes       -= sizeof(gctUINT16);

    /* Save the function count. */
    Shader->functionArraySize =
    Shader->functionCount = *count;

    if (*count > 0) {
        gctINT   previousVersionAdjustment = 0;

        /* Allocate the array of gcFUNCTION structure pointers. */
        status = gcoOS_Allocate(gcvNULL,
                               Shader->functionCount * sizeof(gcFUNCTION),
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->functionArraySize =
            Shader->functionCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
            gcmFOOTER();
            return status;
        }

        Shader->functions = pointer;

        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
        {
            /* precision field which is not in the version */
            previousVersionAdjustment += sizeof(binaryFunction->flags) +
                                         sizeof(binaryFunction->intrinsicsKind);

        }

        /* Parse all functions. */
        for (i = 0; i < Shader->functionCount; i++)
        {
            /* Get the length of the function name. */
            length = (bytes < sizeof(struct _gcBINARY_FUNCTION))
                         ? 0
                         : binaryFunction->nameLength;

            /* Test for special length. */
            if ((gctINT) length < 0)
            {
                length = 0;
            }

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_FUNCTION, name) + length, 2);

            if (bytes < binarySize - previousVersionAdjustment)
            {
                /* Roll back. */
                Shader->functionCount = i;

                /* Invalid function. */
                gcmFATAL("gcSHADER_LoadEx: Invalid function");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            /* Allocate memory for the function inside the gcSHADER object. */
            allocBytes = gcmOFFSETOF(_gcsFUNCTION, name) + length + 1;
            status = gcoOS_Allocate(gcvNULL,
                                    allocBytes,
                                    &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->functionCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                gcmFOOTER();
                return status;
            }

            gcoOS_ZeroMemory(pointer, allocBytes);
            function = pointer;

            /* Copy function to shader. */
            Shader->functions[i]   = function;
            function->object.type  = gcvOBJ_FUNCTION;

            function->argumentArrayCount =
            function->argumentCount = binaryFunction->argumentCount;
            function->packedAwayArgNo = binaryFunction->packedAwayArgNo;
            function->arguments     = gcvNULL;
            function->localVariableCount = binaryFunction->localVariableCount;
            function->localVariables     = gcvNULL;
            function->tempIndexStart     = binaryFunction->tempIndexStart;
            function->tempIndexEnd       = binaryFunction->tempIndexEnd;
            function->tempIndexCount     = binaryFunction->tempIndexCount;
            function->codeStart     = binaryFunction->codeStart;
            function->codeCount     = binaryFunction->codeCount;
            function->label         = (gctUINT32)binaryFunction->label;
            function->die           = binaryFunction->die;
            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
            {
                function->flags = gcvFUNC_NOATTR;
                function->intrinsicsKind = gceINTRIN_NONE;
            }
            else
            {
                gcoOS_MemCopy(&function->flags, &binaryFunction->flags, sizeof(gctUINT32));
                gcoOS_MemCopy(&function->intrinsicsKind, &binaryFunction->intrinsicsKind, sizeof(gctUINT32));
            }

            function->isRecursion   = gcvFALSE;
            function->nameLength    = binaryFunction->nameLength;
            function->name[length]  = '\0';

            if (length > 0)
            {
                gcoOS_MemCopy(function->name,
                              binaryFunction->name - previousVersionAdjustment,
                              length);
            }

            /* substract fields which are not in the file version */
            binarySize -= previousVersionAdjustment;

            /* Point to first argument. */
            binaryArgument = (gcBINARY_ARGUMENT)
                           ((gctUINT8 *) binaryFunction + binarySize);
            bytes         -= binarySize;

            /* Function arguments */
            if (function->argumentCount > 0) {

                binarySize = function->argumentCount * sizeof(gcsFUNCTION_ARGUMENT);

                if (bytes < binarySize)
                {
                    /* Roll back. */
                    Shader->functionCount = i;
                    function->argumentArrayCount =
                    function->argumentCount = 0;

                    /* Invalid argument. */
                    gcmFATAL("gcSHADER_LoadEx: Invalid argument");
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                    return gcvSTATUS_INVALID_DATA;
                }

                /* Allocate the array of gcsFUNCTION_ARGUMENT structures. */
                status = gcoOS_Allocate(gcvNULL, binarySize, &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->functionCount = i;
                    function->argumentArrayCount =
                    function->argumentCount = 0;

                    /* Error. */
                    gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                function->arguments = pointer;

                for (j=0; j<function->argumentCount; j++) {
                    argument = &function->arguments[j];

                    gcoOS_MemCopy((gctPOINTER)&argument->index, (gctPOINTER)&binaryArgument->index, sizeof(argument->index));
                    argument->enable    = binaryArgument->enable;
                    argument->qualifier = binaryArgument->qualifier;
                    argument->precision = binaryArgument->precision;
                    argument->variableIndex = binaryArgument->variableIndex;
                    argument->flags     = binaryArgument->flags;

                    /* Point to next argument. */
                    binaryArgument++;
                    bytes -= sizeof(gcsFUNCTION_ARGUMENT);
                }
            }

            /* Point to first variable. */
            binaryVariable = (gcBINARY_VARIABLE_EX) binaryArgument;

            /* Function variables */
            if (function->localVariableCount > 0) {

                gctINT   previousVersionAdjustment = 0;

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_VARIABLE_TYPE_QUALIFIER_FILE_VERSION)
                {
                    /*add type qualifier adjustment */
                    previousVersionAdjustment = sizeof(binaryVariable->qualifier);
                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION) {
                        /* fields which are not in the version */
                        previousVersionAdjustment += sizeof(binaryVariable->varCategory) +
                                                     sizeof(binaryVariable->firstChild) +
                                                     sizeof(binaryVariable->nextSibling) +
                                                     sizeof(binaryVariable->prevSibling) +
                                                     sizeof(binaryVariable->parent);
                    }
                }

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
                {
                    /* arrayStride and offset fields which are not in the version */
                    previousVersionAdjustment += sizeof(binaryVariable->arrayStride) +
                                                 sizeof(binaryVariable->offset);
                }

                /* Allocate the array of gcVARIABLE structure pointers. */
                status = gcoOS_Allocate(gcvNULL,
                                       function->localVariableCount * sizeof(gcVARIABLE),
                                       &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->functionCount = i;
                    function->localVariableCount = 0;

                    /* Error. */
                    gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                function->localVariables = pointer;

                /* Parse all variables. */
                for (j = 0; j < function->localVariableCount; j++)
                {
                    /* Get the length of the variable name. */
                    length = (bytes < sizeof(struct _gcBINARY_VARIABLE_EX))
                                 ? 0
                                 : binaryVariable->nameLength + binaryVariable->arrayLengthCount * gcmSIZEOF(gctINT);

                    /* Test for special length. */
                    if ((gctINT) length < 0)
                    {
                        length = 0;
                    }

                    /* Compute the number of bytes required. */
                    binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_VARIABLE_EX, memory) + length, 2);

                    if (bytes < binarySize - previousVersionAdjustment)
                    {
                        /* Roll back. */
                        Shader->functionCount = i;
                        function->localVariableCount = j;

                        /* Invalid variable. */
                        gcmFATAL("gcSHADER_LoadEx: Invalid variable");
                        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                        return gcvSTATUS_INVALID_DATA;
                    }

                    /* Allocate memory for the variable inside the gcSHADER object. */
                    status = gcoOS_Allocate(gcvNULL,
                                           gcmOFFSETOF(_gcVARIABLE, name) + length + 1,
                                           &pointer);

                    if (gcmIS_ERROR(status))
                    {
                        /* Roll back. */
                        Shader->functionCount = i;
                        function->localVariableCount = j;

                        /* Error. */
                        gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                        gcmFOOTER();
                        return status;
                    }

                    variable = pointer;

                    /* Copy variable to shader. */
                    function->localVariables[j]   = variable;
                    variable->object.type  = gcvOBJ_VARIABLE;

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION)
                    {
                        SetVariableCategory(variable, gcSHADER_VAR_CATEGORY_NORMAL);
                        variable->firstChild = -1;
                        variable->nextSibling = -1;
                        variable->prevSibling = -1;
                        variable->parent = -1;
                        variable->u.type = (gcSHADER_TYPE) binaryVariable->u.type;
                        variable->qualifier = gcvTYPE_QUALIFIER_NONE;
                    }
                    else
                    {
                        SetVariableCategory(variable, (gcSHADER_VAR_CATEGORY)binaryVariable->varCategory);
                        variable->firstChild = binaryVariable->firstChild;
                        variable->nextSibling = binaryVariable->nextSibling;
                        variable->prevSibling = binaryVariable->prevSibling;
                        variable->parent = binaryVariable->parent;

                        if (binaryVariable->varCategory == gcSHADER_VAR_CATEGORY_NORMAL ||
                            binaryVariable->varCategory == gcSHADER_VAR_CATEGORY_BLOCK_MEMBER)
                            variable->u.type = (gcSHADER_TYPE) binaryVariable->u.type;
                        else
                            variable->u.numStructureElement = binaryVariable->u.numStructureElement;
                        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_VARIABLE_TYPE_QUALIFIER_FILE_VERSION)
                            variable->qualifier = gcvTYPE_QUALIFIER_NONE;
                        else
                        {
                            variable->qualifier = binaryVariable->qualifier;
                        }
                    }

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
                    {
                        variable->precision = gcSHADER_PRECISION_DEFAULT;
                    }
                    else
                    {
                        variable->precision = binaryVariable->precision ;
                    }

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
                    {
                        variable->blockIndex = gcvBLOCK_INDEX_DEFAULT;
                        variable->arrayStride = -1;
                        variable->offset = -1;
                    }
                    else
                    {
                        variable->blockIndex = binaryVariable->blockIndex;
                        gcoOS_MemCopy(&variable->arrayStride,
                                      &binaryVariable->arrayStride,
                                      sizeof(binaryVariable->arrayStride));

                        gcoOS_MemCopy(&variable->offset,
                                      &binaryVariable->offset,
                                      sizeof(binaryVariable->offset));
                    }

                    variable->flags        = binaryVariable->flags;
                    variable->arraySize    = binaryVariable->arraySize;
                    gcoOS_MemCopy((gctPOINTER)&variable->tempIndex, (gctPOINTER)&binaryVariable->tempIndex, sizeof(variable->tempIndex));
                    variable->nameLength   = binaryVariable->nameLength;
                    variable->name[length] = '\0';


                    if (length > 0)
                    {
                        gcoOS_MemCopy(variable->name, binaryVariable->memory - previousVersionAdjustment
                                      + binaryVariable->arrayLengthCount * gcmSIZEOF(gctINT), length);
                    }

                    if (variable->arrayLengthCount > 0)
                    {
                        gctINT arraySize = 1;
                        gctINT k;

                        status = gcoOS_Allocate(gcvNULL,
                                               variable->arrayLengthCount * gcmSIZEOF(gctINT),
                                               &pointer);

                        if (gcmIS_ERROR(status))
                        {
                            /* Roll back. */
                            Shader->variableCount = i;

                            /* Error. */
                            gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                            gcmFOOTER();
                            return status;
                        }

                        gcoOS_ZeroMemory(pointer, variable->arrayLengthCount * gcmSIZEOF(gctINT));
                        variable->arrayLengthList = pointer;

                        gcoOS_MemCopy(variable->arrayLengthList,
                                      binaryVariable->memory - previousVersionAdjustment,
                                      variable->arrayLengthCount * gcmSIZEOF(gctINT));

                        /* Recalculate the array size as arraySize field of gcBINARY_VARIABLE_EX
                           might be of insufficient size (gctINT8) */
                        for (k = 0; k < variable->arrayLengthCount; k++)
                        {
                            gcmASSERT(variable->arrayLengthList[k] > 0);
                            arraySize *= variable->arrayLengthList[k];
                        }

                        SetVariableArraySize(variable, arraySize);
                    }
                    else
                    {
                        variable->arrayLengthList = gcvNULL;
                    }

                    /* substract fields which are not in the file version */
                    binarySize -= previousVersionAdjustment;

                    /* Point to next variable. */
                    binaryVariable = (gcBINARY_VARIABLE_EX)
                                   ((gctUINT8 *) binaryVariable + binarySize);
                    bytes       -= binarySize;
                }
            }

            /* Point to next function. */
            binaryFunction = (gcBINARY_FUNCTION) binaryVariable;
        }
    }

    /************************************************************************/
    /*                          kernel functions                            */
    /************************************************************************/

    /* Get the max kernel function args. */
    maxKernelFunctionArgs = (gctUINT16 *) binaryFunction;

    if ((bytes < sizeof(gctUINT16)) ||
         ((*maxKernelFunctionArgs > 0) && (Shader->type != gcSHADER_TYPE_CL)))
    {
        /* Invalid  max kernel function args */
        gcmFATAL("gcSHADER_LoadEx: Invalid max kernel function args");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* do sanity check on uniform block index */
    for(i = 0; i < Shader->uniformBlockCount; i++)
    {
        gctINT index;

        if (Shader->uniformBlocks[i] == gcvNULL) continue;

        index = GetUBIndex(Shader->uniformBlocks[i]);
        if(index != -1 &&
           (index - *maxKernelFunctionArgs) >= (gctINT16) Shader->uniformCount) {

             /* Roll back. */
             Shader->uniformBlockCount = i;

             /* Invalid uniform block. */
             gcmFATAL("gcSHADER_Load: Invalid uniform block base address index %d", index);
             gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
             return gcvSTATUS_INVALID_DATA;
        }
    }

    /* Save the max kernel function args. */
    Shader->maxKernelFunctionArgs = *maxKernelFunctionArgs;
    bytes       -= sizeof(gctUINT16);

    /* Get the kernel function count. */
    count = (gctUINT16 *) (maxKernelFunctionArgs + 1);

    if ((bytes < sizeof(gctUINT16)) ||
         ((*count > 0) && (Shader->type != gcSHADER_TYPE_CL)))
    {
        /* Invalid function count. */
        gcmFATAL("gcSHADER_LoadEx: Invalid functionCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Point to the first kernel function. */
    binaryKernelFunc = (gcBINARY_KERNEL_FUNCTION) (count + 1);
    bytes       -= sizeof(gctUINT16);

    /* Save the kernel function count. */
    Shader->kernelFunctionArraySize =
    Shader->kernelFunctionCount = *count;

    if (*count > 0) {
        gctINT   previousVersionAdjustment = 0;

        /* Allocate the array of gcKERNEL_FUNCTION structure pointers. */
        status = gcoOS_Allocate(gcvNULL,
                               Shader->kernelFunctionCount * sizeof(gcKERNEL_FUNCTION),
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->kernelFunctionArraySize =
            Shader->kernelFunctionCount = 0;

            /* Error. */
            gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
            gcmFOOTER();
            return status;
        }

        Shader->kernelFunctions = pointer;
        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
        {
            /* precision field which is not in the version */
            previousVersionAdjustment += sizeof(binaryFunction->flags);

        }

        /* Parse all kernel functions. */
        for (i = 0; i < Shader->kernelFunctionCount; i++)
        {
            /* Get the length of the kernel function name. */
            length = (bytes < sizeof(struct _gcBINARY_KERNEL_FUNCTION))
                         ? 0
                         : binaryKernelFunc->nameLength;

            /* Test for special length. */
            if ((gctINT) length < 0)
            {
                length = 0;
            }

            /* Compute the number of bytes required. */
            binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_KERNEL_FUNCTION, name) + length, 2);

            if (bytes < binarySize - previousVersionAdjustment)
            {
                /* Roll back. */
                Shader->kernelFunctionCount = i;

                /* Invalid function. */
                gcmFATAL("gcSHADER_LoadEx: Invalid kernel function");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            /* Allocate memory for the kernel function inside the gcSHADER object. */
            allocBytes = gcmOFFSETOF(_gcsKERNEL_FUNCTION, name) + length + 1;
            status = gcoOS_Allocate(gcvNULL,
                                    allocBytes,
                                    &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->kernelFunctionCount = i;

                /* Error. */
                gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                gcmFOOTER();
                return status;
            }

            gcoOS_ZeroMemory(pointer, allocBytes);
            kernelFunction = pointer;

            /* Copy kernel function to shader. */
            Shader->kernelFunctions[i]   = kernelFunction;
            kernelFunction->object.type  = gcvOBJ_KERNEL_FUNCTION;
            kernelFunction->shader       = Shader;

            kernelFunction->argumentArrayCount   =
            kernelFunction->argumentCount        = binaryKernelFunc->argumentCount;
            kernelFunction->arguments            = gcvNULL;
            kernelFunction->label                = (gctUINT32)binaryKernelFunc->label;
            gcoOS_MemCopy(&kernelFunction->localMemorySize, &binaryKernelFunc->localMemorySize, sizeof(gctUINT32));

            if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
            {
                kernelFunction->flags = gcvFUNC_NOATTR;
            }
            else
            {
                gcoOS_MemCopy(&kernelFunction->flags, &binaryKernelFunc->flags, sizeof(gctUINT32));
            }

            kernelFunction->uniformArgumentArrayCount =
            kernelFunction->uniformArgumentCount = binaryKernelFunc->uniformArgumentCount;
            kernelFunction->uniformArguments     = gcvNULL;
            kernelFunction->samplerIndex         = binaryKernelFunc->samplerIndex;
            kernelFunction->imageSamplerArrayCount =
            kernelFunction->imageSamplerCount    = binaryKernelFunc->imageSamplerCount;
            kernelFunction->imageSamplers        = gcvNULL;
            kernelFunction->localVariableCount   = binaryKernelFunc->localVariableCount;
            kernelFunction->localVariables       = gcvNULL;
            kernelFunction->tempIndexStart       = binaryKernelFunc->tempIndexStart;
            kernelFunction->tempIndexEnd         = binaryKernelFunc->tempIndexEnd;
            kernelFunction->tempIndexCount       = binaryKernelFunc->tempIndexCount;
            kernelFunction->propertyArrayCount   =
            kernelFunction->propertyCount        = binaryKernelFunc->propertyCount;
            kernelFunction->properties           = gcvNULL;
            kernelFunction->propertyValueArrayCount   =
            kernelFunction->propertyValueCount   = binaryKernelFunc->propertyValueCount;
            kernelFunction->propertyValues       = gcvNULL;
            kernelFunction->codeStart            = binaryKernelFunc->codeStart;
            kernelFunction->codeCount            = binaryKernelFunc->codeCount;
            kernelFunction->codeEnd              = binaryKernelFunc->codeEnd;
            kernelFunction->isMain               = binaryKernelFunc->isMain;
            kernelFunction->die                  = binaryKernelFunc->die;
            kernelFunction->nameLength           = binaryKernelFunc->nameLength;
            kernelFunction->name[length]         = '\0';

            if (length > 0)
            {
                gcoOS_MemCopy(kernelFunction->name,
                              binaryKernelFunc->name - previousVersionAdjustment,
                              length);
            }

            binarySize -= previousVersionAdjustment;

            /* Point to first argument. */
            binaryArgument = (gcBINARY_ARGUMENT)
                           ((gctUINT8 *) binaryKernelFunc + binarySize);
            bytes         -= binarySize;

            /* Kernel function arguments */
            if (kernelFunction->argumentCount > 0) {

                binarySize = kernelFunction->argumentCount * sizeof(gcsFUNCTION_ARGUMENT);

                if (bytes < binarySize)
                {
                    /* Roll back. */
                    Shader->kernelFunctionCount = i;
                    kernelFunction->argumentArrayCount =
                    kernelFunction->argumentCount = 0;

                    /* Invalid argument. */
                    gcmFATAL("gcSHADER_LoadEx: Invalid argument");
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                    return gcvSTATUS_INVALID_DATA;
                }

                /* Allocate the array of gcsFUNCTION_ARGUMENT structures. */
                status = gcoOS_Allocate(gcvNULL, binarySize, &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->kernelFunctionCount = i;
                    kernelFunction->argumentArrayCount =
                    kernelFunction->argumentCount = 0;

                    /* Error. */
                    gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                kernelFunction->arguments = pointer;

                for (j=0; j<kernelFunction->argumentCount; j++) {
                    argument = &kernelFunction->arguments[j];

                    gcoOS_MemCopy((gctPOINTER)&argument->index, (gctPOINTER)&binaryArgument->index, sizeof(argument->index));
                    argument->enable    = binaryArgument->enable;
                    argument->qualifier = binaryArgument->qualifier;
                    argument->precision = binaryArgument->precision;
                    argument->variableIndex = binaryArgument->variableIndex;
                    argument->flags     = binaryArgument->flags;

                    /* Point to next argument. */
                    binaryArgument++;
                    bytes -= sizeof(struct _gcBINARY_ARGUMENT);
                }
            }

            /* Point to first uniform. */
            binaryUniform = (gcBINARY_UNIFORM_EX) binaryArgument;

            /* Kernel function uniform arguments */
            if (kernelFunction->uniformArgumentCount > 0) {
                gctINT   previousVersionAdjustment = 0;

                /* Allocate the array of gcUNIFORM structure pointers. */
                status = gcoOS_Allocate(gcvNULL,
                                       kernelFunction->uniformArgumentCount * sizeof(gcUNIFORM),
                                       &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->kernelFunctionCount = i;
                    kernelFunction->uniformArgumentArrayCount =
                    kernelFunction->uniformArgumentCount = 0;

                    /* Error. */
                    gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                kernelFunction->uniformArguments = pointer;

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_LTC_FILE_VERSION)
                {
                    /* fields which are not in the version */
                    previousVersionAdjustment = sizeof(binaryUniform->glUniformIndex);
                }

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_OPENCL_IMAGE_SAMPLER_BY_TEXLD_FILE_VERSION)
                {
                    /* image sampler index field which is not in the version */
                    previousVersionAdjustment += sizeof(binaryUniform->imageSamplerIndex);
                }

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_HALTI_FILE_VERSION)
                {
                    /* initializer not in the version */
                    previousVersionAdjustment += sizeof(binaryUniform->initializer);
                }

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
                {
                    /* type qualifier which is not in the version */
                    previousVersionAdjustment += sizeof(binaryUniform->qualifier) +
                                                 sizeof(binaryUniform->vectorSize) +
                                                 sizeof(binaryUniform->typeNameOffset);
                }

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_OCL_UNIFORM_BLOCK_VERSION)
                {
                    /* variable category varCategory,
                       struct element indices,
                       uniform block index,
                       array stride and
                       offset to uniform block base address not in the version */
                    previousVersionAdjustment += sizeof(binaryUniform->varCategory)+
                                                 sizeof(binaryUniform->firstChild)+
                                                 sizeof(binaryUniform->nextSibling)+
                                                 sizeof(binaryUniform->prevSibling)+
                                                 sizeof(binaryUniform->parent)+
                                                 sizeof(binaryUniform->blockIndex)+
                                                 sizeof(binaryUniform->arrayStride)+
                                                 sizeof(binaryUniform->offset);
                }

                /* Parse all kernel uniform arguments. */
                for (j = 0; j < kernelFunction->uniformArgumentCount; j++)
                {
                    gctUINT uniformSize;

                    /* Get the length of the uniform argument name. */
                    length = (bytes < sizeof(struct _gcBINARY_UNIFORM_EX))
                                 ? 0
                                 : binaryUniform->nameLength + binaryUniform->arrayLengthCount * gcmSIZEOF(gctINT);

                    /* Test for special length. */
                    if ((gctINT) length < 0)
                    {
                        length = 0;
                    }

                    /* Compute the number of bytes required. */
                    binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_UNIFORM_EX, memory) + length, 2);

                    if (bytes < (binarySize - previousVersionAdjustment) )
                    {
                        /* Roll back. */
                        Shader->kernelFunctionCount = i;
                        kernelFunction->uniformArgumentCount = j;

                        /* Invalid variable. */
                        gcmFATAL("gcSHADER_LoadEx: Invalid uniform argument");
                        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                        return gcvSTATUS_INVALID_DATA;
                    }

                    /* Allocate memory for the uniform argument inside the gcSHADER object. */
                    uniformSize = gcmOFFSETOF(_gcUNIFORM, name) + length + 1;
                    status = gcoOS_Allocate(gcvNULL,
                                            uniformSize,
                                            &pointer);

                    if (gcmIS_ERROR(status))
                    {
                        /* Roll back. */
                        Shader->kernelFunctionCount = i;
                        kernelFunction->uniformArgumentCount = j;

                        /* Error. */
                        gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                        gcmFOOTER();
                        return status;
                    }

                    uniform = pointer;

                    /* Clear the memory in case some union member was partially written */
                    gcoOS_ZeroMemory(uniform, uniformSize);

                    /* Copy uniform argument to shader. */
                    kernelFunction->uniformArguments[j]   = uniform;
                    uniform->object.type  = gcvOBJ_UNIFORM;
                    uniform->index        = binaryUniform->index;

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_OCL_UNIFORM_BLOCK_VERSION)
                    {
                        SetUniformCategory(uniform, gcSHADER_VAR_CATEGORY_NORMAL);
                        uniform->firstChild = -1;
                        uniform->nextSibling = -1;
                        uniform->prevSibling = -1;
                        uniform->parent = -1;
                        uniform->u.type = (gcSHADER_TYPE) binaryUniform->u.type;

                        uniform->blockIndex = -1;
                        uniform->arrayStride = -1;
                        uniform->offset = -1;
                    }
                    else
                    {
                        SetUniformCategory(uniform, (gcSHADER_VAR_CATEGORY)binaryUniform->varCategory);
                        uniform->firstChild = binaryUniform->firstChild;
                        uniform->nextSibling = binaryUniform->nextSibling;
                        uniform->prevSibling = binaryUniform->prevSibling;
                        uniform->parent = binaryUniform->parent;
                        if (binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_NORMAL ||
                            binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_BLOCK_ADDRESS ||
                            binaryUniform->varCategory == gcSHADER_VAR_CATEGORY_BLOCK_MEMBER)
                            uniform->u.type = (gcSHADER_TYPE) binaryUniform->u.type;
                        else
                            uniform->u.numStructureElement = binaryUniform->u.numStructureElement;

                        uniform->blockIndex = binaryUniform->blockIndex;
                        gcoOS_MemCopy((gctPOINTER)&uniform->arrayStride,
                                      binaryUniform->arrayStride,
                                      sizeof(gctINT32));
                        gcoOS_MemCopy((gctPOINTER)&uniform->offset,
                                      binaryUniform->offset,
                                      sizeof(gctINT32));
                    }

                    uniform->modelViewProjection = 0;
                    uniform->precision = binaryUniform->precision;

                    gcoOS_MemCopy((gctPOINTER)&uniform->_flags,
                                  binaryUniform->flags,
                                  sizeof(gceUNIFORM_FLAGS));
                    uniform->format       = binaryUniform->format;
                    uniform->isPointer    = binaryUniform->isPointer;
                    uniform->arraySize    = binaryUniform->arraySize;
                    uniform->arrayLengthCount = (gctINT)binaryUniform->arrayLengthCount;
                    uniform->nameLength   = length;
                    uniform->name[length] = '\0';

                    /* Considering LoadEx/SaveEx only be called by OCL and imageFormat will be used in dumper but not used in CL, so just set it to the default value. */
                    uniform->imageFormat = gcIMAGE_FORMAT_DEFAULT;

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_LTC_FILE_VERSION)
                    {
                        uniform->glUniformIndex   = (gctINT16) -1;
                    }
                    else
                    {
                        uniform->glUniformIndex   = binaryUniform->glUniformIndex;
                    }

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_OPENCL_IMAGE_SAMPLER_BY_TEXLD_FILE_VERSION)
                    {
                        uniform->imageSamplerIndex = 0;
                    }
                    else
                    {
                        uniform->imageSamplerIndex = binaryUniform->imageSamplerIndex;
                    }

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_HALTI_FILE_VERSION)
                    {
                        uniform->initializer.f32_v4[0] =
                            uniform->initializer.f32_v4[1] =
                            uniform->initializer.f32_v4[2] =
                            uniform->initializer.f32_v4[3] = 0.0;
                    }
                    else
                    {
                        gcoOS_MemCopy((gctPOINTER)uniform->initializer.f32_v16,
                                      binaryUniform->initializer,
                                      sizeof(gcsValue));
                    }

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
                    {
                        uniform->qualifier = gcvTYPE_QUALIFIER_NONE;
                        SetUniformVectorSize(uniform, 0);
                        SetUniformTypeNameOffset(uniform, -1);
                    }
                    else
                    {
                        uniform->qualifier = binaryUniform->qualifier;
                        SetUniformVectorSize(uniform, binaryUniform->vectorSize);
                        gcoOS_MemCopy(&uniform->typeNameOffset,
                                      &binaryUniform->typeNameOffset,
                                      sizeof(binaryUniform->typeNameOffset));
                    }

                    /* Halti extras. */
                    uniform->blockIndex = -1;
                    uniform->arrayStride = -1;
                    uniform->matrixStride = -1;
                    uniform->isRowMajor = gcvFALSE;
                    uniform->offset = -1;

                    if (length > 0)
                    {
                        gcoOS_MemCopy(uniform->name, binaryUniform->memory, length);
                    }

                    if (uniform->arrayLengthCount > 0)
                    {
                        status = gcoOS_Allocate(gcvNULL,
                                                uniform->arrayLengthCount * gcmSIZEOF(gctINT),
                                                &pointer);

                        if (gcmIS_ERROR(status))
                        {
                            /* Roll back. */
                            Shader->uniformCount = i;

                            /* Error. */
                            gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                            gcmFOOTER();
                            return status;
                        }

                        gcoOS_ZeroMemory(pointer, uniform->arrayLengthCount * gcmSIZEOF(gctINT));
                        uniform->arrayLengthList = pointer;

                        gcoOS_MemCopy(uniform->arrayLengthList,
                                      binaryUniform->memory - previousVersionAdjustment,
                                      uniform->arrayLengthCount * gcmSIZEOF(gctINT));
                    }
                    else
                    {
                        uniform->arrayLengthList = gcvNULL;
                    }

                    /* substract fields which are not in the file version */
                    binarySize -= previousVersionAdjustment;

                    /* Point to next uniform argument. */
                    binaryUniform = (gcBINARY_UNIFORM_EX)
                                   ((gctUINT8 *) binaryUniform + binarySize);
                    bytes       -= binarySize;
                }
            }

            /* Point to first image sampler. */
            binaryImageSampler = (gcBINARY_IMAGE_SAMPLER) binaryUniform;

            /* Kernel function image samplers */
            if (kernelFunction->imageSamplerCount > 0) {

                binarySize = kernelFunction->imageSamplerCount * sizeof(struct _gcBINARY_IMAGE_SAMPLER);

                if (bytes < binarySize)
                {
                    /* Roll back. */
                    Shader->kernelFunctionCount = i;
                    kernelFunction->imageSamplerArrayCount =
                    kernelFunction->imageSamplerCount = 0;

                    /* Invalid argument. */
                    gcmFATAL("gcSHADER_LoadEx: Invalid image sampler");
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                    return gcvSTATUS_INVALID_DATA;
                }

                /* Allocate the array of gcsIMAGE_SAMPLER_PTR structures. */
                status = gcoOS_Allocate(gcvNULL, binarySize, &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->kernelFunctionCount = i;
                    kernelFunction->imageSamplerArrayCount =
                    kernelFunction->imageSamplerCount = 0;

                    /* Error. */
                    gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                kernelFunction->imageSamplers = pointer;

                for (j=0; j<kernelFunction->imageSamplerCount; j++) {
                    imageSampler = &kernelFunction->imageSamplers[j];

                    /*imageSampler->isConstantSamplerType    = binaryImageSampler->isConstantSamplerType;
                    imageSampler->imageNum     = binaryImageSampler->imageNum;
                    imageSampler->samplerType  = binaryImageSampler->samplerType;*/

                    gcoOS_MemCopy(&imageSampler->isConstantSamplerType,
                                  &binaryImageSampler->isConstantSamplerType,
                                  sizeof(binaryImageSampler->isConstantSamplerType));

                    gcoOS_MemCopy(&imageSampler->imageNum,
                                  &binaryImageSampler->imageNum,
                                  sizeof(binaryImageSampler->imageNum));

                    gcoOS_MemCopy(&imageSampler->samplerType,
                                  &binaryImageSampler->samplerType,
                                  sizeof(binaryImageSampler->samplerType));

                    /* Point to next image sampler. */
                    binaryImageSampler++;
                    bytes -= sizeof(struct _gcBINARY_IMAGE_SAMPLER);
                }
            }

            /* Point to first variable. */
            binaryVariable = (gcBINARY_VARIABLE_EX) binaryImageSampler;

            /* Kernel function variables */
            if (kernelFunction->localVariableCount > 0) {

                gctINT   previousVersionAdjustment = 0;

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_VARIABLE_TYPE_QUALIFIER_FILE_VERSION)
                {
                    /*add type qualifier adjustment */
                    previousVersionAdjustment = sizeof(binaryVariable->qualifier);
                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION) {
                        /* fields which are not in the version */
                        previousVersionAdjustment += sizeof(binaryVariable->varCategory) +
                                                     sizeof(binaryVariable->firstChild) +
                                                     sizeof(binaryVariable->nextSibling) +
                                                     sizeof(binaryVariable->prevSibling) +
                                                     sizeof(binaryVariable->parent);
                    }
                }

                if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
                {
                    /* arrayStride and offset fields which are not in the version */
                    previousVersionAdjustment += sizeof(binaryVariable->arrayStride) +
                                                 sizeof(binaryVariable->offset);
                }

                /* Allocate the array of gcVARIABLE structure pointers. */
                status = gcoOS_Allocate(gcvNULL,
                                       kernelFunction->localVariableCount * sizeof(gcVARIABLE),
                                       &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->kernelFunctionCount = i;
                    kernelFunction->localVariableCount = 0;

                    /* Error. */
                    gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                kernelFunction->localVariables = pointer;

                /* Parse all variables. */
                for (j = 0; j < kernelFunction->localVariableCount; j++)
                {
                    /* Get the length of the variable name. */
                    length = (bytes < sizeof(struct _gcBINARY_VARIABLE_EX))
                                 ? 0
                                 : binaryVariable->nameLength + binaryVariable->arrayLengthCount * gcmSIZEOF(gctINT);


                    /* Test for special length. */
                    if ((gctINT) length < 0)
                    {
                        length = 0;
                    }

                    /* Compute the number of bytes required. */
                    binarySize = gcmALIGN(gcmOFFSETOF(_gcBINARY_VARIABLE_EX, memory) + length, 2);

                    if (bytes < binarySize - previousVersionAdjustment)
                    {
                        /* Roll back. */
                        Shader->kernelFunctionCount = i;
                        kernelFunction->localVariableCount = j;

                        /* Invalid variable. */
                        gcmFATAL("gcSHADER_LoadEx: Invalid variable");
                        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                        return gcvSTATUS_INVALID_DATA;
                    }

                    /* Allocate memory for the variable inside the gcSHADER object. */
                    status = gcoOS_Allocate(gcvNULL,
                                           gcmOFFSETOF(_gcVARIABLE, name) + length + 1,
                                           &pointer);

                    if (gcmIS_ERROR(status))
                    {
                        /* Roll back. */
                        Shader->kernelFunctionCount = i;
                        kernelFunction->localVariableCount = j;

                        /* Error. */
                        gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                        gcmFOOTER();
                        return status;
                    }

                    variable = pointer;

                    /* Copy variable to shader. */
                    kernelFunction->localVariables[j]   = variable;
                    variable->object.type  = gcvOBJ_VARIABLE;

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_STRUCT_SYMBOL_FILE_VERSION)
                    {
                        SetVariableCategory(variable, gcSHADER_VAR_CATEGORY_NORMAL);
                        variable->firstChild = -1;
                        variable->nextSibling = -1;
                        variable->prevSibling = -1;
                        variable->parent = -1;
                        variable->u.type = (gcSHADER_TYPE) binaryVariable->u.type;
                        variable->qualifier = gcvTYPE_QUALIFIER_NONE;
                    }
                    else
                    {
                        SetVariableCategory(variable, (gcSHADER_VAR_CATEGORY)binaryVariable->varCategory);
                        variable->firstChild = binaryVariable->firstChild;
                        variable->nextSibling = binaryVariable->nextSibling;
                        variable->prevSibling = binaryVariable->prevSibling;
                        variable->parent = binaryVariable->parent;

                        if (binaryVariable->varCategory == gcSHADER_VAR_CATEGORY_NORMAL ||
                            binaryVariable->varCategory == gcSHADER_VAR_CATEGORY_BLOCK_MEMBER)
                            variable->u.type = (gcSHADER_TYPE) binaryVariable->u.type;
                        else
                            variable->u.numStructureElement = binaryVariable->u.numStructureElement;
                        if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_VARIABLE_TYPE_QUALIFIER_FILE_VERSION)
                            variable->qualifier = gcvTYPE_QUALIFIER_NONE;
                        else
                        {
                            variable->qualifier = binaryVariable->qualifier;
                        }
                    }

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_PRECISION_QUALIFIER_FILE_VERSION)
                    {
                        variable->precision = gcSHADER_PRECISION_DEFAULT;
                    }
                    else
                    {
                        variable->precision = binaryVariable->precision ;
                    }

                    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
                    {
                        variable->blockIndex = gcvBLOCK_INDEX_DEFAULT;
                        variable->arrayStride = -1;
                        variable->offset = -1;
                    }
                    else
                    {
                        variable->blockIndex = binaryVariable->blockIndex;
                        gcoOS_MemCopy(&variable->arrayStride,
                                      &binaryVariable->arrayStride,
                                      sizeof(binaryVariable->arrayStride));

                        gcoOS_MemCopy(&variable->offset,
                                      &binaryVariable->offset,
                                      sizeof(binaryVariable->offset));
                    }

                    variable->flags        = binaryVariable->flags;
                    variable->arraySize    = binaryVariable->arraySize;
                    variable->arrayLengthCount = (gctINT)binaryVariable->arrayLengthCount;
                    gcoOS_MemCopy((gctPOINTER)&variable->tempIndex, (gctPOINTER)&binaryVariable->tempIndex, sizeof(variable->tempIndex));
                    variable->nameLength   = binaryVariable->nameLength;
                    variable->name[length] = '\0';

                    if (length > 0)
                    {
                        gcoOS_MemCopy(variable->name, binaryVariable->memory - previousVersionAdjustment
                                      + binaryVariable->arrayLengthCount * gcmSIZEOF(gctINT), length);
                    }

                    if (variable->arrayLengthCount > 0)
                    {
                        gctINT arraySize = 1;
                        gctINT k;

                        status = gcoOS_Allocate(gcvNULL,
                                               variable->arrayLengthCount * gcmSIZEOF(gctINT),
                                               &pointer);

                        if (gcmIS_ERROR(status))
                        {
                            /* Roll back. */
                            Shader->variableCount = i;

                            /* Error. */
                            gcmFATAL("gcSHADER_Load: gcoOS_Allocate failed status=%d", status);
                            gcmFOOTER();
                            return status;
                        }

                        gcoOS_ZeroMemory(pointer, variable->arrayLengthCount * gcmSIZEOF(gctINT));
                        variable->arrayLengthList = pointer;

                        gcoOS_MemCopy(variable->arrayLengthList,
                                      binaryVariable->memory - previousVersionAdjustment,
                                      variable->arrayLengthCount * gcmSIZEOF(gctINT));

                        /* Recalculate the array size as arraySize field of gcBINARY_VARIABLE_EX
                           might be of insufficient size (gctINT8) */
                        for (k = 0; k < variable->arrayLengthCount; k++)
                        {
                            gcmASSERT(variable->arrayLengthList[k] > 0);
                            arraySize *= variable->arrayLengthList[k];
                        }

                        SetVariableArraySize(variable, arraySize);
                    }
                    else
                    {
                        variable->arrayLengthList = gcvNULL;
                    }

                    /* substract fields which are not in the file version */
                    binarySize -= previousVersionAdjustment;

                    /* Point to next variable. */
                    binaryVariable = (gcBINARY_VARIABLE_EX)
                                   ((gctUINT8 *) binaryVariable + binarySize);
                    bytes       -= binarySize;
                }
            }

            /* Point to first kernel function property. */
            binaryKernelFuncProp = (gcBINARY_KERNEL_FUNCTION_PROPERTY) binaryVariable;

            /* Kernel function properties */
            if (kernelFunction->propertyCount > 0) {

                binarySize = kernelFunction->propertyCount * sizeof(gcsKERNEL_FUNCTION_PROPERTY);

                if (bytes < binarySize)
                {
                    /* Roll back. */
                    Shader->kernelFunctionCount = i;
                    kernelFunction->propertyArrayCount =
                    kernelFunction->propertyCount = 0;

                    /* Invalid argument. */
                    gcmFATAL("gcSHADER_LoadEx: Invalid kernel function property");
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                    return gcvSTATUS_INVALID_DATA;
                }

                /* Allocate the array of gcsKERNEL_FUNCTION_PROPERTY_PTR structures. */
                status = gcoOS_Allocate(gcvNULL, binarySize, &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->kernelFunctionCount = i;
                    kernelFunction->propertyArrayCount =
                    kernelFunction->propertyCount = 0;

                    /* Error. */
                    gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                kernelFunction->properties = pointer;

                for (j=0; j<kernelFunction->propertyCount; j++) {
                    kernelFuncProp = &kernelFunction->properties[j];

                    gcoOS_MemCopy(&kernelFuncProp->propertyType, &binaryKernelFuncProp->propertyType, sizeof(gctUINT32));
                    gcoOS_MemCopy(&kernelFuncProp->propertySize, &binaryKernelFuncProp->propertySize, sizeof(gctUINT32));

                    /* Point to next kernel function property. */
                    binaryKernelFuncProp++;
                    bytes -= sizeof(gcsKERNEL_FUNCTION_PROPERTY);
                }
            }

            /* Point to first kernel function property value. */
            binaryPropertyValue = (gctINT32_PTR) binaryKernelFuncProp;

            /* Kernel function properties */
            if (kernelFunction->propertyValueCount > 0) {

                binarySize = kernelFunction->propertyValueCount * sizeof(gctINT32);

                if (bytes < binarySize)
                {
                    /* Roll back. */
                    Shader->kernelFunctionCount = i;
                    kernelFunction->propertyValueArrayCount =
                    kernelFunction->propertyValueCount = 0;

                    /* Invalid argument. */
                    gcmFATAL("gcSHADER_LoadEx: Invalid kernel function property value");
                    gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                    return gcvSTATUS_INVALID_DATA;
                }

                /* Allocate the array of gctINT32 */
                status = gcoOS_Allocate(gcvNULL, binarySize, &pointer);

                if (gcmIS_ERROR(status))
                {
                    /* Roll back. */
                    Shader->kernelFunctionCount = i;
                    kernelFunction->propertyValueArrayCount =
                    kernelFunction->propertyValueCount = 0;

                    /* Error. */
                    gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                    gcmFOOTER();
                    return status;
                }

                kernelFunction->propertyValues = pointer;

                for (j=0; j<kernelFunction->propertyValueCount; j++) {
                    gcoOS_MemCopy(&kernelFunction->propertyValues[j], &binaryPropertyValue[j], sizeof(gctUINT32));
                }

                /* Point to next property value. */
                binaryPropertyValue = (gctINT32_PTR)
                               ((gctUINT8 *) binaryPropertyValue + binarySize);
                bytes       -= binarySize;

            }

            /* Point to next kernel function. */
            binaryKernelFunc = (gcBINARY_KERNEL_FUNCTION) binaryPropertyValue;
        }
    }

    /************************************************************************/
    /*      private/constant memory size and optimization option            */
    /************************************************************************/

    /* Get the private memory size. */
    privateMemorySize = (gctUINT16 *) binaryKernelFunc;

    if (bytes < sizeof(gctUINT16))
    {
        /* Invalid private memory size. */
        gcmFATAL("gcSHADER_LoadEx: Invalid private memory size");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    Shader->privateMemorySize = *privateMemorySize;

    /* Point to the constant memory size. */
    constantMemorySize  = (gctUINT16 *) (privateMemorySize + 1);
    bytes -= sizeof(gctUINT16);

    if (bytes < sizeof(gctUINT16))
    {
        /* Invalid constant memory size. */
        gcmFATAL("gcSHADER_LoadEx: Invalid constant memory size");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    Shader->constantMemorySize = *constantMemorySize;
    bytes -= sizeof(gctUINT16);

    if (Shader->constantMemorySize > 0) {

        if (bytes < Shader->constantMemorySize)
        {
            /* Invalid constant memory buffer. */
            gcmFATAL("gcSHADER_LoadEx: Invalid constant memory buffer");
            gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
            return gcvSTATUS_INVALID_DATA;
        }

        status = gcoOS_Allocate(gcvNULL,
                                Shader->constantMemorySize,
                                &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Roll back. */
            Shader->constantMemorySize = 0;

            /* Error. */
            gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
            gcmFOOTER();
            return status;
        }

        Shader->constantMemoryBuffer = pointer;
        pointer = (gctUINT16 *) (constantMemorySize + 1);
        gcoOS_MemCopy(Shader->constantMemoryBuffer, pointer, Shader->constantMemorySize);
        constantMemorySize = (gctUINT16 *) ((gctUINTPTR_T) constantMemorySize + gcmALIGN(Shader->constantMemorySize, 2));
        bytes -= gcmALIGN(Shader->constantMemorySize, 2);
    }

    /* _constVectorId */
    curPos = (gctUINT8 *)(constantMemorySize + 1);
    Shader->_constVectorId  = *(gctUINT16 *) curPos;
    bytes -= sizeof(gctUINT16);

    /* _dummyUniformCount */
    curPos += sizeof(gctUINT16);
    Shader->_dummyUniformCount = *(gctUINT16 *) curPos;
    bytes -= sizeof(gctUINT16);

    /* _tempRegCount */
    curPos += sizeof(gctUINT16);
    gcoOS_MemCopy(&Shader->_tempRegCount,
                  curPos,
                  sizeof(gctUINT32));
    bytes -= sizeof(gctUINT32);

    /* _maxLocalTempRegCount */
    curPos += sizeof(gctUINT32);
    gcoOS_MemCopy(&Shader->_maxLocalTempRegCount,
                  curPos,
                  sizeof(gctUINT32));
    bytes -= sizeof(gctUINT32);

    /* WorkGroupSize. */
    curPos += sizeof(gctUINT32);
    Shader->shaderLayout.compute.isWorkGroupSizeFixed = (gctBOOL)(*(gctUINT16 *) curPos);
    bytes -= sizeof(gctUINT16);

    curPos += sizeof(gctUINT16);
    Shader->shaderLayout.compute.isWorkGroupSizeAdjusted = (gctBOOL)(*(gctUINT16 *) curPos);
    bytes -= sizeof(gctUINT16);

    curPos += sizeof(gctUINT16);
    Shader->shaderLayout.compute.adjustedWorkGroupSize = (gctBOOL)(*(gctUINT16 *) curPos);
    bytes -= sizeof(gctUINT16);

    /* Point to the optimization option. */
    curPos += sizeof(gctUINT16);
    optimizationOption  = (gctUINT *) curPos;

    if (bytes < sizeof(gctUINT))
    {
        /* Invalid optimization option. */
        gcmFATAL("gcSHADER_LoadEx: Invalid optimization option");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /*Shader->optimizationOption = *optimizationOption;*/
    gcoOS_MemCopy(&Shader->optimizationOption, optimizationOption, sizeof(gctUINT));

    /* Point to the code count. */
    count   = (gctUINT16 *) (optimizationOption + 1);
    bytes -= sizeof(gctUINT);

      /************************************************************************/
     /*                                                                 code */
    /************************************************************************/

    /* Get the code count. */
    codeCount = (gctUINT32 *) count;

    gcoOS_MemCopy(&Shader->codeCount, codeCount, sizeof(gctUINT32));

    if ((bytes < sizeof(gctUINT32)) || (Shader->codeCount <= 0))
    {
        /* Invalid code count. */
        gcmFATAL("gcSHADER_LoadEx: Invalid codeCount");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Point to the code. */
    code   = (gcSL_INSTRUCTION) (codeCount + 1);
    bytes -= sizeof(gctUINT32);

    /* Save the code count. */
    Shader->lastInstruction = Shader->codeCount;

    /* Compute the number of bytes. */
    binarySize = Shader->codeCount * sizeof(struct _gcSL_INSTRUCTION);

    if (bytes < binarySize)
    {
        /* Roll back. */
        Shader->lastInstruction = Shader->codeCount = 0;

        /* Invalid code count. */
        gcmFATAL("gcSHADER_LoadEx: Invalid codeCount");
        gcmFOOTER();
        return gcvSTATUS_INVALID_DATA;
    }

    /* Allocate memory for the code inside the gcSHADER object. */
    status = gcoOS_Allocate(gcvNULL,
                           binarySize,
                           &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Roll back. */
        Shader->lastInstruction = Shader->codeCount = 0;

        /* Error. */
        gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
        gcmFOOTER();
        return status;
    }

    Shader->code = pointer;

    /* Copy the code into the gcSHADER object. */
    gcoOS_MemCopy(Shader->code, code, binarySize);

    curPos = (gctUINT8 *)code + binarySize;
    if (shaderVersion > gcdSL_SHADER_BINARY_BEFORE_LTC_FILE_VERSION)
    {
        /* Loadtime Optimization related data */

        /* LTC uniform index */
        bytes -= binarySize;  /* remaining bytes */
        /*Shader->ltcUniformCount = *(gctINT *)curPos;*/
        gcoOS_MemCopy(&Shader->ltcUniformCount, curPos, sizeof(gctINT));

        curPos += sizeof(Shader->ltcUniformCount);
        bytes -= sizeof(Shader->ltcUniformCount);  /* remaining bytes */
        /*Shader->ltcUniformBegin = *(gctUINT *) curPos;*/
        gcoOS_MemCopy(&Shader->ltcUniformBegin, curPos, sizeof(gctUINT));

        curPos += sizeof(Shader->ltcUniformBegin);
        bytes -= sizeof(Shader->ltcUniformBegin);
        /*Shader->ltcInstructionCount = *(gctUINT *) curPos;*/
        gcoOS_MemCopy(&Shader->ltcInstructionCount, curPos, sizeof(gctUINT));

        curPos += sizeof(Shader->ltcInstructionCount); /* points to ltcCodeUniformIndex */
        bytes -= sizeof(Shader->ltcInstructionCount);  /* remaining bytes */
        binarySize = sizeof(*Shader->ltcCodeUniformIndex) * Shader->ltcInstructionCount;

        if (binarySize > 0)
        {
            /* Allocate memory for  ltcCodeUniformIndex inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                   binarySize,
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->ltcUniformCount = 0;

                /* Error. */
                gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_MemCopy(pointer, curPos, binarySize);
            Shader->ltcCodeUniformIndex = (gctINT *)pointer;
        }
        else
        {
            Shader->ltcCodeUniformIndex = gcvNULL;
        }

        curPos += binarySize;                           /* points to ltcExpressions */
        bytes -= binarySize;                            /* remaining bytes */
        binarySize = sizeof(*Shader->ltcExpressions) * Shader->ltcInstructionCount;
        if (binarySize > 0)
        {
            /* Allocate memory for  ltcExpressions inside the gcSHADER object. */
            status = gcoOS_Allocate(gcvNULL,
                                   binarySize,
                                   &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->ltcUniformCount = 0;

                /* Error. */
                gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d(%s)", status, gcoOS_DebugStatus2Name(status));
                gcmFOOTER();
                return status;
            }

            gcoOS_MemCopy(pointer, curPos, binarySize);
            Shader->ltcExpressions = (gcSL_INSTRUCTION)pointer;
        }
        curPos += binarySize;
    }
    else
    {
        Shader->ltcUniformCount = 0;
        Shader->ltcExpressions = gcvNULL;
        Shader->ltcUniformBegin = 0;
        Shader->ltcInstructionCount = 0;
        Shader->ltcCodeUniformIndex = gcvNULL;
    } /* if */

    if (shaderVersion <= gcdSL_SHADER_BINARY_BEFORE_CL12_VERSION)
    {
        Shader->typeNameBufferSize = 0;
        Shader->typeNameBuffer = gcvNULL;
    }
    else
    {
        bytes -= binarySize;  /* remaining bytes */

        if (bytes < sizeof(gctUINT))
        {
            /* Invalid code count. */
            gcmFATAL("gcSHADER_LoadEx: Invalid codeCount");
            gcmFOOTER();
            return gcvSTATUS_INVALID_DATA;
        }

        /* Type name buffer size. */
        gcoOS_MemCopy(&Shader->typeNameBufferSize, curPos, sizeof(gctUINT));
        curPos += sizeof(gctUINT);
        binarySize = sizeof(gctUINT);

        if (Shader->typeNameBufferSize) {
            bytes -= binarySize;
            if (bytes < Shader->typeNameBufferSize)
            {
                /* Invalid type name buffer. */
                gcmFATAL("gcSHADER_LoadEx: Invalid type name buffer");
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
                return gcvSTATUS_INVALID_DATA;
            }

            status = gcoOS_Allocate(gcvNULL,
                                    Shader->typeNameBufferSize,
                                    &pointer);
            if (gcmIS_ERROR(status))
            {
                /* Roll back. */
                Shader->typeNameBufferSize = 0;

                /* Error. */
                gcmFATAL("gcSHADER_LoadEx: gcoOS_Allocate failed status=%d", status);
                gcmFOOTER();
                return status;
            }

            Shader->typeNameBuffer = pointer;
            gcoOS_MemCopy(Shader->typeNameBuffer, curPos, Shader->typeNameBufferSize);
            binarySize = gcmALIGN(Shader->typeNameBufferSize, 2);
            curPos += binarySize;
        }
    }

    /* For debugInfo, at least have a gctBOOL */
    bytes -= binarySize;  /* remaining bytes */

    if (bytes < sizeof(gctUINT8))
    {
        /* Invalid code count. */
        gcmFATAL("gcSHADER_LoadEx: Invalid codeCount");
        gcmFOOTER();
        return gcvSTATUS_INVALID_DATA;
    }

    gcoOS_MemCopy(&debugInfo, curPos, sizeof(gctUINT8));
    curPos += sizeof(gctUINT8);
    bytes -= sizeof(gctUINT8);

    if ((gctUINT)debugInfo > 0)
    {
        gctPOINTER ptr = curPos;
        VSC_DIContext * debugInfo = (VSC_DIContext *)(Shader->debugInfo);

        status = vscDILoadDebugInfo(&debugInfo, &ptr, &bytes);

        if (gcmIS_ERROR(status))
        {
            /* Invalid code count. */
            gcmFATAL("gcSHADER_LoadEx: Invalid codeCount");
            gcmFOOTER();
            return gcvSTATUS_INVALID_DATA;
        }

        Shader->debugInfo = (gctPOINTER)debugInfo;
    }

    if (bytes != 0)
    {
        /* Error. */
        gcmFATAL("gcSHADER_LoadEx: %u extraneous bytes in the binary file.",
              bytes - binarySize);
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_Save
**
**  Save a gcSHADER object including header information to a binary buffer.
**  SHADER binary header format: -
**     Word 1:  ('S' 'H' 'D' 'R') : signature
**     Word 2:  ('\od' '\od' '\od' '\od') od = octal digits; binary file version
**     Word 3:  ('E' 'S' '\0' '\0') | gcSHADER_TYPE_VERTEX   or
**              ('E' 'S' '\0' '\0') | gcSHADER_TYPE_FRAGMENT or
**              ('C' 'L' '\0' '\0') | gcSHADER_TYPE_CL
**     Word 4: ('\od' '\od' '\od' '\od') od = octal digits; compiler version
**     Word 5: ('\1' '\0' '\0' '\0') gcSL version
**     Word 6: size of shader binary file in bytes excluding this header
**
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctPOINTER Buffer
**          Pointer to a binary buffer to be used as storage for the gcSHADER
**          object.  If 'Buffer' is gcvNULL, the gcSHADER object will not be saved,
**          but the number of bytes required to hold the binary output for the
**          gcSHADER object will be returned.
**
**      gctUINT32 * BufferSize
**          Pointer to a variable holding the number of bytes allocated in
**          'Buffer'.  Only valid if 'Buffer' is not gcvNULL.
**
**  OUTPUT:
**
**      gctUINT32 * BufferSize
**          Pointer to a variable receiving the number of bytes required to hold
**          the binary form of the gcSHADER object.
*/
gceSTATUS
gcSHADER_SaveEx(
    IN gcSHADER Shader,
    IN gctPOINTER Buffer,
    IN OUT gctUINT32 * BufferSize
    )
{
    gctUINT32 bytes, bytes2, i, j;
    gctINT nameLength;
    gctUINT8 * buffer;
    gctUINT32 outputCount = 0;
    gctUINT32 attributeCount = 0;
    gctUINT32 uniformCount = 0;
    gctUINT32 uniformBlockCount = 0;
    gctUINT32 variableCount = 0;
    gctUINT32 functionCount = 0;
    gctUINT32 kernelFunctionCount = 0;
    gctPOINTER ptr;

    gcmHEADER_ARG("Shader=0x%x Buffer=0x%x BufferSize=0x%x", Shader, Buffer, BufferSize);

    if (Shader == gcvNULL)
    {
    /* Return required number of bytes. */
        *BufferSize = 0;
        gcmFOOTER_ARG("*BufferSize=%d", *BufferSize);
        return gcvSTATUS_OK;
    }

      /************************************************************************/
     /*                                       Compute size of binary buffer. */
    /************************************************************************/

    /* File Header. */
    bytes = _gcdShaderBinaryHeaderSize;

    /* shader sampler index. */
    bytes += sizeof(gctINT);

    /* Attributes. */
    bytes += sizeof(gctUINT16);

    for (i = 0; i < Shader->attributeCount; i++)
    {
        if (Shader->attributes[i] == gcvNULL) continue;

        attributeCount ++;

        nameLength = Shader->attributes[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_ATTRIBUTE, name) + gcmALIGN(nameLength, 2);
    }

    /* Uniforms. */
    bytes += sizeof(gctUINT16);

    for (i = 0; i < Shader->uniformCount; i++)
    {

        if (Shader->uniforms[i] == gcvNULL) continue;

        uniformCount ++;

        nameLength = Shader->uniforms[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_UNIFORM_EX, memory) + gcmALIGN(nameLength, 2);

        if (Shader->uniforms[i]->arrayLengthCount > 0)
        {
            bytes += Shader->uniforms[i]->arrayLengthCount * gcmSIZEOF(gctINT);
        }
    }

    gcmASSERT(uniformCount ||
              (!uniformCount && !Shader->uniformBlockCount));

    if (uniformCount)
    {
        /* Uniform blocks. */
        bytes += sizeof(gctUINT16);

        for (i = 0; i < Shader->uniformBlockCount; i++)
        {
            if (Shader->uniformBlocks[i] == gcvNULL)
            {
                continue;
            }

            uniformBlockCount ++;

            nameLength = Shader->uniformBlocks[i]->nameLength;

            if (nameLength < 0)
            {
                nameLength = 0;
            }

            bytes += gcmOFFSETOF(_gcBINARY_UNIFORM_BLOCK, name) + gcmALIGN(nameLength, 2);
        }
    }

    /* Outputs. */
    bytes += sizeof(gctUINT16);

    for (i = 0; i < Shader->outputCount; i++)
    {
        if (Shader->outputs[i] == gcvNULL) continue;

        outputCount ++;

        nameLength = Shader->outputs[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_OUTPUT, name) + gcmALIGN(nameLength, 2);
    }

    /* Global Variables. */
    bytes += sizeof(gctUINT16);

    for (i = 0; i < Shader->variableCount; i++)
    {
        if (Shader->variables[i] == gcvNULL) continue;

        variableCount ++;

        nameLength = Shader->variables[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_VARIABLE_EX, memory) + gcmALIGN(nameLength, 2);

        if (Shader->variables[i]->arrayLengthCount > 0)
        {
            bytes += Shader->variables[i]->arrayLengthCount * gcmSIZEOF(gctINT);
        }
    }

    /* Functions. */
    bytes += sizeof(gctUINT16);

    for (i = 0; i < Shader->functionCount; i++)
    {
        if (Shader->functions[i] == gcvNULL) continue;

        functionCount ++;

        nameLength = Shader->functions[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_FUNCTION, name) + gcmALIGN(nameLength, 2);

        /* Function arguments */
        bytes += Shader->functions[i]->argumentCount * sizeof(struct _gcBINARY_ARGUMENT);

        /* Function variables */
        for (j = 0; j < Shader->functions[i]->localVariableCount; j++)
        {
            if (Shader->functions[i]->localVariables[j] == gcvNULL) continue;

            nameLength = Shader->functions[i]->localVariables[j]->nameLength;

            if (nameLength < 0)
            {
                nameLength = 0;
            }

            bytes += gcmOFFSETOF(_gcBINARY_VARIABLE_EX, memory) + gcmALIGN(nameLength, 2);

            if (Shader->functions[i]->localVariables[j]->arrayLengthCount > 0)
            {
                bytes += Shader->functions[i]->localVariables[j]->arrayLengthCount * gcmSIZEOF(gctINT);
            }
        }
    }

    /* Max kernel function arguments. */
    bytes += sizeof(gctUINT16);

    /* Kernel functions. */
    bytes += sizeof(gctUINT16);

    for (i = 0; i < Shader->kernelFunctionCount; i++)
    {
        if (Shader->kernelFunctions[i] == gcvNULL) continue;

        kernelFunctionCount ++;

        nameLength = Shader->kernelFunctions[i]->nameLength;

        if (nameLength < 0)
        {
            nameLength = 0;
        }

        bytes += gcmOFFSETOF(_gcBINARY_KERNEL_FUNCTION, name) + gcmALIGN(nameLength, 2);

        /* Kernel function arguments */
        bytes += Shader->kernelFunctions[i]->argumentCount * sizeof(struct _gcBINARY_ARGUMENT);

        /* Kernel function uniform arguments. */
        for (j = 0; j < Shader->kernelFunctions[i]->uniformArgumentCount; j++)
        {
            if (Shader->kernelFunctions[i]->uniformArguments[j] == gcvNULL) continue;

            nameLength = Shader->kernelFunctions[i]->uniformArguments[j]->nameLength;

            if (nameLength < 0)
            {
                nameLength = 0;
            }

            bytes += gcmOFFSETOF(_gcBINARY_UNIFORM_EX, memory) + gcmALIGN(nameLength, 2);

            if (Shader->kernelFunctions[i]->uniformArguments[j]->arrayLengthCount > 0)
            {
                bytes += Shader->kernelFunctions[i]->uniformArguments[j]->arrayLengthCount * gcmSIZEOF(gctINT);
            }
        }

        /* Kernel function image samplers */
        bytes += Shader->kernelFunctions[i]->imageSamplerCount * sizeof(struct _gcBINARY_IMAGE_SAMPLER);

        /* Kernel function variables */
        for (j = 0; j < Shader->kernelFunctions[i]->localVariableCount; j++)
        {
            if (Shader->kernelFunctions[i]->localVariables[j] == gcvNULL) continue;

            nameLength = Shader->kernelFunctions[i]->localVariables[j]->nameLength;

            if (nameLength < 0)
            {
                nameLength = 0;
            }

            bytes += gcmOFFSETOF(_gcBINARY_VARIABLE_EX, memory) + gcmALIGN(nameLength, 2);

            if (Shader->kernelFunctions[i]->localVariables[j]->arrayLengthCount > 0)
            {
                bytes += Shader->kernelFunctions[i]->localVariables[j]->arrayLengthCount * gcmSIZEOF(gctINT);
            }
        }

        /* Kernel function properties */
        bytes += Shader->kernelFunctions[i]->propertyCount * sizeof(struct _gcBINARY_KERNEL_FUNCTION_PROPERTY);

        /* Kernel function property values */
        bytes += Shader->kernelFunctions[i]->propertyValueCount * sizeof(gctINT32);

    }

    /* Private memory size. */
    bytes += sizeof(gctUINT16);

    /* Constant memory size. */
    bytes += sizeof(gctUINT16);

    /* Constant memory buffer. */
    bytes += gcmALIGN(Shader->constantMemorySize, 2);

    /* _constVectorId */
    bytes += sizeof(gctUINT16);

    /* _dummyUniformCount */
    bytes += sizeof(gctUINT16);

    /* _tempRegCount */
    bytes += sizeof(gctUINT32);

    /* _maxLocalTempRegCount */
    bytes += sizeof(gctUINT32);

    /* workGroupSize for compute shader*/
    bytes += sizeof(gctUINT16);
    bytes += sizeof(gctUINT16);
    bytes += sizeof(gctUINT16);

    /* Optimization option. */
    bytes += sizeof(gctUINT);

    /* Code. */
    bytes += sizeof(gctUINT32);
    bytes += Shader->codeCount * sizeof(struct _gcSL_INSTRUCTION);

    /* Loadtime Optimization related data */
    bytes += sizeof(Shader->ltcUniformCount) +
             sizeof(Shader->ltcUniformBegin) +
             sizeof(*Shader->ltcCodeUniformIndex) * Shader->ltcInstructionCount +
             sizeof(Shader->ltcInstructionCount) +
             sizeof(*Shader->ltcExpressions) * Shader->ltcInstructionCount;

    /* Type name buffer size. */
    bytes += sizeof(gctUINT);

    /* Type name buffer. */
    bytes += gcmALIGN(Shader->typeNameBufferSize, 2);

    /* For debugInfo */
    vscDISaveDebugInfo((VSC_DIContext * )(Shader->debugInfo), gcvNULL, &bytes);

    /* Return required number of bytes if Buffer is gcvNULL. */
    if (Buffer == gcvNULL)
    {
        *BufferSize = bytes;
        gcmFOOTER_ARG("*BufferSize=%d", *BufferSize);
        return gcvSTATUS_OK;
    }

    /* Make sure the buffer is large enough. */
    if (*BufferSize < bytes)
    {
        *BufferSize = bytes;
        gcmFOOTER_ARG("*BufferSize=%d status=%d",
                        *BufferSize, gcvSTATUS_BUFFER_TOO_SMALL);
        return gcvSTATUS_BUFFER_TOO_SMALL;
    }

    /* Store number of bytes returned. */
    *BufferSize = bytes;

      /************************************************************************/
     /*                                              Fill the binary buffer. */
    /************************************************************************/

    buffer = Buffer;

    gcoOS_ZeroMemory(buffer, *BufferSize);

    /* Header */
    /* Word 1: signature 'S' 'H' 'D' 'R' */
    *(gceOBJECT_TYPE *) buffer = gcvOBJ_SHADER;
    buffer += sizeof(gceOBJECT_TYPE);

    /* Word 2: binary file version # */
    *(gctUINT32 *) buffer = gcdSL_SHADER_BINARY_FILE_VERSION;
    buffer += sizeof(gctUINT32);

    /* Word 3: chipModel */
    *(gctUINT32 *) buffer = gcGetHWCaps()->chipModel;
    buffer += sizeof(gctUINT32);

    /* Word 4: chipRevision */
    *(gctUINT32 *) buffer = gcGetHWCaps()->chipRevision;
    buffer += sizeof(gctUINT32);

    /* Word 5: language type and shader type */
    *(gctUINT32 *) buffer = Shader->compilerVersion[0];
    buffer += sizeof(gctUINT32);

    /* Word 6: compiler version */
    *(gctUINT32 *) buffer = Shader->compilerVersion[1];
    buffer += sizeof(gctUINT32);

    /* Word 7: flags */
    *(gctUINT32 *) buffer = Shader->flags;
    buffer += sizeof(gctUINT32);

    /* Word 8: client api version. */
    *(gctUINT32 *) buffer = Shader->clientApiVersion;
    buffer += sizeof(gctUINT32);

    /* Word 9: size of binary excluding header */
    *(gctUINT32 *) buffer = bytes - _gcdShaderBinaryHeaderSize;
    buffer += sizeof(gctUINT32);

    /* Sampler index. */
    gcoOS_MemCopy(buffer, &Shader->samplerIndex, sizeof(gctINT));
    buffer += sizeof(gctINT);

    /* Attribute count. */
    *(gctUINT16 *) buffer = (gctUINT16) attributeCount;
    buffer += sizeof(gctUINT16);

    /* Attributes. */
    for (i = 0; i < Shader->attributeCount; i++)
    {
        gcATTRIBUTE attribute;
        gcBINARY_ATTRIBUTE binary;

        if (Shader->attributes[i] == gcvNULL) continue;

        /* Point to source and binary attributes. */
        attribute = Shader->attributes[i];
        binary    = (gcBINARY_ATTRIBUTE) buffer;

        /* Fill in binary attribute. */
        binary->type        = (gctUINT8) attribute->type;
        binary->flags1      = (gctUINT16)(attribute->flags_ & 0xFFFF);
        binary->flags2      = (gctUINT16)((attribute->flags_ >> 16) & 0xFFFF);
        binary->precision   = (gctINT16) attribute->precision;
        binary->arraySize   = (gctINT16) attribute->arraySize;
        binary->arrayLength = (gctINT16) attribute->arrayLength;
        binary->nameLength  = (gctINT16) attribute->nameLength;
        binary->nextSibling = attribute->nextSibling;
        binary->prevSibling = attribute->prevSibling;
        binary->typeNameVarIndex = attribute->typeNameVarIndex;

        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->name, attribute->name, bytes);
        }
        else
        {
            bytes = 0;
        }

        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_ATTRIBUTE, name) + bytes;
    }

    /* Uniform count. */
    *(gctUINT16 *) buffer = (gctUINT16) uniformCount;
    buffer += sizeof(gctUINT16);

    /* Uniforms. */
    for (i = 0; i < Shader->uniformCount; i++)
    {
        gcUNIFORM uniform;
        gcBINARY_UNIFORM_EX binary;

        if (Shader->uniforms[i] == gcvNULL) continue;

        /* Point to source and binary uniforms. */
        uniform = Shader->uniforms[i];
        binary  = (gcBINARY_UNIFORM_EX) buffer;

        /* Fill in binary uniform. */
        binary->varCategory = GetUniformCategory(uniform);
        binary->firstChild = uniform->firstChild;
        binary->nextSibling = uniform->nextSibling;
        binary->prevSibling = uniform->prevSibling;
        binary->parent = uniform->parent;

        if (isUniformNormal(uniform)
            ||  isUniformBlockMember(uniform)
            ||  isUniformBlockAddress(uniform)
           )
            binary->u.type = (gcSHADER_TYPE) uniform->u.type;
        else
            binary->u.numStructureElement = uniform->u.numStructureElement;

        binary->index      = uniform->index;
        binary->arraySize  = (gctINT16) uniform->arraySize;
        binary->arrayLengthCount = (gctUINT16)uniform->arrayLengthCount;
        gcoOS_MemCopy(binary->physical,
                      (gctPOINTER)&uniform->physical,
                      sizeof(gctINT16));
        gcoOS_MemCopy(binary->samplerPhysical,
                      (gctPOINTER)&uniform->samplerPhysical,
                      sizeof(gctINT16));
        gcoOS_MemCopy(binary->address,
                      (gctPOINTER)&uniform->address,
                      sizeof(gctUINT32));
        gcoOS_MemCopy(binary->flags,
                      (gctPOINTER)&uniform->_flags,
                      sizeof(gceUNIFORM_FLAGS));
        binary->blockIndex = uniform->blockIndex;
        gcoOS_MemCopy(binary->arrayStride,
                      (gctPOINTER)&uniform->arrayStride,
                      sizeof(gctINT32));
        gcoOS_MemCopy(binary->offset,
                      (gctPOINTER)&uniform->offset,
                      sizeof(gctINT32));
        binary->format     = (gctUINT16) uniform->format;
        binary->isPointer  = (gctINT16) uniform->isPointer;
        binary->nameLength = (gctINT16) uniform->nameLength;
        binary->glUniformIndex   = uniform->glUniformIndex;
        binary->precision = uniform->precision;
        binary->imageSamplerIndex = uniform->imageSamplerIndex;
        gcoOS_MemCopy(binary->initializer,
                      (gctPOINTER)uniform->initializer.f32_v16,
                      sizeof(gcsValue));
        binary->dummyUniformIndex = uniform->dummyUniformIndex;
        binary->qualifier = (gctUINT16) uniform->qualifier;
        binary->vectorSize = (gctINT16) uniform->vectorSize;
        gcoOS_MemCopy(&binary->typeNameOffset,
                      &uniform->typeNameOffset,
                      sizeof(binary->typeNameOffset));

        gcoOS_MemCopy(binary->resOpFlag,
                      (gctPOINTER)&uniform->resOpFlag,
                      sizeof(gctUINT32));

        if (binary->arrayLengthCount > 0)
        {
            /* Compute number of bytes to copy. */
            bytes2 = binary->arrayLengthCount * gcmSIZEOF(gctINT);

            /* Copy array length. */
            gcoOS_MemCopy(binary->memory, uniform->arrayLengthList, bytes2);
        }
        else
        {
            bytes2 = 0;
        }

        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->memory + bytes2, uniform->name, bytes);
        }
        else
        {
            bytes = 0;
        }

        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_UNIFORM_EX, memory) + bytes + bytes2;
    }

    gcmASSERT(uniformCount ||
              (!uniformCount && !uniformBlockCount));

    if (uniformCount)
    {
        /* Uniform block count. */
        *(gctUINT16 *) buffer = (gctUINT16) uniformBlockCount;
        buffer += sizeof(gctUINT16);

        /* Uniform blocks. */
        for (i = 0; i < Shader->uniformBlockCount; i++)
        {
            gcsUNIFORM_BLOCK uniformBlock;
            gcBINARY_UNIFORM_BLOCK binary;

            if (Shader->uniformBlocks[i] == gcvNULL) continue;

            /* Point to source and binary uniform blocks. */
            uniformBlock = Shader->uniformBlocks[i];
            binary  = (gcBINARY_UNIFORM_BLOCK) buffer;

            /* Fill in binary uniform block. */
            binary->memoryLayout = (gctUINT16)GetUBMemoryLayout(uniformBlock);
            binary->blockSize = (gctUINT16)GetUBBlockSize(uniformBlock);
            binary->numBlockElement = (gctUINT16)GetUBNumBlockElement(uniformBlock);
            binary->firstChild = GetUBFirstChild(uniformBlock);
            binary->nextSibling = GetUBNextSibling(uniformBlock);
            binary->prevSibling = GetUBPrevSibling(uniformBlock);
            binary->index = GetUBIndex(uniformBlock);

            binary->nameLength = (gctINT16) uniformBlock->nameLength;

            gcoOS_MemCopy(binary->binding,
                          (gctPOINTER)&GetUBBinding(uniformBlock),
                          sizeof(gctINT32));

            if (binary->nameLength > 0)
            {
                /* Compute number of bytes to copy. */
                bytes = gcmALIGN(binary->nameLength, 2);

                /* Copy name. */
                gcoOS_MemCopy(binary->name, uniformBlock->name, bytes);
            }
            else
            {
                bytes = 0;
            }

            /* Adjust buffer pointer. */
            buffer += gcmOFFSETOF(_gcBINARY_UNIFORM_BLOCK, name) + bytes;
        }
    }

    /* Output count. */
    *(gctUINT16 *) buffer = (gctUINT16) outputCount;
    buffer += sizeof(gctUINT16);

    /* Outputs. */
    for (i = 0; i < Shader->outputCount; i++)
    {
        gcOUTPUT output;
        gcBINARY_OUTPUT binary;

        if (Shader->outputs[i] == gcvNULL) continue;

        /* Point to source and binary outputs. */
        output = Shader->outputs[i];
        binary = (gcBINARY_OUTPUT) buffer;

        /* Fill in binary output. */
        binary->index       = output->index;
        binary->origType    = output->origType;
        binary->type        = output->type;
        binary->arraySize   = (gctINT8) output->arraySize;
        gcoOS_MemCopy((gctPOINTER)&binary->tempIndex, &output->tempIndex, sizeof(output->tempIndex));
        binary->flags1      = (gctUINT16)(output->flags_ & 0xFFFF);
        binary->flags2      = (gctUINT16)((output->flags_ >> 16) & 0xFFFF);
        binary->precision   = gcSHADER_PRECISION_DEFAULT;
        binary->nameLength  = (gctINT16) output->nameLength;
        binary->nextSibling = output->nextSibling;
        binary->prevSibling = output->prevSibling;
        binary->typeNameVarIndex = output->typeNameVarIndex;

        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->name, output->name, bytes);
        }
        else
        {
            bytes = 0;
        }

        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_OUTPUT, name) + bytes;
    }

    /* Global variable count. */
    *(gctUINT16 *) buffer = (gctUINT16) variableCount;
    buffer += sizeof(gctUINT16);

    /* Global variables. */
    for (i = 0; i < Shader->variableCount; i++)
    {
        gcVARIABLE variable;
        gcBINARY_VARIABLE_EX binary;

        if (Shader->variables[i] == gcvNULL) continue;

        /* Point to source and binary variables. */
        variable = Shader->variables[i];
        binary = (gcBINARY_VARIABLE_EX) buffer;

        /* Fill in binary variable. */
        binary->varCategory = GetVariableCategory(variable);
        binary->firstChild = variable->firstChild;
        binary->nextSibling = variable->nextSibling;
        binary->prevSibling = variable->prevSibling;
        binary->parent = variable->parent;

        if (isVariableSimple(variable))
            binary->u.type = (gcSHADER_TYPE) variable->u.type;
        else
            binary->u.numStructureElement = (gctUINT8)variable->u.numStructureElement;

        binary->blockIndex = variable->blockIndex;
        binary->precision  = variable->precision;
        binary->flags      = variable->flags;
        binary->qualifier  = variable->qualifier;
        binary->arraySize  = (gctINT8) variable->arraySize;
        binary->arrayLengthCount = (gctUINT16) variable->arrayLengthCount;

        gcoOS_MemCopy(&binary->tempIndex,
                      &variable->tempIndex,
                      sizeof(binary->tempIndex));

        gcoOS_MemCopy(&binary->arrayStride,
                      &variable->arrayStride,
                      sizeof(binary->arrayStride));

        gcoOS_MemCopy(&binary->offset,
                      &variable->offset,
                      sizeof(binary->offset));

        binary->nameLength = (gctINT16) variable->nameLength;

        if (binary->arrayLengthCount > 0)
        {
            /* Compute number of bytes to copy. */
            bytes2 = binary->arrayLengthCount * gcmSIZEOF(gctINT);

            /* Copy name. */
            gcoOS_MemCopy(binary->memory, variable->arrayLengthList, bytes2);
        }
        else
        {
            bytes2 = 0;
        }

        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->memory + bytes2, variable->name, bytes);
        }
        else
        {
            bytes = 0;
        }

        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_VARIABLE_EX, memory) + bytes + bytes2;
    }

    /* Function count. */
    *(gctUINT16 *) buffer = (gctUINT16) functionCount;
    buffer += sizeof(gctUINT16);

    /* Functions. */
    for (i = 0; i < Shader->functionCount; i++)
    {
        gcFUNCTION function;
        gcBINARY_FUNCTION binary;

        if (Shader->functions[i] == gcvNULL) continue;

        /* Point to source and binary functions. */
        function = Shader->functions[i];
        binary = (gcBINARY_FUNCTION) buffer;

        /* Fill in binary function. */
        binary->argumentCount       = (gctINT16) function->argumentCount;
        binary->packedAwayArgNo     = (gctINT16) function->packedAwayArgNo;
        binary->localVariableCount  = (gctINT16) function->localVariableCount;
        gcoOS_MemCopy(&binary->flags, &function->flags, sizeof(gctUINT32));
        gcoOS_MemCopy(&binary->intrinsicsKind, &function->intrinsicsKind, sizeof(gctUINT32));
        binary->tempIndexStart      = function->tempIndexStart;
        binary->tempIndexEnd        = function->tempIndexEnd;
        binary->tempIndexCount      = function->tempIndexCount;
        binary->codeStart           = function->codeStart;
        binary->codeCount           = function->codeCount;
        binary->label               = (gctINT16)function->label;
        binary->nameLength          = (gctINT16) function->nameLength;
        binary->die                 = function->die;

        gcmASSERT((gctUINT32)binary->tempIndexStart == function->tempIndexStart);
        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->name, function->name, bytes);
        }
        else
        {
            bytes = 0;
        }

        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_FUNCTION, name) + bytes;

        /* Function arguments */
        for (j = 0; j < function->argumentCount; j++)
        {
            gcsFUNCTION_ARGUMENT *argument;
            gcBINARY_ARGUMENT binary;

            /* Point to source and binary arguments. */
            argument = &function->arguments[j];
            binary = (gcBINARY_ARGUMENT) buffer;

            /* Fill in binary argument. */
            gcoOS_MemCopy((gctPOINTER)&binary->index, &argument->index, sizeof(argument->index));
            binary->enable     = argument->enable;
            binary->qualifier  = argument->qualifier;
            binary->precision  = argument->precision;
            binary->variableIndex = argument->variableIndex;
            binary->flags      = argument->flags;

            /* Adjust buffer pointer. */
            buffer += sizeof(struct _gcBINARY_ARGUMENT);
        }

        /* Function variables */
        for (j = 0; j < function->localVariableCount; j++)
        {
            gcVARIABLE variable;
            gcBINARY_VARIABLE_EX binary;

            if (function->localVariables[j] == gcvNULL) continue;

            /* Point to source and binary variables. */
            variable = function->localVariables[j];
            binary = (gcBINARY_VARIABLE_EX) buffer;

            /* Fill in binary variable. */
            binary->varCategory = GetVariableCategory(variable);
            binary->firstChild = variable->firstChild;
            binary->nextSibling = variable->nextSibling;
            binary->prevSibling = variable->prevSibling;
            binary->parent = variable->parent;

            if (isVariableSimple(variable))
                binary->u.type = (gcSHADER_TYPE) variable->u.type;
            else
                binary->u.numStructureElement = (gctUINT8)variable->u.numStructureElement;

            binary->blockIndex = variable->blockIndex;
            binary->precision  = variable->precision;
            binary->flags      = variable->flags;
            binary->qualifier  = variable->qualifier;
            binary->arraySize  = (gctINT8) variable->arraySize;
            binary->arrayLengthCount = (gctUINT16)variable->arrayLengthCount;
            gcoOS_MemCopy((gctPOINTER)&binary->tempIndex, &variable->tempIndex, sizeof(variable->tempIndex));

            gcoOS_MemCopy(&binary->arrayStride,
                          &variable->arrayStride,
                          sizeof(binary->arrayStride));

            gcoOS_MemCopy(&binary->offset,
                          &variable->offset,
                          sizeof(binary->offset));

            binary->nameLength = (gctINT16) variable->nameLength;

            if (binary->arrayLengthCount > 0)
            {
                /* Compute number of bytes to copy. */
                bytes2 = binary->arrayLengthCount * gcmSIZEOF(gctINT);

                /* Copy name. */
                gcoOS_MemCopy(binary->memory, variable->arrayLengthList, bytes2);
            }
            else
            {
                bytes2 = 0;
            }

            if (binary->nameLength > 0)
            {
                /* Compute number of bytes to copy. */
                bytes = gcmALIGN(binary->nameLength, 2);

                /* Copy name. */
                gcoOS_MemCopy(binary->memory + bytes2, variable->name, bytes);
            }
            else
            {
                bytes = 0;
            }

            /* Adjust buffer pointer. */
            buffer += gcmOFFSETOF(_gcBINARY_VARIABLE_EX, memory) + bytes + bytes2;
        }
    }

    /* Max kernel function args. */
    *(gctUINT16 *) buffer = (gctUINT16) Shader->maxKernelFunctionArgs;
    buffer += sizeof(gctUINT16);

    /* Kernel function count. */
    *(gctUINT16 *) buffer = (gctUINT16) kernelFunctionCount;
    buffer += sizeof(gctUINT16);

    /* Kernel Functions. */
    for (i = 0; i < Shader->kernelFunctionCount; i++)
    {
        gcKERNEL_FUNCTION kernelFunction;
        gcBINARY_KERNEL_FUNCTION binary;

        if (Shader->kernelFunctions[i] == gcvNULL) continue;

        /* Point to source and binary kernel functions. */
        kernelFunction = Shader->kernelFunctions[i];
        binary = (gcBINARY_KERNEL_FUNCTION) buffer;

        /* Fill in binary function. */
        binary->argumentCount       = (gctINT16) kernelFunction->argumentCount;
        binary->label               = (gctINT16)kernelFunction->label;
        gcoOS_MemCopy(&binary->localMemorySize, &kernelFunction->localMemorySize, sizeof(gctUINT32));
        gcoOS_MemCopy(&binary->flags, &kernelFunction->flags, sizeof(gctUINT32));
        binary->uniformArgumentCount = (gctINT16) kernelFunction->uniformArgumentCount;
        binary->samplerIndex        = (gctINT16) kernelFunction->samplerIndex;
        binary->imageSamplerCount   = (gctINT16) kernelFunction->imageSamplerCount;
        binary->localVariableCount  = (gctINT16) kernelFunction->localVariableCount;
        binary->tempIndexStart      = kernelFunction->tempIndexStart;
        binary->tempIndexEnd        = kernelFunction->tempIndexEnd;
        binary->tempIndexCount      = kernelFunction->tempIndexCount;
        binary->propertyCount       = (gctINT16) kernelFunction->propertyCount;
        binary->propertyValueCount  = (gctINT16) kernelFunction->propertyValueCount;
        binary->codeStart           = kernelFunction->codeStart;
        binary->codeCount           = kernelFunction->codeCount;
        binary->codeEnd             = kernelFunction->codeEnd;
        binary->isMain              = (gctUINT16) kernelFunction->isMain;
        binary->nameLength          = (gctINT16) kernelFunction->nameLength;
        binary->die                 = kernelFunction->die;

        if (binary->nameLength > 0)
        {
            /* Compute number of bytes to copy. */
            bytes = gcmALIGN(binary->nameLength, 2);

            /* Copy name. */
            gcoOS_MemCopy(binary->name, kernelFunction->name, bytes);
        }
        else
        {
            bytes = 0;
        }

        /* Adjust buffer pointer. */
        buffer += gcmOFFSETOF(_gcBINARY_KERNEL_FUNCTION, name) + bytes;

        /* Kernel function arguments */
        for (j = 0; j < kernelFunction->argumentCount; j++)
        {
            gcsFUNCTION_ARGUMENT *argument;
            gcBINARY_ARGUMENT binary;

            /* Point to source and binary arguments. */
            argument = &kernelFunction->arguments[j];
            binary = (gcBINARY_ARGUMENT) buffer;

            /* Fill in binary argument. */
            gcoOS_MemCopy((gctPOINTER)&binary->index, &argument->index, sizeof(argument->index));
            binary->enable          = argument->enable;
            binary->qualifier       = argument->qualifier;
            binary->precision       = argument->precision;
            binary->variableIndex   = argument->variableIndex;
            binary->flags           = argument->flags;

            /* Adjust buffer pointer. */
            buffer += sizeof(struct _gcBINARY_ARGUMENT);
        }

        /* Kernel function uniform arguments */
        for (j = 0; j < kernelFunction->uniformArgumentCount; j++)
        {
            gcUNIFORM uniform;
            gcBINARY_UNIFORM_EX binary;

            if (kernelFunction->uniformArguments[j] == gcvNULL) continue;

            /* Point to source and binary uniforms. */
            uniform = kernelFunction->uniformArguments[j];
            binary = (gcBINARY_UNIFORM_EX) buffer;

            /* Fill in binary uniform. */
            binary->varCategory = GetUniformCategory(uniform);
            binary->firstChild = uniform->firstChild;
            binary->nextSibling = uniform->nextSibling;
            binary->prevSibling = uniform->prevSibling;
            binary->parent = uniform->parent;

            if (isUniformNormal(uniform)
                ||  isUniformBlockMember(uniform)
                ||  isUniformBlockAddress(uniform)
               )
                binary->u.type = (gcSHADER_TYPE) uniform->u.type;
            else
                binary->u.numStructureElement = uniform->u.numStructureElement;

            binary->index      = uniform->index;
            binary->arraySize  = (gctINT16) uniform->arraySize;
            binary->arrayLengthCount = (gctUINT16)uniform->arrayLengthCount;
            gcoOS_MemCopy(binary->flags,
                          (gctPOINTER)&uniform->_flags,
                          sizeof(gceUNIFORM_FLAGS));
            binary->blockIndex = uniform->blockIndex;
            gcoOS_MemCopy(binary->arrayStride,
                          (gctPOINTER)&uniform->arrayStride,
                          sizeof(gctINT32));
            gcoOS_MemCopy(binary->offset,
                          (gctPOINTER)&uniform->offset,
                          sizeof(gctINT32));
            binary->format     = (gctUINT16) uniform->format;
            binary->isPointer  = (gctINT16) uniform->isPointer;
            binary->nameLength = (gctINT16) uniform->nameLength;
            binary->glUniformIndex   = uniform->glUniformIndex;
            binary->precision = uniform->precision;
            binary->imageSamplerIndex = uniform->imageSamplerIndex;
            gcoOS_MemCopy(binary->initializer,
                          (gctPOINTER)uniform->initializer.f32_v16,
                          sizeof(gcsValue));
            binary->qualifier = (gctUINT16) uniform->qualifier;
            binary->vectorSize = (gctINT16) uniform->vectorSize;
            gcoOS_MemCopy(&binary->typeNameOffset,
                          &uniform->typeNameOffset,
                          sizeof(binary->typeNameOffset));

            if (binary->arrayLengthCount > 0)
            {
                /* Compute number of bytes to copy. */
                bytes2 = binary->arrayLengthCount * gcmSIZEOF(gctINT);

                /* Copy name. */
                gcoOS_MemCopy(binary->memory, uniform->arrayLengthList, bytes2);
            }
            else
            {
                bytes2 = 0;
            }

            if (binary->nameLength > 0)
            {
                /* Compute number of bytes to copy. */
                bytes = gcmALIGN(binary->nameLength, 2);

                /* Copy name. */
                gcoOS_MemCopy(binary->memory + bytes2, uniform->name, bytes);
            }
            else
            {
                bytes = 0;
            }

            /* Adjust buffer pointer. */
            buffer += gcmOFFSETOF(_gcBINARY_UNIFORM_EX, memory) + bytes + bytes2;
        }

        /* Kernel function image samplers */
        for (j = 0; j < kernelFunction->imageSamplerCount; j++)
        {
            gcsIMAGE_SAMPLER_PTR imageSampler;
            gcBINARY_IMAGE_SAMPLER binary;

            /* Point to source and binary imageSamplers. */
            imageSampler = &kernelFunction->imageSamplers[j];
            binary = (gcBINARY_IMAGE_SAMPLER) buffer;

            /* Fill in binary imageSampler. */
            /*binary->isConstantSamplerType = (gctUINT8) imageSampler->isConstantSamplerType;
            binary->imageNum              = imageSampler->imageNum;
            binary->samplerType           = imageSampler->samplerType;*/

            gcoOS_MemCopy(&binary->isConstantSamplerType,
                          &imageSampler->isConstantSamplerType,
                          sizeof(binary->isConstantSamplerType));

            gcoOS_MemCopy(&binary->imageNum,
                          &imageSampler->imageNum,
                          sizeof(binary->imageNum));

            gcoOS_MemCopy(&binary->samplerType,
                          &imageSampler->samplerType,
                          sizeof(binary->samplerType));

            /* Adjust buffer pointer. */
            buffer += sizeof(struct _gcBINARY_IMAGE_SAMPLER);
        }

        /* Kernel function variables */
        for (j = 0; j < kernelFunction->localVariableCount; j++)
        {
            gcVARIABLE variable;
            gcBINARY_VARIABLE_EX binary;

            if (kernelFunction->localVariables[j] == gcvNULL) continue;

            /* Point to source and binary variables. */
            variable = kernelFunction->localVariables[j];
            binary = (gcBINARY_VARIABLE_EX) buffer;

            /* Fill in binary variable. */
            binary->varCategory = GetVariableCategory(variable);
            binary->firstChild = variable->firstChild;
            binary->nextSibling = variable->nextSibling;
            binary->prevSibling = variable->prevSibling;
            binary->parent = variable->parent;

            if (isVariableSimple(variable))
                binary->u.type = (gcSHADER_TYPE) variable->u.type;
            else
                binary->u.numStructureElement = (gctUINT8)variable->u.numStructureElement;

            binary->blockIndex = variable->blockIndex;
            binary->precision  = variable->precision;
            binary->flags      = variable->flags;
            binary->qualifier  = variable->qualifier;
            binary->arraySize  = (gctINT8) variable->arraySize;
            binary->arrayLengthCount = (gctUINT16)variable->arrayLengthCount;
            gcoOS_MemCopy((gctPOINTER)&binary->tempIndex, &variable->tempIndex, sizeof(variable->tempIndex));

            gcoOS_MemCopy(&binary->arrayStride,
                          &variable->arrayStride,
                          sizeof(binary->arrayStride));

            gcoOS_MemCopy(&binary->offset,
                          &variable->offset,
                          sizeof(binary->offset));

            binary->nameLength = (gctINT16) variable->nameLength;

            if (binary->arrayLengthCount > 0)
            {
                /* Compute number of bytes to copy. */
                bytes2 = binary->arrayLengthCount * gcmSIZEOF(gctINT);

                /* Copy name. */
                gcoOS_MemCopy(binary->memory, variable->arrayLengthList, bytes2);
            }
            else
            {
                bytes2 = 0;
            }

            if (binary->nameLength > 0)
            {
                /* Compute number of bytes to copy. */
                bytes = gcmALIGN(binary->nameLength, 2);

                /* Copy name. */
                gcoOS_MemCopy(binary->memory + bytes2, variable->name, bytes);
            }
            else
            {
                bytes = 0;
            }

            /* Adjust buffer pointer. */
            buffer += gcmOFFSETOF(_gcBINARY_VARIABLE_EX, memory) + bytes + bytes2;
        }

        /* Kernel function properties */
        for (j = 0; j < kernelFunction->propertyCount; j++)
        {
            gcsKERNEL_FUNCTION_PROPERTY_PTR property;
            gcBINARY_KERNEL_FUNCTION_PROPERTY binary;

            /* Point to source and binary properties. */
            property = &kernelFunction->properties[j];
            binary = (gcBINARY_KERNEL_FUNCTION_PROPERTY) buffer;

            /* Fill in binary property. */
            gcoOS_MemCopy(&binary->propertyType, &property->propertyType, sizeof(gctUINT32));
            gcoOS_MemCopy(&binary->propertySize, &property->propertySize, sizeof(gctUINT32));

            /* Adjust buffer pointer. */
            buffer += sizeof(struct _gcBINARY_KERNEL_FUNCTION_PROPERTY);
        }

        /* Kernel function property values */
        for (j = 0; j < kernelFunction->propertyValueCount; j++)
        {
            gcoOS_MemCopy(&((gctINT_PTR)buffer)[j], &kernelFunction->propertyValues[j], sizeof(gctUINT32));
        }

        /* Adjust buffer pointer. */
        buffer += sizeof(gctINT32) * kernelFunction->propertyValueCount;
    }

    /* Private memory size. */
    *(gctUINT16 *) buffer = (gctUINT16) Shader->privateMemorySize;
    buffer += sizeof(gctUINT16);

    /* Constant memory size. */
    *(gctUINT16 *) buffer = (gctUINT16) Shader->constantMemorySize;
    buffer += sizeof(gctUINT16);

    /* Constant memory buffer. */
    if (Shader->constantMemoryBuffer != gcvNULL) {
        gcoOS_MemCopy(buffer, Shader->constantMemoryBuffer, Shader->constantMemorySize);
        buffer += gcmALIGN(Shader->constantMemorySize, 2);
    }

    /* _constVectorId */
    *(gctUINT16 *) buffer = (gctUINT16) Shader->_constVectorId;
    buffer += sizeof(gctUINT16);

    /* _dummyUniformCount */
    *(gctUINT16 *) buffer = (gctUINT16) Shader->_dummyUniformCount;
    buffer += sizeof(gctUINT16);

    /* _tempRegCount */
    gcoOS_MemCopy(buffer, &Shader->_tempRegCount, sizeof(gctUINT32));
    buffer += sizeof(gctUINT32);

    /* _maxLocalTempRegCount */
    gcoOS_MemCopy(buffer, &Shader->_maxLocalTempRegCount, sizeof(gctUINT32));
    buffer += sizeof(gctUINT32);

    /* WorkGroupSize. */
    *(gctUINT16 *) buffer = (gctUINT16)Shader->shaderLayout.compute.isWorkGroupSizeFixed;
    buffer += sizeof(gctUINT16);

    *(gctUINT16 *) buffer = (gctUINT16)Shader->shaderLayout.compute.isWorkGroupSizeAdjusted;
    buffer += sizeof(gctUINT16);

    *(gctUINT16 *) buffer = (gctUINT16)Shader->shaderLayout.compute.adjustedWorkGroupSize;
    buffer += sizeof(gctUINT16);

    /* Optimization option. */
    /**(gctUINT *) buffer = (gctUINT) Shader->optimizationOption;*/
    gcoOS_MemCopy(buffer, &Shader->optimizationOption, sizeof(gctUINT));
    buffer += sizeof(gctUINT);

    /* Code count. */
    /**(gctUINT32 *) buffer = (gctUINT32) Shader->codeCount;*/
    gcoOS_MemCopy(buffer, &Shader->codeCount, sizeof(gctUINT32));
    buffer += sizeof(gctUINT32);

    /* Copy the code. */
    bytes = Shader->codeCount * sizeof(struct _gcSL_INSTRUCTION);
    if (bytes > 0) gcoOS_MemCopy(buffer, Shader->code, bytes);
    buffer += bytes;

    /* Loadtime Optimization related data */

    /* LTC uniform index */
    /**(gctINT *) buffer = Shader->ltcUniformCount;*/
    gcoOS_MemCopy(buffer, &Shader->ltcUniformCount, sizeof(gctINT));
    buffer += sizeof(Shader->ltcUniformCount);

    /**(gctUINT *) buffer = Shader->ltcUniformBegin;*/
    gcoOS_MemCopy(buffer, &Shader->ltcUniformBegin, sizeof(gctUINT));
    buffer += sizeof(Shader->ltcUniformBegin);

    /* LTC expressions */
    /**(gctUINT *) buffer = Shader->ltcInstructionCount;*/
    gcoOS_MemCopy(buffer, &Shader->ltcInstructionCount, sizeof(gctUINT));
    buffer += sizeof(Shader->ltcInstructionCount);

    bytes = sizeof(*Shader->ltcCodeUniformIndex) * Shader->ltcInstructionCount;
    if (bytes > 0) gcoOS_MemCopy(buffer, Shader->ltcCodeUniformIndex, bytes);
    buffer += bytes;

    bytes = sizeof(*Shader->ltcExpressions) * Shader->ltcInstructionCount;
    if (bytes > 0) gcoOS_MemCopy(buffer, Shader->ltcExpressions, bytes);
    buffer += bytes;

    /* Type name buffer size. */
    gcoOS_MemCopy(buffer, &Shader->typeNameBufferSize, sizeof(gctUINT));
    buffer += sizeof(gctUINT);

    /* Type name buffer. */
    if (Shader->typeNameBufferSize) {
        gcmASSERT(Shader->typeNameBuffer);
        gcoOS_MemCopy(buffer, Shader->typeNameBuffer, Shader->typeNameBufferSize);
        buffer += gcmALIGN(Shader->typeNameBufferSize, 2);
    }

    ptr = (gctPOINTER) buffer;
    vscDISaveDebugInfo((VSC_DIContext * )(Shader->debugInfo), &ptr, gcvNULL);

    /* Success. */
    gcmFOOTER_ARG("*BufferSize=%lu", *BufferSize);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddInputLocation
**
**  Add a location for an input to Shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctINT Location
**          Location to add.
**
**      gctUINT32 Length
**          Array length of the location to add.  'Length' must be at least 1.
*/
gceSTATUS
gcSHADER_AddInputLocation(
    IN gcSHADER Shader,
    IN gctINT Location,
    IN gctUINT32 Length
    )
{
    gctINT  * locations;
    gctUINT32 i;
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Location=%d Length=%lu", Shader, Location, Length);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check location array count. */
    if (Shader->inputLocationArraySize < Shader->inputLocationCount + Length)
    {
        gctPOINTER pointer = gcvNULL;

        /* Allocate a new array of object pointers. */
        status = gcoOS_Allocate(gcvNULL,
                                gcmSIZEOF(gcATTRIBUTE) * (Shader->inputLocationCount + Length + 9),
                                &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        locations = pointer;

        if (Shader->inputLocations != gcvNULL)
        {
            /* Copy the current object pointers. */
            gcoOS_MemCopy(locations,
                          Shader->inputLocations,
                          gcmSIZEOF(locations)
                          * Shader->inputLocationCount);

            /* Free the current array of locations. */
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->inputLocations));
        }

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
        Shader->inputLocationArraySize = Shader->inputLocationCount + Length + 9;
        Shader->inputLocations = locations;
    }

    for(i = 0; i < Length; i++) {
        Shader->inputLocations[Shader->inputLocationCount++] = Location;
        if(Location != -1) Location++;
    }

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}


/*******************************************************************************
**  gcSHADER_AddOutputLocation
**
**  Add a location for an output to Shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctINT Location
**          Location to add.
**
**      gctUINT32 Length
**          Array length of the location to add.  'Length' must be at least 1.
*/
gceSTATUS
gcSHADER_AddOutputLocation(
    IN gcSHADER Shader,
    IN gctINT Location,
    IN gctUINT32 Length
    )
{
    gctINT  * locations;
    gctUINT32 i;
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Location=%d Length=%lu", Shader, Location, Length);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check location array count. */
    if (Shader->outputLocationArraySize < Shader->outputLocationCount + Length)
    {
        gctPOINTER pointer = gcvNULL;

        /* Allocate a new array of object pointers. */
        status = gcoOS_Allocate(gcvNULL,
                                gcmSIZEOF(gcATTRIBUTE) * (Shader->outputLocationCount + Length + 9),
                                &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        locations = pointer;

        if (Shader->outputLocations != gcvNULL)
        {
            /* Copy the current object pointers. */
            gcoOS_MemCopy(locations,
                          Shader->outputLocations,
                          gcmSIZEOF(locations)
                          * Shader->outputLocationCount);

            /* Free the current array of locations. */
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->outputLocations));
        }

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
        Shader->outputLocationArraySize = Shader->outputLocationCount + Length + 9;
        Shader->outputLocations = locations;
    }

    for (i = 0; i < Length; i++)
    {
        Shader->outputLocations[Shader->outputLocationCount++] = Location;
        if (Location != -1) Location++;
    }

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetLocationCount
**
**  Get the number of input/output locations for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of locations.
*/
gceSTATUS
gcSHADER_GetLocationCount(
    IN gcSHADER Shader,
    IN gctBOOL Input,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    /* Return attribute count. */
    if (Input)
    {
        *Count = Shader->inputLocationCount;
    }
    else
    {
        *Count = Shader->outputLocationCount;
    }

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetLocation
**
**  Get the location assocated with an indexed input/output for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT Index
**          Index of input/output to retreive the location setting for.
**
**  OUTPUT:
**
**      gctINT * Location
**          Pointer to a variable receiving the location value.
*/
gceSTATUS
gcSHADER_GetLocation(
    IN gcSHADER Shader,
    IN gctUINT Index,
    IN gctBOOL Input,
    OUT gctINT * Location
    )
{
    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Location != gcvNULL);

    if (Input)
    {
        gcmASSERT(Index < Shader->inputLocationCount);

        /* Return the gcATTRIBUTE object pointer. */
        *Location = (gctINT)Shader->inputLocations[Index];
    }
    else
    {
        gcmASSERT(Index < Shader->outputLocationCount);

        /* Return the gcATTRIBUTE object pointer. */
        *Location = (gctINT)Shader->outputLocations[Index];
    }

    /* Success. */
    gcmFOOTER_ARG("*Location=%d", *Location);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetBuiltinNameKind
**
**  Get the builtin name kind for the Name.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          String of the name.
**
**  OUTPUT:
**
**      gceBuiltinNameKind * Kind
**          Pointer to a variable receiving the builtin name kind value.
*/
gceSTATUS
gcSHADER_GetBuiltinNameKind(
    IN gcSHADER              Shader,
    IN gctCONST_STRING       Name,
    OUT gctUINT32 *          Kind
    )
{
    gceBuiltinNameKind kind = gcSL_NONBUILTINGNAME;
    gctCONST_STRING    ptr  = Name;

    if (Name[0] == '#')
    {
        ptr = Name + 1;
    }
    else if (Name[0] == 'g' && Name[1] == 'l' && Name[2] == '_')
    {
        ptr = Name + 3;
    }
    else
    {
        *Kind = gcSL_NONBUILTINGNAME;
        return gcvSTATUS_OK;
    }

    if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "Position")))
    {
        kind = gcSL_POSITION;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "PointSize")))
    {
        kind = gcSL_POINT_SIZE;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "In_Position")))
    {
        kind = gcSL_IN_POSITION;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "In_PointSize")))
    {
        kind = gcSL_IN_POINT_SIZE;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "Color")))
    {
        kind = gcSL_COLOR;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "FrontFacing")))
    {
        kind = gcSL_FRONT_FACING;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "PointCoord")))
    {
        kind = gcSL_POINT_COORD;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "Position.w")))
    {
        kind = gcSL_POSITION_W;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "FogFragCoord")))
    {
        kind = gcSL_FOG_COORD;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "VertexID")))
    {
        kind = gcSL_VERTEX_ID;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "InstanceID")))
    {
        kind = gcSL_INSTANCE_ID;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "Depth")))
    {
        kind = gcSL_DEPTH;
    }
    else if(gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "FrontColor")))
    {
        kind = gcSL_FRONT_COLOR;
    }
    else if(gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "BackColor")))
    {
        kind = gcSL_BACK_COLOR;
    }
    else if(gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "FrontSecondaryColor")))
    {
        kind = gcSL_FRONT_SECONDARY_COLOR;
    }
    else if(gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "BackSecondaryColor")))
    {
        kind = gcSL_BACK_SECONDARY_COLOR;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "group_id")) ||
             gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "WorkGroupID")))
    {
        kind = gcSL_WORK_GROUP_ID;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "local_id")))
    {
        kind = gcSL_LOCAL_INVOCATION_ID;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "global_id")))
    {
        kind = gcSL_GLOBAL_INVOCATION_ID;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "HelperInvocation")))
    {
        kind = gcSL_HELPER_INVOCATION;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "Subsample_Depth")))
    {
        kind = gcSL_SUBSAMPLE_DEPTH;
    }
    /* TS built-in name. */
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "in")))
    {
        kind = gcSL_IN;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "PatchVerticesIn")))
    {
        kind = gcSL_PATCH_VERTICES_IN;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "PrimitiveID")))
    {
        kind = gcSL_PRIMITIVE_ID;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "InvocationID")))
    {
        kind = gcSL_INVOCATION_ID;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "TessLevelOuter")))
    {
        kind = gcSL_TESS_LEVEL_OUTER;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "TessLevelInner")))
    {
        kind = gcSL_TESS_LEVEL_INNER;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "out")))
    {
        kind = gcSL_OUT;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "TessCoord")))
    {
        kind = gcSL_TESS_COORD;
    }
    /* sample shading variables. */
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "SampleID")))
    {
        kind = gcSL_SAMPLE_ID;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "SamplePosition")))
    {
        kind = gcSL_SAMPLE_POSITION;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "SampleMaskIn")))
    {
        kind = gcSL_SAMPLE_MASK_IN;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "SampleMask")))
    {
        kind = gcSL_SAMPLE_MASK;
    }
    /* GS variables. */
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "Layer")))
    {
        kind = gcSL_LAYER;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "PrimitiveIDIn")))
    {
        kind = gcSL_PRIMITIVE_ID_IN;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "BoundingBox")))
    {
        kind = gcSL_BOUNDING_BOX;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrCmp(ptr, "LastFragData")))
    {
        kind = gcSL_LAST_FRAG_DATA;
    }
    else
    {
        if (Name[0] == '#')
        {
            *Kind = gcSL_NONBUILTINGNAME;
            return gcvSTATUS_OK;
        }
        gcmASSERT(gcvFALSE);  /* something wrong, builtin name not handled? */
    }

    /* Return the gcATTRIBUTE object pointer. */
    *Kind = (gctUINT32)kind;

    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetBuiltinNameString
**
**  Get the builtin name corresponding to its kind.
**
**  INPUT:
**
**      gctUINT32 Kind
**          Builtin name kind.
**
**  RETURN:
**
**      gctCONST_STRING
**          Pointer to the builtin name string.
*/
gctCONST_STRING
gcSHADER_GetBuiltinNameString(
    IN gctINT Kind
    )
{
    static gctCONST_STRING sBuildinNames[] =
    {
        "gl_Position", /* -1:  gcSL_POSITION */
        "gl_PointSize", /* -2:  gcSL_POINT_SIZE */
        "gl_Color", /* -3:  gcSL_COLOR */
        "gl_FrontFacing", /* -4:  gcSL_FRONT_FACING */
        "gl_PointCoord", /* -5:  gcSL_POINT_COORD */
        "gl_Position.w", /* -6:  gcSL_POSITION_W */
        "gl_Depth", /* -7:  gcSL_DEPTH */
        "gl_FogFragCoord", /* -8:  gcSL_FOG_COORD */
        "gl_VertexID", /* -9:  gcSL_VERTEX_ID */
        "gl_InstanceID", /* -10: gcSL_INSTANCE_ID */
        "gl_WorkGroupID", /* -11: gcSL_WORK_GROUP_ID */
        "gl_LocalInvocationID", /* -12: gcSL_LOCAL_INVOCATION_ID */
        "gl_GlobalInvocationID", /* -13: gcSL_GLOBAL_INVOCATION_ID */
        "gl_HelperInvocation", /* -14: gcSL_HELPER_INVOCATION */
        "gl_FrontColor", /* -15: gcSL_FRONT_COLOR */
        "gl_BackColor", /* -16: gcSL_BACK_COLOR */
        "gl_FrontSeconaryColor", /* -17: gcSL_FRONT_SECONDARY_COLOR */
        "gl_BackSeconaryColor", /* -18: gcSL_BACK_SECONDARY_COLOR */
        "gl_Tex_Coord", /* -19: gcSL_TEX_COORD */
        "#Subsample_Depth", /* -20: gcSL_SUBSAMPLE_DEPTH internal subsample_depth register */
        "gl_PerVertex", /* -21 gcSL_PERVERTEX  */
        "gl_in", /* -22 gcSL_IN */
        "gl_out", /* -23 gcSL_OUT */
        "gl_InvocationID", /* -24 gcSL_INVOCATION_ID */
        "gl_PatchVerticesIn", /* -25 gcSL_PATCH_VERTICES_IN */
        "gl_PrimitiveID", /* -26 gcSL_PRIMITIVE_ID */
        "gl_TessLevelOuter", /* -27 gcSL_TESS_LEVEL_OUTER */
        "gl_TessLevelInner", /* -28 gcSL_TESS_LEVEL_INNER */
        "gl_Layer", /* -29 gcSL_LAYER */
        "gl_PrimitiveIDIn", /* -30 gcSL_PRIMITIVE_ID_IN */
        "gl_TessCoord", /* -31 gcSL_TESS_COORD */
        "gl_SampleID", /* -32 gcSL_SAMPLE_ID */
        "gl_SamplePosition", /* -33 gcSL_SAMPLE_POSITION */
        "gl_SampleMaskIn", /* -34 gcSL_SAMPLE_MASK_IN */
        "gl_SampleMask", /* -35 gcSL_SAMPLE_MASK */
        "gl_in.gl_Position", /* -36 gcSL_IN_POSITION */
        "gl_in.gl_PointSize", /* -37 gcSL_IN_POINTSIZE */
        "gl_BoundingBox", /* -38 gcSL_BOUNDING_BOX */
        "gl_LastFragData", /* -39 gcSL_LAST_FRAG_DATA */
    };

    if (Kind < 0 && Kind > (-1 - (gctINT)gcmCOUNTOF(sBuildinNames)))
    {
        return  sBuildinNames[-1 - Kind];
    }

    return gcvNULL;
}

gceSTATUS
gcSHADER_NewAttribute(
    IN gcSHADER             Shader,
    IN gctCONST_STRING      Name,
    IN gcSHADER_TYPE        Type,
    IN gctUINT32            Length,
    IN gctBOOL              IsTexture,
    IN gcSHADER_SHADERMODE  ShaderMode,
    IN gcSHADER_PRECISION   Precision,
    OUT gcATTRIBUTE *       Attribute
    )
{
    gctUINT32 nameLength, bytes;
    gcATTRIBUTE attribute;
    gceSTATUS status;
    gctBOOL copyName;
    gctBOOL pointSpriteTex = gcvFALSE;
    gctPOINTER pointer = gcvNULL;
    gctUINT32 kind;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d Length=%lu IsTexture=%d",
                  Shader, Name, Type, Length, IsTexture);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    *Attribute = gcvNULL;

    if (IsTexture != 0)
    {
        pointSpriteTex = ((IsTexture & POINTSPRITE_TEX_ATTRIBUTE) != 0);
        IsTexture = gcvTRUE;
    }

    /* Get the length of the name. */
    nameLength = gcoOS_StrLen(Name, gcvNULL);

    if (gcmIS_SUCCESS(gcSHADER_GetBuiltinNameKind(Shader, Name, &kind)) &&
        kind != gcSL_NONBUILTINGNAME)
    {
        nameLength = kind;
        bytes      = gcmOFFSETOF(_gcATTRIBUTE, name);
        copyName   = gcvFALSE;
    }
    else
    {
        /* Compute the number of bytes required for the gcATTRIBUTE object. */
        bytes    = gcmOFFSETOF(_gcATTRIBUTE, name) + nameLength + 1;
        copyName = gcvTRUE;
    }

    /* Allocate the gcATTRIBUTE object. */
    gcmONERROR(gcoOS_Allocate(gcvNULL, bytes, &pointer));

    attribute = (gcATTRIBUTE)pointer;

    gcoOS_ZeroMemory(attribute, bytes);

    /* Initialize the gcATTRIBUTE object. */
    attribute->object.type           = gcvOBJ_ATTRIBUTE;
    attribute->index                 = (gctUINT16) Shader->attributeCount;
    attribute->type                  = Type;
    attribute->precision             = Precision;
    attribute->arraySize             = Length;
    attribute->arrayLength           = Length > 1 ? 1 : 0;
    attribute->flags_                = 0;
    attribute->inputIndex            = -1;
    attribute->shaderMode            = ShaderMode;
    attribute->componentShadeMode[0] = ShaderMode;
    attribute->componentShadeMode[1] = ShaderMode;
    attribute->componentShadeMode[2] = ShaderMode;
    attribute->componentShadeMode[3] = ShaderMode;
    attribute->location              = -1;
    attribute->fieldIndex            = -1;
    attribute->nameLength            = nameLength;
    attribute->ioBlockIndex          = -1;
    attribute->ioBlockArrayIndex     = 0;
    attribute->nextSibling           = -1;
    attribute->prevSibling           = -1;
    attribute->typeNameVarIndex      = -1;

    gcmATTRIBUTE_SetIsTexture(attribute, IsTexture);
    gcmATTRIBUTE_SetEnabled(attribute, gcvTRUE);
    gcmATTRIBUTE_SetPointspriteTc (attribute, pointSpriteTex);

    if (copyName)
    {
        /* Copy the attribute name. */
        gcoOS_MemCopy(attribute->name, Name, nameLength + 1);
    }
    *Attribute = attribute;

OnError:
    gcmFOOTER();
    return status;
}
/*******************************************************************************
**  gcSHADER_ReallocateAttributes
**
**  Reallocate an array of pointers to gcATTRIBUTE objects.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcSHADER_ReallocateAttributes(
    IN gcSHADER Shader,
    IN gctUINT32 Count
    )
{
    gcATTRIBUTE * attributes;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Count=%lu", Shader, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Count < Shader->attributeCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Shader->attributeArraySize)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcATTRIBUTE) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    attributes = pointer;

    gcoOS_ZeroMemory(attributes, gcmSIZEOF(gcATTRIBUTE) * Count);

    if (Shader->attributes != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(attributes,
                      Shader->attributes,
                      gcmSIZEOF(gcATTRIBUTE)
                      * Shader->attributeCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->attributes));
    }

    /* Set new gcATTRIBTE object pointer. */
    Shader->attributeArraySize = Count;
    Shader->attributes          = attributes;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddAttribute
**
**  Add an attribute to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          Name of the attribute to add.
**
**      gcSHADER_TYPE Type
**          Type of the attribute to add.
**
**      gctUINT32 Length
**          Array length of the attribute to add.  'Length' must be at least 1.
**
**      gctBOOL IsTexture
**          gcvTRUE if the attribute is used as a texture coordinate, gcvFALSE if not.
**
**  OUTPUT:
**
**      gcATTRIBUTE * Attribute
**          Pointer to a variable receiving the gcATTRIBUTE object pointer.
*/
gceSTATUS
gcSHADER_AddAttribute(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gctUINT32 Length,
    IN gctBOOL IsTexture,
    IN gcSHADER_SHADERMODE ShaderMode,
    IN gcSHADER_PRECISION Precision,
    OUT gcATTRIBUTE * Attribute
    )
{
    gcATTRIBUTE     attribute;
    gceSTATUS       status;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d Length=%lu IsTexture=%d",
                  Shader, Name, Type, Length, IsTexture);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check array count. */
    if (Shader->attributeArraySize <= Shader->attributeCount)
    {
        /* Reallocate a new array of object pointers. */
        gcmONERROR(gcSHADER_ReallocateAttributes(Shader, Shader->attributeCount + 10));
    }

    gcmONERROR(gcSHADER_NewAttribute(Shader,
                                     Name,
                                     Type,
                                     Length,
                                     IsTexture,
                                     ShaderMode,
                                     Precision,
                                     &attribute));


    /* Set new gcATTRIBTE object pointer. */
    Shader->attributes[Shader->attributeCount++] = attribute;

    if (Attribute != gcvNULL)
    {
        /* Return the gcATTRIBUTE object pointer. */
        *Attribute = attribute;
    }

OnError:
    gcmFOOTER_ARG("*Attribute=0x%x", gcmOPT_POINTER(Attribute));
    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddAttributeWithLocation
**
**  Add an attribute together with a location to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          Name of the attribute to add.
**
**      gcSHADER_TYPE Type
**          Type of the attribute to add.
**
**      gcSHADER_PRECISION Precision,
**          Precision of the attribute to add.
**
**      gctUINT32 Length
**          Array length of the attribute to add.  'Length' must be at least 1.
**
**      gctBOOL IsTexture
**          gcvTRUE if the attribute is used as a texture coordinate, gcvFALSE if not.
**
**      gctINT Location
**          Location associated with the attribute.
**
**  OUTPUT:
**
**      gcATTRIBUTE * Attribute
**          Pointer to a variable receiving the gcATTRIBUTE object pointer.
*/
gceSTATUS
gcSHADER_AddAttributeWithLocation(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gcSHADER_PRECISION Precision,
    IN gctUINT32 Length,
    IN gctUINT32 ArrayLengthCount,
    IN gctBOOL IsTexture,
    IN gcSHADER_SHADERMODE ShaderMode,
    IN gctINT Location,
    IN gctINT FieldIndex,
    IN gctBOOL IsInvariant,
    IN gctBOOL IsPrecise,
    OUT gcATTRIBUTE * Attribute
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcATTRIBUTE attribute;
    gctUINT32 nameLength, bytes;
    gctBOOL copyName;
    gctPOINTER pointer = gcvNULL;
    gctUINT32 kind;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d Length=%lu IsTexture=%d, Location=%d",
                  Shader, Name, Type, Length, IsTexture, Location);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check array count. */
    if (Shader->attributeArraySize <= Shader->attributeCount)
    {
        /* Reallocate a new array of object pointers. */
        gcmONERROR(gcSHADER_ReallocateAttributes(Shader, Shader->attributeCount + 10));
    }

    /* Get the length of the name. */
    nameLength = gcoOS_StrLen(Name, gcvNULL);

    if (gcmIS_SUCCESS(gcSHADER_GetBuiltinNameKind(Shader, Name, &kind)) &&
        kind != gcSL_NONBUILTINGNAME)
    {
        nameLength = kind;
        bytes      = gcmOFFSETOF(_gcATTRIBUTE, name);
        copyName   = gcvFALSE;
    }
    else
    {
        /* Compute the number of bytes required for the gcATTRIBUTE object. */
        bytes    = gcmOFFSETOF(_gcATTRIBUTE, name) + nameLength + 1;
        copyName = gcvTRUE;
    }

    /* Allocate the gcATTRIBUTE object. */
    gcmONERROR(gcoOS_Allocate(gcvNULL, bytes, &pointer));

    attribute = (gcATTRIBUTE)pointer;

    gcoOS_ZeroMemory(attribute, bytes);

    /* Initialize the gcATTRIBUTE object. */
    attribute->object.type                  = gcvOBJ_ATTRIBUTE;
    attribute->index                        = (gctUINT16) Shader->attributeCount;
    attribute->type                         = Type;
    attribute->precision                    = gcSHADER_PRECISION_DEFAULT;
    attribute->arraySize                    = (gctINT)Length;
    attribute->arrayLength                  = (gctINT)ArrayLengthCount;
    attribute->flags_                       = 0;
    gcmATTRIBUTE_SetIsTexture(attribute, IsTexture);
    gcmATTRIBUTE_SetEnabled(attribute, gcvTRUE);
    gcmATTRIBUTE_SetIsInvariant(attribute, IsInvariant);
    gcmATTRIBUTE_SetIsPrecise(attribute, IsPrecise);
    attribute->inputIndex                   = -1;
    attribute->shaderMode                   = ShaderMode;
    attribute->componentShadeMode[0]        = ShaderMode;
    attribute->componentShadeMode[1]        = ShaderMode;
    attribute->componentShadeMode[2]        = ShaderMode;
    attribute->componentShadeMode[3]        = ShaderMode;
    attribute->location                     = -1;
    attribute->fieldIndex                   = -1;
    attribute->nameLength                   = nameLength;
    attribute->ioBlockIndex                 = -1;
    attribute->ioBlockArrayIndex            = 0;
    attribute->nextSibling                  = -1;
    attribute->prevSibling                  = -1;
    attribute->typeNameVarIndex             = -1;

    if (copyName)
    {
        /* Copy the attribute name. */
        gcoOS_MemCopy(attribute->name, Name, nameLength + 1);
    }

    Shader->attributes[Shader->attributeCount++] = attribute;

    /*Set the precision on the attribute */
    gcmONERROR(gcATTRIBUTE_SetPrecision(attribute, Precision));

    /* here the length argument is 1 as array attributes are not split */
    gcmONERROR(gcSHADER_AddInputLocation(Shader,
                                         Location,
                                         1));
    attribute->location = Location;
    attribute->fieldIndex  = FieldIndex;

    if (Attribute != gcvNULL)
    {
        /* Return the gcATTRIBUTE object pointer. */
        *Attribute = attribute;
    }

OnError:
    gcmFOOTER_ARG("*Attribute=0x%x", gcmOPT_POINTER(Attribute));
    /* Success. */
    return status;
}

/*******************************************************************************
**  gcSHADER_GetVertexInstIDInputIndex
**
**  Get the input index of vertex/instance ID for this shader.
**  return -1 if no vertex/instance ID is used in the shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
*/
gctINT
gcSHADER_GetVertexInstIdInputIndex(
    IN gcSHADER Shader
    )
{
    gctINT inputIndex = -1;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if(Shader->type == gcSHADER_TYPE_VERTEX &&
       gcHWCaps.hwFeatureFlags.vtxInstanceIdAsAttr)
    {
        gctINT i;
        gctBOOL hasVertexInstId = gcvFALSE;

        for (i = 0; i < (gctINT)Shader->variableCount; ++i)
        {
            gcVARIABLE variable = Shader->variables[i];

            if(!variable) continue;

            if(isVariableNormal(variable) &&
               ((gctINT)variable->nameLength < 0))
            {
                if (variable->nameLength == gcSL_INSTANCE_ID ||
                    variable->nameLength == gcSL_VERTEX_ID)
                {
                    hasVertexInstId = gcvTRUE;
                    break;
                }
            }
        }
        if(hasVertexInstId)
        {
            gcATTRIBUTE attribute;
            gctUINT32 components = 0, rows = 0;

            inputIndex = 0;
            /* find the last used attribute, and calculate its register usage
             * the VertexId and InstanceID is the register after that last
             * attribute's end register */
            for (i = (gctINT)Shader->attributeCount - 1; i >= 0; i--)
            {
                attribute = Shader->attributes[i];

                if(!attribute || !gcmATTRIBUTE_enabled(attribute)
                              || attribute->inputIndex == -1) continue;

                /* Determine rows and components. */
                gcTYPE_GetTypeInfo(attribute->type, &components, &rows, 0);
                rows *= attribute->arraySize;

                inputIndex = attribute->inputIndex + rows;
                break;
            }
            if (inputIndex == 0)
            {
                /* special handle for HW which doesn't support zero attribute,
                 * driver needs to add one dummy input, vertexID is allocated
                 * to r1 by regAllocator, here we need to tell driver that
                 * we have one dummy input */
                if (!gcHWCaps.hwFeatureFlags.supportZeroAttrsInFE)
                {
                    inputIndex = 1;
                }
            }
        }
    }

    /* Success. */
    gcmFOOTER_ARG("VertexInstIdInputIndex=%d", inputIndex);
    return inputIndex;
}

/*******************************************************************************
**  gcSHADER_GetAttributeCount
**
**  Get the number of attributes for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of attributes.
*/
gceSTATUS
gcSHADER_GetAttributeCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    /* Return attribute count. */
    *Count = Shader->attributeCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

static gceSTATUS
_convertVariableToAttribute(
    IN gcSHADER         Shader,
    IN gcVARIABLE       Variable,
    OUT gcATTRIBUTE *   Attribute
    )
{
    gceSTATUS           status = gcvSTATUS_OK;
    gctCONST_STRING     name;

    if (GetVariableNameLength(Variable) < 0)
    {
        /* special name */
        name = _PredefinedName(Shader, (gctUINT32)GetVariableNameLength(Variable), gcvTRUE);
        gcmASSERT(name != gcvNULL);
    }
    else
    {
        name = GetVariableName(Variable);
    }
    gcmONERROR(gcSHADER_NewAttribute(Shader,
                                     name,
                                     GetVariableType(Variable),
                                     GetVariableArraySize(Variable),
                                     gcvFALSE, /* used as texture coord? */
                                     gcSHADER_SHADER_DEFAULT,
                                     Variable->precision,
                                     Attribute));

OnError:
    return status;
}

static gceSTATUS
_checkBuiltinInputs(
    IN gcSHADER Shader
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctINT builinInputCount = (gcShaderHasVertexIdVar(Shader) ? 1 : 0) +
                              (gcShaderHasInstanceIdVar(Shader) ? 1 : 0);

    if ((builinInputCount > 0) &&
        Shader->builtinAttributeCount == 0)
    {
        gctINT instanceIdVarIndex = -1;
        gctINT vertexIdVarIndex = -1;
        gctUINT i;
        gcATTRIBUTE attribute;

        for (i = 0; i < Shader->variableCount; ++i)
        {
            gcVARIABLE variable = Shader->variables[i];

            if(!variable) continue;

            if(instanceIdVarIndex != -1 && vertexIdVarIndex != -1) break;

            if(isVariableNormal(variable) &&
                ((gctINT)variable->nameLength < 0))
            {
                if (instanceIdVarIndex == -1 && variable->nameLength == gcSL_INSTANCE_ID)
                {
                    instanceIdVarIndex = i;
                }
                else if (vertexIdVarIndex == -1 && variable->nameLength == gcSL_VERTEX_ID &&
                         !GetVariableIsCompilerGenerated(variable))
                {
                    vertexIdVarIndex = i;
                }
            }
        }
        /* the faked attribute is not constructed yet */
        if (vertexIdVarIndex != -1)
        {
            gcmONERROR(_convertVariableToAttribute(Shader,
                                        Shader->variables[vertexIdVarIndex],
                                        &attribute));
            Shader->builtinAttributes[Shader->builtinAttributeCount++] = attribute;
        }
        if (instanceIdVarIndex != -1)
        {
            gcmONERROR(_convertVariableToAttribute(Shader,
                                        Shader->variables[instanceIdVarIndex],
                                        &attribute));
            Shader->builtinAttributes[Shader->builtinAttributeCount++] = attribute;
        }
    }

OnError:
    return status;
}

/*******************************************************************************
**  gcSHADER_GetAttributeAndBuiltinInputCount
**
**  Get the number of attributes including builtin inputs for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of attributes including builtin inputs.
*/
gceSTATUS
gcSHADER_GetAttributeAndBuiltinInputCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    /* check builtin inputs */
    _checkBuiltinInputs(Shader);

    /* Return attribute count. */
    *Count = Shader->attributeCount + Shader->builtinAttributeCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetAttribute
**
**  Get the gcATTRIBUTE object poniter for an indexed attribute for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT Index
**          Index of attribute to retreive the name for.
**
**  OUTPUT:
**
**      gcATTRIBUTE * Attribute
**          Pointer to a variable receiving the gcATTRIBUTE object pointer.
*/
gceSTATUS
gcSHADER_GetAttribute(
    IN gcSHADER Shader,
    IN gctUINT Index,
    OUT gcATTRIBUTE * Attribute
    )
{
    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Index < (Shader->attributeCount + Shader->builtinAttributeCount));
    gcmDEBUG_VERIFY_ARGUMENT(Attribute != gcvNULL);

    /* Return the gcATTRIBUTE object pointer. */
    if (Index < Shader->attributeCount)
    {
        *Attribute = Shader->attributes[Index];
    }
    else
    {
        gcmASSERT(Index - Shader->attributeCount < 2 );
        *Attribute = Shader->builtinAttributes[Index - Shader->attributeCount];
    }

    /* Success. */
    gcmFOOTER_ARG("*Attribute=0x%x", *Attribute);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                            gcSHADER_GetAttributeByName
********************************************************************************
**
**    Get the gcATTRIBUTE object poniter for an name attribute for this shader.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gctSTRING name
**            Name of output to retrieve.
**
**        gctUINT32 nameLength
**            Length of name to retrieve
**
**    OUTPUT:
**
**        gcATTRIBUTE * Attribute
**            Pointer to a variable receiving the gcATTRIBUTE object pointer.
*/
gceSTATUS
gcSHADER_GetAttributeByName(
    IN gcSHADER Shader,
    IN gctSTRING Name,
    IN gctUINT32 NameLength,
    OUT gcATTRIBUTE * Attribute
    )
{
    gctUINT32 idx;

    gcmHEADER_ARG("Shader=0x%x Name=0x%x", Shader, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Attribute != gcvNULL);

    *Attribute = gcvNULL;
    /* special handling gl_VertexID and gl_InstanceID */
    if ((sizeof("gl_VertexID") == NameLength) &&
        Name &&
        (gcmIS_SUCCESS(gcoOS_MemCmp("gl_VertexID", Name, sizeof("gl_VertexID")))))
    {
        /* gl_VertexID is always in front of gl_InstanceID */
        if (gcShaderHasVertexIdVar(Shader))
        {
            gcmASSERT(Shader->builtinAttributes[0] &&
                      Shader->builtinAttributes[0]->nameLength == gcSL_VERTEX_ID);
            *Attribute = Shader->builtinAttributes[0];
        }
    }
    else if ((sizeof("gl_InstanceID") == NameLength) &&
             Name &&
             (gcmIS_SUCCESS(gcoOS_MemCmp("gl_InstanceID", Name, sizeof("gl_InstanceID")))))
    {
        if (gcShaderHasVertexIdVar(Shader))
        {
            gcmASSERT(Shader->builtinAttributes[0]);
            if (Shader->builtinAttributes[0]->nameLength == gcSL_INSTANCE_ID)
            {
                *Attribute = Shader->builtinAttributes[0];
            }
            else
            {
                gcmASSERT(Shader->builtinAttributes[0]->nameLength == gcSL_VERTEX_ID);
                gcmASSERT(Shader->builtinAttributes[1]->nameLength == gcSL_INSTANCE_ID);
                *Attribute = Shader->builtinAttributes[1];
            }
        }
    }
    else
    {
        for (idx = 0; idx < Shader->attributeCount; idx++)
        {
            gcATTRIBUTE attribute = Shader->attributes[idx];

            if (attribute && attribute->nameLength == (gctINT) NameLength)
            {
                if (Name == gcvNULL)
                {
                    break;
                }
                else if (gcmIS_SUCCESS(gcoOS_MemCmp(attribute->name,
                                       Name,
                                       NameLength)))
                {
                    break;
                }
            }
        }

        if (idx < Shader->attributeCount)
            *Attribute = Shader->attributes[idx];
    }

    /* Success. */
    gcmFOOTER_ARG("*Attribute=0x%x", *Attribute);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_ReallocateUniforms
**
**  Reallocate an array of pointers to gcUNIFORM objects.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcSHADER_ReallocateUniforms(
    IN gcSHADER Shader,
    IN gctUINT32 Count
    )
{
    gcUNIFORM * uniforms;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Count=%lu", Shader, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Count < Shader->uniformCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Shader->uniformArraySize)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcUNIFORM) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    uniforms = pointer;

    if (Shader->uniforms != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(uniforms,
                      Shader->uniforms,
                      gcmSIZEOF(gcUNIFORM) * Shader->uniformCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->uniforms));
    }

    /* Set new gcUNIFORM object pointer. */
    Shader->uniformArraySize = Count;
    Shader->uniforms         = uniforms;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

/* find the uniform with Name in the Shader,
 * if found, return it in *Uniform
 * otherwise add the uniform to shader
 */
gceSTATUS
gcSHADER_FindAddUniform(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gctUINT32 Length,
    IN gcSHADER_PRECISION Precision,
    OUT gcUNIFORM * Uniform
    )
{
    gceSTATUS   status = gcvSTATUS_OK;
    gctUINT     i;
    gcUNIFORM   uniform;
    gctINT      nameLength = (gctINT)gcoOS_StrLen(Name, gcvNULL);
    for (i = 0; i < Shader->uniformCount; i++)
    {
        uniform = Shader->uniforms[i];
        if (uniform && nameLength == uniform->nameLength &&
            gcmIS_SUCCESS(gcoOS_StrCmp(Name, uniform->name)))
        {
            *Uniform  = uniform;
            if (uniform->u.type != Type)
            {
                status = gcvSTATUS_UNIFORM_MISMATCH;
            }
            return status;
        }
    }

    return gcSHADER_AddUniform(Shader, Name, Type, Length, Precision, Uniform);
}

/*******************************************************************************
**  gcSHADER_AddUniform
**
**  Add an uniform to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          Name of the uniform to add.
**
**      gcSHADER_TYPE Type
**          Type of the uniform to add.
**
**      gctUINT32 Length
**          Array length of the uniform to add.  'Length' must be at least 1.
**
**  OUTPUT:
**
**      gcUNIFORM * Uniform
**          Pointer to a variable receiving the gcUNIFORM object pointer.
*/
gceSTATUS
gcSHADER_AddUniform(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gctUINT32 Length,
    IN gcSHADER_PRECISION Precision,
    OUT gcUNIFORM * Uniform
    )
{
    gctUINT32 nameLength=0, bytes;
    gcUNIFORM uniform;
    gceSTATUS status;
    gctPOINTER pointer;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d Length=%lu",
                  Shader, Name, Type, Length);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check array count. */
    if (Shader->uniformArraySize <= Shader->uniformCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateUniforms(Shader, Shader->uniformCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Get the length of the name. */
    nameLength = gcoOS_StrLen(Name, gcvNULL);

    /* Compute the number of bytes required for the gcUNIFORM object. */
    bytes = gcmOFFSETOF(_gcUNIFORM, name) + nameLength + 1;

    /* Allocate the gcUNIFORM object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    uniform = pointer;

    /* Clear the memory in case some union member was partially written */
    gcoOS_ZeroMemory(uniform, bytes);

    /* Initialize the gcUNIFORM object. */
    uniform->object.type  = gcvOBJ_UNIFORM;
    uniform->index        = (gctUINT16) (Shader->maxKernelFunctionArgs + Shader->uniformCount);
    SetUniformCategory(uniform, gcSHADER_VAR_CATEGORY_NORMAL);
    uniform->firstChild = -1;
    uniform->nextSibling = -1;
    uniform->prevSibling = -1;
    uniform->parent = -1;
    uniform->u.type      = Type;
    uniform->precision    = Precision;
    uniform->arraySize    = Length;
    SetUniformFlags(uniform, 0);

    if (uniform->arraySize > 1)
    {
        SetUniformFlags(uniform, gcvUNIFORM_FLAG_IS_ARRAY);
        uniform->arrayLengthCount = 1;
        status = gcoOS_Allocate(gcvNULL, gcmSIZEOF(gctINT), &pointer);

        if (gcmIS_ERROR(status))
        {
            gcoOS_Free(gcvNULL, pointer);
            gcoOS_Free(gcvNULL, uniform);
            /* Error. */
            gcmFOOTER();
            return status;
        }
        gcoOS_ZeroMemory(pointer, gcmSIZEOF(gctINT));
        uniform->arrayLengthList = pointer;
        uniform->arrayLengthList[0] = Length;
    }
    else
    {
        uniform->arrayLengthCount = 0;
        uniform->arrayLengthList = gcvNULL;
    }
    uniform->modelViewProjection = 0;
    uniform->format       = gcSL_FLOAT;
    SetUniformVectorSize(uniform, 0);
    SetUniformTypeNameOffset(uniform, -1);
    uniform->isPointer    = gcvFALSE;
    uniform->nameLength   = nameLength;
    uniform->physical     = -1;
    uniform->samplerPhysical = -1;
    uniform->address      = ~0U;
    uniform->RAPriority       = 0;
    uniform->dummyUniformIndex = -1;

    /* Halti fields */
    uniform->blockIndex   = -1;
    uniform->arrayStride = -1;
    uniform->matrixStride = -1;
    uniform->isRowMajor = 0;
    uniform->offset = -1;
    /* ES31 fields */
    uniform->binding = -1;
    uniform->location = -1;
    uniform->baseBindingIdx = -1;
    uniform->imageFormat = gcIMAGE_FORMAT_DEFAULT;
    SetUniformUsedArraySize(uniform, 0);

    uniform->glUniformIndex = -1;
    uniform->matchIndex     = -1;

    if(gcmType_Kind(Type) == gceTK_SAMPLER)
    {
        uniform->physical = Shader->samplerIndex;
        Shader->samplerIndex += Length > 1 ? Length : 1;
    }

    /* Copy the uniform name. */
    gcoOS_MemCopy(uniform->name, Name, nameLength + 1);

    /* Set new gcUNIFORM object pointer. */
    Shader->uniforms[Shader->uniformCount++] = uniform;

    if (Uniform != gcvNULL)
    {
        /* Return the gcUNIFORM object pointer. */
        *Uniform = uniform;
    }

    gcmFOOTER_ARG("*Uniform=0x%x", gcmOPT_POINTER(Uniform));
    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddUniformEx
**
**  Add an uniform to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          Name of the uniform to add.
**
**      gcSHADER_TYPE Type
**          Type of the uniform to add.
**
**      gcSHADER_PRECISION precision
**          Precision of the uniform to add.
**
**      gctUINT32 Length
**          Array length of the uniform to add.  'Length' must be at least 1.
**
**  OUTPUT:
**
**      gcUNIFORM * Uniform
**          Pointer to a variable receiving the gcUNIFORM object pointer.
*/
gceSTATUS
gcSHADER_AddUniformEx(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gcSHADER_PRECISION precision,
    IN gctUINT32 Length,
    OUT gcUNIFORM * Uniform
    )
{
    gctUINT32 nameLength, bytes;
    gcUNIFORM uniform;
    gceSTATUS status;
    gctPOINTER pointer;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d Length=%lu",
                  Shader, Name, Type, Length);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check array count. */
    if (Shader->uniformArraySize <= Shader->uniformCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateUniforms(Shader, Shader->uniformCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Get the length of the name. */
    nameLength = gcoOS_StrLen(Name, gcvNULL);

    /* Compute the number of bytes required for the gcUNIFORM object. */
    bytes = gcmOFFSETOF(_gcUNIFORM, name) + nameLength + 1;

    /* Allocate the gcUNIFORM object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    uniform = pointer;

    /* Clear the memory in case some union member was partially written */
    gcoOS_ZeroMemory(uniform, bytes);

    /* Initialize the gcUNIFORM object. */
    uniform->object.type  = gcvOBJ_UNIFORM;
    uniform->index        = (gctUINT16) (Shader->maxKernelFunctionArgs + Shader->uniformCount);
    SetUniformCategory(uniform, gcSHADER_VAR_CATEGORY_NORMAL);
    uniform->firstChild = -1;
    uniform->nextSibling = -1;
    uniform->prevSibling = -1;
    uniform->parent = -1;
    uniform->u.type      = Type;
    uniform->precision    = precision;
    uniform->arraySize    = Length;
    if (uniform->arraySize > 1)
    {
        SetUniformFlags(uniform, gcvUNIFORM_FLAG_IS_ARRAY);
        uniform->arrayLengthCount = 1;
        status = gcoOS_Allocate(gcvNULL, gcmSIZEOF(gctINT), &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, uniform));
            gcmFOOTER();
            return status;
        }
        gcoOS_ZeroMemory(pointer, gcmSIZEOF(gctINT));
        uniform->arrayLengthList = pointer;
        uniform->arrayLengthList[0] = Length;
    }
    else
    {
        uniform->arrayLengthCount = 0;
        uniform->arrayLengthList = gcvNULL;
    }
    uniform->modelViewProjection = 0;
    uniform->format       = gcSL_FLOAT;
    SetUniformVectorSize(uniform, 0);
    SetUniformTypeNameOffset(uniform, -1);
    uniform->isPointer    = gcvFALSE;
    uniform->nameLength   = nameLength;
    uniform->physical     = -1;
    uniform->samplerPhysical = -1;
    uniform->address      = ~0U;
    uniform->RAPriority       = 0;
    uniform->dummyUniformIndex = -1;
    SetUniformFlags(uniform, 0);

    uniform->blockIndex   = -1;
    /* Halti fields */
    uniform->arrayStride = -1;
    uniform->matrixStride = -1;
    uniform->isRowMajor = 0;
    uniform->offset = -1;
    /* ES31 fields */
    uniform->binding = -1;
    uniform->location = -1;
    uniform->baseBindingIdx = -1;
    uniform->imageFormat = gcIMAGE_FORMAT_DEFAULT;
    SetUniformUsedArraySize(uniform, 0);

    uniform->glUniformIndex = -1;
    uniform->matchIndex     = -1;

    if(gcmType_Kind(Type) == gceTK_SAMPLER)
    {
        uniform->physical = Shader->samplerIndex;
        Shader->samplerIndex += Length > 1 ? Length : 1;
    }

    /* Copy the uniform name. */
    gcoOS_MemCopy(uniform->name, Name, nameLength + 1);

    /* Set new gcUNIFORM object pointer. */
    Shader->uniforms[Shader->uniformCount++] = uniform;

    if (Uniform != gcvNULL)
    {
        /* Return the gcUNIFORM object pointer. */
        *Uniform = uniform;
    }

    gcmFOOTER_ARG("*Uniform=0x%x", gcmOPT_POINTER(Uniform));
    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                               gcSHADER_AddUniformEx1
********************************************************************************
**
**    Add an uniform to a gcSHADER object.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gctCONST_STRING Name
**            Name of the uniform to add.
**
**        gcSHADER_TYPE Type
**            Type of the uniform to add.
**
**      gcSHADER_PRECISION precision
**          Precision of the uniform to add.
**
**      gctUINT32 Length
**            Array length of the uniform to add.  'Length' must be at least 1.
**
**      gcSHADER_VAR_CATEGORY varCategory
**          Variable category, normal or struct.
**
**      gctUINT16 numStructureElement
**          If struct, its element number.
**
**      gctINT16 parent
**          If struct, parent index in gcSHADER.variables.
**
**      gctINT16 prevSibling
**          If struct, previous sibling index in gcSHADER.variables.
**
**      gctINT16 imageFormat
**          image format for the uniform to add
**
**    OUTPUT:
**
**        gcUNIFORM * Uniform
**            Pointer to a variable receiving the gcUNIFORM object pointer.
**
**      gctINT16* ThisUniformIndex
**          Returned value about uniform index in gcSHADER.
*/
gceSTATUS
gcSHADER_AddUniformEx1(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gcSHADER_PRECISION precision,
    IN gctINT32 location,
    IN gctINT32 binding,
    IN gctINT32 bindingOffset,
    IN gctINT ArrayLengthCount,
    IN gctINT * ArrayLengthList,
    IN gcSHADER_VAR_CATEGORY varCategory,
    IN gctUINT16 numStructureElement,
    IN gctINT16 parent,
    IN gctINT16 prevSibling,
    IN gctINT16 imageFormat,
    OUT gctINT16* ThisUniformIndex,
    OUT gcUNIFORM * Uniform
    )
{
    gctUINT32 nameLength=0, bytes;
    gcUNIFORM uniform;
    gceSTATUS status;
    gctPOINTER pointer;
    gctINT16 thisIdx;
    gctUINT vertexUniforms = gcHWCaps.maxVSConstRegCount;
    gctUINT fragmentUniforms = gcHWCaps.maxPSConstRegCount;
    gctUINT length = 0;
    gctINT i;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d",
                  Shader, Name, Type);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (ArrayLengthCount > 0)
    {
        length = ArrayLengthList[0];
    }

    if(168 == vertexUniforms && ArrayLengthCount > 0)
    {
        if (Shader->type == gcSHADER_TYPE_VERTEX)
        {
            if (Type == gcSHADER_FLOAT_4X4)
            {
                if (length * 4 > vertexUniforms)
                {
                    /*gcmPRINT("Shader vertex uniforms of matrix array exceed the hardware limitations and is truncated !");*/
                    if (gcPatchId == gcvPATCH_RIPTIDEGP2)
                    {
                        length = vertexUniforms / 5;
                        length += 3;
                    }

                    if(gcPatchId == gcvPATCH_NBA2013)
                    {
                         length = vertexUniforms / 5;
                    }

                }
            }
            if (Type == gcSHADER_FLOAT_X4)
            {
                if (length > vertexUniforms)
                {
                    /*gcmPRINT("Shader vertex uniforms of vec4 exceed the hardware limitations and is truncated !");*/
                     if(gcPatchId == gcvPATCH_NBA2013)
                     {
                         length = vertexUniforms / 2;
                     }
                }
            }
        }
        else
        {
            if(Type == gcSHADER_FLOAT_4X4)
            {
                if(length * 4 > fragmentUniforms)
                {
                    /*gcmPRINT("Shader fragment uniforms of matrix array exceed the hardware limitations and is truncated !");*/
                     if(gcPatchId == gcvPATCH_NBA2013)
                     {
                        length = fragmentUniforms / 5;
                     }
                }
            }
        }
    }
    /* Check array count. */
    if (Shader->uniformArraySize <= Shader->uniformCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateUniforms(Shader, Shader->uniformCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Get the length of the name. */
    nameLength = gcoOS_StrLen(Name, gcvNULL);

    /* Compute the number of bytes required for the gcUNIFORM object. */
    bytes = gcmOFFSETOF(_gcUNIFORM, name) + nameLength + 1;

    /* Allocate the gcUNIFORM object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    uniform = pointer;

    /* Clear the memory in case some union member was partially written */
    gcoOS_ZeroMemory(uniform, bytes);

    /* Initialize the gcUNIFORM object. */
    uniform->object.type  = gcvOBJ_UNIFORM;
    uniform->index        = (gctUINT16) (Shader->maxKernelFunctionArgs + Shader->uniformCount);

    SetUniformCategory(uniform, varCategory);

    if (isUniformNormal(uniform) ||
        isUniformBlockMember(uniform) ||
        isUniformBlockAddress(uniform) ||
        isUniformLodMinMax(uniform) ||
        isUniformLevelBaseSize(uniform) ||
        isUniformExtraForTexGather(uniform) ||
        isUniformSampleLocation(uniform) ||
        isUniformMultiSampleBuffers(uniform))
    {
        uniform->u.type = Type;
    }
    else
    {
        uniform->u.numStructureElement = numStructureElement;
    }

    /* Link variables */
    thisIdx = (gctINT16)Shader->uniformCount;
    uniform->parent = parent;
    if (parent != -1)
    {
        if (Shader->uniforms[parent]->firstChild == -1)
            Shader->uniforms[parent]->firstChild = thisIdx;
        else
        {
            gctINT curIdx, preIdx;
            curIdx = Shader->uniforms[parent]->firstChild;
            preIdx = -1;
            while (curIdx != -1)
            {
                preIdx = curIdx;
                curIdx = Shader->uniforms[curIdx]->nextSibling;
            }
            gcmASSERT(preIdx != -1);
            Shader->uniforms[preIdx]->nextSibling = thisIdx;
        }
    }

    uniform->prevSibling = prevSibling;
    if (prevSibling != -1)
        Shader->uniforms[prevSibling]->nextSibling = thisIdx;

    uniform->nextSibling = -1;
    uniform->firstChild = -1;

    uniform->precision    = precision;

    /* Fill the array related information. */
    uniform->arrayLengthCount = ArrayLengthCount;
    if (ArrayLengthCount == 0)
    {
        SetUniformFlags(uniform, 0);
        uniform->arraySize = 1;
        uniform->arrayLengthList = gcvNULL;
    }
    else
    {
        SetUniformFlags(uniform, gcvUNIFORM_FLAG_IS_ARRAY);
        uniform->arraySize   = length;

        uniform->arrayLengthList = gcvNULL;
        gcmASSERT(ArrayLengthCount > 0);
        status = gcoOS_Allocate(gcvNULL, gcmSIZEOF(gctINT) * ArrayLengthCount, &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, uniform));
            gcmFOOTER();
            return status;
        }
        gcoOS_ZeroMemory(pointer, gcmSIZEOF(gctINT) * ArrayLengthCount);

        uniform->arrayLengthList = pointer;

        for (i = 0; i < ArrayLengthCount; i++)
        {
            if (i == 0)
                uniform->arrayLengthList[i] = length;
            else
                uniform->arrayLengthList[i] = ArrayLengthList[i];
        }
    }

    uniform->modelViewProjection = 0;
    uniform->format       = gcSL_FLOAT;
    SetUniformVectorSize(uniform, 0);
    SetUniformTypeNameOffset(uniform, -1);
    uniform->isPointer    = gcvFALSE;
    uniform->nameLength   = nameLength;
    uniform->physical     = -1;
    uniform->samplerPhysical = -1;
    uniform->address      = ~0U;
    uniform->RAPriority       = 0;
    uniform->dummyUniformIndex = -1;
    uniform->blockIndex   = -1;
    /* Halti fields */
    uniform->arrayStride = -1;
    uniform->matrixStride = -1;
    uniform->isRowMajor = 0;
    SetUniformOffset(uniform, bindingOffset);

    /* ES31 fields */
    SetUniformLayoutLocation(uniform, location);
    SetUniformBinding(uniform, binding);
    SetUniformImageFormat(uniform, imageFormat);

    /* For atomic counter base addr uniform idx */
    uniform->baseBindingIdx = -1;

    uniform->glUniformIndex = -1;
    uniform->matchIndex     = -1;

#if __USE_IMAGE_LOAD_TO_ACCESS_SAMPLER_BUFFER__
    if (isUniformSamplerBuffer(uniform))
    {
        SetUniformFlags(uniform, gcvUNIFORM_FLAG_TREAT_SAMPLER_AS_CONST);
    }
#endif

    if (gcmType_Kind(Type) == gceTK_SAMPLER)
    {
        uniform->physical = Shader->samplerIndex;
        Shader->samplerIndex += uniform->arraySize > 1 ? uniform->arraySize : 1;
    }

    /* Copy the uniform name. */
    gcoOS_MemCopy(uniform->name, Name, nameLength + 1);

    /* Set new gcUNIFORM object pointer. */
    Shader->uniforms[Shader->uniformCount++] = uniform;

    if (Uniform != gcvNULL)
    {
        /* Return the gcUNIFORM object pointer. */
        *Uniform = uniform;
    }

    /* Return this index */
    if (ThisUniformIndex)
        *ThisUniformIndex = thisIdx;

    gcmFOOTER_ARG("*Uniform=0x%x", gcmOPT_POINTER(Uniform));
    /* Success. */
    return gcvSTATUS_OK;
}

/* create uniform for the constant vector and initialize it with Value */
gceSTATUS
gcSHADER_CreateConstantUniform(
    IN gcSHADER                  Shader,
    IN gcSHADER_TYPE             Type,
    IN gcsValue *                Value,
    OUT gcUNIFORM *              Uniform
    )
{
    gceSTATUS      status   = gcvSTATUS_OK;
    gctUINT        offset   = 0;
    gcUNIFORM      uniform;
    gctCHAR        name[64];

    /* construct const vector name, create and initialize constant uniform */
    gcoOS_PrintStrSafe(name, sizeof(name), &offset, "#sh%d_ConstVector_%d",
                       Shader->_id, Shader->_constVectorId++);
    gcmONERROR(gcSHADER_AddUniform(Shader, name, Type, 1, gcSHADER_PRECISION_HIGH, &uniform));

    gcmASSERT(isUniformNormal(uniform) &&
              gcmType_Rows(uniform->u.type) == 1);
    SetUniformFlag(uniform, gcvUNIFORM_FLAG_COMPILETIME_INITIALIZED);
    SetUniformFlag(uniform, gcvUNIFORM_FLAG_COMPILER_GEN);
    uniform->initializer = *Value;

    *Uniform = uniform;

OnError:
    return status;
}

/* add uniform with compile-time initializer */
gceSTATUS
gcSHADER_AddUniformWithInitializer(
    IN gcSHADER                  Shader,
    IN gctCONST_STRING           Name,
    IN gcSHADER_TYPE             Type,
    IN gctUINT32                 Length,
    IN gcSHADER_PRECISION        Precision,
    IN gcsValue *                Value,
    OUT gcUNIFORM *              Uniform
    )
{
    gceSTATUS      status   = gcvSTATUS_OK;
    gcUNIFORM      uniform;

    gcmONERROR(gcSHADER_AddUniform(Shader, Name, Type, 1, Precision, &uniform));

    gcmASSERT(isUniformNormal(uniform));
    SetUniformFlag(uniform, gcvUNIFORM_FLAG_COMPILETIME_INITIALIZED);
    SetUniformFlag(uniform, gcvUNIFORM_FLAG_COMPILER_GEN);
    uniform->initializer = *Value;

    *Uniform = uniform;

OnError:
    return status;
}

/*******************************************************************************
**  gcSHADER_ReallocateUniformBlocks
**
**  Reallocate an array of pointers to gcsUNIFORM_BLOCK objects.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcSHADER_ReallocateUniformBlocks(
    IN gcSHADER Shader,
    IN gctUINT32 Count
    )
{
    gcsUNIFORM_BLOCK * uniformBlocks;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Count=%lu", Shader, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Count < Shader->uniformBlockCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Shader->uniformBlockArraySize)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsUNIFORM_BLOCK) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    uniformBlocks = pointer;

    if (Shader->uniformBlocks != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(uniformBlocks,
                      Shader->uniformBlocks,
                      gcmSIZEOF(gcsUNIFORM_BLOCK)
                      * Shader->uniformBlockCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->uniformBlocks));
    }

    /* Set new gcsUNIFORM_BLOCK object pointer. */
    Shader->uniformBlockArraySize = Count;
    Shader->uniformBlocks         = uniformBlocks;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                    gcSHADER_AddUniformBlock
********************************************************************************
**
**    Add a uniform block to a gcSHADER object.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gctCONST_STRING Name
**            Name of the uniform block to add.
**
**        gcsSHADER_VAR_INFO *BlockInfo
**            block info associated with uniform block to be added.
**
**        gceINTERFACE_BLOCK_LAYOUT_ID  MemoryLayout;
**             Memory layout qualifier for members in block
**
**    OUTPUT:
**
**        gcsUNIFORM_BLOCK * Uniform
**            Pointer to a variable receiving the gcsUNIFORM_BLOCK object pointer.
**
*/
gceSTATUS
gcSHADER_AddUniformBlock(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcsSHADER_VAR_INFO *BlockInfo,
    IN gceINTERFACE_BLOCK_LAYOUT_ID MemoryLayout,
    IN gctINT16 ArrayIndex,
    IN gctUINT16 ArrayLength,
    OUT gcsUNIFORM_BLOCK * UniformBlock
    )
{
    gctUINT32 nameLength=0, bytes;
    gcsUNIFORM_BLOCK uniformBlock = gcvNULL;
    gcUNIFORM blockAddressUniform;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;
    gctUINT16 thisIdx;
    gctBOOL isDefaultUBO = gcvFALSE;
    gctBOOL isConstantUBO = gcvFALSE;

    gcmHEADER_ARG("Shader=0x%x Name=%s BlockInfo=0x%x MemoryLayout=%d",
                  Shader, Name, BlockInfo, MemoryLayout);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check block array size. */
    if (Shader->uniformBlockArraySize <= Shader->uniformBlockCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateUniformBlocks(Shader, Shader->uniformBlockCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Get the length of the name. */
    nameLength = gcoOS_StrLen(Name, gcvNULL);

    if (gcmIS_SUCCESS(gcoOS_StrCmp(Name, "#DefaultUBO")))
    {
        if(Shader->_defaultUniformBlockIndex != -1)
        {
            gcSHADER_GetUniformBlock(Shader, Shader->_defaultUniformBlockIndex, UniformBlock);
            return gcvSTATUS_OK;
        }
        isDefaultUBO = gcvTRUE;
    }
    else if (gcmIS_SUCCESS(gcoOS_StrNCmp(Name, "#ConstantUBO", 12)))
    {
        if (Shader->constUniformBlockIndex != -1)
        {
            gcSHADER_GetUniformBlock(Shader, Shader->constUniformBlockIndex, UniformBlock);
            return gcvSTATUS_OK;
        }
        isConstantUBO = gcvTRUE;
    }
    /* Compute the number of bytes required for the gcUNIFORM_BLOCK object. */
    bytes    = gcmOFFSETOF(_gcsUNIFORM_BLOCK, name) + nameLength + 1;

    /* Allocate the gcUNIFORM object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    uniformBlock = pointer;
    /* Zero the memory. */
    gcoOS_ZeroMemory(uniformBlock, bytes);

    /* Initialize the gcsUNIFORM_BLOCK object. */
    GetUBObject(uniformBlock)->type = gcvOBJ_UNIFORM_BLOCK;

    thisIdx = (gctUINT16)Shader->uniformBlockCount;

    SetUBCategory(uniformBlock, gcSHADER_VAR_CATEGORY_BLOCK);
    SetUBBlockIndex(uniformBlock, thisIdx);

    /* ubo array share the same address uniform array, so add it once for
       the first ubo array element, and let the other elements have the
       same address uniform array */
    if(BlockInfo->prevSibling == -1)
    {
        status = gcSHADER_AddUniform(Shader,
                                     Name,
                                     gcSHADER_UINT_X1,
                                     ArrayLength ? ArrayLength : 1,
                                     gcSHADER_PRECISION_HIGH,
                                     &blockAddressUniform);
        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            if(uniformBlock != gcvNULL)
            {
                gcoOS_Free(gcvNULL, uniformBlock);
            }
            return status;
        }

        /* Link back to each other */
        SetUniformCategory(blockAddressUniform, gcSHADER_VAR_CATEGORY_BLOCK_ADDRESS);
        SetUBIndex(uniformBlock, (gctINT16)blockAddressUniform->index);
        blockAddressUniform->blockIndex   = GetUBBlockIndex(uniformBlock);
        SetUniformFlag(blockAddressUniform, gcvUNIFORM_FLAG_USED_IN_SHADER);
        SetUniformFlag(blockAddressUniform, gcvUNIFORM_FLAG_COMPILER_GEN);
    }
    else
    {
        gcsUNIFORM_BLOCK prevUB;
        gcSHADER_GetUniformBlock(Shader, BlockInfo->prevSibling, &prevUB);
        SetUBIndex(uniformBlock, GetUBIndex(prevUB));
    }


    SetUBShaderVarInfo(uniformBlock, *BlockInfo);
    /* Link variables */
    SetUBParent(uniformBlock, -1);
    SetUBFirstChild(uniformBlock, -1);
    SetUBNextSibling(uniformBlock, -1);

    if(GetSVIPrevSibling(BlockInfo) != -1)
    {
       SetUBNextSibling(Shader->uniformBlocks[GetSVIPrevSibling(BlockInfo)], thisIdx);
       SetUBPrevSibling(uniformBlock, GetSVIPrevSibling(BlockInfo));
    }
    else
    {
        SetUBPrevSibling(uniformBlock, -1);
    }

    SetUBArraySize(uniformBlock, 1);
    SetUBMemoryLayout(uniformBlock, MemoryLayout);
    SetUBBlockSize(uniformBlock, 0);
    SetUBMatchIndex(uniformBlock, -1);
    SetUBArrayIndex(uniformBlock, ArrayIndex);
    SetUBNameLength(uniformBlock, nameLength);

    /* Copy the uniform name. */
    if(isDefaultUBO)
    {
        Shader->_defaultUniformBlockIndex = GetUBBlockIndex(uniformBlock);
    }
    else if (isConstantUBO)
    {
        Shader->constUniformBlockIndex = GetUBBlockIndex(uniformBlock);
    }
    gcoOS_MemCopy(uniformBlock->name, Name, nameLength + 1);

    /* Set new gcsUNIFORM object pointer. */
    Shader->uniformBlocks[Shader->uniformBlockCount++] = uniformBlock;

    if (UniformBlock != gcvNULL)
    {
        /* Return the gcsUNIFORM_BLOCK object pointer. */
        *UniformBlock = uniformBlock;
    }

    gcmFOOTER_ARG("*UniformBlock=0x%x", gcmOPT_POINTER(UniformBlock));
    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_ReallocateStorageBlocks
**
**  Reallocate an array of pointers to gcsSTORAGE_BLOCK objects.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcSHADER_ReallocateStorageBlocks(
    IN gcSHADER Shader,
    IN gctUINT32 Count
    )
{
    gcsSTORAGE_BLOCK * storageBlocks;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Count=%lu", Shader, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Count < Shader->storageBlockCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Shader->storageBlockArraySize)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsSTORAGE_BLOCK) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    storageBlocks = pointer;

    if (Shader->storageBlocks != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(storageBlocks,
                      Shader->storageBlocks,
                      gcmSIZEOF(gcsUNIFORM_BLOCK)
                      * Shader->storageBlockCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->storageBlocks));
    }

    /* Set new gcsSTORAGE_BLOCK object pointer. */
    Shader->storageBlockArraySize = Count;
    Shader->storageBlocks         = storageBlocks;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                    gcSHADER_AddStorageBlock
********************************************************************************
**
**    Add a uniform block to a gcSHADER object.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gctCONST_STRING Name
**            Name of the uniform block to add.
**
**        gcsSHADER_VAR_INFO *BlockInfo
**            block info associated with uniform block to be added.
**
**        gceINTERFACE_BLOCK_LAYOUT_ID  MemoryLayout;
**             Memory layout qualifier for members in block
**
**    OUTPUT:
**
**        gcsUNIFORM_BLOCK * StorageBlock
**            Pointer to a variable receiving the gcsUNIFORM_BLOCK object pointer.
**
*/
gceSTATUS
gcSHADER_AddStorageBlock(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcsSHADER_VAR_INFO *BlockInfo,
    IN gceINTERFACE_BLOCK_LAYOUT_ID MemoryLayout,
    OUT gcsSTORAGE_BLOCK * StorageBlock
    )
{
    gctUINT32 nameLength=0, bytes;
    gcsSTORAGE_BLOCK storageBlock;
    gcUNIFORM blockAddressUniform;
    gceSTATUS status;
    gctPOINTER pointer;
    gctUINT16 thisIdx;

    gcmHEADER_ARG("Shader=0x%x Name=%s BlockInfo=0x%x MemoryLayout=%d",
                  Shader, Name, BlockInfo, MemoryLayout);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check block array size. */
    if (Shader->storageBlockArraySize <= Shader->storageBlockCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateStorageBlocks(Shader, Shader->storageBlockCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Get the length of the name. */
    nameLength = gcoOS_StrLen(Name, gcvNULL);

    /* Compute the number of bytes required for the gcsSTORAGE_BLOCK object. */
    bytes    = gcmOFFSETOF(_gcsSTORAGE_IO_BLOCK, name) + nameLength + 1;

    /* Allocate the gcsSTORAGE_BLOCK object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    storageBlock = pointer;
    /* Zero the memory. */
    gcoOS_ZeroMemory(storageBlock, bytes);

    /* Initialize the gcsSTORAGE_BLOCK object. */
    GetSBObject(storageBlock)->type  = gcvOBJ_STORAGE_BLOCK;

    thisIdx = (gctUINT16)Shader->storageBlockCount;

    SetSBCategory(storageBlock, gcSHADER_VAR_CATEGORY_BLOCK);
    SetSBBlockIndex(storageBlock, thisIdx);

    status = gcSHADER_AddUniform(Shader,
                                 Name,
                                 gcSHADER_UINT_X2,
                                 1,
                                 gcSHADER_PRECISION_HIGH,
                                 &blockAddressUniform);
    if (gcmIS_ERROR(status))
    {
        gcoOS_Free(gcvNULL, pointer);

        /* Error. */
        gcmFOOTER();
        return status;
    }

    /* Link back to each other */
    SetUniformCategory(blockAddressUniform, gcSHADER_VAR_CATEGORY_BLOCK_ADDRESS);
    SetSBIndex(storageBlock, (gctINT16)blockAddressUniform->index);
    SetSBSharedVariableBaseAddress(storageBlock, -1);
    blockAddressUniform->blockIndex   = GetSBBlockIndex(storageBlock);
    SetUniformKind(blockAddressUniform, gcvUNIFORM_KIND_STORAGE_BLOCK_ADDRESS);

    SetSBShaderVarInfo(storageBlock, *BlockInfo);
    /* Link variables */
    SetSBParent(storageBlock, -1);
    SetSBFirstChild(storageBlock, -1);
    SetSBNextSibling(storageBlock, -1);

    if(GetSVIPrevSibling(BlockInfo) != -1)
    {
       SetSBNextSibling(Shader->storageBlocks[GetSVIPrevSibling(BlockInfo)], thisIdx);
       SetSBPrevSibling(storageBlock, GetSVIPrevSibling(BlockInfo));
    }
    else
    {
        SetSBPrevSibling(storageBlock, -1);
    }

    SetSBArraySize(storageBlock, 1);
    SetSBMemoryLayout(storageBlock, MemoryLayout);
    SetSBBlockSize(storageBlock, 0);
    SetSBSharedVariableBaseAddress(storageBlock, -1);
    SetSBNameLength(storageBlock, nameLength);

    /* Copy the storage block name. */
    gcoOS_MemCopy(GetSBName(storageBlock), Name, nameLength + 1);

    /* Set new gcsSTORAGE_BLOCK object pointer. */
    Shader->storageBlocks[Shader->storageBlockCount++] = storageBlock;

    if (StorageBlock != gcvNULL)
    {
        /* Return the gcsSTORAGE_BLOCK object pointer. */
        *StorageBlock = storageBlock;
    }

    gcmFOOTER_ARG("*StorageBlock=0x%x", gcmOPT_POINTER(StorageBlock));
    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_ReallocateIoBlocks
**
**  Reallocate an array of pointers to gcsIO_BLOCK objects.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcSHADER_ReallocateIoBlocks(
    IN gcSHADER Shader,
    IN gctUINT32 Count
    )
{
    gcsIO_BLOCK * ioBlocks;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Count=%lu", Shader, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Count < Shader->ioBlockCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Shader->ioBlockArraySize)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsIO_BLOCK) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    ioBlocks = pointer;

    if (Shader->ioBlocks != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(ioBlocks,
                      Shader->ioBlocks,
                      gcmSIZEOF(gcsIO_BLOCK)
                      * Shader->ioBlockCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->ioBlocks));
    }

    /* Set new gcsIO_BLOCK object pointer. */
    Shader->ioBlockArraySize = Count;
    Shader->ioBlocks         = ioBlocks;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                    gcSHADER_AddIoBlock
********************************************************************************
**
**    Add a uniform block to a gcSHADER object.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gctCONST_STRING Name
**            Name of the io block to add.
**
**        gcsSHADER_VAR_INFO *BlockInfo
**            block info associated with io block to be added.
**
**        gceINTERFACE_BLOCK_LAYOUT_ID  MemoryLayout;
**             Memory layout qualifier for members in block
**
**    OUTPUT:
**
**        gcsIO_BLOCK * IoBlock
**            Pointer to a variable receiving the gcsIO_BLOCK object pointer.
**
*/
gceSTATUS
gcSHADER_AddIoBlock(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gctCONST_STRING InstanceName,
    IN gcsSHADER_VAR_INFO *BlockInfo,
    IN gceINTERFACE_BLOCK_LAYOUT_ID MemoryLayout,
    OUT gcsIO_BLOCK * IoBlock
    )
{
    gctUINT32 nameLength=0, instanceNameLength=0, bytes;
    gcsIO_BLOCK ioBlock;
    gceSTATUS status;
    gctPOINTER pointer;
    gctUINT16 thisIdx;
    gctBOOL copyName;
    gctUINT32 kind;

    gcmHEADER_ARG("Shader=0x%x Name=%s BlockInfo=0x%x MemoryLayout=%d",
                  Shader, Name, BlockInfo, MemoryLayout);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check block array size. */
    if (Shader->ioBlockArraySize <= Shader->ioBlockCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateIoBlocks(Shader, Shader->ioBlockCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    if (InstanceName &&
        gcmIS_SUCCESS(gcSHADER_GetBuiltinNameKind(Shader, InstanceName, &kind)) &&
        kind != gcSL_NONBUILTINGNAME)
    {
        nameLength = kind;
        instanceNameLength = 0;
        bytes      = gcmOFFSETOF(_gcsSTORAGE_IO_BLOCK, name);
        copyName   = gcvFALSE;
    }
    else
    {
        /* Get the length of the name. */
        nameLength = gcoOS_StrLen(Name, gcvNULL);
        /* Get the length of the instance name. */
        if (InstanceName != gcvNULL)
        {
            instanceNameLength = gcoOS_StrLen(InstanceName, gcvNULL) + 1;
        }
        /* Compute the number of bytes required for the gcsIO_BLOCK object. */
        bytes    = gcmOFFSETOF(_gcsSTORAGE_IO_BLOCK, name) + nameLength + instanceNameLength + 1;
        /* Mark the name to be copied. */
        copyName   = gcvTRUE;
    }

    /* Allocate the gcsIO_BLOCK object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    ioBlock = pointer;
    /* Zero the memory. */
    gcoOS_ZeroMemory(ioBlock, bytes);

    /* Initialize the gcsIO_BLOCK object. */
    GetSBObject(ioBlock)->type  = gcvOBJ_IO_BLOCK;

    thisIdx = (gctUINT16)Shader->ioBlockCount;

    SetSBCategory(ioBlock, gcSHADER_VAR_CATEGORY_BLOCK);
    SetSBBlockIndex(ioBlock, thisIdx);

    /* Link back to each other */
    SetSBSharedVariableBaseAddress(ioBlock, -1);

    SetSBShaderVarInfo(ioBlock, *BlockInfo);
    /* Link variables */
    SetSBParent(ioBlock, -1);
    SetSBFirstChild(ioBlock, -1);
    SetSBNextSibling(ioBlock, -1);

    if(GetSVIPrevSibling(BlockInfo) != -1)
    {
       SetSBNextSibling(Shader->ioBlocks[GetSVIPrevSibling(BlockInfo)], thisIdx);
       SetSBPrevSibling(ioBlock, GetSVIPrevSibling(BlockInfo));
    }
    else
    {
        SetSBPrevSibling(ioBlock, -1);
    }

    SetSBMemoryLayout(ioBlock, MemoryLayout);
    SetSBBlockSize(ioBlock, 0);
    SetSBSharedVariableBaseAddress(ioBlock, -1);
    SetSBNameLength(ioBlock, nameLength);
    if (instanceNameLength > 0)
    {
        SetSBInstanceNameLength(ioBlock, instanceNameLength - 1);
    }
    else
    {
        SetSBInstanceNameLength(ioBlock, 0);
    }

    /* Copy the storage block name. */
    if (copyName)
    {
        gcoOS_MemCopy(GetSBName(ioBlock), Name, nameLength);

        if (instanceNameLength > 0)
        {
            GetSBName(ioBlock)[nameLength] = '.';
            gcoOS_MemCopy(&GetSBName(ioBlock)[nameLength + 1], InstanceName, instanceNameLength);
        }
        else
        {
            GetSBName(ioBlock)[nameLength] = '\0';
        }
    }

    /* Set new gcsIO_BLOCK object pointer. */
    Shader->ioBlocks[Shader->ioBlockCount++] = ioBlock;

    if (IoBlock != gcvNULL)
    {
        /* Return the gcsIO_BLOCK object pointer. */
        *IoBlock = ioBlock;
    }

    gcmFOOTER_ARG("*IoBlock=0x%x", gcmOPT_POINTER(IoBlock));
    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetUniformVectorCountByCategory
**
**  Get the number of vectors used by uniforms for this shader according to variable
**  category.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSHADER_VAR_CATEGORY Category
**          Category of uniform.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of vectors.
*/
gceSTATUS
gcSHADER_GetUniformVectorCountByCategory(
    IN gcSHADER Shader,
    IN gcSHADER_VAR_CATEGORY Category,
    OUT gctUINT32 * Count
    )
{
    gctINT i;
    gctUINT32 vectorCount = 0;

    for (i = 0; i < (gctINT)Shader->uniformCount; ++i)
    {
        gctUINT32 components = 0, rows = 0;
        /* Get uniform. */
        gcUNIFORM uniform = Shader->uniforms[i];

        if(!uniform)
            continue;

        if (GetUniformCategory(uniform) != Category)
            continue;

        gcTYPE_GetTypeInfo(uniform->u.type, &components, &rows, 0);
        rows *= uniform->arraySize;

        vectorCount += rows;
    }

    *Count = vectorCount;

    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetUniformVectorCount
**
**  Get the number of vectors used by uniforms for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of vectors.
*/
gceSTATUS
gcSHADER_GetUniformVectorCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gctINT i;
    gctUINT32 vectorCount = 0;

    for (i = 0; i < (gctINT)Shader->uniformCount; ++i)
    {
        gctUINT32 components = 0, rows = 0;
        /* Get uniform. */
        gcUNIFORM uniform = Shader->uniforms[i];

        if(!uniform)
            continue;

        if (!isUniformNormal(uniform))
            continue;

        gcTYPE_GetTypeInfo(uniform->u.type, &components, &rows, 0);
        rows *= uniform->arraySize;

        vectorCount += rows;
    }

    *Count = vectorCount;

    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetUniformVectorCountUsedInShader
**
**  Get the number of vectors used by uniforms for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of vectors.
*/
gceSTATUS
gcSHADER_GetUniformVectorCountUsedInShader(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gctINT i;
    gctUINT32 vectorCount = 0;

    for (i = 0; i < (gctINT)Shader->uniformCount; ++i)
    {
        gctUINT32 components = 0, rows = 0;
        /* Get uniform. */
        gcUNIFORM uniform = Shader->uniforms[i];

        if(!uniform)
            continue;

        if (!isUniformNormal(uniform))
            continue;

        if (!isUniformUsedInShader(uniform))
            continue;

        gcTYPE_GetTypeInfo(uniform->u.type, &components, &rows, 0);
        rows *= uniform->arraySize;

        vectorCount += rows;
    }

    *Count = vectorCount;

    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetUniformCount
**
**  Get the number of uniforms for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of uniforms.
*/
gceSTATUS
gcSHADER_GetUniformCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    /* Return uniform count. */
    *Count = Shader->uniformCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                          gcSHADER_GetSamplerCount
********************************************************************************
**
**    Get the number of samplers for this shader.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**    OUTPUT:
**
**        gctUINT32 * Count
**            Pointer to a variable receiving the number of samplers.
*/
gceSTATUS
gcSHADER_GetSamplerCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gctUINT32 i, count = 0;
    gcUNIFORM uniform;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        *Count = count;
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    for (i = 0; i < Shader->uniformCount; i++)
    {
        uniform = Shader->uniforms[i];

        if(gcmType_Kind(uniform->u.type) == gceTK_SAMPLER)
        {
            count += uniform->arraySize;
        }
    }

    /* Return uniform count. */
    *Count = count;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                          gcSHADER_GetKernelUniformCount
********************************************************************************
**
**    Get the number of kernel uniforms for this shader.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**    OUTPUT:
**
**        gctUINT32 * Count
**            Pointer to a variable receiving the number of uniforms.
*/
gceSTATUS
gcSHADER_GetKernelUniformCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    /* Return uniform count. */
    *Count = Shader->uniformCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetUniformBlockCount
**
**  Get the number of uniform blocks for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of uniform blocks.
*/
gceSTATUS
gcSHADER_GetUniformBlockCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    /* Return uniform count. */
    *Count = Shader->uniformBlockCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetUniformBlockCount
**
**  Get the number of uniform blocks for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of uniform blocks.
*/
gceSTATUS
gcSHADER_GetUniformBlockCountUsedInShader(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gctUINT32 i;
    gctUINT count = 0;
    gcsUNIFORM_BLOCK ubo;
    gcUNIFORM uniform;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    for (i = 0; i < Shader->uniformBlockCount; i++)
    {
        ubo = Shader->uniformBlocks[i];

        if (!ubo) continue;

        gcSHADER_GetUniform(Shader, GetUBIndex(ubo), &uniform);

        if (!isUniformUsedInShader(uniform)) continue;
        count++;
    }

    /* Return uniform count. */
    if (Count)
    {
        *Count = count;
    }

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

static void
_gcSHADER_UpdateUniformBlockUniformCount(
    IN gcsUNIFORM_BLOCK UniformBlock,
    IN gcUNIFORM  Uniform
    )
{
    if(Uniform &&
       isUniformBlockMember(Uniform))
    {
       UniformBlock->uniformCount++;
    }
}

static void
_gcSHADER_UpdateUniformBlockUniformArray(
    IN gcsUNIFORM_BLOCK UniformBlock,
    IN gcUNIFORM  Uniform
    )
{
    if(Uniform &&
       isUniformBlockMember(Uniform))
    {
       UniformBlock->uniforms[UniformBlock->uniformCount++] = Uniform;
    }
}

static gceSTATUS
_gcSHADER_TraceUniformBlockMembers(
    IN gcSHADER Shader,
    IN gctINT  UniformIndex,
    IN gcsUNIFORM_BLOCK  UniformBlock,
    IN void (*UpdateFunc)(gcsUNIFORM_BLOCK, gcUNIFORM)
    )
{
    gceSTATUS status;
    gcUNIFORM uniform;
    gctINT uniformIndex;

    gcmHEADER_ARG("Shader=0x%x UniformIndex=%d UniformBlock=0x%x UpdateFunc=0x%x",
                  Shader, UniformIndex, UniformBlock, UpdateFunc);
    uniformIndex = UniformIndex;
    while(uniformIndex != -1)
    {
        status = gcSHADER_GetUniform(Shader,
                                     uniformIndex,
                                     &uniform);
        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
        if(uniform)
        {
            if(isUniformStruct(uniform))
            {
                status = _gcSHADER_TraceUniformBlockMembers(Shader,
                                                            uniform->firstChild,
                                                            UniformBlock,
                                                            UpdateFunc);
                if (gcmIS_ERROR(status))
                {
                    /* Error. */
                    gcmFOOTER();
                    return status;
                }
            }
            else
            {
                UpdateFunc(UniformBlock, uniform);
            }
        }
        uniformIndex = uniform->nextSibling;
    }
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_gcSHADER_InitializeUniformBlockUniformInfo(
    IN gcSHADER Shader,
    IN gcsUNIFORM_BLOCK UniformBlock
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x UniformBlock=0x%x", Shader, UniformBlock);

    gcmDEBUG_VERIFY_ARGUMENT(UniformBlock != gcvNULL);

    gcmASSERT(GetUBUniformCount(UniformBlock) == 0  &&
              GetUBUniforms(UniformBlock) == gcvNULL);

    SetUBUniformCount(UniformBlock, 0);
    status = _gcSHADER_TraceUniformBlockMembers(Shader,
                                                GetUBFirstChild(UniformBlock),
                                                UniformBlock,
                                                _gcSHADER_UpdateUniformBlockUniformCount);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    if(GetUBUniformCount(UniformBlock))
    {
        gctPOINTER pointer;

        /* Allocate a new array of uniform pointers. */
        status = gcoOS_Allocate(gcvNULL,
                                gcmSIZEOF(gcUNIFORM) * GetUBUniformCount(UniformBlock),
                                &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        SetUBUniformCount(UniformBlock, 0);
        SetUBUniforms(UniformBlock, pointer);
        status = _gcSHADER_TraceUniformBlockMembers(Shader,
                                                    GetUBFirstChild(UniformBlock),
                                                    UniformBlock,
                                                    _gcSHADER_UpdateUniformBlockUniformArray);
        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetUniformBlockUniformCount
**
**  Get the number of uniforms in a uniform block for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcsUNIFORM_BLOCK UniformBlock
**          Pointer to uniform block to retreive the uniform count.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of uniform blocks.
*/
gceSTATUS
gcSHADER_GetUniformBlockUniformCount(
    IN gcSHADER Shader,
    gcsUNIFORM_BLOCK UniformBlock,
    OUT gctUINT32 * Count
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x UniformBlock=0x%x", Shader, UniformBlock);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(UniformBlock != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if(GetUBUniformCount(UniformBlock) == 0)
    {
        /* compute the uniform count and create the array of pointers to the uniforms */

        status = _gcSHADER_InitializeUniformBlockUniformInfo(Shader,
                                                             UniformBlock);
        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Return uniform count. */
    *Count = GetUBUniformCount(UniformBlock);

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

static void
_gcSHADER_UpdateStorageBlockVariableCount(
    IN gcsSTORAGE_BLOCK StorageBlock,
    IN gcVARIABLE  Variable
    )
{
    if(Variable &&
       isVariableBlockMember(Variable))
    {
       GetSBVariableCount(StorageBlock)++;
    }
}

static void
_gcSHADER_UpdateStorageBlockVariableArray(
    IN gcsSTORAGE_BLOCK StorageBlock,
    IN gcVARIABLE  Variable
    )
{
    if(Variable &&
       isVariableBlockMember(Variable))
    {
       StorageBlock->variables[GetSBVariableCount(StorageBlock)++] = Variable;
    }
}

static gceSTATUS
_gcSHADER_TraceStorageBlockMembers(
    IN gcSHADER Shader,
    IN gctINT  VariableIndex,
    IN gcsSTORAGE_BLOCK  StorageBlock,
    IN gctBOOL TopLevel,
    IN gctINT16 ParentIndex,
    IN void (*UpdateFunc)(gcsSTORAGE_BLOCK, gcVARIABLE)
    )
{
    gceSTATUS status;
    gcVARIABLE variable;
    gctINT variableIndex;
    gctINT16 parentIndex = -1;

    gcmHEADER_ARG("Shader=0x%x VariableIndex=%d StorageBlock=0x%x UpdateFunc=0x%x",
                  Shader, VariableIndex, StorageBlock, UpdateFunc);
    variableIndex = VariableIndex;
    while(variableIndex != -1)
    {
        status = gcSHADER_GetVariable(Shader,
                                      variableIndex,
                                      &variable);
        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        if(variable)
        {
            if(isVariableStruct(variable))
            {
                if (TopLevel && isVariableArray(variable) && variable->arraySize != -1)
                    parentIndex = (gctINT16)variableIndex;

                status = _gcSHADER_TraceStorageBlockMembers(Shader,
                                                            variable->firstChild,
                                                            StorageBlock,
                                                            gcvFALSE,
                                                            parentIndex,
                                                            UpdateFunc);
                if (gcmIS_ERROR(status))
                {
                    /* Error. */
                    gcmFOOTER();
                    return status;
                }
            }
            else
            {
                UpdateFunc(StorageBlock, variable);
            }
        }

        if (!TopLevel &&
            isVariableStruct(variable) &&
            ParentIndex != -1)
        {
            gcVARIABLE nextVariable = gcvNULL, parentVariable = gcvNULL;

            status = gcSHADER_GetVariable(Shader,
                                          variable->parent,
                                          &parentVariable);

            if (gcmIS_ERROR(status))
            {
                /* Error. */
                gcmFOOTER();
                return status;
            }

            if (isVariableTopLevelStruct(parentVariable) &&
                parentVariable->arraySize > 1)
            {
                variableIndex = variable->nextSibling;

                while (variableIndex != -1)
                {
                    status = gcSHADER_GetVariable(Shader,
                                                  variableIndex,
                                                  &nextVariable);
                    if (gcmIS_ERROR(status))
                    {
                        /* Error. */
                        gcmFOOTER();
                        return status;
                    }
                    variableIndex = nextVariable->nextSibling;
                }
            }
            else
            {
                variableIndex = variable->nextSibling;
            }
        }
        else
        {
            variableIndex = variable->nextSibling;
        }
    }
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_gcSHADER_InitializeStorageBlockVariableInfo(
    IN gcSHADER Shader,
    IN gcsSTORAGE_BLOCK StorageBlock
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x StorageBlock=0x%x", Shader, StorageBlock);

    gcmDEBUG_VERIFY_ARGUMENT(StorageBlock != gcvNULL);

    gcmASSERT(GetSBVariableCount(StorageBlock) == 0  &&
              GetSBVariables(StorageBlock) == gcvNULL);

    SetSBVariableCount(StorageBlock, 0);
    status = _gcSHADER_TraceStorageBlockMembers(Shader,
                                                GetSBFirstChild(StorageBlock),
                                                StorageBlock,
                                                gcvTRUE,
                                                -1,
                                                _gcSHADER_UpdateStorageBlockVariableCount);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    if(GetSBVariableCount(StorageBlock))
    {
        gctPOINTER pointer;

        /* Allocate a new array of variable pointers. */
        status = gcoOS_Allocate(gcvNULL,
                                gcmSIZEOF(gcVARIABLE) * GetSBVariableCount(StorageBlock),
                                &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        SetSBVariableCount(StorageBlock, 0);
        SetSBVariables(StorageBlock, pointer);
        status = _gcSHADER_TraceStorageBlockMembers(Shader,
                                                    GetSBFirstChild(StorageBlock),
                                                    StorageBlock,
                                                    gcvTRUE,
                                                    -1,
                                                    _gcSHADER_UpdateStorageBlockVariableArray);
        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}


/*******************************************************************************
**  gcSHADER_GetIoBlockVariableCount
**
**  Get the number of variables in a io block for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcsIO_BLOCK IoBlock
**          Pointer to io block to retreive the variable count.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of variables in block.
*/
gceSTATUS
gcSHADER_GetIoBlockVariableCount(
    IN gcSHADER Shader,
    gcsIO_BLOCK IoBlock,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x IoBlock=0x%x", Shader, IoBlock);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(IoBlock != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    /* Return variable count. */
    *Count = 0;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetStorageBlockVariableCount
**
**  Get the number of variables in a storage block for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcsSTORAGE_BLOCK StorageBlock
**          Pointer to storage block to retreive the variable count.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of variables in block.
*/
gceSTATUS
gcSHADER_GetStorageBlockVariableCount(
    IN gcSHADER Shader,
    gcsSTORAGE_BLOCK StorageBlock,
    OUT gctUINT32 * Count
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x StorageBlock=0x%x", Shader, StorageBlock);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(StorageBlock != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if(GetSBVariableCount(StorageBlock) == 0)
    {
        /* compute the variable count and create the array of pointers to the variables */

        status = _gcSHADER_InitializeStorageBlockVariableInfo(Shader,
                                                              StorageBlock);
        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Return variable count. */
    *Count = GetSBVariableCount(StorageBlock);

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_SetStorageBlockTopLevelMemberArrayInfo
**
**  Set the top level member array info (size, stride) of a storage block
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctINT VariableIndex
**          Index to variable in the storage block
**
**      gctINT TopMember
**          Flag indicating that variable is top level
**
**      gctINT ArraySize
**          Top level array size to be used on non top level variable
**
**      gctINT ArrayStride
**          Top level array stride to be used on non top level variable
**
*/
gceSTATUS
gcSHADER_SetStorageBlockTopLevelMemberArrayInfo(
    IN gcSHADER Shader,
    IN gctINT  VariableIndex,
    IN gctBOOL TopMember,
    IN gctINT ArraySize,
    IN gctINT ArrayStride
    )
{
    gceSTATUS status;
    gcVARIABLE variable;
    gctINT variableIndex;
    gctINT arraySize;
    gctINT arrayStride;

    gcmHEADER_ARG("Shader=0x%x VariableIndex=%d TopMember=%d ArraySize=%d ArrayStride=%d",
                  Shader, VariableIndex, TopMember, ArraySize, ArrayStride);

    variableIndex = VariableIndex;
    while(variableIndex != -1)
    {
        status = gcSHADER_GetVariable(Shader,
                                      variableIndex,
                                      &variable);
        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        if(variable)
        {
            if(TopMember)
            {
                /* Only arrays of aggregate types(structures or arrays) can be treated as top-level array. */
                if ((isVariableStruct(variable) && isVariableArray(variable)) ||
                    isVariableArraysOfArrays(variable))
                {
                    arraySize = GetVariableArraySize(variable);
                    if(arraySize == -1) arraySize = 0;
                    arrayStride = GetVariableArrayStride(variable);

                    if (isVariableStruct(variable) && variable->arraySize == -1)
                    {
                        gctINT i;

                        for (i = 1; i < variable->arrayLengthCount; i++)
                        {
                            gcmASSERT(variable->arrayLengthList[i] > 0);
                            arrayStride *= variable->arrayLengthList[i];
                        }
                    }
                }
                else
                {
                    arraySize = 1;
                    arrayStride = 0;
                }
            }
            else
            {
                arraySize = ArraySize;
                arrayStride = ArrayStride;
            }

            SetVariableTopLevelArraySize(variable, arraySize);
            SetVariableTopLevelArrayStride(variable, arrayStride);

            if(isVariableStruct(variable))
            {
                status = gcSHADER_SetStorageBlockTopLevelMemberArrayInfo(Shader,
                                                                         variable->firstChild,
                                                                         gcvFALSE,
                                                                         arraySize,
                                                                         arrayStride);
                if (gcmIS_ERROR(status))
                {
                    /* Error. */
                    gcmFOOTER();
                    return status;
                }
            }
        }
        variableIndex = variable->nextSibling;
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetStorageBlockVariable
**
**  Get the gcVARIABLE object pointer for an indexed variable of a storage
**  block for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcsSTORAGE_BLOCK StorageBlock
**          Pointer to storage block to retreive the variable.
**
**      gctUINT Index
**          Index of variable to retreive the name for.
**
**  OUTPUT:
**
**      gcVARIABLE * Variable
**          Pointer to a variable receiving the gcVARIABLE object pointer.
*/
gceSTATUS
gcSHADER_GetStorageBlockVariable(
    IN gcSHADER Shader,
    IN gcsSTORAGE_BLOCK StorageBlock,
    IN gctUINT Index,
    OUT gcVARIABLE * Variable
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x StorageBlock=0x%x Index=%u", Shader, StorageBlock, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(StorageBlock != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(Variable != gcvNULL);

    if(GetSBVariableCount(StorageBlock) == 0) {
        /* compute the variable count and create the array of pointers to the variables */
        status = _gcSHADER_InitializeStorageBlockVariableInfo(Shader,
                                                              StorageBlock);
        if (gcmIS_ERROR(status)) {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    if (Index >= GetSBVariableCount(StorageBlock)) {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    /* Return the gcVARIABLE object pointer. */
    *Variable = GetSBVariables(StorageBlock)[Index];

    /* Success. */
    gcmFOOTER_ARG("*Variable=0x%x", *Variable);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetStorageBlockCount
**
**  Get the number of storage blocks for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of storage blocks.
*/
gceSTATUS
gcSHADER_GetStorageBlockCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    /* Return storage block count. */
    *Count = Shader->storageBlockCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetStorageBlock
**
**  Get the gcsSTORAGE_BLOCK object pointer for an indexed storage block for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT Index
**          Index of storage block to retreive the name for.
**
**  OUTPUT:
**
**      gcsSTORAGE_BLOCK * StorageBlock
**          Pointer to a variable receiving the gcsSTORAGE_BLOCK object pointer.
*/
gceSTATUS
gcSHADER_GetStorageBlock(
    IN gcSHADER Shader,
    IN gctUINT Index,
    OUT gcsSTORAGE_BLOCK * StorageBlock
    )
{
    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Index < Shader->storageBlockCount);
    gcmDEBUG_VERIFY_ARGUMENT(StorageBlock != gcvNULL);

    /* Return the gcsSTORAGE_BLOCK object pointer. */
    *StorageBlock = Shader->storageBlocks[Index];

    /* Success. */
    gcmFOOTER_ARG("*StorageBlock=0x%x", *StorageBlock);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetIoBlockVariable
**
**  Get the gcVARIABLE object pointer for an indexed variable of a storage
**  block for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcsIO_BLOCK IoBlock
**          Pointer to io block to retreive the variable.
**
**      gctUINT Index
**          Index of variable to retreive the name for.
**
**  OUTPUT:
**
**      gcVARIABLE * Variable
**          Pointer to a variable receiving the gcVARIABLE object pointer.
*/
gceSTATUS
gcSHADER_GetIoBlockVariable(
    IN gcSHADER Shader,
    IN gcsIO_BLOCK IoBlock,
    IN gctUINT Index,
    OUT gcVARIABLE * Variable
    )
{
    gcmHEADER_ARG("Shader=0x%x IoBlock=0x%x Index=%u", Shader, IoBlock, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(IoBlock != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(Variable != gcvNULL);

    /* Return the gcVARIABLE object pointer. */
    *Variable = gcvNULL;

    /* Success. */
    gcmFOOTER_ARG("*Variable=0x%x", *Variable);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetIoBlockCount
**
**  Get the number of io blocks for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of io blocks.
*/
gceSTATUS
gcSHADER_GetIoBlockCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    /* Return io block count. */
    *Count = Shader->ioBlockCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetIoBlock
**
**  Get the gcsIO_BLOCK object pointer for an indexed io block for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT Index
**          Index of io block to retreive the name for.
**
**  OUTPUT:
**
**      gcsIO_BLOCK * IoBlock
**          Pointer to a variable receiving the gcsIO_BLOCK object pointer.
*/
gceSTATUS
gcSHADER_GetIoBlock(
    IN gcSHADER Shader,
    IN gctUINT Index,
    OUT gcsIO_BLOCK * IoBlock
    )
{
    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Index < Shader->ioBlockCount);
    gcmDEBUG_VERIFY_ARGUMENT(IoBlock != gcvNULL);

    /* Return the gcsIO_BLOCK object pointer. */
    *IoBlock = Shader->ioBlocks[Index];

    /* Success. */
    gcmFOOTER_ARG("*IoBlock=0x%x", *IoBlock);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetIoBlockByName
**
**  Get the gcsIO_BLOCK object pointer for an indexed io block for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING BlockName
**          Block name of io block to retreive the name for.
**
**      gctCONST_STRING InstanceName
**          Instance name of io block to retreive the name for.
**
**  OUTPUT:
**
**      gcsIO_BLOCK * IoBlock
**          Pointer to a variable receiving the gcsIO_BLOCK object pointer.
*/
gceSTATUS
gcSHADER_GetIoBlockByName(
    IN gcSHADER Shader,
    IN gctCONST_STRING BlockName,
    IN gctCONST_STRING InstanceName,
    OUT gcsIO_BLOCK * IoBlock
    )
{
    gctUINT32 i;
    gcsIO_BLOCK block = gcvNULL;
    gceSTATUS status = gcvSTATUS_NAME_NOT_FOUND;
    gctINT nameLength, instanceNameLength = 0;

    gcmHEADER_ARG("Shader=0x%x BlockName=0x%x InstanceName=0x%x", Shader, BlockName, InstanceName);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(IoBlock != gcvNULL && BlockName != gcvNULL);

    nameLength = (gctINT)gcoOS_StrLen(BlockName, gcvNULL);
    if (InstanceName != gcvNULL)
    {
        instanceNameLength = (gctINT)gcoOS_StrLen(InstanceName, gcvNULL);
    }

    if (Shader->ioBlockCount > 0)
    {
        for (i = 0; i < Shader->ioBlockCount; i++)
        {
            if (Shader->ioBlocks[i] == gcvNULL)
                continue;

            if (nameLength == Shader->ioBlocks[i]->nameLength &&
                gcmIS_SUCCESS(gcoOS_StrNCmp(Shader->ioBlocks[i]->name, BlockName, nameLength)) &&
                instanceNameLength == Shader->ioBlocks[i]->instanceNameLength &&
                (instanceNameLength == 0 ||
                 gcmIS_SUCCESS(gcoOS_StrNCmp(&Shader->ioBlocks[i]->name[nameLength + 1], InstanceName, instanceNameLength))))
            {
                block = Shader->ioBlocks[i];
                status = gcvSTATUS_OK;
                break;
            }
        }
    }

    if (IoBlock)
    {
        *IoBlock = block;
    }

    /* Success. */
    gcmFOOTER_ARG("*IoBlock=0x%x", *IoBlock);
    return status;
}

/*******************************************************************************
**  gcSHADER_GetFunctionByName
**
**  Get the gcFUNCTION object pointer for an named kernel function for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT FunctionName
**          Name of kernel function to retreive the name for.
**
**  OUTPUT:
**
**      gcFUNCTION * Function
**          Pointer to a variable receiving the gcKERNEL_FUNCTION object pointer.
*/
gceSTATUS
gcSHADER_GetFunctionByName(
    IN gcSHADER Shader,
    IN gctCONST_STRING FunctionName,
    OUT gcFUNCTION * Function
    )
{
    gctUINT32 i;
    gceSTATUS status = gcvSTATUS_NAME_NOT_FOUND;
    gcmHEADER_ARG("Shader=0x%x FunctionName=%s", Shader, FunctionName);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Function != gcvNULL);

    /* Return the gcKERNEL_FUNCTION object pointer. */
    if (Shader->functionCount > 0)
    {
        for (i = 0; i < Shader->functionCount; i++)
        {
            if (Shader->functions[i] == gcvNULL)
                continue;

            if (gcmIS_SUCCESS(gcoOS_StrCmp(Shader->functions[i]->name, FunctionName)))
            {
                *Function = Shader->functions[i];
                status = gcvSTATUS_OK;
                break;
            }
        }
    }

    /* Success. */
    gcmFOOTER_ARG("*Function=0x%x", *Function);
    return status;
}

/*******************************************************************************
**  gcSHADER_GetFunctionByHeadIndex
**
**  Get the gcFUNCTION object pointer for an named kernel function for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT FunctionHeadIndex
**          Head index of kernel function to retreive the name for.
**
**  OUTPUT:
**
**      gcFUNCTION * Function
**          Pointer to a variable receiving the gcFUNCTION object pointer.
*/
gceSTATUS
gcSHADER_GetFunctionByHeadIndex(
    IN     gcSHADER         Shader,
    IN     gctUINT          HeadIndex,
    OUT    gcFUNCTION *     Function
    )
{
    gctUINT32  i;
    gcFUNCTION function = gcvNULL;
    gceSTATUS status = gcvSTATUS_NAME_NOT_FOUND;
    gcmHEADER_ARG("Shader=0x%x FunctionHeadIndex=%d", Shader, HeadIndex);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Function != gcvNULL);

    /* Return the gcFUNCTION object pointer. */
    if (Shader->functionCount > 0)
    {
        for (i = 0; i < Shader->functionCount; i++) {
            if (Shader->functions[i] == gcvNULL) continue;

            if ((Shader->functions[i]->codeStart == HeadIndex) ||
                (Shader->functions[i]->label == HeadIndex))
            {
                function = Shader->functions[i];
                status = gcvSTATUS_OK;
                break;
            }
        }
    }

    *Function = function;

    /* Success. */
    gcmFOOTER_ARG("*Function=0x%x", *Function);
    return status;
}

/*******************************************************************************
**  gcSHADER_GetKernelFunctionByHeadIndex
**
**  Get the gcKERNEL_FUNCTION object pointer for an named kernel function for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT FunctionHeadIndex
**          Head index of kernel function to retreive the name for.
**
**  OUTPUT:
**
**      gcKERNEL_FUNCTION * Function
**          Pointer to a variable receiving the gcKERNEL_FUNCTION object pointer.
*/
gceSTATUS
gcSHADER_GetKernelFunctionByHeadIndex(
    IN  gcSHADER            Shader,
    IN  gctUINT             HeadIndex,
    OUT gcKERNEL_FUNCTION * Function
    )
{
    gctUINT32               i;
    gcKERNEL_FUNCTION       function = gcvNULL;
    gceSTATUS               status = gcvSTATUS_NAME_NOT_FOUND;

    gcmHEADER_ARG("Shader=0x%x FunctionHeadIndex=%d", Shader, HeadIndex);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Function != gcvNULL);

    /* Return the gcKERNEL_FUNCTION object pointer. */
    if (Shader->kernelFunctionCount > 0)
    {
        for (i = 0; i < Shader->kernelFunctionCount; i++) {
            if (Shader->kernelFunctions[i] == gcvNULL) continue;

            if (Shader->kernelFunctions[i]->codeStart == HeadIndex)
            {
                function = Shader->kernelFunctions[i];
                status = gcvSTATUS_OK;
                break;
            }
        }
    }

    *Function = function;

    /* Success. */
    gcmFOOTER_ARG("*Function=0x%x", *Function);
    return status;
}

/*******************************************************************************
**  gcSHADER_GetKernelFucntion
**
**  Get the gcKERNEL_FUNCTION object pointer for an indexed kernel function for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT Index
**          Index of kernel function to retreive the name for.
**
**  OUTPUT:
**
**      gcKERNEL_FUNCTION * KernelFunction
**          Pointer to a variable receiving the gcKERNEL_FUNCTION object pointer.
*/
gceSTATUS
gcSHADER_GetKernelFunction(
    IN gcSHADER Shader,
    IN gctUINT Index,
    OUT gcKERNEL_FUNCTION * KernelFunction
    )
{
    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Index < Shader->kernelFunctionCount);
    gcmDEBUG_VERIFY_ARGUMENT(KernelFunction != gcvNULL);

    /* Return the gcKERNEL_FUNCTION object pointer. */
    *KernelFunction = Shader->kernelFunctions[Index];

    /* Success. */
    gcmFOOTER_ARG("*KernelFunction=0x%x", *KernelFunction);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetKernelFucntionByName
**
**  Get the gcKERNEL_FUNCTION object pointer for an named kernel function for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT KernelName
**          Name of kernel function to retreive the name for.
**
**  OUTPUT:
**
**      gcKERNEL_FUNCTION * KernelFunction
**          Pointer to a variable receiving the gcKERNEL_FUNCTION object pointer.
*/
gceSTATUS
gcSHADER_GetKernelFunctionByName(
    IN gcSHADER Shader,
    IN gctSTRING KernelName,
    OUT gcKERNEL_FUNCTION * KernelFunction
    )
{
    gctUINT32 i;

    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, KernelName);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(KernelFunction != gcvNULL);

    /* Return the gcKERNEL_FUNCTION object pointer. */
    if(Shader->kernelFunctionCount > 0)
    {
        for (i = 0; i < Shader->kernelFunctionCount; i++)
        {
            if (Shader->kernelFunctions[i] == gcvNULL)
                continue;

            if (gcmIS_SUCCESS(gcoOS_StrCmp(Shader->kernelFunctions[i]->name, KernelName)))
            {
                *KernelFunction = Shader->kernelFunctions[i];
                break;
            }
        }
    }

    /* Success. */
    gcmFOOTER_ARG("*KernelFunction=0x%x", *KernelFunction);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetKernelFunctionCount
**
**  Get the number of kernel functions for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of kernel functions.
*/
gceSTATUS
gcSHADER_GetKernelFunctionCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    /* Return uniform count. */
    *Count = Shader->kernelFunctionCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetUniform
**
**  Get the gcUNIFORM object pointer for an indexed uniform for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT Index
**          Index of uniform to retreive the name for.
**
**  OUTPUT:
**
**      gcUNIFORM * Uniform
**          Pointer to a variable receiving the gcUNIFORM object pointer.
*/
gceSTATUS
gcSHADER_GetUniform(
    IN gcSHADER Shader,
    IN gctUINT Index,
    OUT gcUNIFORM * Uniform
    )
{
    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Index < Shader->uniformCount);
    gcmDEBUG_VERIFY_ARGUMENT(Uniform != gcvNULL);

    /* Return the gcUNIFORM object pointer. */
    *Uniform = Shader->uniforms[Index];

    /* Success. */
    gcmFOOTER_ARG("*Uniform=0x%x", *Uniform);
    return gcvSTATUS_OK;
}


gceSTATUS
gcSHADER_GetUniformByName(
    IN gcSHADER Shader,
    IN gctCONST_STRING UniformName,
    IN gctUINT32 NameLength,
    OUT gcUNIFORM * Uniform
    )
{
    gctUINT32 idx;

    gcmHEADER_ARG("Shader=0x%x UniformName=%s", Shader, UniformName);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Uniform != gcvNULL);

    *Uniform = gcvNULL;
    for (idx = 0; idx < Shader->uniformCount; idx++)
    {
        gcUNIFORM uniform = Shader->uniforms[idx];

        if ((uniform->nameLength == (gctINT) NameLength)
            &&  gcmIS_SUCCESS(gcoOS_MemCmp(uniform->name,
                              UniformName,
                              NameLength))
            )
        {
            break;
        }
    }

    if (idx < Shader->uniformCount)
        *Uniform = Shader->uniforms[idx];

    /* Success. */
    gcmFOOTER_ARG("*Uniform=0x%x", *Uniform);
    return gcvSTATUS_OK;
}


/*******************************************************************************
**                             gcSHADER_GetUniformByPhysicalAddress
********************************************************************************
**
**    Get the gcUNIFORM object pointer by physical address for this shader.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gctINT Index
**            physical address of the uniform.
**
**    OUTPUT:
**
**        gcUNIFORM * Uniform
**            Pointer to a variable receiving the gcUNIFORM object pointer.
*/
gceSTATUS
gcSHADER_GetUniformByPhysicalAddress(
    IN gcSHADER Shader,
    IN gctINT PhysicalAddress,
    OUT gcUNIFORM * Uniform
    )
{
    gctUINT32 i;
    gcUNIFORM uniform = gcvNULL;
    gcmHEADER_ARG("Shader=0x%x PhysicalAddress=%u", Shader, PhysicalAddress);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Uniform != gcvNULL);

    for (i = 0; i < Shader->uniformCount; i++)
    {
        uniform = Shader->uniforms[i];

        if (uniform && isUniformSampler(uniform) &&
            GetUniformPhysical(uniform) == PhysicalAddress)
        {
            break;
        }
    }

    if (i == Shader->uniformCount)
        uniform = gcvNULL;

    /* Return the gcUNIFORM object pointer. */
    if (Uniform)
    {
        *Uniform = uniform;
    }

    /* Success. */
    gcmFOOTER_ARG("*Uniform=0x%x", *Uniform);
    return gcvSTATUS_OK;
}


/*******************************************************************************
**                             gcSHADER_ComputeUniformPhysicalAddress
********************************************************************************
**
**    Compuate the gcUNIFORM object pointer for this shader.
**
**    INPUT:
**
**        gctUINT32 HwConstRegBases
**            Base physical addresses for the uniform.
**
**
**        gcUNIFORM Uniform
**            The uniform pointer.
**
**    OUTPUT:
**
**        gctUINT32 * PhysicalAddress
**            Pointer to a variable receiving the physical address.
*/
gceSTATUS
gcSHADER_ComputeUniformPhysicalAddress(
    IN gctUINT32 HwConstRegBases[],
    IN gcUNIFORM Uniform,
    OUT gctUINT32 * PhysicalAddress
    )
{
    gctUINT32 baseAddress;
    gctUINT32 physicalAddress = 0;
    gctUINT32 shift;

    gcmHEADER_ARG("HwConstRegBases=0x%x, Uniform=0x%x", HwConstRegBases, Uniform);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Uniform != gcvNULL);

    shift = (gctUINT32)gcmExtractSwizzle(GetUniformSwizzle(Uniform), 0);

    switch (GetUniformShaderKind(Uniform))
    {
    case gcSHADER_TYPE_VERTEX:
        baseAddress = HwConstRegBases[gcvPROGRAM_STAGE_VERTEX];
        break;
    case gcSHADER_TYPE_FRAGMENT:
        baseAddress = HwConstRegBases[gcvPROGRAM_STAGE_FRAGMENT];
        break;
    case gcSHADER_TYPE_TCS:
        baseAddress = HwConstRegBases[gcvPROGRAM_STAGE_TCS];
        break;
    case gcSHADER_TYPE_TES:
        baseAddress = HwConstRegBases[gcvPROGRAM_STAGE_TES];
        break;
    case gcSHADER_TYPE_GEOMETRY:
        baseAddress = HwConstRegBases[gcvPROGRAM_STAGE_GEOMETRY];
        break;
    default:
        baseAddress = HwConstRegBases[gcvPROGRAM_STAGE_FRAGMENT];
        break;
    }

    physicalAddress = baseAddress + GetUniformPhysical(Uniform) * 16 + shift * 4;

    if (PhysicalAddress)
    {
        *PhysicalAddress = physicalAddress;
    }

    /* Success. */
    gcmFOOTER_ARG("physicalAddress=%u", physicalAddress);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetUniformBlock
**
**  Get the gcsUNIFORM_BLOCK object pointer for an indexed uniform block for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT Index
**          Index of uniform to retreive the name for.
**
**  OUTPUT:
**
**      gcsUNIFORM_BLOCK * UniformBlock
**          Pointer to a variable receiving the gcsUNIFORM_BLOCK object pointer.
*/
gceSTATUS
gcSHADER_GetUniformBlock(
    IN gcSHADER Shader,
    IN gctUINT Index,
    OUT gcsUNIFORM_BLOCK * UniformBlock
    )
{
    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Index < Shader->uniformBlockCount);
    gcmDEBUG_VERIFY_ARGUMENT(UniformBlock != gcvNULL);

    /* Return the gcsUNIFORM_BLOCK object pointer. */
    *UniformBlock = Shader->uniformBlocks[Index];

    /* Success. */
    gcmFOOTER_ARG("*UniformBlock=0x%x", *UniformBlock);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetUniformBlockUniform
**
**  Get the gcUNIFORM object pointer for an indexed uniform of a uniform
**  block for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcsUNIFORM_BLOCK UniformBlock
**          Pointer to uniform block to retreive the uniform.
**
**      gctUINT Index
**          Index of uniform to retreive the name for.
**
**  OUTPUT:
**
**      gcUNIFORM * Uniform
**          Pointer to a variable receiving the gcUNIFORM object pointer.
*/
gceSTATUS
gcSHADER_GetUniformBlockUniform(
    IN gcSHADER Shader,
    IN gcsUNIFORM_BLOCK UniformBlock,
    IN gctUINT Index,
    OUT gcUNIFORM * Uniform
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x UniformBlock=0x%x Index=%u", Shader, UniformBlock, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(UniformBlock != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(Uniform != gcvNULL);

    if(GetUBUniformCount(UniformBlock) == 0) {
        /* compute the uniform count and create the array of pointers to the uniforms */
        status = _gcSHADER_InitializeUniformBlockUniformInfo(Shader,
                                                             UniformBlock);
        if (gcmIS_ERROR(status)) {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    if (Index >= GetUBUniformCount(UniformBlock)) {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    /* Return the gcUNIFORM object pointer. */
    *Uniform = GetUBUniforms(UniformBlock)[Index];

    /* Success. */
    gcmFOOTER_ARG("*Uniform=0x%x", *Uniform);
    return gcvSTATUS_OK;
}

static void
_PostOrderUniform(
    IN gcSHADER Shader,
    IN gctINT rootUniformIndex,
    IN gctINT firstUniformIndex,
    IN gctINT *CurBase,
    IN gctINT offset,
    IN gctBOOL_PTR StartCalc,
    OUT gctINT *FirstUniformIndex,
    OUT gctINT *LastUniformIndex,
    OUT gctINT *OffsetUniformIndex,
    OUT gctINT *DeviationInOffsetUniform)
{
    gctINT16         uniformIndex;

    if (!*StartCalc && (rootUniformIndex == firstUniformIndex))
        *StartCalc = gcvTRUE;

    if (Shader->uniforms[rootUniformIndex]->firstChild != -1 &&
        !(isUniformImage(Shader->uniforms[rootUniformIndex]) ||
          isUniformSampler(Shader->uniforms[rootUniformIndex])))
    {
        gcmASSERT (isUniformStruct(Shader->uniforms[rootUniformIndex]));

        uniformIndex = Shader->uniforms[rootUniformIndex]->firstChild;
        while (uniformIndex != -1)
        {
            if (!*StartCalc && (uniformIndex == firstUniformIndex))
                *StartCalc = gcvTRUE;

            _PostOrderUniform(Shader, uniformIndex, firstUniformIndex, CurBase, offset,
                              StartCalc, FirstUniformIndex, LastUniformIndex,
                              OffsetUniformIndex, DeviationInOffsetUniform);
            uniformIndex = Shader->uniforms[uniformIndex]->nextSibling;
        }
    }

    /* Process root */
    if (isUniformNormal(Shader->uniforms[rootUniformIndex]) ||
        isUniformBlockMember(Shader->uniforms[rootUniformIndex]) ||
        isUniformBlockAddress(Shader->uniforms[rootUniformIndex]) ||
        isUniformLodMinMax(Shader->uniforms[rootUniformIndex]) ||
        isUniformLevelBaseSize(Shader->uniforms[rootUniformIndex]) ||
        isUniformSampleLocation(Shader->uniforms[rootUniformIndex]) ||
        isUniformMultiSampleBuffers(Shader->uniforms[rootUniformIndex]))
    {
        if (*StartCalc)
        {
            if (FirstUniformIndex && *FirstUniformIndex == -1)
                *FirstUniformIndex = rootUniformIndex;

            if (LastUniformIndex && *LastUniformIndex < rootUniformIndex)
                *LastUniformIndex = rootUniformIndex;

            if (OffsetUniformIndex && offset >= 0 && CurBase && DeviationInOffsetUniform)
            {
                gctINT sizeUniform = Shader->uniforms[rootUniformIndex]->arraySize *
                                     gcmType_Rows(Shader->uniforms[rootUniformIndex]->u.type);

                if ((offset < *CurBase +  sizeUniform) && (*OffsetUniformIndex == -1))
                {
                    *OffsetUniformIndex = rootUniformIndex;
                    *DeviationInOffsetUniform = offset - *CurBase;
                }

                (*CurBase) += sizeUniform;
            }
        }
    }
    else
    {
        /* Nothing to do. */
    }
}

/*******************************************************************************
**                             gcSHADER_GetUniformIndexingRange
********************************************************************************
**
**    Get the gcUNIFORM object pointer for an indexed uniform for this shader.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gctINT uniformIndex
**            Index of the start uniform.
**
**        gctINT offset
**            Offset to indexing.
**
**    OUTPUT:
**
**        gctINT * LastUniformIndex
**            Pointer to index of last uniform in indexing range.
**
**        gctINT * OffsetUniformIndex
**            Pointer to index of uniform that indexing at offset.
**
**        gctINT * DeviationInOffsetUniform
**            Pointer to offset in uniform picked up.
*/
gceSTATUS
gcSHADER_GetUniformIndexingRange(
    IN gcSHADER Shader,
    IN gctINT uniformIndex,
    IN gctINT offset,
    OUT gctINT * LastUniformIndex,
    OUT gctINT * OffsetUniformIndex,
    OUT gctINT * DeviationInOffsetUniform
    )
{
    gceSTATUS        status = gcvSTATUS_OK;
    gctINT           root = -1, firstUniformIndex, curBase = 0;
    gcUNIFORM        thisUniform;
    gctBOOL          bStartCalc = gcvFALSE;

    /* Find arrayed root for this uniform */
    thisUniform = Shader->uniforms[uniformIndex];
    while (thisUniform)
    {
        if (!isUniformImageExtraLayer(thisUniform) &&
            thisUniform->parent != -1 &&
            !isUniformLodMinMax(thisUniform)  &&
            !isUniformLevelBaseSize(thisUniform) &&
            !isUniformMLSampler(thisUniform))
        {
            gctINT parent = thisUniform->parent;
            thisUniform = Shader->uniforms[thisUniform->parent];

            /* Find the out-most array */
            if (thisUniform->arraySize > 1)
                root = parent;
        }
        else
            thisUniform = gcvNULL;
    }

    /* Post order to calc range */
    firstUniformIndex = -1;
    if (LastUniformIndex) *LastUniformIndex = 0;
    if (OffsetUniformIndex) *OffsetUniformIndex = -1;
    _PostOrderUniform(Shader,
                      (root == -1) ? uniformIndex : root, uniformIndex, &curBase, offset,
                      &bStartCalc, &firstUniformIndex, LastUniformIndex, OffsetUniformIndex,
                      DeviationInOffsetUniform);

    gcmASSERT(firstUniformIndex == uniformIndex);

    if (OffsetUniformIndex && *OffsetUniformIndex == -1)
        status = gcvSTATUS_INVALID_DATA;

    return status;
}

/*******************************************************************************
**  gcSHADER_ReallocateOutputs
**
**  Reallocate an array of pointers to gcOUTPUT objects.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcSHADER_ReallocateOutputs(
    IN gcSHADER Shader,
    IN gctUINT32 Count
    )
{
    gcOUTPUT * outputs;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Count=%lu", Shader, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Count < Shader->outputCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Shader->outputArraySize)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcOUTPUT) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    outputs = pointer;

    if (Shader->outputs != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(outputs,
                                   Shader->outputs,
                                   gcmSIZEOF(gcOUTPUT)
                      * Shader->outputCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->outputs));
    }

    /* Set new gcOUTPUT object pointer. */
    Shader->outputArraySize = Count;
    Shader->outputs          = outputs;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOutput
**
**  Add an output to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          Name of the output to add.
**
**      gcSHADER_TYPE Type
**          Type of the output to add.
**
**      gctUINT32 Length
**          Array length of the output to add.  'Length' must be at least 1.
**
**      gctUINT16 TempRegister
**          Temporary register index that holds the output value.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOutput(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gctUINT32 Length,
    IN gctUINT32 TempRegister,
    IN gcSHADER_PRECISION Precision
    )
{
    gctUINT32 nameLength, bytes, i;
    gcOUTPUT output;
    gceSTATUS status;
    gctBOOL copyName;
    gctPOINTER pointer = gcvNULL;
    gctUINT32 kind;
    gctINT location = -1;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d Length=%lu TempRegister=%u",
                  Shader, Name, Type, Length, TempRegister);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check array count. */
    if (Shader->outputArraySize < Shader->outputCount + Length)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateOutputs(Shader, Shader->outputCount + Length + 9);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    if (gcmIS_SUCCESS(gcSHADER_GetBuiltinNameKind(Shader, Name, &kind)) &&
        kind != gcSL_NONBUILTINGNAME)
    {
        nameLength = kind;
        bytes      = gcmOFFSETOF(_gcOUTPUT, name);
        copyName   = gcvFALSE;
    }
    else
    {
        /* Get the length of the name. */
        nameLength = gcoOS_StrLen(Name, gcvNULL);

        /* Compute the number of bytes required for the gcOUTPUT object. */
        bytes      = gcmOFFSETOF(_gcOUTPUT, name) + nameLength + 1;

        /* Mark the name to be copied. */
        copyName   = gcvTRUE;
    }

    /* Generate gcOUTPUT object for each array entry. */
    for (i = 0; i < Length; ++i)
    {
        /* Allocate the gcOUTPUT object. */
        status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        output = pointer;

        gcoOS_ZeroMemory(output, bytes);

        /* Initialize the gcOUTPUT object. */
        output->object.type         = gcvOBJ_OUTPUT;
        output->index               = (gctUINT16)Shader->outputCount;
        output->origType            = Type;
        output->type                = Type;
        output->precision           = Precision;
        output->flags_              = 0;
        /* TODO: refine the code, there is size=1 arrays */
        gcmOUTPUT_SetIsArray(output, (Length > 1));
        output->arraySize           = Length;
        output->arrayIndex          = i;
        output->tempIndex           = TempRegister;
        output->shaderMode          = gcSHADER_SHADER_DEFAULT;
        output->layoutQualifier     = gcvLAYOUT_QUALIFIER_NONE;
        output->nameLength          = nameLength;
        output->ioBlockIndex        = -1;
        output->ioBlockArrayIndex   = 0;
        output->nextSibling         = -1;
        output->prevSibling         = -1;
        output->typeNameVarIndex    = -1;

        if (copyName)
        {
            /* Copy the output name. */
            gcoOS_MemCopy(output->name, Name, nameLength + 1);
        }

        /* set default output location */
        output->location    = Shader->outputCount;
        /* Set new gcOUTPUT object pointer. */
        Shader->outputs[Shader->outputCount++] = output;

        if (location == -1)
        {
            location = output->location;
        }
    }

    status = gcSHADER_AddOutputLocation(Shader,
                                        location,
                                        Length);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    for (i = Shader->outputCount - Length; i < Shader->outputCount; i++)
    {
       Shader->outputs[i]->location = Shader->outputLocations[i];
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static gceSTATUS
_AddOutputEx(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gcSHADER_PRECISION Precision,
    IN gctBOOL IsArray,
    IN gctUINT32 Length,
    IN gctUINT32 TempRegister,
    IN gctINT FieldIndex,
    IN gctBOOL IsInvariant,
    IN gctBOOL IsPrecise,
    IN gcSHADER_SHADERMODE ShaderMode,
    OUT gcOUTPUT * Output
    )
{
    gctUINT32 nameLength, bytes, i;
    gcOUTPUT output;
    gceSTATUS status;
    gctBOOL copyName;
    gctPOINTER pointer = gcvNULL;
    gctUINT32 kind;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d Length=%lu Precision=%d TempRegister=%u",
                  Shader, Name, Type, Length, Precision, TempRegister);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check array count. */
    if (Shader->outputArraySize < Shader->outputCount + Length)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateOutputs(Shader, Shader->outputCount + Length + 9);

        if (gcmIS_ERROR(status))
    {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    if (gcmIS_SUCCESS(gcSHADER_GetBuiltinNameKind(Shader, Name, &kind)) &&
        kind != gcSL_NONBUILTINGNAME)
    {
        nameLength = kind;
        bytes      = gcmOFFSETOF(_gcOUTPUT, name);
        copyName   = gcvFALSE;
    }
    else
    {
        /* Get the length of the name. */
        nameLength = gcoOS_StrLen(Name, gcvNULL);

        /* Compute the number of bytes required for the gcOUTPUT object. */
        bytes      = gcmOFFSETOF(_gcOUTPUT, name) + nameLength + 1;

        /* Mark the name to be copied. */
        copyName   = gcvTRUE;
    }

    /* Generate gcOUTPUT object for each array entry. */
    for (i = 0; i < Length; ++i)
    {
        /* Allocate the gcOUTPUT object. */
        status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        output = pointer;

        gcoOS_ZeroMemory(output, bytes);

        /* Initialize the gcOUTPUT object. */
        output->object.type           = gcvOBJ_OUTPUT;
        output->index                 = (gctUINT16)Shader->outputCount;
        output->origType              = Type;
        output->type                  = Type;
        output->precision             = Precision;
        output->flags_                = 0;
        /* TODO: refine the code, there is size=1 arrays */
        gcmOUTPUT_SetIsArray(output, IsArray);

        /* Check if we need to force all outputs to be invariant. */
        if (gcShaderForceAllOutputInvariant(Shader))
        {
            gcmOUTPUT_SetIsInvariant(output, gcvTRUE);
        }
        else
        {
            gcmOUTPUT_SetIsInvariant(output, IsInvariant);
        }

        gcmOUTPUT_SetIsPrecise(output, IsInvariant);
        output->arraySize             = Length;
        output->arrayIndex            = i;
        output->tempIndex             = TempRegister;
        output->shaderMode            = ShaderMode;
        output->layoutQualifier       = gcvLAYOUT_QUALIFIER_NONE;
        output->ioBlockIndex          = -1;
        output->ioBlockArrayIndex     = 0;
        output->nameLength            = nameLength;
        output->nextSibling           = -1;
        output->prevSibling           = -1;
        output->typeNameVarIndex      = -1;

        /* Don't update temp register count if this temp register is invalid. */
        if (TempRegister != (gctUINT32)-1)
        {
            gcSHADER_UpdateTempRegCount(Shader, TempRegister);
        }

        if (copyName)
        {
            /* Copy the output name. */
            gcoOS_MemCopy(output->name, Name, nameLength + 1);
        }

        /* set default location */
        output->location = gcUseFullNewLinker(GetHWHasHalti2()) ? -1: Shader->outputCount;
        /* set default field index */
        output->fieldIndex = FieldIndex;
        /* Set new gcOUTPUT object pointer. */
        Shader->outputs[Shader->outputCount++] = output;
    }

    if(Output) {
       /* Return the first gcOUTPUT object pointer. */
       *Output = Shader->outputs[Shader->outputCount - Length];
    }

    gcmFOOTER_ARG("*Output=0x%x", gcmOPT_POINTER(Output));
    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOutputWithLocation
**
**  Add an output with an associated location to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          Name of the output to add.
**
**      gcSHADER_TYPE Type
**          Type of the output to add.
**
**    gcSHADER_PRECISION Precision
**          Precision of the output.
**
**      gctUINT32 Length
**          Array length of the output to add.  'Length' must be at least 1.
**
**      gctUINT32 TempRegister
**          Temporary register index that holds the output value.
**
**      gctINT Location
**          Location associated with the output.
**
**  OUTPUT:
**
**      gcOUTPUT * Output
**          Pointer to an output receiving the gcOUTPUT object pointer.
*/
gceSTATUS
gcSHADER_AddOutputWithLocation(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gcSHADER_PRECISION Precision,
    IN gctBOOL IsArray,
    IN gctUINT32 Length,
    IN gctUINT32 TempRegister,
    IN gcSHADER_SHADERMODE ShaderMode,
    IN gctINT Location,
    IN gctINT FieldIndex,
    IN gctBOOL IsInvariant,
    IN gctBOOL IsPrecise,
    OUT gcOUTPUT * Output
    )
{
    gceSTATUS status;
    gctUINT32 i;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d Length=%lu Precision=%d TempRegister=%u Location=%d",
                  Shader, Name, Type, Length, Precision, TempRegister, Location);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    status =  _AddOutputEx(Shader,
                           Name,
                           Type,
                           Precision,
                           IsArray,
                           Length,
                           TempRegister,
                           FieldIndex,
                           IsInvariant,
                           IsPrecise,
                           ShaderMode,
                           Output);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    status = gcSHADER_AddOutputLocation(Shader,
                                        Location,
                                        Length);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    for(i = Shader->outputCount - Length; i < Shader->outputCount; i++) {
       Shader->outputs[i]->location = Shader->outputLocations[i];
    }

    gcmFOOTER_ARG("*Output=0x%x", gcmOPT_POINTER(Output));
    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOutputIndexed
**
**  Add an indexed output to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          Name of the output to add.
**
**      gctUINT Index
**          Index of output to add.
**
**      gctUINT32 TempRegister
**          Temporary register index that holds the output value.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOutputIndexed(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gctUINT32 Index,
    IN gctUINT32 TempIndex
    )
{
    gctUINT32 i;
    gctUINT32 kind = 0;

    gcmHEADER_ARG("Shader=0x%x Name=%s Index=%lu TempIndex=%d",
                  Shader, Name, Index, TempIndex);

    gcSHADER_GetBuiltinNameKind(Shader, Name, &kind);

    for (i = 0; i < Shader->outputCount; ++i)
    {
        gcOUTPUT output = Shader->outputs[i];

        if ((output->nameLength > 0 &&
             gcmIS_SUCCESS(gcoOS_StrCmp(Name, output->name))) ||
             ((kind == (gctUINT)output->nameLength) &&
              ((output->nameLength == gcSL_COLOR) ||
               (output->nameLength == gcSL_TESS_LEVEL_OUTER) ||
               (output->nameLength == gcSL_TESS_LEVEL_INNER) ||
               (output->nameLength == gcSL_BOUNDING_BOX))))
        {
            if (Index >= (gctUINT32)output->arraySize)
            {
                gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_INDEX);
                return gcvSTATUS_INVALID_INDEX;
            }

            output = Shader->outputs[i + Index];
            output->tempIndex = TempIndex;
            gcmASSERT(output->arrayIndex == (gctINT)Index);
            gcSHADER_UpdateTempRegCount(Shader, TempIndex);
            gcmFOOTER_NO();
            return gcvSTATUS_OK;
        }
    }

    gcmFOOTER_ARG("status=%d", gcvSTATUS_NAME_MISMATCH);
    return gcvSTATUS_NAME_MISMATCH;
}

/*******************************************************************************
**  gcOUTPUT_SetType
**
**  Set the type of an output.
**
**  INPUT:
**
**      gcOUTPUT Output
**          Pointer to a gcOUTPUT object.
**
**      gcSHADER_TYPE Type
**          Type of the output.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcOUTPUT_SetType(
    IN gcOUTPUT Output,
    IN gcSHADER_TYPE Type
    )
{
    gcmHEADER_ARG("Output=0x%x Type=%d",
                  Output, Type);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Output, gcvOBJ_OUTPUT);

    Output->type = Type;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetOutputCount
**
**  Get the number of outputs for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of outputs.
*/
gceSTATUS
gcSHADER_GetOutputCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    /* Return output count. */
    *Count = Shader->outputCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetOutput
**
**  Get the gcOUTPUT object pointer for an indexed output for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT Index
**          Index of output to retrieve.
**
**  OUTPUT:
**
**      gcOUTPUT * Output
**          Pointer to a variable receiving the gcOUTPUT object pointer.
*/
gceSTATUS
gcSHADER_GetOutput(
    IN gcSHADER Shader,
    IN gctUINT Index,
    OUT gcOUTPUT * Output
    )
{
    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Index < Shader->outputCount);
    gcmDEBUG_VERIFY_ARGUMENT(Output != gcvNULL);

    /* Return the gcOUTPUT object pointer. */
    *Output = Shader->outputs[Index];

    /* Success. */
    gcmFOOTER_ARG("*Output=0x%x", *Output);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                               gcSHADER_GetOutputByName
********************************************************************************
**
**    Get the gcOUTPUT object pointer for this shader by output name.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gctSTRING name
**            Name of output to retrieve.
**
**      gctUINT32 nameLength
**          Length of name to retrieve
**
**    OUTPUT:
**
**        gcOUTPUT * Output
**            Pointer to a variable receiving the gcOUTPUT object pointer.
*/
gceSTATUS
gcSHADER_GetOutputByName(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gctUINT32 NameLength,
    OUT gcOUTPUT * Output
    )
{
    gctUINT32 idx;

    gcmHEADER_ARG("Shader=0x%x Name=%s", Shader, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Output != gcvNULL);

    *Output = gcvNULL;
    for (idx = 0; idx < Shader->outputCount; idx++)
    {
        gcOUTPUT output = Shader->outputs[idx];

        if ((output->nameLength == (gctINT) NameLength)
            &&  gcmIS_SUCCESS(gcoOS_MemCmp(output->name,
                              Name,
                              NameLength))
            )
        {
            break;
        }
    }

    if (idx < Shader->outputCount)
        *Output = Shader->outputs[idx];

    /* Success. */
    gcmFOOTER_ARG("*Output=0x%x", *Output);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                               gcSHADER_GetOutputByTempIndex
********************************************************************************
**
**    Get the gcOUTPUT object pointer for this shader by output temp index.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gctUINT32 TempIndex
**            Temp index of output to retrieve.
**
**
**    OUTPUT:
**
**        gcOUTPUT * Output
**            Pointer to a variable receiving the gcOUTPUT object pointer.
*/
gceSTATUS
gcSHADER_GetOutputByTempIndex(
    IN gcSHADER Shader,
    IN gctUINT32 TempIndex,
    OUT gcOUTPUT * Output
    )
{
    gctUINT32 idx;

    gcmHEADER_ARG("Shader=0x%x TempIndex=%d", Shader, TempIndex);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Output != gcvNULL);

    *Output = gcvNULL;
    for (idx = 0; idx < Shader->outputCount; idx++)
    {
        gcOUTPUT output = Shader->outputs[idx];
        gctUINT32 rows;

        if (!output) continue;

        gcTYPE_GetTypeInfo(output->type, gcvNULL, &rows, gcvNULL);

        if (output->tempIndex >= TempIndex && TempIndex <= output->tempIndex + rows -1)
        {
            break;
        }
    }

    if (idx < Shader->outputCount)
        *Output = Shader->outputs[idx];

    /* Success. */
    gcmFOOTER_ARG("*Output=0x%x", *Output);
    return gcvSTATUS_OK;
}

gceSTATUS
gcSHADER_GetOutputIndexByOutput(
    IN gcSHADER Shader,
    IN gcOUTPUT Output,
    IN OUT gctINT16 * Index
    )
{
    gctINT16 idx;

    gcmHEADER_ARG("Shader=0x%x Output=0x%x", Shader, Output);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Output != gcvNULL);

    for (idx = 0; idx < (gctINT16)Shader->outputCount; idx++)
    {
        if (Shader->outputs[idx] && Output == Shader->outputs[idx])
        {
            break;
        }
    }

    if (idx >= (gctINT16)Shader->outputCount)
        idx = -1;

    if (Index)
    {
        *Index = idx;
    }

    /* Success. */
    gcmFOOTER_ARG("*Output=0x%x", *Output);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_ReallocateVariables
**
**  Reallocate an array of pointers to gcVARIABLE objects.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcSHADER_ReallocateVariables(
    IN gcSHADER Shader,
    IN gctUINT32 Count
    )
{
    gcVARIABLE * variables;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Count=%lu", Shader, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Count < Shader->variableCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Shader->variableArraySize)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcVARIABLE) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    variables = pointer;

    if (Shader->variables != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(variables,
                      Shader->variables,
                      gcmSIZEOF(gcVARIABLE)
                      * Shader->variableCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->variables));
    }

    /* Set new gcVARIABLE object pointer. */
    Shader->variableArraySize = Count;
    Shader->variables          = variables;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddVariable
**
**  Add a variable to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          Name of the variable to add.
**
**      gcSHADER_TYPE Type
**          Type of the variable to add.
**
**      gctUINT32 Length
**          Array length of the variable to add.  'Length' must be at least 1.
**
**      gctUINT32 TempRegister
**          Temporary register index that holds the variable value.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddVariable(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gctUINT32 Length,
    IN gctUINT32 TempRegister
    )
{
    gctUINT32 nameLength=0, bytes;
    gcVARIABLE variable;
    gceSTATUS status = gcvSTATUS_OK;
    gctBOOL copyName;
    gctPOINTER pointer = gcvNULL;
    gctUINT32 kind;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d Length=%lu TempRegister=%u",
                  Shader, Name, Type, Length, TempRegister);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check array count. */
    if (Shader->variableArraySize <= Shader->variableCount)
    {
        /* Reallocate a new array of object pointers. */
        gcmONERROR(gcSHADER_ReallocateVariables(Shader, Shader->variableCount + 10));
    }

    if (gcmIS_SUCCESS(gcSHADER_GetBuiltinNameKind(Shader, Name, &kind)) &&
        (gctINT32)kind != gcSL_NONBUILTINGNAME)
    {
        nameLength = kind;
        bytes      = gcmOFFSETOF(_gcVARIABLE, name);
        copyName   = gcvFALSE;
    }
    else
    {
        /* Get the length of the name. */
        nameLength = gcoOS_StrLen(Name, gcvNULL);

        /* Compute the number of bytes required for the gcVARIABLE object. */
        bytes = gcmOFFSETOF(_gcVARIABLE, name) + nameLength + 1;

        /* Mark the name to be copied. */
        copyName   = gcvTRUE;
    }

    /* Allocate the gcVARIABLE object. */
    gcmONERROR(gcoOS_Allocate(gcvNULL, bytes, &pointer));

    variable = pointer;
    /* Clear the memory in case some union member was partially written */
    gcoOS_ZeroMemory(variable, bytes);

    /* Initialize the gcVARIABLE object. */
    variable->object.type = gcvOBJ_VARIABLE;
    variable->index       = (gctUINT16) Shader->variableCount;
    SetVariableCategory(variable, gcSHADER_VAR_CATEGORY_NORMAL);
    variable->firstChild = -1;
    variable->nextSibling = -1;
    variable->prevSibling = -1;
    variable->parent = -1;
    variable->qualifier = gcvTYPE_QUALIFIER_NONE;
    variable->u.type      = Type;
    variable->precision   = gcSHADER_PRECISION_DEFAULT;
    variable->arraySize   = Length;
    variable->tempIndex   = TempRegister;
    variable->nameLength  = nameLength;

    /* ES3.1 fields */
    variable->blockIndex = gcvBLOCK_INDEX_DEFAULT;
    variable->arrayStride = -1;
    variable->matrixStride = -1;
    variable->offset = -1;

    variable->topLevelArraySize = variable->arraySize;
    variable->topLevelArrayStride = -1;

    if ((gctINT32)kind != gcSL_NONBUILTINGNAME)
    {
        if ((gctINT32)kind == gcSL_VERTEX_ID)
        {
            gcShaderSetHasVertexIdVar(Shader);
        }
        else if ((gctINT32)kind == gcSL_INSTANCE_ID)
        {
            gcShaderSetHasInstanceIdVar(Shader);
        }
    }
    /* Copy the variable name. */
    if (copyName)
    {
       gcoOS_MemCopy(variable->name, Name, nameLength + 1);
    }

    /* Set new gcVARIABLE object pointer. */
    Shader->variables[Shader->variableCount++] = variable;

OnError:
    /* Success. */
    gcmFOOTER_NO();
    return status;
}

/*******************************************************************************
**  gcSHADER_AddVariableEx
**
**  Add a variable to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          Name of the variable to add.
**
**      gcSHADER_TYPE Type
**          Type of the variable to add.
**
**      gctUINT32 Length
**          Array length of the variable to add.  'Length' must be at least 1.
**
**      gctUINT32 TempRegister
**          Temporary register index that holds the variable value.
**
**      gcSHADER_VAR_CATEGORY varCategory
**          Variable category, normal or struct.
**
**      gctUINT16 numStructureElement
**          If struct, its element number.
**
**      gctINT16 parent
**          If struct, parent index in gcSHADER.variables.
**
**      gctINT16 prevSibling
**          If struct, previous sibling index in gcSHADER.variables.
**
**  OUTPUT:
**
**      gctINT16* ThisVarIndex
**          Returned value about variable index in gcSHADER.
*/
gceSTATUS
gcSHADER_AddVariableEx(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gctINT ArrayLengthCount,
    IN gctINT * ArrayLengthList,
    IN gctUINT32 TempRegister,
    IN gcSHADER_VAR_CATEGORY varCategory,
    IN gctUINT8 Precision,
    IN gctUINT16 numStructureElement,
    IN gctINT16 parent,
    IN gctINT16 prevSibling,
    OUT gctINT16* ThisVarIndex
    )
{
    gctUINT32 nameLength=0, bytes;
    gcVARIABLE variable;
    gceSTATUS status;
    gctBOOL copyName;
    gctPOINTER pointer = gcvNULL;
    gctINT16 thisIdx;
    gctUINT32 kind;
    gctINT i;

    gcmHEADER_ARG("Shader=0x%x Name=%s Type=%d TempRegister=%u varCategory=%d "
                  "numStructureElement=%d parent=%d prevSibling=%d ThisIndex=%d",
                  Shader, Name, Type, TempRegister, varCategory,
                  numStructureElement, parent, prevSibling, ThisVarIndex);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Check array count. */
    if (Shader->variableArraySize <= Shader->variableCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateVariables(Shader, Shader->variableCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    if (gcmIS_SUCCESS(gcSHADER_GetBuiltinNameKind(Shader, Name, &kind)) &&
        kind != gcSL_NONBUILTINGNAME)
    {
        nameLength = kind;
        bytes      = gcmOFFSETOF(_gcVARIABLE, name);
        copyName   = gcvFALSE;
    }
    else
    {
        /* Get the length of the name. */
        nameLength = gcoOS_StrLen(Name, gcvNULL);

        /* Compute the number of bytes required for the gcVARIABLE object. */
        bytes = gcmOFFSETOF(_gcVARIABLE, name) + nameLength + 1;

        /* Mark the name to be copied. */
        copyName   = gcvTRUE;
    }

    /* Allocate the gcVARIABLE object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    variable = pointer;

    /* Clear the memory in case some union member was partially written */
    gcoOS_ZeroMemory(variable, bytes);

    /* Initialize the gcVARIABLE object. */
    variable->object.type = gcvOBJ_VARIABLE;
    variable->index       = (gctUINT16) Shader->variableCount;
    SetVariableCategory(variable, varCategory);

    if (isVariableSimple(variable))
        variable->u.type = Type;
    else
        variable->u.numStructureElement = numStructureElement;

    variable->precision   = Precision;
    /* Link variables */
    thisIdx = (gctINT16)Shader->variableCount;
    variable->parent = parent;
    if (parent != -1)
    {
        if (Shader->variables[parent]->firstChild == -1)
            Shader->variables[parent]->firstChild = thisIdx;
        else
        {
            gctINT curIdx, preIdx;
            curIdx = Shader->variables[parent]->firstChild;
            preIdx = -1;
            while (curIdx != -1)
            {
                preIdx = curIdx;
                curIdx = Shader->variables[curIdx]->nextSibling;
            }
            gcmASSERT(preIdx != -1);
            Shader->variables[preIdx]->nextSibling = thisIdx;
        }
    }

    variable->prevSibling = prevSibling;
    if (prevSibling != -1)
        Shader->variables[prevSibling]->nextSibling = thisIdx;

    variable->nextSibling = -1;
    variable->firstChild = -1;
    variable->qualifier = gcvTYPE_QUALIFIER_NONE;

    variable->arrayLengthCount = ArrayLengthCount;
    if (ArrayLengthCount == 0)
    {
        variable->arraySize = 1;
        variable->arrayLengthList = gcvNULL;
    }
    else
    {
        variable->arraySize   = ArrayLengthList[0];

        variable->arrayLengthList = gcvNULL;
        if (ArrayLengthCount > 0)
        {
            status = gcoOS_Allocate(gcvNULL, gcmSIZEOF(gctINT) * ArrayLengthCount, &pointer);

            if (gcmIS_ERROR(status))
            {
                /* Error. */
                if(variable != gcvNULL)
                {
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, variable));
                }
                gcmFOOTER();
                return status;
            }
            gcoOS_ZeroMemory(pointer, gcmSIZEOF(gctINT) * ArrayLengthCount);

            variable->arrayLengthList = pointer;

            for (i = 0; i < ArrayLengthCount; i++)
            {
                variable->arrayLengthList[i] = ArrayLengthList[i];
            }
        }
    }

    variable->tempIndex   = TempRegister;
    variable->nameLength  = nameLength;

    /* ES3.1 fields */
    variable->blockIndex = gcvBLOCK_INDEX_DEFAULT;
    variable->arrayStride = -1;
    variable->matrixStride = -1;
    variable->offset = -1;

    variable->topLevelArraySize = variable->arraySize;
    variable->topLevelArrayStride = -1;

    if (kind != gcSL_NONBUILTINGNAME)
    {
        if (kind == (gctUINT32)gcSL_VERTEX_ID)
        {
            gcShaderSetHasVertexIdVar(Shader);
        }
        else if (kind == (gctUINT32)gcSL_INSTANCE_ID)
        {
            gcShaderSetHasInstanceIdVar(Shader);
        }
    }

    /* Copy the variable name. */
    if (copyName)
    {
       gcoOS_MemCopy(variable->name, Name, nameLength + 1);
    }

    /* Set new gcVARIABLE object pointer. */
    Shader->variables[Shader->variableCount++] = variable;

    /* Return this index */
    if (ThisVarIndex)
        *ThisVarIndex = thisIdx;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddVariableEx1
**
**  Add a variable to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctCONST_STRING Name
**          Name of the variable to add.
**
**      gctUINT32 TempRegister
**          Temporary register index that holds the variable value.
**
**      gcsSHADER_VAR_INFO *VarInfo
**          Variable information struct pointer.
**
**  OUTPUT:
**
**      gctINT16* ThisVarIndex
**          Returned value about variable index in gcSHADER.
*/
gceSTATUS
gcSHADER_AddVariableEx1(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    IN gctUINT32 TempRegister,
    IN gcsSHADER_VAR_INFO *VarInfo,
    OUT gctINT16* ThisVarIndex
    )
{
    gcVARIABLE variable;
    gceSTATUS status;
    gctINT16 thisIdx;

    gcmHEADER_ARG("Shader=0x%x Name=%s TempRegister=%u \
                   VarInfo=0x%x",
                  Shader, Name, TempRegister, VarInfo);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    status = gcSHADER_AddVariableEx(Shader,
                                    Name,
                                    VarInfo->type,
                                    VarInfo->arrayCount,
                                    VarInfo->arraySizeList,
                                    TempRegister,
                                    VarInfo->varCategory,
                                    VarInfo->precision,
                                    VarInfo->u.numStructureElement,
                                    VarInfo->parent,
                                    VarInfo->prevSibling,
                                    &thisIdx);
    if (gcmIS_ERROR(status)) {
       /* Error. */
       gcmFOOTER();
       return status;
    }

    gcmVERIFY_OK(gcSHADER_GetVariable(Shader, thisIdx, &variable));
    variable->precision = VarInfo->precision;
    if (VarInfo->isLocal)
    {
        SetVariableIsLocal(variable);
    }
    if (VarInfo->isOutput)
    {
        SetVariableIsOutput(variable);
    }
    if (VarInfo->isPrecise)
    {
        SetVariableIsPrecise(variable);
    }
    if (VarInfo->isPerVertex)
    {
        SetVariableIsPerVertex(variable);
    }

    /* Return this index */
    if (ThisVarIndex)
        *ThisVarIndex = thisIdx;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_UpdateVariable
********************************************************************************
**
**  Update a variable to a gcSHADER object.
**
**  INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gctUINT Index
**            Index of variable to retrieve.
**
**        gceVARIABLE_UPDATE_FLAGS flag
**            Flag which property of variable will be updated.
**
**      gctUINT newValue
**          New value to update.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_UpdateVariable(
    IN gcSHADER Shader,
    IN gctUINT Index,
    IN gceVARIABLE_UPDATE_FLAGS flag,
    IN gctUINT newValue
    )
{
    gcVARIABLE   variable;

    gcmHEADER_ARG("Shader=0x%x Index=%u flag=%d, newValue=%d", Shader, Index, flag, newValue);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Index < Shader->variableCount);

    gcmVERIFY_OK(gcSHADER_GetVariable(Shader, Index, &variable));

    switch (flag)
    {
    case gcvVARIABLE_UPDATE_TEMPREG:
        variable->tempIndex =  newValue;
        break;
    case gcvVARIABLE_UPDATE_TYPE_QUALIFIER:
        variable->qualifier = (gctTYPE_QUALIFIER)newValue;
        break;
    case gcvVARIABLE_UPDATE_NOUPDATE:
    default:
        break;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
gcSHADER_CopyVariable(
    IN gcSHADER Shader,
    IN gcVARIABLE Variable,
    IN gctUINT16 * Index
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctUINT32 bytes;
    gctPOINTER pointer = gcvNULL;
    gctBOOL copyName = gcvFALSE;
    gcVARIABLE variable = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Variable=0x%x Index=%d", Shader, Variable, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->variableArraySize <= Shader->variableCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateVariables(Shader, Shader->variableCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    if (Variable->nameLength < 0)
    {
        bytes = gcmOFFSETOF(_gcVARIABLE, name);
        copyName = gcvFALSE;
    }
    else
    {
        bytes = gcmOFFSETOF(_gcVARIABLE, name) + Variable->nameLength + 1;
        copyName = gcvTRUE;
    }

    /* Allocate the gcVARIABLE object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    variable = pointer;

    gcoOS_MemCopy(variable, Variable, bytes);

    variable->index = (gctUINT16)Shader->variableCount;
    Shader->variables[Shader->variableCount++] = variable;

    if (copyName)
    {
        gcoOS_MemCopy(variable->name, Variable->name, variable->nameLength + 1);
    }

    if (variable->arrayLengthCount > 0)
    {
        gctINT i;
        status = gcoOS_Allocate(gcvNULL, gcmSIZEOF(gctINT) * variable->arrayLengthCount, &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
        gcoOS_ZeroMemory(pointer, gcmSIZEOF(gctINT) * variable->arrayLengthCount);
        variable->arrayLengthList = pointer;

        for (i = 0; i < variable->arrayLengthCount; i++)
        {
            variable->arrayLengthList[i] = Variable->arrayLengthList[i];
        }
    }

    if (Index)
    {
        *Index = variable->index;
    }
    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetTempCount
**
**  Get the number of temp register used for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      return the Shader's temp register count, included in
**      variable, output, arguments, temporay in instruciton
 */
gctUINT
gcSHADER_GetTempCount(
    IN gcSHADER        Shader
    )
{
    gctUINT                i, tempCount;
    gcSL_INSTRUCTION    code;

    tempCount = 0;

    /* Check symbol table to find the maximal index. */
    if (Shader->variableCount > 0)
    {
        gctUINT variableCount = Shader->variableCount;

        for (i = 0; i < variableCount; i++)
        {
            gcVARIABLE variable = Shader->variables[i];

            if (isVariableNormal(variable))
            {
                gctUINT size = GetVariableKnownArraySize(variable) *
                               gcmType_Rows(variable->u.type);
                gctUINT end  = variable->tempIndex + size;

                if (end > tempCount) tempCount = end;
            }
        }
    }

    /* We need to check output for VS since VS can declare output but without
    ** using. */
    if (((Shader->type == gcSHADER_TYPE_VERTEX) ||
         gcSHADER_IsHaltiCompiler(Shader)) &&
        (Shader->outputCount > 0))
    {
        gctUINT outputCount = Shader->outputCount;

        for (i = 0; i < outputCount; i++)
        {
            gcOUTPUT output = Shader->outputs[i];
            gctUINT    size;
            gctUINT end;

            /* output could be null if it is not used */
            if (output == gcvNULL)
                continue;

            size = output->arraySize * gcmType_Rows(output->type);
            end = output->tempIndex + size;

            if (end > tempCount) tempCount = end;
        }
    }
    /******************** Check the argument temp index Function **********************/
    for (i = 0; i < Shader->functionCount; ++i)
    {
        gcFUNCTION function = Shader->functions[i];
        gctUINT32 j;

        for (j = 0; j < function->argumentCount; ++j)
        {
            gctINT argIndex = function->arguments[j].index;

            if  (argIndex >= (gctINT) tempCount)
            {
                tempCount = argIndex + 1;
            }
        }
    }

    /*************** Check the argument temp index for Kernel Function *****************/
    for (i = 0; i < Shader->kernelFunctionCount; ++i)
    {
        gcKERNEL_FUNCTION kernelFunction = Shader->kernelFunctions[i];
        gctUINT32 j;

        for (j = 0; j < kernelFunction->argumentCount; ++j)
        {
            gctINT argIndex = kernelFunction->arguments[j].index;
            if  (argIndex >= (gctINT) tempCount)
            {
                tempCount = argIndex + 1;
            }
        }
    }
    for (i=0; i < Shader->codeCount; i++)
    {
        code = &Shader->code[i];

        if (gcSL_isOpcodeHaveNoTarget(gcmSL_OPCODE_GET(code->opcode, Opcode)))
        {
            continue;
        }

        if ((gctUINT) code->tempIndex >= tempCount)
        {
            /* Adjust temporary register count. */
            tempCount = code->tempIndex + 1;
        }
    }

    if (tempCount < Shader->_tempRegCount)
    {
        tempCount = Shader->_tempRegCount;
    }
    return tempCount;
}

/*******************************************************************************
**  gcSHADER_GetVariableCount
**
**  Get the number of variables for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of variables.
*/
gceSTATUS
gcSHADER_GetVariableCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    /* Return output count. */
    *Count = Shader->variableCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetVariable
**
**  Get the gcVARIABLE object pointer for an indexed variable for this shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT Index
**          Index of variable to retrieve.
**
**  OUTPUT:
**
**      gcVARIABLE * Variable
**          Pointer to a variable receiving the gcVARIABLE object pointer.
*/
gceSTATUS
gcSHADER_GetVariable(
    IN gcSHADER Shader,
    IN gctUINT Index,
    OUT gcVARIABLE * Variable
    )
{
    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Index < Shader->variableCount);
    gcmDEBUG_VERIFY_ARGUMENT(Variable != gcvNULL);

    /* Return the gcOUTPUT object pointer. */
    *Variable = Shader->variables[Index];

    /* Success. */
    gcmFOOTER_ARG("*Variable=0x%x", *Variable);
    return gcvSTATUS_OK;
}

gceSTATUS
gcSHADER_GetVariableByName(
    IN gcSHADER Shader,
    IN gctCONST_STRING VariableName,
    IN gctUINT16 NameLength,
    OUT gcVARIABLE * Variable
    )
{
    gctUINT32 i;

    gcmHEADER_ARG("Shader=0x%x VariableName=%s", Shader, VariableName);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Variable != gcvNULL);

    for (i = 0; i < Shader->variableCount; i++)
    {
        gcVARIABLE variable = Shader->variables[i];

        if (variable->nameLength == (gctINT)NameLength
            &&  gcmIS_SUCCESS(gcoOS_MemCmp(variable->name,
                              VariableName,
                              NameLength))
            )
        {
            break;
        }
    }

    if (i < Shader->variableCount && Variable)
        *Variable = Shader->variables[i];

    /* Success. */
    gcmFOOTER();
    return gcvSTATUS_OK;
}

static void
_PostOrderVariable(
    IN gcSHADER Shader,
    IN gcVARIABLE rootVariable,
    IN gcVARIABLE firstVariable,
    IN gctBOOL_PTR StartCalc,
    IN gctINT            fisrtTempIndex,
    OUT gctUINT *        Start,
    OUT gctUINT *        End,
    OUT gcSHADER_TYPE *  TempTypeArray
)
{
    gctUINT          start = 0xffffffff, end = 0;
    gcVARIABLE       var;
    gctINT16        varIndex;

    if (!*StartCalc && (rootVariable == firstVariable))
        *StartCalc = gcvTRUE;

    if (rootVariable->firstChild != -1)
    {
        gcmASSERT (isVariableStruct(rootVariable));

        varIndex = rootVariable->firstChild;
        while (varIndex != -1)
        {
            gctUINT          startTemp = 0, endTemp = 0;

            var = Shader->variables[varIndex];

            if (!*StartCalc && (var == firstVariable))
                *StartCalc = gcvTRUE;

            _PostOrderVariable(Shader, var, firstVariable, StartCalc,
                               fisrtTempIndex,
                               &startTemp, &endTemp, TempTypeArray);

            if (*StartCalc)
            {
                /* Currently, only select the maximum range, but
                   we can improve it to get separated ranges for
                   more accurate analysis later */
                if (startTemp < start) start = startTemp;
                if (endTemp > end) end = endTemp;
            }

            varIndex = var->nextSibling;
        }
    }

    /* Process root */
    if (isVariableNormal(rootVariable))
    {
        if (*StartCalc)
        {
            gctINT arraySize = 1;

            arraySize = GetVariableKnownArraySize(rootVariable);

            start = rootVariable->tempIndex;
            end = rootVariable->tempIndex + arraySize * gcmType_Rows(rootVariable->u.type);
            if (TempTypeArray != gcvNULL)
            {
                gctINT i;
                gcmASSERT((gctINT)start >= fisrtTempIndex);
                for (i=start; i < (gctINT)end; i++)
                {
                    TempTypeArray[i - fisrtTempIndex] =
                        gcmType_RowType(rootVariable->u.type);
                }
            }
        }
    }
    else
    {
        /* Nothing to do since start and end have been cal when visiting its children. */
    }

    if (Start)
    {
        *Start = start;
    }
    if (End)
    {
        *End = end;
    }
}

/*******************************************************************************
**                               gcSHADER_GetVariableIndexingRange
********************************************************************************
**
**    Get the gcVARIABLE indexing range.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gcVARIABLE variable
**            Start variable.
**
**        gctBOOL whole
**            Indicate whether maximum indexing range is queried
**
**    OUTPUT:
**
**        gctUINT *Start
**            Pointer to range start (temp register index).
**
**        gctUINT *End
**            Pointer to range end (temp register index).
*/
gceSTATUS
gcSHADER_GetVariableIndexingRange(
    IN gcSHADER Shader,
    IN gcVARIABLE variable,
    IN gctBOOL whole,
    OUT gctUINT *Start,
    OUT gctUINT *End
    )
{
    gceSTATUS        status = gcvSTATUS_OK;
    gctINT           root = -1;
    gcVARIABLE       var;
    gctBOOL          bStartCalc;

    /* Find arrayed root for this variable */
    var = variable;
    while (var)
    {
        if (var->parent != -1)
        {
            gctINT parent = var->parent;
            var = Shader->variables[var->parent];

            /* Find the out-most array */
            if (GetVariableArraySize(var) > 1)
                root = parent;
        }
        else
            var = gcvNULL;
    }

    /* To control whole or part of struct element array */
    if (whole)
        bStartCalc = gcvTRUE;
    else
        bStartCalc = gcvFALSE;

    /* Post order to calc range */
    _PostOrderVariable(Shader, (root == -1) ? variable : Shader->variables[root],
                       variable, &bStartCalc, -1, Start, End, gcvNULL);

    return status;
}


/*******************************************************************************
**                               gcSHADER_GetVariableTempTypes
********************************************************************************
**
**    Get the gcVARIABLE temp types and save the type to TempTypeArray.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        gcVARIABLE variable
**            Start variable.
**
**        gctUINT TempTypeArraySize
**            The size of temp type array.
**
**    OUTPUT:
**
**        gcSHADER_TYPE * TempTypeArray
**            Pointer to temp type array
**
*/
gceSTATUS
gcSHADER_GetVariableTempTypes(
    IN gcSHADER            Shader,
    IN gcVARIABLE          Variable,
    IN gctUINT             TempTypeArraySize,
    IN gctINT              FisrtTempIndex,
    OUT gcSHADER_TYPE *    TempTypeArray
    )
{
    gceSTATUS        status = gcvSTATUS_OK;
    gctINT           root = -1;
    gcVARIABLE       var;
    gctBOOL          bStartCalc;
    gctUINT          start, end;

    /* Find arrayed root for this variable */
    var = Variable;
    while (var)
    {
        if (var->parent != -1)
        {
            gctINT parent = var->parent;
            var = Shader->variables[var->parent];

            /* Find the out-most array */
            if (GetVariableArraySize(var) > 1)
                root = parent;
        }
        else
            var = gcvNULL;
    }

    /* To control whole or part of struct element array */
    bStartCalc = gcvTRUE;

    /* Post order to calc range */
    _PostOrderVariable(Shader, (root == -1) ? Variable : Shader->variables[root],
                       Variable, &bStartCalc, FisrtTempIndex,
                       &start, &end, TempTypeArray);

    return status;
}

/*******************************************************************************
**   _ExpandCode
**
**  Expand the code size in the gcSHADER object by another 32 instructions.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT CodeCount
**          Number of codes to expand.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
_ExpandCode(
    IN gcSHADER Shader,
    IN gctUINT  CodeCount
    )
{
    gctUINT32 bytes;
    gceSTATUS status;
    gcSL_INSTRUCTION code;
    gctPOINTER pointer = gcvNULL;

    /* Allocate CodeCount extra instruction slots. */
    bytes = (Shader->codeCount + CodeCount) * sizeof(struct _gcSL_INSTRUCTION);

    /* Allocate the memory. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        return status;
    }

    code = pointer;

    if (Shader->code != gcvNULL)
    {
        /* Copy the current code. */
        gcoOS_MemCopy(code,
                      Shader->code,
                      Shader->codeCount *
                      sizeof(struct _gcSL_INSTRUCTION));

        /* Free the current code buffer. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->code));
    }

    /* Zero the new instruction slots (we might not write in all). */
    gcoOS_ZeroMemory(code + Shader->codeCount,
                     CodeCount * sizeof(struct _gcSL_INSTRUCTION));

    /* Adjust the array counters. */
    Shader->codeCount += CodeCount;
    Shader->code       = code;

    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOpcode
**
**  Add an opcode to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_OPCODE Opcode
**          Opcode to add.
**
**      gctUINT32 TempRegister
**          Temporary register index that acts as the target of the opcode.
**
**      gctUINT8 Enable
**          Write enable value for the temporary register that acts as the
**          target of the opcode.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOpcode(
    IN gcSHADER Shader,
    IN gcSL_OPCODE Opcode,
    IN gctUINT32 TempRegister,
    IN gctUINT8 Enable,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision,
    IN gctUINT32 srcLoc
    )
{
    gcSL_INSTRUCTION code;
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Opcode=%d TempRegister=%u Enable=%u Format=%d",
                  Shader, Opcode, TempRegister, Enable, Format);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->lastInstruction++;
    }

    /* Did we reach the end of the allocated instruction array? */
    if (Shader->lastInstruction >= Shader->codeCount)
    {
        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    /* Initialize the opcode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Opcode, Opcode);
    code->temp        = gcmSL_TARGET_SET(0, Enable, Enable)
                      | gcmSL_TARGET_SET(0, Precision, Precision)
                      | gcmSL_TARGET_SET(0, Format, Format);
    code->tempIndex   = TempRegister;
    code->tempIndexed = 0;
    gcSHADER_UpdateTempRegCount(Shader, TempRegister);

    code->srcLoc = srcLoc;

    /* Move to SOURCE0 operand. */
    Shader->instrIndex = gcSHADER_SOURCE0;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOpcode2
**
**  Add an opcode and condition to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_OPCODE Opcode
**          Opcode to add.
**
**      gcSL_CONDITION Condition
**          Condition of the opcode.
**
**      gctUINT32 TempRegister
**          Temporary register index that acts as the target of the opcode.
**
**      gctUINT8 Enable
**          Write enable value for the temporary register that acts as the
**          target of the opcode.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOpcode2(
    IN gcSHADER Shader,
    IN gcSL_OPCODE Opcode,
    IN gcSL_CONDITION Condition,
    IN gctUINT32 TempRegister,
    IN gctUINT8 Enable,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision,
    IN gctUINT32 srcLoc
    )
{
    gcSL_INSTRUCTION code;
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Opcode=%d Condition=%d TempRegister=%u "
                  "Enable=%u Format=%d",
                  Shader, Opcode, Condition, TempRegister, Enable, Format);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->lastInstruction++;
    }

    /* Did we reach the end of teh allocated instruction array? */
    if (Shader->lastInstruction >= Shader->codeCount)
    {
        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instrcution. */
    code = Shader->code + Shader->lastInstruction;

    /* Initialize the opcode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Opcode, Opcode);
    code->temp        = gcmSL_TARGET_SET(0, Condition, Condition)
                      | gcmSL_TARGET_SET(0, Enable, Enable)
                      | gcmSL_TARGET_SET(0, Format, Format)
                      | gcmSL_TARGET_SET(0, Precision, Precision);
    code->tempIndex   = TempRegister;
    code->tempIndexed = 0;
    gcSHADER_UpdateTempRegCount(Shader, TempRegister);
    code->srcLoc = srcLoc;

    /* Move to SOURCE0 operand. */
    Shader->instrIndex = gcSHADER_SOURCE0;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOpcodeIndexed
**
**  Add an opcode to a gcSHADER object that writes to an dynamically indexed
**  target.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_OPCODE Opcode
**          Opcode to add.
**
**      gctUINT32 TempRegister
**          Temporary register index that acts as the target of the opcode.
**
**      gctUINT8 Enable
**          Write enable bits  for the temporary register that acts as the
**          target of the opcode.
**
**      gcSL_INDEXED Mode
**          Location of the dynamic index inside the temporary register.  Valid
**          values can be:
**
**              gcSL_INDEXED_X - Use x component of the temporary register.
**              gcSL_INDEXED_Y - Use y component of the temporary register.
**              gcSL_INDEXED_Z - Use z component of the temporary register.
**              gcSL_INDEXED_W - Use w component of the temporary register.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOpcodeIndexed(
    IN gcSHADER Shader,
    IN gcSL_OPCODE Opcode,
    IN gctUINT32 TempRegister,
    IN gctUINT8 Enable,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision,
    IN gctUINT32 srcLoc
    )
{
    gcSL_INSTRUCTION code;
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Opcode=%d TempRegister=%u Enable=%u Mode=%d "
                  "IndexRegister=%u Format=%d",
                  Shader, Opcode, TempRegister, Enable, Mode, IndexRegister,
                  Format);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->lastInstruction++;
    }

    /* Did we reach the end of teh allocated instruction array? */
    if (Shader->lastInstruction >= Shader->codeCount)
    {
        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instrcution. */
    code = Shader->code + Shader->lastInstruction;

    /* Initialize the opcode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Opcode, Opcode);
    code->temp        = gcmSL_TARGET_SET(0, Enable, Enable)
                      | gcmSL_TARGET_SET(0, Format, Format)
                      | gcmSL_TARGET_SET(0, Precision, Precision)
                      | gcmSL_TARGET_SET(0, Indexed, Mode);
    code->tempIndex   = TempRegister;
    code->tempIndexed = IndexRegister;
    gcSHADER_UpdateTempRegCount(Shader, TempRegister);
    gcSHADER_UpdateTempRegCount(Shader, IndexRegister);

    code->srcLoc = srcLoc;

    /* Move to SOURCE0 operand. */
    Shader->instrIndex = gcSHADER_SOURCE0;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOpcodeIndexedWithPrecision
**
**  Add an opcode to a gcSHADER object that writes to an dynamically indexed
**  target with precision setting.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_OPCODE Opcode
**          Opcode to add.
**
**      gctUINT32 TempRegister
**          Temporary register index that acts as the target of the opcode.
**
**      gctUINT8 Enable
**          Write enable bits  for the temporary register that acts as the
**          target of the opcode.
**
**      gcSL_INDEXED Mode
**          Location of the dynamic index inside the temporary register.  Valid
**          values can be:
**
**              gcSL_INDEXED_X - Use x component of the temporary register.
**              gcSL_INDEXED_Y - Use y component of the temporary register.
**              gcSL_INDEXED_Z - Use z component of the temporary register.
**              gcSL_INDEXED_W - Use w component of the temporary register.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**      gcSHADER_PRECISION Precision
**          Precision of temporary register.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOpcodeIndexedWithPrecision(
    IN gcSHADER Shader,
    IN gcSL_OPCODE Opcode,
    IN gctUINT32 TempRegister,
    IN gctUINT8 Enable,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision,
    IN gctUINT32 srcLoc
    )
{
    gcSL_INSTRUCTION code;
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Opcode=%d TempRegister=%u Enable=%u Mode=%d "
                  "IndexRegister=%u Format=%d Precision=%d",
                  Shader, Opcode, TempRegister, Enable, Mode, IndexRegister,
                  Format, Precision);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->lastInstruction++;
    }

    /* Did we reach the end of teh allocated instruction array? */
    if (Shader->lastInstruction >= Shader->codeCount)
    {
        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instrcution. */
    code = Shader->code + Shader->lastInstruction;

    /* Initialize the opcode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Opcode, Opcode);
    code->temp        = gcmSL_TARGET_SET(0, Enable, Enable)
                      | gcmSL_TARGET_SET(0, Indexed, Mode)
                      | gcmSL_TARGET_SET(0, Precision, Precision)
                      | gcmSL_TARGET_SET(0, Format, Format);
    code->tempIndex   = TempRegister;
    code->tempIndexed = IndexRegister;
    gcSHADER_UpdateTempRegCount(Shader, TempRegister);
    gcSHADER_UpdateTempRegCount(Shader, IndexRegister);
    code->srcLoc = srcLoc;

    /* Move to SOURCE0 operand. */
    Shader->instrIndex = gcSHADER_SOURCE0;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOpcodeConditionIndexed
**
**  Add an opcode to a gcSHADER object that writes to an dynamically indexed
**  target.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_OPCODE Opcode
**          Opcode to add.
**
**      gcSL_CONDITION Condition
**          Condition to check.
**
**      gctUINT32 TempRegister
**          Temporary register index that acts as the target of the opcode.
**
**      gctUINT8 Enable
**          Write enable bits  for the temporary register that acts as the
**          target of the opcode.
**
**      gcSL_INDEXED Indexed
**          Location of the dynamic index inside the temporary register.  Valid
**          values can be:
**
**              gcSL_INDEXED_X - Use x component of the temporary register.
**              gcSL_INDEXED_Y - Use y component of the temporary register.
**              gcSL_INDEXED_Z - Use z component of the temporary register.
**              gcSL_INDEXED_W - Use w component of the temporary register.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOpcodeConditionIndexed(
    IN gcSHADER Shader,
    IN gcSL_OPCODE Opcode,
    IN gcSL_CONDITION Condition,
    IN gctUINT32 TempRegister,
    IN gctUINT8 Enable,
    IN gcSL_INDEXED Indexed,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision,
    IN gctUINT32 srcLoc
    )
{
    gcSL_INSTRUCTION code;
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Opcode=%d Condition=%u TempRegister=%u Enable=%u Indexed=%d "
                  "IndexRegister=%u Format=%d",
                  Shader, Opcode, Condition, TempRegister, Enable, Indexed, IndexRegister,
                  Format);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->lastInstruction++;
    }

    /* Did we reach the end of teh allocated instruction array? */
    if (Shader->lastInstruction >= Shader->codeCount)
    {
        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instrcution. */
    code = Shader->code + Shader->lastInstruction;

    /* Initialize the opcode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Opcode, Opcode);
    code->temp        = gcmSL_TARGET_SET(0, Condition, Condition)
                      | gcmSL_TARGET_SET(0, Enable, Enable)
                      | gcmSL_TARGET_SET(0, Indexed, Indexed)
                      | gcmSL_TARGET_SET(0, Format, Format)
                      | gcmSL_TARGET_SET(0, Precision, Precision);
    code->tempIndex   = TempRegister;
    code->tempIndexed = IndexRegister;
    gcSHADER_UpdateTempRegCount(Shader, TempRegister);
    gcSHADER_UpdateTempRegCount(Shader, IndexRegister);
    code->srcLoc = srcLoc;

    /* Move to SOURCE0 operand. */
    Shader->instrIndex = gcSHADER_SOURCE0;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOpcodeConditionIndexedWithPrecision
**
**  Add an opcode to a gcSHADER object that writes to an dynamically indexed
**  target with precision.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_OPCODE Opcode
**          Opcode to add.
**
**      gcSL_CONDITION Condition
**          Condition to check.
**
**      gctUINT32 TempRegister
**          Temporary register index that acts as the target of the opcode.
**
**      gctUINT8 Enable
**          Write enable bits  for the temporary register that acts as the
**          target of the opcode.
**
**      gcSL_INDEXED Indexed
**          Location of the dynamic index inside the temporary register.  Valid
**          values can be:
**
**              gcSL_INDEXED_X - Use x component of the temporary register.
**              gcSL_INDEXED_Y - Use y component of the temporary register.
**              gcSL_INDEXED_Z - Use z component of the temporary register.
**              gcSL_INDEXED_W - Use w component of the temporary register.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**      gcSHADER_PRECISION Precision
**          Precision of temporary register.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOpcodeConditionIndexedWithPrecision(
    IN gcSHADER Shader,
    IN gcSL_OPCODE Opcode,
    IN gcSL_CONDITION Condition,
    IN gctUINT32 TempRegister,
    IN gctUINT8 Enable,
    IN gcSL_INDEXED Indexed,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision,
    IN gctUINT32 srcLoc
    )
{
    gcSL_INSTRUCTION code;
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Opcode=%d Condition=%u TempRegister=%u Enable=%u Indexed=%d "
                  "IndexRegister=%u Format=%d Precision=%d",
                  Shader, Opcode, Condition, TempRegister, Enable, Indexed, IndexRegister,
                  Format, Precision);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->lastInstruction++;
    }

    /* Did we reach the end of teh allocated instruction array? */
    if (Shader->lastInstruction >= Shader->codeCount)
    {
        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instrcution. */
    code = Shader->code + Shader->lastInstruction;

    /* Initialize the opcode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Opcode, Opcode);
    code->temp        = gcmSL_TARGET_SET(0, Condition, Condition)
                      | gcmSL_TARGET_SET(0, Enable, Enable)
                      | gcmSL_TARGET_SET(0, Indexed, Indexed)
                      | gcmSL_TARGET_SET(0, Precision, Precision)
                      | gcmSL_TARGET_SET(0, Format, Format);
    code->tempIndex   = TempRegister;
    code->tempIndexed = IndexRegister;
    gcSHADER_UpdateTempRegCount(Shader, TempRegister);
    gcSHADER_UpdateTempRegCount(Shader, IndexRegister);
    code->srcLoc = srcLoc;

    /* Move to SOURCE0 operand. */
    Shader->instrIndex = gcSHADER_SOURCE0;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_FindNextUsedLabelId
**
**  Find a label id which is not used inside the gcSHADER object
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  RETURN:
**
**      the next unused label id
*/
gctUINT
gcSHADER_FindNextUsedLabelId(
    IN gcSHADER Shader
    )
{
    gcSHADER_LABEL label;
    gctUINT        maxLabelId = 0;

    /* Walk all defines shader labels to find the requested label. */
    for (label = Shader->labels; label != gcvNULL; label = label->next)
    {
        if (label->label > maxLabelId)
        {
            maxLabelId = label->label;
        }
    }

    return maxLabelId+1;
}

/*******************************************************************************
**  gcSHADER_FindLabel
**
**  Find a label inside the gcSHADER object
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a  gcSHADER object.
**
**      gctUINT Label
**          Label identifier.
**
**  OUTPUT:
**
**      gcSHADER_LABEL * ShaderLabel
**          Pointer to a variable receiving the pointer to the gcSHADER_LABEL
**          structure representing the requested label.
*/
gctBOOL
gcSHADER_FindLabel(
    IN gcSHADER Shader,
    IN gctUINT Label,
    OUT gcSHADER_LABEL * ShaderLabel
    )
{
    gcSHADER_LABEL label;

    gcmHEADER_ARG("Shader=0x%x Label=%u", Shader, Label);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(ShaderLabel != gcvNULL);

    /* Walk all defines shader labels to find the requested label. */
    for (label = Shader->labels; label != gcvNULL; label = label->next)
    {
        if (label->label == Label)
        {
            /* Label matches, return pointer to gcSHADER_LABEL structure. */
            *ShaderLabel = label;

            /* Success. */
            gcmFOOTER_ARG("*ShaderLabel=0x%x", *ShaderLabel);
            return gcvTRUE;
        }
    }

    gcmFOOTER_NO();
    return gcvFALSE;
}

/*******************************************************************************
**  _FindOrCreateLabel
**
**  Find a label inside the gcSHADER object or create one if the label could not
**  be found.
**
**  INPUT:
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**      gctUINT Label
**          Label identifier.
**
**  OUTPUT:
**
**      gcSHADER_LABEL * ShaderLabel
**          Pointer to a variable receiving the pointer to the gcSHADER_LABEL
**          structure representing the requested label.
*/
gceSTATUS
_FindOrCreateLabel(
    IN gcSHADER Shader,
    IN gctUINT Label,
    OUT gcSHADER_LABEL * ShaderLabel
    )
{
    gcSHADER_LABEL label;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Label=%u", Shader, Label);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(ShaderLabel != gcvNULL);

    if (gcSHADER_FindLabel(Shader, Label, ShaderLabel))
    {
        /* Success. */
        gcmFOOTER_ARG("*ShaderLabel=0x%x", *ShaderLabel);
        return gcvSTATUS_OK;
    }

    /* Allocate a new gcSHADER_LABEL structure.  */
    status = gcoOS_Allocate(gcvNULL,
                            sizeof(struct _gcSHADER_LABEL),
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    label = pointer;

    /* Initialize the gcSHADER_LABEL structure. */
    label->next       = Shader->labels;
    label->label      = Label;
    label->defined    = ~0U;
    label->referenced = gcvNULL;
    label->function = gcvNULL;

    /* Move gcSHADER_LABEL structure to head of list. */
    Shader->labels = label;

    /* Return pointer to the gcSHADER_LABEL structure. */
    *ShaderLabel = label;

    /* Success. */
    gcmFOOTER_ARG("*ShaderLabel=0x%x", *ShaderLabel);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_FindFunctionByLabel
**
**  Find a function inside the gcSHADER object by call target (label)
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a  gcSHADER object.
**
**      gctUINT Label
**          Label identifier.
**
**  OUTPUT:
**
**      gcFUNCTION * Function
**          Pointer to a variable receiving the pointer to the gcFUNCTION
*/
gctBOOL
gcSHADER_FindFunctionByLabel(
    IN gcSHADER Shader,
    IN gctUINT Label,
    OUT gcFUNCTION * Function
    )
{
    gcFUNCTION func;
    gctUINT    i;
    gcmHEADER_ARG("Shader=0x%x Label=%u", Shader, Label);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Function != gcvNULL);

    /* Walk all defines shader labels to find the requested label. */
    for (i = 0; i  < Shader->functionCount; i++)
    {
        func = Shader->functions[i];
        if (func->codeStart == Label)
        {
            /* Label matches, return pointer to gcSHADER_LABEL structure. */
            *Function = func;

            /* Success. */
            gcmFOOTER_ARG("*Function=0x%x", *Function);
            return gcvTRUE;
        }
    }

    gcmFOOTER_NO();
    return gcvFALSE;
}

/*******************************************************************************
**  gcSHADER_AddOpcodeConditional
**
**  Add an conditional jump or call opcode to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_OPCODE Opcode
**          Opcode to add.
**
**      gcSL_CONDITION Condition
**          Condition that needs to evaluate to gcvTRUE in order for the opcode to
**          execute.
**
**      gctUINT Label
**          Target label if 'Condition' evaluates to gcvTRUE.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOpcodeConditional(
    IN gcSHADER Shader,
    IN gcSL_OPCODE Opcode,
    IN gcSL_CONDITION Condition,
    IN gctUINT Label,
    IN gctUINT32 srcLoc
    )
{
    gcSL_INSTRUCTION code;
    gceSTATUS status;
    gcSHADER_LABEL label;
    gcSHADER_LINK link;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Opcode=%d Condition=%d Label=%u",
                  Shader, Opcode, Condition, Label);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->lastInstruction++;
    }

    /* Did we reach the end of teh allocated instruction array? */
    if (Shader->lastInstruction >= Shader->codeCount)
    {
        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instrcution. */
    code = Shader->code + Shader->lastInstruction;

    /* Initialize the opcode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Opcode, Opcode);
    code->temp        = gcmSL_TARGET_SET(0, Condition, Condition);
    code->tempIndex   = Label;
    code->srcLoc      = srcLoc;

    if ((Opcode == gcSL_JMP) || (Opcode == gcSL_CALL) )
    {
        /* Find or create the label. */
        status = _FindOrCreateLabel(Shader, Label, &label);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        /* Allocate a new gcSHADER_LINK structure. */
        status = gcoOS_Allocate(gcvNULL,
                               sizeof(struct _gcSHADER_LINK),
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        link = pointer;

        /* Initialize the gcSHADER_LINK structure. */
        link->next       = label->referenced;
        link->referenced = Shader->lastInstruction;

        /* Move gcSHADER_LINK structure to head of list. */
        label->referenced = link;
    }

    /* Move to SOURCE0 operand. */
    Shader->instrIndex = gcSHADER_SOURCE0;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOpcodeConditionalFormatted
**
**  Add an conditional jump or call opcode to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_OPCODE Opcode
**          Opcode to add.
**
**      gcSL_CONDITION Condition
**          Condition that needs to evaluate to gcvTRUE in order for the opcode to
**          execute.
**
**      gcSL_FORMAT Format
**          Format of conditional operands
**
**      gctUINT Label
**          Target label if 'Condition' evaluates to gcvTRUE.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOpcodeConditionalFormatted(
    IN gcSHADER Shader,
    IN gcSL_OPCODE Opcode,
    IN gcSL_CONDITION Condition,
    IN gcSL_FORMAT Format,
    IN gctUINT Label,
    IN gctUINT32 srcLoc
    )
{
    gcSL_INSTRUCTION code;
    gceSTATUS status;
    gcSHADER_LABEL label;
    gcSHADER_LINK link;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Opcode=%d Condition=%d Format=%u Label=%u",
                  Shader, Opcode, Condition, Format, Label);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->lastInstruction++;
    }

    /* Did we reach the end of teh allocated instruction array? */
    if (Shader->lastInstruction >= Shader->codeCount)
    {
        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instrcution. */
    code = Shader->code + Shader->lastInstruction;

    /* Initialize the opcode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Opcode, Opcode);
    code->temp        = gcmSL_TARGET_SET(0, Condition, Condition)
                      | gcmSL_TARGET_SET(0, Format, Format);
    code->tempIndex   =  Label;
    code->srcLoc      = srcLoc;

    if ((Opcode == gcSL_JMP) || (Opcode == gcSL_CALL) )
    {
        /* Find or create the label. */
        status = _FindOrCreateLabel(Shader, Label, &label);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        /* Allocate a new gcSHADER_LINK structure. */
        status = gcoOS_Allocate(gcvNULL,
                               sizeof(struct _gcSHADER_LINK),
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        link = pointer;

        /* Initialize the gcSHADER_LINK structure. */
        link->next       = label->referenced;
        link->referenced = Shader->lastInstruction;

        /* Move gcSHADER_LINK structure to head of list. */
        label->referenced = link;
    }

    /* Move to SOURCE0 operand. */
    Shader->instrIndex = gcSHADER_SOURCE0;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddOpcodeConditionalFormattedEnable
**
**  Add an conditional jump or call opcode to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_OPCODE Opcode
**          Opcode to add.
**
**      gcSL_CONDITION Condition
**          Condition that needs to evaluate to gcvTRUE in order for the opcode to
**          execute.
**
**      gcSL_FORMAT Format
**          Format of conditional operands
**
**      gctUINT8 Enable
**          Write enable value for the target of the opcode.
**
**      gctUINT Label
**          Target label if 'Condition' evaluates to gcvTRUE.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddOpcodeConditionalFormattedEnable(
    IN gcSHADER Shader,
    IN gcSL_OPCODE Opcode,
    IN gcSL_CONDITION Condition,
    IN gcSL_FORMAT Format,
    IN gctUINT8 Enable,
    IN gctUINT Label,
    IN gctUINT32 srcLoc
    )
{
    gcSL_INSTRUCTION code;
    gceSTATUS status;
    gcSHADER_LABEL label;
    gcSHADER_LINK link;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Opcode=%d Condition=%d "
                  "Enable=%u Format=%d Label=%u",
                  Shader, Opcode, Condition, Enable, Format, Label);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->lastInstruction++;
    }

    /* Did we reach the end of teh allocated instruction array? */
    if (Shader->lastInstruction >= Shader->codeCount)
    {
        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instrcution. */
    code = Shader->code + Shader->lastInstruction;

    /* Initialize the opcode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Opcode, Opcode);
    code->temp        = gcmSL_TARGET_SET(0, Condition, Condition)
                      | gcmSL_TARGET_SET(0, Enable, Enable)
                      | gcmSL_TARGET_SET(0, Format, Format);
    code->tempIndex   = Label;
    code->srcLoc      = srcLoc;

    if ((Opcode == gcSL_JMP) || (Opcode == gcSL_CALL) )
    {
        /* Find or create the label. */
        status = _FindOrCreateLabel(Shader, Label, &label);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        /* Allocate a new gcSHADER_LINK structure. */
        status = gcoOS_Allocate(gcvNULL,
                               sizeof(struct _gcSHADER_LINK),
                               &pointer);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }

        link = pointer;

        /* Initialize the gcSHADER_LINK structure. */
        link->next       = label->referenced;
        link->referenced = Shader->lastInstruction;

        /* Move gcSHADER_LINK structure to head of list. */
        label->referenced = link;
    }

    /* Move to SOURCE0 operand. */
    Shader->instrIndex = gcSHADER_SOURCE0;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddLabel
**
**  Define a label at the current instruction of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT Label
**          Label to define.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddLabel(
    IN gcSHADER Shader,
    IN gctUINT Label
    )
{
    gcSHADER_LABEL label;
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Label=%u", Shader, Label);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
    }

    /* Find or create the label. */
    status = _FindOrCreateLabel(Shader, Label, &label);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    /* Set definition of the label. */
    label->defined = Shader->lastInstruction;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*****************************************************************************************************
**  gcSHADER_SetTargetPacked
**
**  Set instruction target's PackedComponents field to indicate the number of packed components
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSHADER_INSTRUCTION_INDEX InstIndex
**          Instruction argument index
**
**      gctINT Components
**          Number of packed components.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_SetTargetPacked(
    IN gcSHADER Shader,
    IN gcSHADER_INSTRUCTION_INDEX InstIndex,
    IN gctINT Components
    )
{
    gcSL_INSTRUCTION code;
    gctUINT lastInstruction;

    gcmHEADER_ARG("Shader=0x%x InstIndex=%d  Components=%d",
                   Shader, InstIndex, Components);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    lastInstruction = Shader->lastInstruction +
                      (Shader->instrIndex > gcSHADER_SOURCE0);

    /* Did we reach the end of the allocated instruction array? */
    if (lastInstruction >= Shader->codeCount)
    {
        gceSTATUS status;

        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instruction. */
    code = Shader->code + lastInstruction;

    /* Set the rounding mode portion of the instruction. */
    code->temp = gcmSL_TARGET_SET(code->temp, PackedComponents, Components);

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*****************************************************************************************************
**  gcSHADER_UpdateTargetPacked
**
**  Update instruction target's PackedComponents field to indicate the number of packed components
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctINT Components
**          Number of packed components.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_UpdateTargetPacked(
    IN gcSHADER Shader,
    IN gctINT Components
    )
{
    gcSL_INSTRUCTION code;
    gctUINT lastInstruction;

    gcmHEADER_ARG("Shader=0x%x Components=%d",
                   Shader, Components);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    lastInstruction = Shader->lastInstruction;
    if (Shader->instrIndex == gcSHADER_OPCODE)
    {
        if (lastInstruction == 0)
        {
            gcmASSERT(0);
            gcmFOOTER_NO();
            return gcvSTATUS_INVALID_DATA;
        }
        lastInstruction--;
    }

    /* Did we reach the end of the allocated instruction array? */
    if (lastInstruction >= Shader->codeCount)
    {
        gceSTATUS status;

        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instruction. */
    code = Shader->code + lastInstruction;

    /* Set the rounding mode portion of the instruction. */
    code->temp = gcmSL_TARGET_SET(code->temp, PackedComponents, Components);

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_UpdateSourcePacked
**
**  Update source's PackedComponents field to indicate the number of packed components
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSHADER_INSTRUCTION_INDEX InstIndex
**          Instruction argument index: gcSHADER_SOURCE0/gcSHADER_SOURCE1.
**
**      gctINT Components
**          Number of packed components.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_UpdateSourcePacked(
    IN gcSHADER Shader,
    IN gcSHADER_INSTRUCTION_INDEX InstrIndex,
    IN gctINT Components
    )
{
    gcSL_INSTRUCTION code;
    gctUINT lastInstruction;

    gcmHEADER_ARG("Shader=0x%x InstrIndex=%d  Components=%d",
                   Shader, InstrIndex, Components);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    lastInstruction = Shader->lastInstruction;
    if (InstrIndex == gcSHADER_SOURCE1 &&
        Shader->instrIndex == gcSHADER_OPCODE)
    {
        if (lastInstruction == 0)
        {
            gcmASSERT(0);
            gcmFOOTER_NO();
            return gcvSTATUS_INVALID_DATA;
        }
        lastInstruction--;
    }

    /* Did we reach the end of the allocated instruction array? */
    if (lastInstruction >= Shader->codeCount)
    {
        gceSTATUS status;

        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instruction. */
    code = Shader->code + lastInstruction;

    switch(InstrIndex) {
    case gcSHADER_SOURCE0:
        code->source0 = gcmSL_SOURCE_SET(code->source0, PackedComponents, Components);
        break;

    case gcSHADER_SOURCE1:
        code->source1 = gcmSL_SOURCE_SET(code->source1, PackedComponents, Components);
        break;

    default:
        gcmASSERT(0);
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_DATA;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_UpdateResOpType
**
**  Update the resOpType
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_OPCODE_RES_TYPE ResOpType
**
**      gctINT Components
**          Number of packed components.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_UpdateResOpType(
    IN gcSHADER Shader,
    IN gcSL_OPCODE_RES_TYPE OpCodeResType
    )
{
    gcSL_INSTRUCTION code;

    gcmHEADER_ARG("Shader=0x%x InstrIndex=%d  Components=%d",
                   Shader, InstrIndex, Components);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex == gcSHADER_OPCODE)
    {
        code = Shader->code + Shader->lastInstruction - 1;
    }
    else
    {
        code = Shader->code + Shader->lastInstruction;
    }

    code->opcode = gcmSL_OPCODE_SET(code->opcode, RES_TYPE, OpCodeResType);

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddRoundingMode
**
**  Add rounding mode to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_ROUND Round
**          Rounding mode.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddRoundingMode(
    IN gcSHADER Shader,
    IN gcSL_ROUND Round
    )
{
    gcSL_INSTRUCTION code;
    gctUINT lastInstruction;

    gcmHEADER_ARG("Shader=0x%x Round=%d", Shader, Round);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);


    lastInstruction = Shader->lastInstruction +
                      (Shader->instrIndex > gcSHADER_SOURCE0);

    /* Did we reach the end of the allocated instruction array? */
    if (lastInstruction >= Shader->codeCount)
    {
        gceSTATUS status;

        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instruction. */
    code = Shader->code + lastInstruction;

    /* Set the rounding mode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Round, Round);

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddSaturation
**
**  Add saturation modifier to a gcSHADER instruction.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_MODIFIER_SAT Sat
**          Saturation modifier.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSaturation(
    IN gcSHADER Shader,
    IN gcSL_MODIFIER_SAT  Sat
    )
{
    gcSL_INSTRUCTION code;
    gctUINT lastInstruction;

    gcmHEADER_ARG("Shader=0x%x Sat=%d", Shader, Sat);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    lastInstruction = Shader->lastInstruction +
                      (Shader->instrIndex > gcSHADER_SOURCE0);

    /* Did we reach the end of the allocated instruction array? */
    if (lastInstruction >= Shader->codeCount)
    {
        gceSTATUS status;

        /* Allocate 32 extra instruction slots. */
        status = _ExpandCode(Shader, 32);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Point to the current instruction. */
    code = Shader->code + lastInstruction;

    /* Set the rounding mode portion of the instruction. */
    gcmSL_OPCODE_UPDATE(code->opcode, Sat, Sat);

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_NewTempRegs
**
**  Allocate RegCount of temp registers from the shader.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT RegCount
**          Count of temp register be allocated.
**
**      gcSHADER_TYPE  Type
**          Type of the temp register.
**
**
**  Return:
**
**      The start temp register index, the next available temp register
**      index is the return value plus RegCount.
*/
gctUINT32
gcSHADER_NewTempRegs(
    IN gcSHADER       Shader,
    IN gctUINT        RegCount,
    IN gcSHADER_TYPE  Type
    )
{
    gctUINT32 tempIndex;

    /* store1 always use temp0 as its dest, thus make sure other places not use temp(0) */
    if (Shader->_tempRegCount == 0)
    {
        Shader->_tempRegCount++;
    }

    tempIndex = Shader->_tempRegCount;
    Shader->_tempRegCount += RegCount;

    if(Shader->flags & gcSHADER_FLAG_HWREG_ALLOCATED)
    {
        gctUINT32 endTempIndex = tempIndex + RegCount -1;
        /* skip special hardware register names */
        if ((tempIndex >= VIR_SR_Begin && tempIndex < VIR_SR_End) ||
             (endTempIndex >= VIR_SR_Begin && endTempIndex < VIR_SR_End) )
        {
            tempIndex = Shader->_tempRegCount = VIR_SR_End;
            Shader->_tempRegCount += RegCount;
        }
    }

    if (Shader->currentFunction != gcvNULL)
    {
        Shader->currentFunction->tempIndexEnd = (gctUINT32)(Shader->_tempRegCount - 1);
    }

    if (Shader->currentKernelFunction != gcvNULL)
    {
        Shader->currentKernelFunction->tempIndexEnd = (gctUINT32)(Shader->_tempRegCount - 1);
    }

    return tempIndex;
}

/*******************************************************************************
**  gcSHADER_AddSource
**
**  Add a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_TYPE Type
**          Type of the source operand.
**
**      gctUINT32 SourceIndex
**          Index of the source operand.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSource(
    IN gcSHADER Shader,
    IN gcSL_TYPE Type,
    IN gctUINT32 SourceIndex,
    IN gctUINT8 Swizzle,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Type=%d SourceIndex=%u Swizzle=%u Format=%d",
                  Shader, Type, SourceIndex, Swizzle, Format);

    /* Use AddSourceIndexed with addressing mode gcSL_NOT_INDEXED. */
    status = gcSHADER_AddSourceIndexed(Shader,
                                       Type,
                                       SourceIndex,
                                       Swizzle,
                                       gcSL_NOT_INDEXED,
                                       0,
                                       Format,
                                       Precision);

    gcmFOOTER();
    return status;
}

/*******************************************************************************
**  gcSHADER_AddSourceIndexed
**
**  Add a dynamically indexed source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_TYPE Type
**          Type of the source operand.
**
**      gctUINT32 SourceIndex
**          Index of the source operand.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gcSL_INDEXED Mode
**          Addressing mode for the index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceIndexed(
    IN gcSHADER Shader,
    IN gcSL_TYPE Type,
    IN gctUINT32 SourceIndex,
    IN gctUINT8 Swizzle,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;

    gcmHEADER_ARG("Shader=0x%x Type=%d SourceIndex=%u Swizzle=%u Mode=%d "
                  "IndexRegister=%u Format=%d",
                  Shader, Type, SourceIndex, Swizzle, Mode, IndexRegister,
                  Format);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    source = gcmSL_SOURCE_SET(0, Swizzle, Swizzle)
           | gcmSL_SOURCE_SET(0, Type, Type)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
           | gcmSL_SOURCE_SET(0, Format, Format)
           | gcmSL_SOURCE_SET(0, Precision, Precision);
    gcSHADER_UpdateTempRegCount(Shader, SourceIndex );
    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }
    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = SourceIndex;
        code->source0Indexed = IndexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = source;
        code->source1Index   = SourceIndex;
        code->source1Indexed = IndexRegister;

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_DATA;
    }

    /* Suuccess. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddSourceIndexedWithPrecision
**
**  Add a dynamically indexed source operand to a gcSHADER object with precision.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcSL_TYPE Type
**          Type of the source operand.
**
**      gctUINT32 SourceIndex
**          Index of the source operand.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gcSL_INDEXED Mode
**          Addressing mode for the index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**    gcSHADER_PRECISION Precision
**        Precision of source value
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceIndexedWithPrecision(
    IN gcSHADER Shader,
    IN gcSL_TYPE Type,
    IN gctUINT32 SourceIndex,
    IN gctUINT8 Swizzle,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;

    gcmHEADER_ARG("Shader=0x%x Type=%d SourceIndex=%u Swizzle=%u Mode=%d "
                  "IndexRegister=%u Format=%d Precision=%d",
                  Shader, Type, SourceIndex, Swizzle, Mode, IndexRegister,
                  Format, Precision);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;
    gcSHADER_UpdateTempRegCount(Shader, SourceIndex );
    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    source = gcmSL_SOURCE_SET(0, Swizzle, Swizzle)
           | gcmSL_SOURCE_SET(0, Type, Type)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
#if SOURCE_is_32BIT
           | gcmSL_SOURCE_SET(0, Precision, Precision)
#endif
           | gcmSL_SOURCE_SET(0, Format, Format);

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = SourceIndex;
        code->source0Indexed = IndexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = source;
        code->source1Index   = SourceIndex;
        code->source1Indexed = IndexRegister;

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_DATA;
    }

    /* Suuccess. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddSourceAttribute
**
**  Add an attribute as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the attribute in case the attribute is a matrix
**          or array.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceAttribute(
    IN gcSHADER Shader,
    IN gcATTRIBUTE Attribute,
    IN gctUINT8 Swizzle,
    IN gctINT Index
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Attribute=0x%x Swizzle=%u Index=%d",
                  Shader, Attribute, Swizzle, Index);

    /* Use AddSourceAttributeIndexed with addressing mode gcSL_NOT_INDEXED. */
    status = gcSHADER_AddSourceAttributeIndexed(Shader,
                                                Attribute,
                                                Swizzle,
                                                Index,
                                                gcSL_NOT_INDEXED,
                                                0);

    gcmFOOTER();
    return status;
}

/*******************************************************************************
**  gcSHADER_AddSourceAttributeIndexed
**
**  Add an indexed attribute as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the attribute in case the attribute is a matrix
**          or array.
**
**      gcSL_INDEXED Mode
**          Addressing mode of the dynamic index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceAttributeIndexed(
    IN gcSHADER Shader,
    IN gcATTRIBUTE Attribute,
    IN gctUINT8 Swizzle,
    IN gctINT Index,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;
    gctUINT32 index;
    gctUINT16 indexRegister;

    gcmHEADER_ARG("Shader=0x%x Attribute=0x%x Swizzle=%u Index=%d Mode=%d "
                  "IndexRegister=%u",
                  Shader, Attribute, Swizzle, Index, Mode, IndexRegister);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);
    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    /* Cteate the source. */
    source = gcmSL_SOURCE_SET(0, Type, gcSL_ATTRIBUTE)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
           | gcmSL_SOURCE_SET(0, Swizzle, Swizzle)
           | gcmSL_SOURCE_SET(0, Precision, Attribute->precision);

    /* Create the index. */
    index = gcmSL_INDEX_SET(0, Index, Attribute->index)
          | gcmSL_INDEX_SET(0, ConstValue, Index);

    gcmASSERT((Mode == gcSL_NOT_INDEXED) || (Index < 4));

    indexRegister = (Mode == gcSL_NOT_INDEXED) ? (Index & ~3) : IndexRegister;

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = index;
        code->source0Indexed = indexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = source;
        code->source1Index   = index;
        code->source1Indexed = indexRegister;

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        gcmFOOTER_NO();
        /* Invalid data. */
        return gcvSTATUS_INVALID_DATA;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddSourceUniform
**
**  Add a uniform as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the uniform in case the uniform is a matrix or
**          array.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceUniform(
    IN gcSHADER Shader,
    IN gcUNIFORM Uniform,
    IN gctUINT8 Swizzle,
    IN gctINT Index
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Uniform=0x%x Swizzle=%u Index=%d",
                  Shader, Uniform, Swizzle, Index);

    /* Use AddSourceUniformIndexed with addressing mode gcSL_NOT_INDEXED. */
    status = gcSHADER_AddSourceUniformIndexed(Shader,
                                              Uniform,
                                              Swizzle,
                                              Index,
                                              gcSL_NOT_INDEXED,
                                              0);

    gcmFOOTER();
    return status;
}

/*******************************************************************************
**  gcSHADER_AddSourceUniformIndexed
**
**  Add an indexed uniform as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the uniform in case the uniform is a matrix or
**          array.
**
**      gcSL_INDEXED Mode
**          Addressing mode of the dynamic index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceUniformIndexed(
    IN gcSHADER Shader,
    IN gcUNIFORM Uniform,
    IN gctUINT8 Swizzle,
    IN gctINT Index,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;
    gctUINT32 index;
    gctUINT16 indexRegister;

    gcmHEADER_ARG("Shader=0x%08x Uniform=0x%08x Swizzle=%u Index=%d Mode=%d "
                  "IndexRegister=%u",
                  Shader, Uniform, Swizzle, Index, Mode, IndexRegister);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);
    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    /* Create the source. */
    source = gcmSL_SOURCE_SET(0, Type, gcSL_UNIFORM)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
           | gcmSL_SOURCE_SET(0, Swizzle, Swizzle)
           | gcmSL_SOURCE_SET(0, Precision, Uniform->precision);

    /* Create the index. */
    index = gcmSL_INDEX_SET(0, Index, Uniform->index)
          | gcmSL_INDEX_SET(0, ConstValue, Index);

    gcmASSERT((Mode == gcSL_NOT_INDEXED) || (Index < 4));

    if (Mode == gcSL_NOT_INDEXED)
    {
        indexRegister = Index & ~3;
        SetUniformFlag(Uniform, gcvUNIFORM_FLAG_DIRECTLY_ADDRESSED);
    }
    else
    {
        SetUniformFlag(Uniform, gcvUNIFORM_FLAG_INDIRECTLY_ADDRESSED);
        indexRegister = IndexRegister;
    }

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = index;
        code->source0Indexed = indexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = source;
        code->source1Index   = index;
        code->source1Indexed = indexRegister;

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}


/*******************************************************************************
**  gcSHADER_AddSourceSamplerIndexed
**
**  Add a "0-based" indexed sampler as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gcSL_INDEXED Mode
**          Addressing mode of the dynamic index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceSamplerIndexed(
    IN gcSHADER Shader,
    IN gctUINT8 Swizzle,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;

    gcmHEADER_ARG("Shader=0x%x Swizzle=%u Mode=%d IndexRegister=%u",
                  Shader, Swizzle, Mode, IndexRegister);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Mode != gcSL_NOT_INDEXED);
    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    /* Create the source. */
    source = gcmSL_SOURCE_SET(0, Type, gcSL_SAMPLER)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
           | gcmSL_SOURCE_SET(0, Swizzle, Swizzle);

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    gcmASSERT(Shader->instrIndex == gcSHADER_SOURCE0);

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = 0;
        code->source0Indexed = IndexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    if (Shader->currentFunction != gcvNULL)
    {
        SetFunctionHasSamplerIndexing(Shader->currentFunction);
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddSourceAttributeFormatted
**
**  Add a formatted attribute as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the attribute in case the attribute is a matrix
**          or array.
**
**    gcSL_FORMAT Format
**        Format of attribute value
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceAttributeFormatted(
    IN gcSHADER Shader,
    IN gcATTRIBUTE Attribute,
    IN gctUINT8 Swizzle,
    IN gctINT Index,
    IN gcSL_FORMAT Format
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Attribute=0x%x Swizzle=%u Index=%d Format=%u",
                  Shader, Attribute, Swizzle, Index, Format);

    /* Use AddSourceAttributeIndexed with addressing mode gcSL_NOT_INDEXED. */
    status = gcSHADER_AddSourceAttributeIndexedFormatted(Shader,
                                                     Attribute,
                                                     Swizzle,
                                                     Index,
                                                     gcSL_NOT_INDEXED,
                                                     0,
                                                     Format);

    gcmFOOTER();
    return status;
}

/*******************************************************************************
**  gcSHADER_AddSourceAttributeIndexedFormatted
**
**  Add a formatted indexed attribute as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the attribute in case the attribute is a matrix
**          or array.
**
**      gcSL_INDEXED Mode
**          Addressing mode of the dynamic index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**    gcSL_FORMAT Format
**        Format of indexed attribute value
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceAttributeIndexedFormatted(
    IN gcSHADER Shader,
    IN gcATTRIBUTE Attribute,
    IN gctUINT8 Swizzle,
    IN gctINT Index,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;
    gctUINT32 index;
    gctUINT16 indexRegister;

    gcmHEADER_ARG("Shader=0x%x Attribute=0x%x Swizzle=%u Index=%d Mode=%d "
                  "IndexRegister=%u Format=%u",
                  Shader, Attribute, Swizzle, Index, Mode, IndexRegister, Format);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    /* Cteate the source. */
    source = gcmSL_SOURCE_SET(0, Type, gcSL_ATTRIBUTE)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
           | gcmSL_SOURCE_SET(0, Precision, Attribute->precision)
           | gcmSL_SOURCE_SET(0, Format, Format)
           | gcmSL_SOURCE_SET(0, Swizzle, Swizzle);

    /* Create the index. */
    index = gcmSL_INDEX_SET(0, Index, Attribute->index)
          | gcmSL_INDEX_SET(0, ConstValue, Index);

    gcmASSERT((Mode == gcSL_NOT_INDEXED) || (Index < 4));

    indexRegister = (Mode == gcSL_NOT_INDEXED) ? (Index & ~3) : IndexRegister;

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = index;
        code->source0Indexed = indexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = source;
        code->source1Index   = index;
        code->source1Indexed = indexRegister;

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        gcmFOOTER_NO();
        /* Invalid data. */
        return gcvSTATUS_INVALID_DATA;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddSourceAttributeIndexedFormattedWithPrecision
**
**  Add a formatted indexed attribute as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the attribute in case the attribute is a matrix
**          or array.
**
**      gcSL_INDEXED Mode
**          Addressing mode of the dynamic index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**    gcSL_FORMAT Format
**        Format of indexed attribute value
**
**    gcSHADER_PRECISION Precision
**        Precision of attribute value
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceAttributeIndexedFormattedWithPrecision(
    IN gcSHADER Shader,
    IN gcATTRIBUTE Attribute,
    IN gctUINT8 Swizzle,
    IN gctINT Index,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;
    gctUINT32 index;
    gctUINT16 indexRegister;

    gcmHEADER_ARG("Shader=0x%x Attribute=0x%x Swizzle=%u Index=%d Mode=%d "
                  "IndexRegister=%u Format=%u Precision=%u",
                  Shader, Attribute, Swizzle, Index, Mode, IndexRegister, Format, Precision);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    /* Cteate the source. */
    source = gcmSL_SOURCE_SET(0, Type, gcSL_ATTRIBUTE)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
#if SOURCE_is_32BIT
           | gcmSL_SOURCE_SET(0, Precision, Precision)
#endif
           | gcmSL_SOURCE_SET(0, Format, Format)
           | gcmSL_SOURCE_SET(0, Swizzle, Swizzle);

    /* Create the index. */
    index = gcmSL_INDEX_SET(0, Index, Attribute->index)
          | gcmSL_INDEX_SET(0, ConstValue, Index);

    gcmASSERT((Mode == gcSL_NOT_INDEXED) || (Index < 4));

    indexRegister = (Mode == gcSL_NOT_INDEXED) ? (Index & ~3) : IndexRegister;

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = index;
        code->source0Indexed = indexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = source;
        code->source1Index   = index;
        code->source1Indexed = indexRegister;

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        gcmFOOTER_NO();
        /* Invalid data. */
        return gcvSTATUS_INVALID_DATA;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/********************************************************************************************
**  gcSHADER_AddSourceOutputIndexedFormattedWithPrecision
**
**  Add a formatted indexed output as a source operand to a gcSHADER object with precision.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcOUTPUT Output
**          Pointer to a gcOUTPUT object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the attribute in case the attribute is a matrix
**          or array.
**
**      gcSL_INDEXED Mode
**          Addressing mode of the dynamic index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**    gcSL_FORMAT Format
**        Format of indexed attribute value
**
**    gcSHADER_PRECISION Precision
**        Precision of attribute value
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceOutputIndexedFormattedWithPrecision(
    IN gcSHADER Shader,
    IN gcOUTPUT Output,
    IN gctUINT8 Swizzle,
    IN gctINT Index,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;
    gctUINT32 index;
    gctUINT16 indexRegister;
    gctINT16 outputIndex;

    gcmHEADER_ARG("Shader=0x%x Swizzle=%u Index=%d Mode=%d "
                  "IndexRegister=%u Format=%u Precision=%u",
                  Shader, Swizzle, Index, Mode, IndexRegister, Format, Precision);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(Output, gcvOBJ_OUTPUT);

    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    gcSHADER_GetOutputIndexByOutput(Shader, Output, &outputIndex);

    /* Cteate the source. */
    source = gcmSL_SOURCE_SET(0, Type, gcSL_OUTPUT)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
#if SOURCE_is_32BIT
           | gcmSL_SOURCE_SET(0, Precision, Precision)
#endif
           | gcmSL_SOURCE_SET(0, Format, Format)
           | gcmSL_SOURCE_SET(0, Swizzle, Swizzle);

    /* Create the index. */
    index = gcmSL_INDEX_SET(0, Index, outputIndex)
          | gcmSL_INDEX_SET(0, ConstValue, Index);

    gcmASSERT((Mode == gcSL_NOT_INDEXED) || (Index < 4));

    indexRegister = (Mode == gcSL_NOT_INDEXED) ? (Index & ~3) : IndexRegister;

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = index;
        code->source0Indexed = indexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = source;
        code->source1Index   = index;
        code->source1Indexed = indexRegister;

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        gcmFOOTER_NO();
        /* Invalid data. */
        return gcvSTATUS_INVALID_DATA;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddSourceUniformFormatted
**
**  Add a formatted uniform as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the uniform in case the uniform is a matrix or
**          array.
**
**    gcSL_FORMAT Format
**        Format of UNIFORM value
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceUniformFormatted(
    IN gcSHADER Shader,
    IN gcUNIFORM Uniform,
    IN gctUINT8 Swizzle,
    IN gctINT Index,
    IN gcSL_FORMAT Format
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Uniform=0x%x Swizzle=%u Index=%d Format=%u",
                  Shader, Uniform, Swizzle, Index, Format);

    /* Use AddSourceUniformIndexed with addressing mode gcSL_NOT_INDEXED. */
    status = gcSHADER_AddSourceUniformIndexedFormatted(Shader,
                                                       Uniform,
                                                       Swizzle,
                                                       Index,
                                                       gcSL_NOT_INDEXED,
                                                       0,
                                                       Format);

    gcmFOOTER();
    return status;
}

/*******************************************************************************
**  gcSHADER_AddSourceUniformIndexedFormatted
**
**  Add a formatted indexed uniform as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the uniform in case the uniform is a matrix or
**          array.
**
**      gcSL_INDEXED Mode
**          Addressing mode of the dynamic index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**    gcSL_FORMAT Format
**        Format of uniform value
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceUniformIndexedFormatted(
    IN gcSHADER Shader,
    IN gcUNIFORM Uniform,
    IN gctUINT8 Swizzle,
    IN gctINT Index,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;
    gctUINT32 index;
    gctUINT16 indexRegister;

    gcmHEADER_ARG("Shader=0x%08x Uniform=0x%08x Swizzle=%u Index=%d Mode=%d "
                  "IndexRegister=%u Format=%u",
                  Shader, Uniform, Swizzle, Index, Mode, IndexRegister, Format);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    /* Create the source. */
    source = gcmSL_SOURCE_SET(0, Type, gcSL_UNIFORM)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
           | gcmSL_SOURCE_SET(0, Format, Format)
           | gcmSL_SOURCE_SET(0, Precision, Uniform->precision)
           | gcmSL_SOURCE_SET(0, Swizzle, Swizzle);

    /* Create the index. */
    index = gcmSL_INDEX_SET(0, Index, Uniform->index)
          | gcmSL_INDEX_SET(0, ConstValue, Index);

    gcmASSERT((Mode == gcSL_NOT_INDEXED) || (Index < 4));

    if (Mode == gcSL_NOT_INDEXED)
    {
        indexRegister = Index & ~3;
        SetUniformFlag(Uniform, gcvUNIFORM_FLAG_DIRECTLY_ADDRESSED);
    }
    else
    {
        SetUniformFlag(Uniform, gcvUNIFORM_FLAG_INDIRECTLY_ADDRESSED);
        indexRegister = IndexRegister;
    }

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = index;
        code->source0Indexed = indexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = source;
        code->source1Index   = index;
        code->source1Indexed = indexRegister;

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/******************************************************************************************
**  gcSHADER_AddSourceUniformIndexedFormattedWithPrecision
**
**  Add a formatted indexed uniform as a source operand to a gcSHADER object with precision
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gctINT Index
**          Static index into the uniform in case the uniform is a matrix or
**          array.
**
**      gcSL_INDEXED Mode
**          Addressing mode of the dynamic index.
**
**      gcSL_INDEXED_LEVEL IndexedLevel
**          Indexed level of dynamic index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**    gcSL_FORMAT Format
**        Format of uniform value
**
**    gcSHADER_PRECISION Precision
**        Precision of attribute value
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceUniformIndexedFormattedWithPrecision(
    IN gcSHADER Shader,
    IN gcUNIFORM Uniform,
    IN gctUINT8 Swizzle,
    IN gctINT Index,
    IN gcSL_INDEXED Mode,
    IN gcSL_INDEXED_LEVEL IndexedLevel,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;
    gctUINT32 index;
    gctUINT16 indexRegister;

    gcmHEADER_ARG("Shader=0x%08x Uniform=0x%08x Swizzle=%u Index=%d Mode=%d "
                  "IndexRegister=%u Format=%u Precision=%u",
                  Shader, Uniform, Swizzle, Index, Mode, IndexRegister, Format, Precision);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    /* Create the source. */
    source = gcmSL_SOURCE_SET(0, Type, gcSL_UNIFORM)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
           | gcmSL_SOURCE_SET(0, Indexed_Level, IndexedLevel)
           | gcmSL_SOURCE_SET(0, Format, Format)
#if SOURCE_is_32BIT
           | gcmSL_SOURCE_SET(0, Precision, Precision)
#endif
           | gcmSL_SOURCE_SET(0, Format, Format)
           | gcmSL_SOURCE_SET(0, Swizzle, Swizzle);

    /* Create the index. */
    index = gcmSL_INDEX_SET(0, Index, Uniform->index)
          | gcmSL_INDEX_SET(0, ConstValue, Index);

    gcmASSERT((Mode == gcSL_NOT_INDEXED) || (Index < 4));

    if (Mode == gcSL_NOT_INDEXED)
    {
        indexRegister = Index & ~3;
        SetUniformFlag(Uniform, gcvUNIFORM_FLAG_DIRECTLY_ADDRESSED);
    }
    else
    {
        SetUniformFlag(Uniform, gcvUNIFORM_FLAG_INDIRECTLY_ADDRESSED);
        indexRegister = IndexRegister;
    }

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = index;
        code->source0Indexed = indexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = source;
        code->source1Index   = index;
        code->source1Indexed = indexRegister;

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddSourceSamplerIndexedFormatted
**
**  Add a "0-based" formatted indexed sampler as a source operand to a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gcSL_INDEXED Mode
**          Addressing mode of the dynamic index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**    gcSL_FORMAT Format
**        Format of sampler value
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceSamplerIndexedFormatted(
    IN gcSHADER Shader,
    IN gctUINT8 Swizzle,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;

    gcmHEADER_ARG("Shader=0x%x Swizzle=%u Mode=%d IndexRegister=%u Format=%u",
                  Shader, Swizzle, Mode, IndexRegister, Format);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Mode != gcSL_NOT_INDEXED);

    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    /* Create the source. */
    source = gcmSL_SOURCE_SET(0, Type, gcSL_SAMPLER)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
           | gcmSL_SOURCE_SET(0, Format, Format)
           | gcmSL_SOURCE_SET(0, Swizzle, Swizzle);

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    gcmASSERT(Shader->instrIndex == gcSHADER_SOURCE0);

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = 0;
        code->source0Indexed = IndexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    if (Shader->currentFunction != gcvNULL)
    {
        SetFunctionHasSamplerIndexing(Shader->currentFunction);
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddSourceSamplerIndexedFormattedWithPrecision
**
**  Add a "0-based" formatted indexed sampler as a source operand to a gcSHADER
**  object with precision.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT8 Swizzle
**          x, y, z, and w swizzle values packed into one 8-bit value.
**
**      gcSL_INDEXED Mode
**          Addressing mode of the dynamic index.
**
**      gctUINT16 IndexRegister
**          Temporary register index that holds the dynamic index.
**
**    gcSL_FORMAT Format
**        Format of sampler value
**
**    gcSHADER_PRECISION Precision
**        Precision of attribute value
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceSamplerIndexedFormattedWithPrecision(
    IN gcSHADER Shader,
    IN gctUINT8 Swizzle,
    IN gcSL_INDEXED Mode,
    IN gctUINT16 IndexRegister,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision
    )
{
    gcSL_INSTRUCTION code;
    gctSOURCE_t source;

    gcmHEADER_ARG("Shader=0x%x Swizzle=%u Mode=%d IndexRegister=%u Format=%u Precision=%u",
                  Shader, Swizzle, Mode, IndexRegister, Format, Precision);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Mode != gcSL_NOT_INDEXED);

    if (Mode != gcSL_NOT_INDEXED)
    {
        gcSHADER_UpdateTempRegCount(Shader, IndexRegister );
    }

    /* Create the source. */
    source = gcmSL_SOURCE_SET(0, Type, gcSL_SAMPLER)
           | gcmSL_SOURCE_SET(0, Indexed, Mode)
#if SOURCE_is_32BIT
           | gcmSL_SOURCE_SET(0, Precision, Precision)
#endif
           | gcmSL_SOURCE_SET(0, Format, Format)
           | gcmSL_SOURCE_SET(0, Swizzle, Swizzle);

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    gcmASSERT(Shader->instrIndex == gcSHADER_SOURCE0);

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = source;
        code->source0Index   = 0;
        code->source0Indexed = IndexRegister;

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    if (Shader->currentFunction != gcvNULL)
    {
        SetFunctionHasSamplerIndexing(Shader->currentFunction);
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_AddSourceConstant
**
**  Add a constant floating point value as a source operand to a gcSHADER
**  object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctFLOAT Constant
**          Floating point constant.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_AddSourceConstant(
    IN gcSHADER Shader,
    IN gctFLOAT Constant
    )
{
    gcSL_INSTRUCTION code;
    gcuFLOAT_UINT32 constant;

    gcmHEADER_ARG("Shader=0x%x Constant=%f", Shader, Constant);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        constant.f           = Constant;
        code->source0        = gcSL_CONSTANT;
        code->source0Index   = (gctUINT16) (constant.u & 0xFFFF);  /* LSB */
        code->source0Indexed = (gctUINT16) (constant.u >> 16);     /* MSB */

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        constant.f           = Constant;
        code->source1        = gcSL_CONSTANT;
        code->source1Index   = (gctUINT16) (constant.u & 0xFFFF);  /* LSB */
        code->source1Indexed = (gctUINT16) (constant.u >> 16);     /* MSB */

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Suuccess. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**    gcSHADER_AddSourceConstantFormatted
**
**    Add a formatted constant value as a source operand to a gcSHADER object
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        void *Constant
**            Pointer to constant value (32 bits).
**
**        gcSL_FORMAT Format
**            Format of constant value
**
**    OUTPUT:
**
**        Nothing.
*/
gceSTATUS
gcSHADER_AddSourceConstantFormatted(
    IN gcSHADER Shader,
    IN void *Constant,
    IN gcSL_FORMAT Format
    )
{
    gcSL_INSTRUCTION code;

    gcmHEADER_ARG("Shader=0x%x Constant=0x%x Format=%d", Shader, Constant, Format);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = gcmSL_SOURCE_SET(0, Type, gcSL_CONSTANT)
                             | gcmSL_SOURCE_SET(0, Format, Format);
        code->source0Index   = (gctUINT16)((*((gctUINT *) Constant)) & 0xFFFF);  /* LSB */
        code->source0Indexed = (gctUINT16)((*((gctUINT *) Constant)) >> 16);     /* MSB */

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = gcmSL_SOURCE_SET(0, Type, gcSL_CONSTANT)
                             | gcmSL_SOURCE_SET(0, Format, Format);
        code->source1Index   = (gctUINT16)((*((gctUINT *) Constant)) & 0xFFFF);  /* LSB */
        code->source1Indexed = (gctUINT16)((*((gctUINT *) Constant)) >> 16);     /* MSB */

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Suuccess. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**    gcSHADER_AddSourceConstantFormattedWithPrecision
**
**    Add a formatted constant value as a source operand to a gcSHADER object
**    with precision.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**        void *Constant
**            Pointer to constant value (32 bits).
**
**        gcSL_FORMAT Format
**            Format of constant value
**
**    gcSHADER_PRECISION Precision
**        Precision of constant value
**    OUTPUT:
**
**        Nothing.
*/
gceSTATUS
gcSHADER_AddSourceConstantFormattedWithPrecision(
    IN gcSHADER Shader,
    IN void *Constant,
    IN gcSL_FORMAT Format,
    IN gcSHADER_PRECISION Precision
    )
{
    gcSL_INSTRUCTION code;

    gcmHEADER_ARG("Shader=0x%x Constant=0x%x Format=%d Precision=%d",
                  Shader, Constant, Format, Precision);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    /* Point to the current instruction. */
    code = Shader->code + Shader->lastInstruction;

    switch (Shader->instrIndex)
    {
    case gcSHADER_SOURCE0:
        /* Update source0 operand. */
        code->source0        = gcmSL_SOURCE_SET(0, Type, gcSL_CONSTANT)
#if SOURCE_is_32BIT
                             | gcmSL_SOURCE_SET(0, Precision, Precision)
#endif
                             | gcmSL_SOURCE_SET(0, Format, Format);
        code->source0Index   = (gctUINT16)((*((gctUINT *) Constant)) & 0xFFFF); /* LSB */
        code->source0Indexed = (gctUINT16)((*((gctUINT *) Constant)) >> 16);    /* MSB */

        /* Move to source1 operand. */
        Shader->instrIndex = gcSHADER_SOURCE1;
        break;

    case gcSHADER_SOURCE1:
        /* Update source1 operand. */
        code->source1        = gcmSL_SOURCE_SET(0, Type, gcSL_CONSTANT)
#if SOURCE_is_32BIT
                             | gcmSL_SOURCE_SET(0, Precision, Precision)
#endif
                             | gcmSL_SOURCE_SET(0, Format, Format);
        code->source1Index   = (gctUINT16)((*((gctUINT *) Constant)) & 0xFFFF); /* LSB */
        code->source1Indexed = (gctUINT16)((*((gctUINT *) Constant)) >> 16);    /* MSB */

        /* Move to next instruction. */
        Shader->instrIndex = gcSHADER_OPCODE;
        Shader->lastInstruction++;
        break;

    default:
        /* Invalid data. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    /* Suuccess. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_Pack
**
**  Pack a dynamically created gcSHADER object by trimming the allocated arrays
**  and resolving all the labeling.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_Pack(
    IN gcSHADER Shader
    )
{
    gcSHADER_LABEL label;
    gcSHADER_LINK link;
    gctUINT32 bytes;
    gcSL_INSTRUCTION code;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        /* Move to start of a new instruction. */
        Shader->lastInstruction++;
        Shader->instrIndex = gcSHADER_OPCODE;
    }

    /* shader may have 0 instruction */
    if (Shader->code == gcvNULL || Shader->lastInstruction == 0)
    {
        if (Shader->code != gcvNULL)
        {
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->code));
            Shader->code = gcvNULL;
        }

        Shader->lastInstruction = 0;
        Shader->codeCount = 0;

        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    /* Allocate CodeCount extra instruction slots. */
    bytes = (Shader->lastInstruction) * sizeof(struct _gcSL_INSTRUCTION);

    /* Allocate the memory. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER_NO();
        return status;
    }

    code = pointer;

    /* Copy the current code. */
    gcoOS_MemCopy(code,
                  Shader->code,
                  Shader->lastInstruction *
                  sizeof(struct _gcSL_INSTRUCTION));

    /* Free the current code buffer. */
    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->code));

    /* Update total number of instructions. */
    Shader->code      = code;
    Shader->codeCount = Shader->lastInstruction;

    /* Loop while we have labels to resolve. */
    while (Shader->labels != gcvNULL)
    {
        /* Remove gcSHADER_LABEL structure from head of list. */
        label          = Shader->labels;
        Shader->labels = label->next;

        if (label->defined != ~0U)
        {
            /* Loop while we have references to this label. */
            while (label->referenced != gcvNULL)
            {
                /* Remove gcSHADER_LINK structure from head of list. */
                link              = label->referenced;
                label->referenced = link->next;

                /* Update the reference with the correct label location. */
                gcmASSERT(gcmSL_OPCODE_GET(Shader->code[link->referenced].opcode, Opcode) == gcSL_CALL ||
                          gcmSL_OPCODE_GET(Shader->code[link->referenced].opcode, Opcode) == gcSL_JMP);
                Shader->code[link->referenced].tempIndex = label->defined;

                /* Free the gcSHADER_LINK structure. */
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, link));
            }
        }
        else
        {
            if (!(label->function &&
                  (IsFunctionIntrinsicsBuiltIn(label->function) || IsFunctionExtern(label->function))))
            {
                /* only the intrinsic function or extern function labels could be not defined */
                /* Make sure the label is defined. */
                gcmFATAL("Label %u has not been defined.", label->label);
            }

            while (label->referenced != gcvNULL)
            {
                /* Remove gcSHADER_LINK structure from head of list. */
                link              = label->referenced;
                label->referenced = link->next;

                /* Free the gcSHADER_LINK structure. */
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, link));
            }
        }

        /* Free the gcSHADER_LABEL structure. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, label));
    }


    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                                  gcSHADER_ExpandArraysOfArrays
********************************************************************************
**
**    Expand array size for a object if this object is an arrays of arrays.
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**    OUTPUT:
**
**        Nothing.
*/
gceSTATUS
gcSHADER_ExpandArraysOfArrays(
    IN gcSHADER Shader
    )
{
    gctUINT32 i;
    gctINT j;

    /* Expand array size for uniforms. */
    for (i = 0; i < Shader->uniformCount; i++)
    {
        gcUNIFORM uniform = Shader->uniforms[i];

        if (uniform == gcvNULL) continue;

        if (uniform->arrayLengthCount < 2) continue;

        gcmASSERT(uniform->arraySize != -1);

        for (j = 1; j < uniform->arrayLengthCount; j++)
        {
            uniform->arraySize *= uniform->arrayLengthList[j];
        }
    }

    /* Expand array size for variables. */
    for (i = 0; i < Shader->variableCount; i++)
    {
        gcVARIABLE variable = Shader->variables[i];

        if (variable == gcvNULL) continue;

        if (variable->arrayLengthCount < 2) continue;

        if (variable->arraySize < 0) continue;

        for (j = 1; j < variable->arrayLengthCount; j++)
        {
            if (variable->arrayLengthList[j] == -1)
            {
                variable->arraySize = -1;
                break;
            }
            variable->arraySize *= variable->arrayLengthList[j];
        }
    }

    return gcvSTATUS_OK;
}

gctUINT
gcSHADER_GetFunctionByCodeId(
    IN gcSHADER             Shader,
    IN gctUINT              codeID,
    OUT gctBOOL            *IsKernelFunc
    )
{
    gctUINT i;

    for (i = 0; i < Shader->functionCount; ++i)
    {
        if ((codeID >= Shader->functions[i]->codeStart) &&
            (codeID < Shader->functions[i]->codeStart + Shader->functions[i]->codeCount))
            return i;
    }

    for (i = 0; i < Shader->kernelFunctionCount; i++)
    {
        if ((codeID >= Shader->kernelFunctions[i]->codeStart) &&
            (codeID < Shader->kernelFunctions[i]->codeStart + Shader->kernelFunctions[i]->codeCount))
        {
            if (IsKernelFunc)
            {
                *IsKernelFunc = gcvTRUE;
            }
            return i;
        }
    }

    return (gctUINT)-1;
}

gctUINT
gcSHADER_GetFunctionByFuncHead(
    IN gcSHADER             Shader,
    IN gctUINT              codeID,
    OUT gctBOOL            *IsKernelFunc
    )
{
    gctUINT i;

    for (i = 0; i < Shader->functionCount; i++)
    {
        if (codeID == Shader->functions[i]->codeStart ||
            codeID == Shader->functions[i]->label)
        {
            if (IsKernelFunc)
            {
                *IsKernelFunc = gcvFALSE;
            }
            return i;
        }
    }

    for (i = 0; i < Shader->kernelFunctionCount; i++)
    {
        if (codeID == Shader->kernelFunctions[i]->codeStart ||
            codeID == Shader->kernelFunctions[i]->label)
        {
            if (IsKernelFunc)
            {
                *IsKernelFunc = gcvTRUE;
            }
            return i;
        }
    }

    return (gctUINT)-1;
}

void
gcSHADER_SetDebugInfo(
    IN gcSHADER             Shader,
    IN void *               DebugInfoContext
    )
{
    Shader->debugInfo = DebugInfoContext;
}

gctPOINTER
gcSHADER_GetDebugInfo(
    IN gcSHADER             Shader
    )
{
    if (Shader != NULL)
        return (gctPOINTER)(Shader->debugInfo);

    return NULL;
}

gceSTATUS
gcSHADER_SetAttrLocationByDriver(
    IN gcSHADER             Shader,
    IN gctCHAR*             Name,
    IN gctINT               Location
    )
{
    gceSTATUS               status = gcvSTATUS_OK;
    gcATTRIBUTE             attribute = gcvNULL;

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmASSERT(Name != gcvNULL && Location >= 0);

    gcmONERROR(gcSHADER_GetAttributeByName(Shader,
                                           Name,
                                           gcoOS_StrLen(Name, gcvNULL),
                                           &attribute));
    /* Not found. */
    if (attribute == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_NAME_NOT_FOUND;
    }

    /* Location mismatch. */
    if (GetATTRLocation(attribute) != -1            &&
        !gcmATTRIBUTE_isLocSetByDriver(attribute)   &&
        GetATTRLocation(attribute) != Location)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_MISMATCH;
    }

    /* Update the location. */
    SetATTRLocation(attribute, Location);
    gcmATTRIBUTE_SetLocSetByDriver(attribute, gcvTRUE);
    gcSHADER_AddInputLocation(Shader, Location, 1);

OnError:
    gcmFOOTER_NO();
    return status;
}

static gctBOOL
_AnalyzeFunctions(
    IN gcSHADER Shader,
    IN gctBOOL * List,
    IN gctUINT ListIndex,
    IN gctBOOL IsKernelFunc,
    IN gctUINT FuncIndex
    )
{
    gctBOOL isCallerFuncKernelFunc = gcvFALSE;
    gctUINT i, j, codeStart, codeEnd;
    gctUINT callerFuncIndex, callerFuncListIndex;
    gcSL_OPCODE opcode;
    gcKERNEL_FUNCTION kernelFunction = gcvNULL;
    gcFUNCTION nonKernelFunction = gcvNULL;
    gcsFUNCTION_ARGUMENT argument;

    if (IsKernelFunc)
    {
        kernelFunction = Shader->kernelFunctions[FuncIndex];
        codeStart = kernelFunction->codeStart;
        codeEnd = kernelFunction->codeEnd;
    }
    else
    {
        nonKernelFunction = Shader->functions[FuncIndex];
        codeStart = nonKernelFunction->codeStart;
        codeEnd = nonKernelFunction->codeStart + nonKernelFunction->codeCount;
    }

    for (i = codeStart; i < codeEnd; ++i)
    {
        opcode = (gcSL_OPCODE)gcmSL_OPCODE_GET(Shader->code[i].opcode, Opcode);

        /* Check some function flags. */
        if (gcSL_isOpcodeImageRelated(opcode) &&
            gcmSL_SOURCE_GET(Shader->code[i].source0, Type) == gcSL_TEMP)
        {
            if (IsKernelFunc)
            {
                for (j = 0; j < kernelFunction->argumentCount; j++)
                {
                    argument = kernelFunction->arguments[j];

                    if (argument.index == Shader->code[i].source0Index)
                    {
                        SetFunctionParamAsImgSource0(kernelFunction);
                    }
                }
            }
            else
            {
                for (j = 0; j < nonKernelFunction->argumentCount; j++)
                {
                    argument = nonKernelFunction->arguments[j];

                    if (argument.index == Shader->code[i].source0Index)
                    {
                        SetFunctionParamAsImgSource0(nonKernelFunction);
                    }
                }
            }
            continue;
        }

        if (opcode != gcSL_CALL)
        {
            continue;
        }

        /* Analyze the caller function now. */
        callerFuncIndex = gcSHADER_GetFunctionByFuncHead(Shader, Shader->code[i].tempIndex, &isCallerFuncKernelFunc);

        gcmASSERT((isCallerFuncKernelFunc && callerFuncIndex < Shader->kernelFunctionCount) ||
                  (!isCallerFuncKernelFunc && callerFuncIndex < Shader->functionCount));

        /* Save the inheritable function flags from the caller function. */
        if (isCallerFuncKernelFunc)
        {
            if (IsFunctionHasSamplerIndexing(Shader->kernelFunctions[callerFuncIndex]))
            {
                SetFunctionHasSamplerIndexing(kernelFunction);
            }

            if (IsFunctionParamAsImgSource0(Shader->kernelFunctions[callerFuncIndex]))
            {
                SetFunctionParamAsImgSource0(kernelFunction);
            }
        }
        else
        {
            if (IsFunctionHasSamplerIndexing(Shader->functions[callerFuncIndex]))
            {
                SetFunctionHasSamplerIndexing(nonKernelFunction);
            }

            if (IsFunctionParamAsImgSource0(Shader->functions[callerFuncIndex]))
            {
                SetFunctionParamAsImgSource0(nonKernelFunction);
            }
        }

        /* If the caller is a recursive function, then the callee itself is also a recursive function */
        if (isCallerFuncKernelFunc)
        {
            if (Shader->kernelFunctions[callerFuncIndex]->isRecursion == gcvTRUE)
                return gcvTRUE;
        }
        else
        {
            if (Shader->functions[callerFuncIndex]->isRecursion == gcvTRUE)
                return gcvTRUE;
        }


        if (isCallerFuncKernelFunc)
        {
            callerFuncListIndex = callerFuncIndex + Shader->functionCount;
        }
        else
        {
            callerFuncListIndex = callerFuncIndex;
        }

        /* If the function called itself, it is a recursive function */
        if (List[callerFuncListIndex] == gcvTRUE)
            return gcvTRUE;

        /* continue to check the caller function*/
        List[callerFuncListIndex] = gcvTRUE;

        if (_AnalyzeFunctions(Shader, List, callerFuncListIndex, isCallerFuncKernelFunc, callerFuncIndex))
            return gcvTRUE;

        List[callerFuncListIndex] = gcvFALSE;
    }
    return gcvFALSE;
}


/*******************************************************************************
**                                  gcSHADER_AnalyzeFunctions
********************************************************************************
**
** 1) Check function has sampler indexing
** 2) Detect if there is a recursive function in the shader code
**
**    INPUT:
**
**        gcSHADER Shader
**            Pointer to a gcSHADER object.
**
**    OUTPUT:
**
**        Nothing.
*/
gceSTATUS
gcSHADER_AnalyzeFunctions(
    IN gcSHADER Shader,
    IN gctBOOL NeedToCheckRecursive
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctBOOL* funcList = gcvNULL;
    gctPOINTER pointer = gcvNULL;
    gctBOOL isKernelFunc = gcvFALSE;
    gctBOOL detectRecursiveFunc = gcvFALSE;
    gctUINT nonKernelFuncCount = Shader->functionCount;
    gctUINT kernelFuncCount = (GetShaderType(Shader) == gcSHADER_TYPE_CL) ? Shader->kernelFunctionCount : 0;
    gctUINT funcCount = nonKernelFuncCount + kernelFuncCount;
    gctUINT i, j, funcIndex;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (funcCount == 0)
    {
        gcmFOOTER_NO();
        return status;
    }

    /* Init function list. */
    if (gcmIS_ERROR(gcoOS_Allocate(gcvNULL, gcmSIZEOF(gctBOOL) * funcCount, &pointer)))
    {
        gcmFATAL("gcSHADER_AnalyzeFunctions: gcoOS_Allocate failed");
        gcmFOOTER_ARG("status=%d", gcvSTATUS_COMPILER_FE_PARSER_ERROR);
        return gcvSTATUS_COMPILER_FE_PARSER_ERROR;
    }

    funcList = (gctBOOL *)pointer;
    for (i = 0; i < funcCount; ++i)
    {
        funcList[i] = gcvFALSE;
    }

    /* Check all functions, including kernel functions and non-kernel functions,
    ** and we put the non-kernel in the top of func list array.
    */
    for (i = 0; i < funcCount; i++)
    {
        /* This is a kernel function. */
        if (i >= nonKernelFuncCount)
        {
            funcIndex = i - nonKernelFuncCount;
            isKernelFunc = gcvTRUE;
        }
        /* This is a non-kernel function. */
        else
        {
            funcIndex = i;
            isKernelFunc = gcvFALSE;
        }

        /* Skip the recursive function */
        if ((isKernelFunc && Shader->kernelFunctions[funcIndex]->isRecursion) ||
            (!isKernelFunc && Shader->functions[funcIndex]->isRecursion))
        {
            continue;
        }

        funcList[i] = gcvTRUE;
        detectRecursiveFunc = _AnalyzeFunctions(Shader, funcList, i, isKernelFunc, funcIndex);

        /* Set recursive for all function calls. */
        for (j = 0; j < funcCount; j++)
        {
            if (funcList[j])
            {
                if (detectRecursiveFunc)
                {
                    if (isKernelFunc)
                    {
                        Shader->kernelFunctions[funcIndex]->isRecursion = gcvTRUE;
                    }
                    else
                    {
                        Shader->functions[funcIndex]->isRecursion = gcvTRUE;
                    }
                }
                funcList[j] = gcvFALSE;
            }
        }
    }

    /* We don't need to check if there is any recursive function for a OCL shader now. */
    if (!NeedToCheckRecursive || (GetShaderType(Shader) == gcSHADER_TYPE_CL))
    {
        gcmOS_SAFE_FREE(gcvNULL, funcList);

        gcmFOOTER_NO();
        return status;
    }

    /*
    ** According to GLSL-ES Spec,
    ** if a function is recursive and called in main function or global namespace, reject it.
    */
    for (i = 0; i < Shader->codeCount; ++i)
    {
        if (gcmSL_OPCODE_GET(Shader->code[i].opcode, Opcode) != gcSL_CALL)
            continue;
        /* Skip not global call*/
        j = gcSHADER_GetFunctionByCodeId(Shader, i, gcvNULL);
        if (j != (gctUINT)-1)
            continue;
        j = gcSHADER_GetFunctionByFuncHead(Shader, Shader->code[i].tempIndex, &isKernelFunc);
        if (j != (gctUINT)-1 && Shader->functions[j]->isRecursion)
        {
            status = gcvSTATUS_COMPILER_FE_PARSER_ERROR;
            break;
        }
    }

    gcmOS_SAFE_FREE(gcvNULL, funcList);

    if (gcmIS_ERROR(status))
    {
        gcmFOOTER_ARG("status=%d", status);
        return status;
    }

    /* Success. */
    gcmFOOTER_NO();
    return status;
}

static gctBOOL
ReadSource(
    IN gcoOS Os,
    IN gctCONST_STRING FileName,
    OUT gctUINT32 * SourceSize,
    OUT gctSTRING * Source
    )
{
    gceSTATUS    status;
    gctFILE        file;
    gctUINT32    count;
    gctSIZE_T    byteRead;
    gctSTRING    source;

    gcmASSERT(FileName != gcvNULL);

    status = gcoOS_Open(Os, FileName, gcvFILE_READ, &file);

    if (gcmIS_ERROR(status))
    {
        gcoOS_Print("ERROR: Failed to open input file: %s\n", FileName);
        return gcvFALSE;
    }

    gcmVERIFY_OK(gcoOS_Seek(Os, file, 0, gcvFILE_SEEK_END));
    gcmVERIFY_OK(gcoOS_GetPos(Os, file, &count));

    source = gcvNULL;
    status = gcoOS_Allocate(Os, count + 1, (gctPOINTER *) &source);

    if (!gcmIS_SUCCESS(status))
    {
        gcmVERIFY_OK(gcoOS_Close(Os, file));
        gcoOS_Print("ERROR: Not enough memory.\n");
        return gcvFALSE;
    }

    gcmVERIFY_OK(gcoOS_SetPos(Os, file, 0));

    status = gcoOS_Read(Os, file, count, source, &byteRead);
    if (!gcmIS_SUCCESS(status) || byteRead != count)
    {
        gcoOS_Print("ERROR: Failed to open input file: %s\n", FileName);
        gcmVERIFY_OK(gcoOS_Close(Os, file));

        gcoOS_Free(Os, source);

        return gcvFALSE;
    }

    source[count] = '\0';
    gcmVERIFY_OK(gcoOS_Close(Os, file));

    *SourceSize = count;
    *Source = source;

    return gcvTRUE;
}

static void
_getShaderSourceList(
    IN OUT gcOPTIMIZER_OPTION * Option,
    IN     gctCHAR *            Args
    )
{
    gctCHAR *  pos        = Args;
    gctINT     shaderId   = 0;
    gctSTRING  fileName   = gcvNULL;
    gceSTATUS  status     = gcvSTATUS_OK;

    /* handle VC_OPTION=-SHADER:id1,file1[:id2,file ...] */
    while (pos)
    {
        gcoOS_StrToInt(pos, &shaderId);
        if (shaderId > 0)
        {
            /* find the file name */

            /* find next ',', ' ' or '\0' */
            while (*pos != ',' && *pos != ' ' && *pos != '\0') pos++;

            if (*pos == ',')
            {
                gctCHAR * s1                = gcvNULL;
                gctBOOL   readOK            = gcvFALSE;
                ShaderSourceList *shaderSrc = gcvNULL;
                gctUINT32 sourceSize        = 0;
                gctSTRING source            = gcvNULL;
                pos++;

                gcoOS_StrDup(gcvNULL, pos, &fileName);
                s1 = fileName;

                /* find the file name end */
                while (*s1 != ':' && *s1 != ' ' && *s1 != '\0') s1++;

                *s1 = '\0';

                readOK = ReadSource(gcvNULL, fileName, &sourceSize, &source);
                if (!readOK)
                {
                    if (source != gcvNULL)
                    {
                        gcmOS_SAFE_FREE(gcvNULL, source);
                    }
                    gcmOS_SAFE_FREE(gcvNULL, fileName);
                    break;
                }

                status = gcoOS_Allocate(gcvNULL, sizeof(ShaderSourceList),
                                        (gctPOINTER *) &shaderSrc);
                if (status != gcvSTATUS_OK)
                {
                    if (source != gcvNULL)
                    {
                        gcmOS_SAFE_FREE(gcvNULL, source);
                    }
                    gcmOS_SAFE_FREE(gcvNULL, fileName);
                    break;
                }

                shaderSrc->next       = Option->shaderSrcList;
                shaderSrc->shaderId   = shaderId;
                shaderSrc->src        = source;
                shaderSrc->sourceSize = sourceSize;
                gcoOS_StrDup(gcvNULL, fileName, &shaderSrc->fileName);
                Option->shaderSrcList = shaderSrc;
                /* move pos to the end of file name */
                pos += (s1 - fileName);

                gcmOS_SAFE_FREE(gcvNULL, fileName);

            }
            else
                break;  /* invalid option */

            /* find the next shader source id and filename */
            if (*pos == ':')
                pos++;
            else
                break;
        }
        else
        {
            break;   /* invalid shader id */
        }
    }
    return;
}

static void
_getForceInlineList(
    IN OUT gcOPTIMIZER_OPTION * Option,
    IN     gctCHAR *            Args,
    IN     enum ForceInlineKind Kind
    )
{
    gctCHAR *  pos      = Args;
    gctSTRING  funcName = gcvNULL;
    gctSTRING  str      = gcvNULL;
    gceSTATUS  status   = gcvSTATUS_OK;

    /* handle VC_OPTION=-FORCEINLINE:func1[,func2 ...] */
    while (pos)
    {
        gctCHAR savedChar;
        InlineStringList * inlineStrLst = gcvNULL;
        str = pos;

        /* find next ',', ' ' or '\0' */
        while (*pos != ',' && *pos != ' ' && *pos != '\0') pos++;

        savedChar = *pos;
        /* temporary set *pos to '\0' */
        *pos = '\0';

        gcoOS_StrDup(gcvNULL, str, &funcName);
        *pos = savedChar; /* recover the saved char */

        status = gcoOS_Allocate(gcvNULL, sizeof(InlineStringList),
                                (gctPOINTER *) &inlineStrLst);
        if (status != gcvSTATUS_OK)
        {
            gcmOS_SAFE_FREE(gcvNULL, funcName);
            break;
        }

        inlineStrLst->next       = Option->forceInline;
        inlineStrLst->kind       = Kind;
        inlineStrLst->func       = funcName;

        Option->forceInline      = inlineStrLst;

        /* find the next funcName */
        if (*pos == ',')
            pos++;
        else
            break;
    }
    return;
}

static void
_processDefineOption(
    IN OUT gcOPTIMIZER_OPTION * Option,
    IN     gctCHAR *            Args
    )
{
    gctCHAR *  pos = Args;
    gctSTRING  name;
    gceSTATUS  status = gcvSTATUS_OK;

    /* handle VC_OPTION=-Ddef[=val], it can have multiple -D options */
    while (pos)
    {
        gcmASSERT(pos[0] == '-' && pos[1] == 'D');
        if (gcoOS_StrNCmp(pos, "-DUMP:", sizeof("-DUMP:")-1) == gcvSTATUS_OK)
        {
            /* skip -DUMP: and find next -D */
            gctCHAR * pos1 = gcvNULL;
            gcoOS_StrStr(pos+2, "-D", &pos1);
            if (pos1 == gcvNULL)
                break;

            pos = pos1;
        }

        name = pos+2;
        while (*name == ' ' || *name == '\t') name++;  /* find first non-space char */

        pos = name;
        while (*pos != ' ' && *pos != '\0') pos++;

        if (name[0] != '\0')
        {
            gctCHAR * s1 = gcvNULL;
            gctCHAR   ch;
            MacroDefineList *macroDef = gcvNULL;

            status = gcoOS_Allocate(gcvNULL, sizeof(MacroDefineList),
                                    (gctPOINTER *) &macroDef);
            if (status != gcvSTATUS_OK)
            {
               break;
            }

            /* dup the name string */
            ch = *pos;
            *pos = '\0';
            gcoOS_StrDup(gcvNULL, name, &s1);
            *pos = ch;

            macroDef->next       = Option->macroDefines;
            macroDef->kind       = MDK_Define;
            macroDef->str        = s1;
            Option->macroDefines = macroDef;


            /* find the next -D option */
            gcoOS_StrStr(pos, "-D", &pos);
        }
        else
        {
            break;   /* invalid option */
        }
    }
    return;
}

static void
_processUndefOption(
    IN OUT gcOPTIMIZER_OPTION * Option,
    IN     gctCHAR *            Args
    )
{
    gctCHAR *  pos = Args;
    gctSTRING  name;
    gceSTATUS  status = gcvSTATUS_OK;

    /* handle VC_OPTION=-Uundef, it can have multiple -U options */
    while (pos)
    {
        gcmASSERT(pos[0] == '-' && pos[1] == 'U');

        name = pos+2;
        while (*name == ' ' || *name == '\t') name++;  /* find first non-space char */

        pos = name;
        while (*pos != ' ' && *pos != '\0') pos++;

        if (name[0] != '\0')
        {
            gctCHAR * s1 = gcvNULL;
            gctCHAR   ch;
            MacroDefineList *macroDef = gcvNULL;

            status = gcoOS_Allocate(gcvNULL, sizeof(MacroDefineList),
                                    (gctPOINTER *) &macroDef);
            if (status != gcvSTATUS_OK)
            {
               break;
            }

            /* dup the name string */
            ch = *pos;
            *pos = '\0';
            gcoOS_StrDup(gcvNULL, name, &s1);
            *pos = ch;

            macroDef->next       = Option->macroDefines;
            macroDef->kind       = MDK_Undef;
            macroDef->str       = s1;
            Option->macroDefines = macroDef;


            /* find the next -U option */
            gcoOS_StrStr(pos, "-U", &pos);
        }
        else
        {
            break;   /* invalid option */
        }
    }
    return;
}

void
gcGetOptionFromEnv(
    IN OUT gcOPTIMIZER_OPTION * Option
    )
{
    static gctINT envChecked    = 0;

    if (!envChecked) {
        char* p = gcvNULL;
        gctSTRING pos = gcvNULL;
        gctSTRING s1;
        gcoOS_GetEnv(gcvNULL, "VC_OPTION", &p);
        if (p)
        {
            /* debug & dump options:
             *
             *   VC_OPTION=-DUMP:SRC[:IR][:OPT|:OPTV|:CG|:CGV|:ALL|:ALLV|:LOG] [:T[-]m,n]
             */
            gcoOS_StrStr(p, "-DUMP", &pos);
            if (pos)
            {
                pos += sizeof("-DUMP") - 1;
                while (pos[0] == ':')
                {
                    ++pos;
                    if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "SRC", sizeof("SRC")-1))
                    {
                        /* dump shader source code */
                        Option->dumpShaderSource = gcvTRUE;
                        pos += sizeof("SRC") -1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "FE", sizeof("FE")-1))
                    {
                        Option->dumpShaderSource     = gcvTRUE;
                        Option->dumpFELog            = gcvTRUE;
                        pos += sizeof("FE") -1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "IR", sizeof("IR")-1))
                    {
                        /* dump incoming and final IR */
                        Option->dumpBEFinalIR = gcvTRUE;
                        pos += sizeof("IR") -1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "LOG", sizeof("LOG")-1))
                    {
                        /* dump FE log file in case of compiler error */
                        Option->dumpFELog = gcvTRUE;
                        pos += sizeof("LOG") -1;
                    }
                    else if (*pos == 't' || *pos == 'T') /* Traige option */
                    {
                        gctBOOL exclude = gcvFALSE;
                        gctINT  m,n;
                        ++pos;

                        if (*pos == '-' )
                        {
                            exclude = gcvTRUE;
                            ++pos;
                        }

                        /* getting the range */
                        gcoOS_StrToInt(pos, &m);
                        if (m >= 0)
                        {
                            Option->_dumpStart = exclude ? -m : m;
                            s1 = pos;
                            /* find next ',', ' ' or '\0' */
                            while (*s1 != ',' && *s1 != ' ' && *s1 != '\0') s1++;

                            if (*s1 == ',')
                            {
                                gcoOS_StrToInt(s1+1, &n);
                                gcmASSERT(n > 0);
                                Option->_dumpEnd =  exclude ? -n : n;
                            }
                            else
                            {
                                /* set _dumpEnd to _dumpStart if the end
                                   range is not specified */
                                Option->_dumpEnd =  Option->_dumpStart;
                            }
                        }
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "ALL", sizeof("ALL")-1))
                    {
                        Option->dumpShaderSource     = gcvTRUE;
                        Option->dumpBEFinalIR        = gcvTRUE;
                        Option->dumpFELog            = gcvTRUE;
                        Option->dumpSpirvIR          = gcvTRUE;
                        pos += sizeof("ALL") -1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "UNIFORM", sizeof("UNIFORM")-1))
                    {
                        /* dump uniform value when setting uniform */
                        Option->dumpUniform = gcvTRUE;
                        pos += sizeof("UNIFORM") -1;
                    }
                }
            }

            gcoOS_StrStr(p, "-PATCH_TEXLD:", &pos);
            if (pos)
            {
                gctINT m = 0, n = 0;
                /* handle -PATCH_TEXLD:M:N */
                pos += sizeof("-PATCH_TEXLD:") - 1;
                gcoOS_StrToInt(pos, &m);
                if (m > 0)
                {
                    gcmASSERT(m < 20);  /* m should be reasonable value */
                    Option->patchEveryTEXLDs = m;
                    Option->patchDummyTEXLDs = 1;  /* default to be 1 */
                    s1 = pos;
                    /* find next ':', ' ' or '\0' */
                    while (*s1 != ':' && *s1 != ' ' && *s1 != '\0') s1++;

                    if (*s1 == ':')
                    {
                        gcoOS_StrToInt(s1+1, &n);
                        if (n > 0)
                        {
                            gcmASSERT(n < 20);  /* n should be reasonable value */
                            Option->patchDummyTEXLDs = n;  /* default to be 1 */
                        }
                    }
                    Option->needPowerOptimization = gcvTRUE;
                }
            }

            /* handle other options here */
            gcoOS_StrStr(p, "-SPLITVEC", &pos);
            if (pos)
            {
                pos += sizeof("-SPLITVEC") - 1;
                while (pos[0] == ':')
                {
                    ++pos;
                    if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "MULLO", sizeof("MULLO")-1))
                    {
                        Option->splitVec4MULLO = gcvTRUE;
                        Option->splitVec = gcvTRUE;
                        Option->needPowerOptimization = gcvTRUE;
                        pos += sizeof("MULLO") -1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "MUL", sizeof("MUL")-1))
                    {
                        Option->splitVec4MUL = gcvTRUE;
                        Option->splitVec = gcvTRUE;
                        Option->needPowerOptimization = gcvTRUE;
                        pos += sizeof("MUL") -1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "DP3", sizeof("DP3")-1))
                    {
                        Option->splitVec4DP3 = gcvTRUE;
                        Option->splitVec = gcvTRUE;
                        Option->needPowerOptimization = gcvTRUE;
                        pos += sizeof("DP3") -1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "DP4", sizeof("DP4")-1))
                    {
                        Option->splitVec4DP4 = gcvTRUE;
                        Option->splitVec = gcvTRUE;
                        Option->needPowerOptimization = gcvTRUE;
                        pos += sizeof("DP4") -1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "ALL", sizeof("ALL")-1))
                    {
                        Option->splitVec4MUL   = gcvTRUE;
                        Option->splitVec4MULLO = gcvTRUE;
                        Option->splitVec4DP3   = gcvTRUE;
                        Option->splitVec4DP4   = gcvTRUE;
                        Option->splitVec       = gcvTRUE;
                        Option->needPowerOptimization = gcvTRUE;
                        pos += sizeof("ALL") -1;
                    }
                }
            }

            gcoOS_StrStr(p, "-SPLITMAD", &pos);
            if (pos)
            {
                Option->splitMAD = gcvTRUE;
                Option->needPowerOptimization = gcvTRUE;
            }

            gcoOS_StrStr(p, "-INSERTNOP", &pos);
            if (pos)
            {
                pos += sizeof("-INSERTNOP") - 1;

                while (pos[0] == ':')
                {
                    ++pos;

                    if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "MULLO", sizeof("MULLO")-1))
                    {
                        Option->insertNOPAfterMULLO = gcvTRUE;
                        Option->insertNOP = gcvTRUE;
                        Option->needPowerOptimization = gcvTRUE;
                        pos += sizeof("MULLO")-1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "MUL", sizeof("MUL")-1))
                    {
                        Option->insertNOPAfterMUL = gcvTRUE;
                        Option->insertNOP = gcvTRUE;
                        Option->needPowerOptimization = gcvTRUE;
                        pos += sizeof("MUL")-1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "DP3", sizeof("DP3")-1))
                    {
                        Option->insertNOPAfterDP3 = gcvTRUE;
                        Option->insertNOP = gcvTRUE;
                        Option->needPowerOptimization = gcvTRUE;
                        pos += sizeof("DP3")-1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "DP4", sizeof("DP4")-1))
                    {
                        Option->insertNOPAfterDP4 = gcvTRUE;
                        Option->insertNOP = gcvTRUE;
                        Option->needPowerOptimization = gcvTRUE;
                        pos += sizeof("DP4")-1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "SEENTEXLD", sizeof("SEENTEXLD")-1))
                    {
                        Option->insertNOPOnlyWhenTexldSeen = gcvTRUE;
                        pos += sizeof("SEENTEXLD")-1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "ALL", sizeof("ALL")-1))
                    {
                        Option->insertNOPAfterMUL   = gcvTRUE;
                        Option->insertNOPAfterMULLO = gcvTRUE;
                        Option->insertNOPAfterDP3   = gcvTRUE;
                        Option->insertNOPAfterDP4   = gcvTRUE;
                        Option->insertNOP           = gcvTRUE;
                        Option->needPowerOptimization = gcvTRUE;
                        pos += sizeof("ALL") -1;
                    }
                }
            }

            gcoOS_StrStr(p, "-NOIMM", &pos);
            if (pos)
            {
                Option->noImmediate = gcvTRUE;
            }

            gcoOS_StrStr(p, "-FORCEIMM", &pos);
            if (pos)
            {
                Option->forceImmediate = gcvTRUE;
            }

            gcoOS_StrStr(p, "-PACKVARYING", &pos);
            if (pos)
            {
                pos += sizeof("-PACKVARYING") -1;
                while (pos[0] == ':')
                {
                    ++pos;

                    if (*pos == '0')
                    {
                        Option->packVarying = gcvOPTIMIZATION_VARYINGPACKING_NONE;
                        ++pos;
                    }
                    else if (*pos == '1')
                    {
                        Option->packVarying = gcvOPTIMIZATION_VARYINGPACKING_NOSPLIT;
                        ++pos;
                    }
                    else if (*pos == '2')
                    {
                        Option->packVarying = gcvOPTIMIZATION_VARYINGPACKING_SPLIT;
                        ++pos;
                    }
                    else if (*pos == 't' || *pos == 'T') /* Traige option */
                    {
                        gctBOOL exclude = gcvFALSE;
                        gctINT  m,n;
                        ++pos;

                        if (*pos == '-' )
                        {
                            exclude = gcvTRUE;
                            ++pos;
                        }

                        /* getting the range */
                        gcoOS_StrToInt(pos, &m);
                        if (m >= 0)
                        {
                            Option->_triageStart = exclude ? -m : m;
                            s1 = pos;
                            /* find next ',', ' ' or '\0' */
                            while (*s1 != ',' && *s1 != ' ' && *s1 != '\0') s1++;

                            if (*s1 == ',')
                            {
                                gcoOS_StrToInt(s1+1, &n);
                                gcmASSERT(n > 0);
                                Option->_triageEnd =  exclude ? -n : n;
                            }
                            else
                            {
                                /* set _triageEnd to _triageStart if the end
                                   range is not specified */
                                Option->_triageEnd =  Option->_triageStart;
                            }
                        }
                    }
                    else if (*pos == 'l' || *pos == 'L') /* Load balance setting option */
                    {
                        /* LshaderIdx:min:max */
                        gctINT  shaderIdx=0,m=-1,n=-1;
                        ++pos;

                        /* getting the load balance shader index */
                        gcoOS_StrToInt(pos, &shaderIdx);
                        if (shaderIdx > 0 || shaderIdx == -1)
                        {

                            s1 = pos;
                            /* find next ',', ' ' or '\0' */
                            while (*s1 != ',' && *s1 != ' ' && *s1 != '\0') s1++;

                            if (*s1 == ',')
                            {
                                s1++; /* advance to next char */

                                /* getting the range */
                                gcoOS_StrToInt(s1, &m);
                                if (m >= 0)
                                {
                                    /* find next ',', ' ' or '\0' */
                                    while (*s1 != ',' && *s1 != ' ' && *s1 != '\0') s1++;

                                    if (*s1 == ',')
                                    {
                                        gcoOS_StrToInt(s1+1, &n);
                                        if (n > 0)
                                        {
                                            /* valid shaderIdx and min, max */
                                            Option->_loadBalanceShaderIdx = shaderIdx;
                                            Option->_loadBalanceMin = m;
                                            Option->_loadBalanceMax = n;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            /* turn/off features:

                  VC_OPTION=-F:n,0|1[:n,0|1]
             */
            gcoOS_StrStr(p, "-F:", &pos);
            if (pos)
            {
                gctINT featureBits=0;
                pos += sizeof("-F") -1;
                while (pos[0] == ':')
                {
                    ++pos;

                    gcoOS_StrToInt(pos, &featureBits);
                    if (featureBits != 0)
                    {
                        s1 = pos;
                        /* find next ',', ' ' or '\0' */
                        while (*s1 != ',' && *s1 != ' ' && *s1 != '\0') s1++;

                        if (*s1 == ',')
                        {
                            s1++; /* advance to next char */

                            /* getting the value */
                            if (*s1 == '0')
                            {
                                /* turn off the featureBits */
                                Option->featureBits &= ~featureBits;
                            }
                            else if (*s1 == '1')
                            {
                                /* turn on the featureBits */
                                Option->featureBits |= featureBits;
                            }
                        }
                        pos = s1+1;
                    }
                }
            }

            /* Load-time Constant optimization:

                VC_OPTION=-LTC:0|1

            */
            gcoOS_StrStr(p, "-LTC:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-LTC:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off the LTC */
                    Option->enableLTC = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on the LTC */
                    Option->enableLTC = gcvTRUE;
                }
            }

             /* debug option:

                VC_OPTION=-DEBUG:0|1

            */
            gcoOS_StrStr(p, "-DEBUG:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-DEBUG:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off debug */
                    Option->enableDebug = 0;
                }
                else if (value == 1)
                {
                    /* turn on the debug */
                    Option->enableDebug = 1;
                }
                else if (value == 2)
                {
                    /* enable debug and debug dump */
                    Option->enableDebug = 2;
                }
                else if (value == 3)
                {
                    /* enable debug and detail debug dump */
                    Option->enableDebug = 3;
                }
            }
            /* Replace specified shader's source code with the contents in
               specified file:

                 VC_OPTION=-SHADER:id1,file1[:id2,file ...]

            */
            gcoOS_StrStr(p, "-SHADER:", &pos);
            if (pos)
            {
                pos += sizeof("-SHADER:") -1;
                _getShaderSourceList(Option, pos);
            }

            /* -Ddef[=value] -Uundef options */
            gcoOS_StrStr(p, "-D", &pos);
            if (pos)
            {
                if (gcoOS_StrNCmp(pos, "-DUMP:", sizeof("-DUMP:")-1) == gcvSTATUS_OK)
                {
                    gctCHAR * pos1;
                    gcoOS_StrStr(pos+2, "-D", &pos1);
                    if (pos1)
                        _processDefineOption(Option, pos1);
                }
                else
                    _processDefineOption(Option, pos);
            }

            gcoOS_StrStr(p, "-U", &pos);
            if (pos)
            {
                _processUndefOption(Option, pos);
            }

            /* inliner kind (default is 1, VIR inliner):

                  VC_OPTION=-INLINER:[0-1]
                     0:  gcsl inliner
                     1:  VIR inliner

                  When VIRCG is not enabled, gcsl inliner is always use.
             */
            gcoOS_StrStr(p, "-INLINER:", &pos);
            if (pos)
            {
                gctINT inlinerKind=-1;
                pos += sizeof("-INLINER:") -1;
                gcoOS_StrToInt(pos, &inlinerKind);
                if (inlinerKind >= 0)
                {
                    Option->inlinerKind = (gctUINT)inlinerKind;
                }
            }

            /* inline level (default 2 at O1):

                  VC_OPTION=-INLINELEVEL:[0-3]
                     0:  no inline
                     1:  only inline the function only called once or small function
                     2:  inline functions be called less than 5 times or medium size function
                     3:  inline everything possible
                     4:  force inline every functions
             */
            gcoOS_StrStr(p, "-INLINELEVEL:", &pos);
            if (pos)
            {
                gctINT inlineLevel=-1;
                pos += sizeof("-INLINELEVEL:") -1;
                gcoOS_StrToInt(pos, &inlineLevel);
                if (inlineLevel >= 0)
                {
                    Option->inlineLevel = (gctUINT)inlineLevel;
                }
            }

            /* inline recompilation functions for depth comparison if inline level is not 0.
               (default 1)

                  VC_OPTION=-INLINEDEPTHCOMP:[0-3]
                     0:  follows inline level
                     1:  inline depth comparison functions for halti2
                     2:  inline depth comparison functions for halti1
                     3:  inline depth comparison functions for halti0
             */
            gcoOS_StrStr(p, "-INLINEDEPTHCOMP:", &pos);
            if (pos)
            {
                gctINT inlineDepthComparison=-1;
                pos += sizeof("-INLINEDEPTHCOMP:") -1;
                gcoOS_StrToInt(pos, &inlineDepthComparison);
                if (inlineDepthComparison >= 0)
                {
                    Option->inlineDepthComparison = (gctUINT)inlineDepthComparison;
                }
            }

            /* inline recompilation functions for format conversion if inline level is not 0.
               (default 1)

                  VC_OPTION=-INLINEFORMATCONV:[0-3]
                     0:  follows inline level
                     1:  inline depth comparison functions for halti2
                     2:  inline depth comparison functions for halti1
                     3:  inline depth comparison functions for halti0
             */
            gcoOS_StrStr(p, "-INLINEFORMATCONV:", &pos);
            if (pos)
            {
                gctINT inlineFormatConversion=-1;
                pos += sizeof("-INLINEFORMATCONV:") -1;
                gcoOS_StrToInt(pos, &inlineFormatConversion);
                if (inlineFormatConversion >= 0)
                {
                    Option->inlineFormatConversion = (gctUINT)inlineFormatConversion;
                }
            }

            /* Force inline specified functions
             *
             *    VC_OPTION=-FORCEINLINE:func1[,func2]*
             *
             */
            gcoOS_StrStr(p, "-FORCEINLINE:", &pos);
            if (pos)
            {
                pos += sizeof("-FORCEINLINE:") -1;
                _getForceInlineList(Option, pos, FIK_Inline);
            }

            /* Force not inline specified functions
             *
             *    VC_OPTION=-NOTINLINE:func1[,func2]*
             *
             */
            gcoOS_StrStr(p, "-NOTINLINE:", &pos);
            if (pos)
            {
                pos += sizeof("-NOTINLINE:") -1;
                _getForceInlineList(Option, pos, FIK_NotInline);
            }

            /* dual 16 mode
             *
             *    VC_OPTION=-DUAL16:[0-3]
             *       0:  force dual16 off, no dual16 any more.
             *       1:  auto-on mode for specific benchmarks
             *       2:  auto-on mode for all applications.
             *       3:  force dual16 on for all applications no matter highp is specified or not.
             */
            gcoOS_StrStr(p, "-DUAL16:", &pos);
            if (pos)
            {
                gctINT dual16=-1;
                pos += sizeof("-DUAL16") -1;
                while (pos[0] == ':')
                {
                    ++pos;
                    if (*pos == 't' || *pos == 'T') /* Traige option */
                    {
                        gctBOOL exclude = gcvFALSE;
                        gctINT  m,n;
                        ++pos;

                        if (*pos == '-' )
                        {
                            exclude = gcvTRUE;
                            ++pos;
                        }

                        /* getting the range */
                        gcoOS_StrToInt(pos, &m);
                        if (m >= 0)
                        {
                            Option->_dual16Start = exclude ? -m : m;
                            s1 = pos;
                            /* find next ',', ' ' or '\0' */
                            while (*s1 != ',' && *s1 != ' ' && *s1 != '\0') s1++;

                            if (*s1 == ',')
                            {
                                gcoOS_StrToInt(s1+1, &n);
                                gcmASSERT(n > 0);
                                Option->_dual16End =  exclude ? -n : n;
                            }
                            else
                            {
                                /* set _dumpEnd to _dumpStart if the end
                                   range is not specified */
                                Option->_dual16End =  Option->_dual16Start;
                            }
                        }
                    }
                    else
                    {
                        gcoOS_StrToInt(pos, &dual16);
                        if (dual16 >= 0)
                        {
                            Option->dual16Mode = (gctUINT)dual16;
                            Option->dual16Specified = gcvTRUE;
                        }
                        pos++;
                    }
                }
            }

            /* dual 16 highp rule
            *
            *    VC_OPTION=-HPDUAL16:[0-x]
            *       0: no dual16 highp rules applied
            *       1: Dual16_PrecisionRule_TEXLD_COORD_HP
            *       2: Dual16_PrecisionRule_RCP_HP
            *       4: Dual16_PrecisionRule_FRAC_HP
            *       8: Dual16_PrecisionRule_IMMED_HP
            *       default is Dual16_PrecisionRule_FULL
            *           (which is Dual16_PrecisionRule_TEXLD_COORD_HP |
            *                     Dual16_PrecisionRule_RCP_HP         |
            *                     Dual16_PrecisionRule_FRAC_HP        |
            *                     Dual16_PrecisionRule_IMMED_HP)
            */
            gcoOS_StrStr(p, "-HPDUAL16:", &pos);
            if (pos)
            {
                gctINT dual16PrecisionRule=-1;
                pos += sizeof("-HPDUAL16:") -1;
                gcoOS_StrToInt(pos, &dual16PrecisionRule);
                if (dual16PrecisionRule >= 0)
                {
                    Option->dual16PrecisionRule = (gctUINT)dual16PrecisionRule;
                    Option->dual16PrecisionRuleFromEnv = gcvTRUE;
                }
            }

             /* Upload Uniform Block to state buffer if there are space available
              * Doing this may potentially improve the performance as the load
              * instruction for uniform block member can be removed.
              *
              *   VC_OPTION=-UPLOADUBO:0|1
              *
              */
            gcoOS_StrStr(p, "-UPLOADUBO:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-UPLOADUBO:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off uploading of UBO */
                    Option->uploadUBO = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on uploading of UBO */
                    Option->uploadUBO = gcvTRUE;
                }
            }

             /* OpenCL floating point capabilities setting
              * FASTRELAXEDMATH => -cl-fast-relaxed-math option
              * FINITEMATHONLY => -cl-finite-math-only option
              * RTZ => Round To Even
              * RTZ => Round to Zero
              *
              * VC_OPTION=-OCLFPCAPS:FASTRELAXEDMATH:FINITEMATHONLY:RTNE:RTZ
              */
            gcoOS_StrStr(p, "-OCLFPCAPS:", &pos);
            if (pos)
            {
                pos += sizeof("-OCLFPCAPS") - 1;

                while (pos[0] == ':')
                {
                    ++pos;

                    if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "FASTRELAXEDMATH", sizeof("FASTRELAXEDMATH")-1))
                    {
                        Option->oclFpCaps |= VC_OPTION_OCLFPCAPS_FASTRELAXEDMATH;
                        pos += sizeof("FASTRELAEXMATH")-1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "NOFASTRELAXEDMATH", sizeof("NOFASTRELAXEDMATH")-1))
                    {
                        Option->oclFpCaps |= VC_OPTION_OCLFPCAPS_NOFASTRELAXEDMATH;
                        pos += sizeof("NOFASTRELAEXMATH")-1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "FINITEMATHONLY", sizeof("FINITEMATHONLY")-1))
                    {
                        Option->oclFpCaps |= VC_OPTION_OCLFPCAPS_FINITEMATHONLY;
                        pos += sizeof("FINITEMATHONLY")-1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "RTNE", sizeof("RTNE")-1))
                    {
                        Option->oclFpCaps |= VC_OPTION_OCLFPCAPS_ROUNDTOEVEN;
                        pos += sizeof("RTNE")-1;
                    }
                    else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "RTZ", sizeof("RTZ")-1))
                    {
                        Option->oclFpCaps |= VC_OPTION_OCLFPCAPS_ROUNDTOZERO;
                        pos += sizeof("RTZ")-1;
                    }
                }
            }

             /*
              * Handle OCL basic type as packed
              *
              *   VC_OPTION=-OCLPACKEDBASICTYPE:0|1
              *
              */
            gcoOS_StrStr(p, "-OCLPACKEDBASICTYPE:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-OCLPACKEDBASICTYPE:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off ocl treating basic type as packed */
                    Option->oclPackedBasicType = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on ocl treating basic type as packed */
                    Option->oclPackedBasicType = gcvTRUE;
                }
            }

             /*
              * Handle OCL relaxing local address space in OCV
              *
              *   VC_OPTION=-OCLOCVLOCALADDRESSSPACE:0|1
              *
              */
            gcoOS_StrStr(p, "-OCLOCVLOCALADDRESSSPACE:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-OCLOCVLOCALADDRESSSPACE:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off ocl relaxing local address space in OCV */
                    Option->oclOcvLocalAddressSpace = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on ocl relaxing local address space in OCV */
                    Option->oclOcvLocalAddressSpace = gcvTRUE;
                }
            }

             /*
              * Handle OCL in OPENCV mode
              *
              *   VC_OPTION=-OCLOPENCV:0|1
              *
              */
            gcoOS_StrStr(p, "-OCLOPENCV:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-OCLOPENCV:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off ocl in OPENCV mode */
                    Option->oclOpenCV = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on ocl in OPENCV mode */
                    Option->oclOpenCV = gcvTRUE;
                }
            }

             /*
              * Handle OCL long and ulong
              *
              *   VC_OPTION=-OCLHASLONG:0|1
              *
              */
            gcoOS_StrStr(p, "-OCLHASLONG:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-OCLHASLONG:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off ocl has long */
                    Option->oclHasLong = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on ocl has long */
                    Option->oclHasLong = gcvTRUE;
                }
            }

             /*
              * OCL long and ulong support in VIR
              *
              *   VC_OPTION=-OCLINT64INVIR:0|1
              *
              */
            gcoOS_StrStr(p, "-OCLINT64INVIR:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-OCLINT64INVIR:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off ocl long support in VIR */
                    Option->oclInt64InVir = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on ocl long support in VIR*/
                    Option->oclInt64InVir = gcvTRUE;
                }
            }

            /*
              * write/read Shader info to/from file function in old compiler
              *
              *   VC_OPTION=-LIBSHADERFILE:0|1
              *
              */
            gcoOS_StrStr(p, "-LIBSHADERFILE:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-LIBSHADERFILE:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off shader file in old compiler */
                    Option->enableLibShaderFile = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on shader file in old compiler*/
                    Option->enableLibShaderFile = gcvTRUE;
                }
            }

            /*  USE gcSL_NEG for -a instead of SUB(0, a)
             *
             *   VC_OPTION=-OCLUSENEG
             *
             */
            gcoOS_StrStr(p, "-OCLUSENEG:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-OCLUSENEG:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off ocl to use NEG opcode */
                    Option->oclUseNeg = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on ocl to use NEG opcode */
                    Option->oclUseNeg = gcvTRUE;
                }
            }

            /*  USE image intrinsic query function
             *
             *   VC_OPTION=-OCLUSEIMG_INTRINSIC_QUERY
             *
             */
            gcoOS_StrStr(p, "-OCLUSEIMG_INTRINSIC_QUERY:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-OCLUSEIMG_INTRINSIC_QUERY:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off ocl to use image intrinsic query function */
                    Option->oclUseImgIntrinsicQuery = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on ocl to use image intrinsic query function */
                    Option->oclUseImgIntrinsicQuery = gcvTRUE;
                }
            }

            /*  Pass kernel struct arguments by value in OCL
             *
             *   VC_OPTION=-OCLPASS_KERNEL_STRUCT_ARG_BY_VALUE:0|1
             *
             */
            gcoOS_StrStr(p, "-OCLPASS_KERNEL_STRUCT_ARG_BY_VALUE:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-OCLPASS_KERNEL_STRUCT_ARG_BY_VALUE:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off ocl to pass kernel struct argument by value */
                    Option->oclPassKernelStructArgByValue = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on ocl to pass kernel struct argument by value */
                    Option->oclPassKernelStructArgByValue = gcvTRUE;
                }
            }

            /* use VIR code generator:
             *
             *   VC_OPTION=-VIRCG:[0|1|2]|T[-]m[,n]
             *    Tm:    turn on VIRCG for shader id m
             *    Tm,n:  turn on VIRCG for shader id is in range of [m, n]
             *    T-m:   turn off VIRCG for shader id m
             *    T-m,n: turn off VIRCG for shader id is in range of [m, n]
             */
            gcoOS_StrStr(p, "-VIRCG:", &pos);
            if (pos)
            {
                pos += sizeof("-VIRCG") -1;
                Option->virCodeGenSpecified = gcvTRUE;

                while (pos[0] == ':')
                {
                    ++pos;

                    if (*pos == '0')
                    {
                        Option->useVIRCodeGen = VIRCG_None;
                        ++pos;
                    }
                    else if (*pos == '1')
                    {
                        Option->useVIRCodeGen = VIRCG_WITH_TREECG;
                        ++pos;
                    }
                    else if (*pos == '2')
                    {
                        Option->useVIRCodeGen = VIRCG_FULL;
                        ++pos;
                    }
                    else if (*pos == 't' || *pos == 'T') /* Traige option */
                    {
                        gctBOOL exclude = gcvFALSE;
                        gctINT  m,n;
                        ++pos;

                        if (*pos == '-' )
                        {
                            exclude = gcvTRUE;
                            ++pos;
                        }

                        /* getting the range */
                        gcoOS_StrToInt(pos, &m);
                        if (m >= 0)
                        {
                            Option->_vircgStart = exclude ? -m : m;
                            s1 = pos;
                            /* find next ',', ' ' or '\0' */
                            while (*s1 != ',' && *s1 != ' ' && *s1 != '\0') s1++;

                            if (*s1 == ',')
                            {
                                gcoOS_StrToInt(s1+1, &n);
                                gcmASSERT(n > 0);
                                Option->_vircgEnd =  exclude ? -n : n;
                            }
                            else
                            {
                                /* set _vircgEnd to _vircgStart if the end
                                   range is not specified */
                                Option->_vircgEnd =  Option->_vircgStart;
                            }
                        }
                    }
                }
            }
            /* OCL use VIR code generator:
             *
             *   VC_OPTION=-CLVIRCG:[0|1]|T[-]m[,n]
             *    Tm:    turn on VIRCG for OCL shader id m
             *    Tm,n:  turn on VIRCG for OCL shader id is in range of [m, n]
             *    T-m:   turn off VIRCG for OCL shader id m
             *    T-m,n: turn off VIRCG for OCL shader id is in range of [m, n]
             */
            gcoOS_StrStr(p, "-CLVIRCG:", &pos);
            if (pos)
            {
                pos += sizeof("-CLVIRCG") -1;

                while (pos[0] == ':')
                {
                    ++pos;

                    if (*pos == '0')
                    {
                        Option->CLUseVIRCodeGen = gcvFALSE;
                        ++pos;
                    }
                    else if (*pos == '1')
                    {
                        Option->CLUseVIRCodeGen = gcvTRUE;
                        ++pos;
                    }
                    else if (*pos == 't' || *pos == 'T') /* Traige option */
                    {
                        gctBOOL exclude = gcvFALSE;
                        gctINT  m,n;
                        ++pos;

                        if (*pos == '-' )
                        {
                            exclude = gcvTRUE;
                            ++pos;
                        }

                        /* getting the range */
                        gcoOS_StrToInt(pos, &m);
                        if (m >= 0)
                        {
                            Option->_vircgStart = exclude ? -m : m;
                            s1 = pos;
                            /* find next ',', ' ' or '\0' */
                            while (*s1 != ',' && *s1 != ' ' && *s1 != '\0') s1++;

                            if (*s1 == ',')
                            {
                                gcoOS_StrToInt(s1+1, &n);
                                gcmASSERT(n > 0);
                                Option->_vircgEnd =  exclude ? -n : n;
                            }
                            else
                            {
                                /* set _vircgEnd to _vircgStart if the end
                                   range is not specified */
                                Option->_vircgEnd =  Option->_vircgStart;
                            }
                        }
                    }
                }
            }

             /* Create default Uniform Block Object to encapsulate uniforms
              * This is done to enable the use of load instruction to get
              * the uniforms from memory
              *
              *   VC_OPTION=-CREATEDEFAULTUBO:0|1
              *
              */
            gcoOS_StrStr(p, "-CREATEDEFAULTUBO:", &pos);
            if (pos)
            {
                gctINT value=-1;
                pos += sizeof("-CREATEDEFAULTUBO:") -1;
                gcoOS_StrToInt(pos, &value);

                if (value == 0)
                {
                    /* turn off creation of default UBO */
                    Option->createDefaultUBO = gcvFALSE;
                }
                else if (value == 1)
                {
                    /* turn on creation of default UBO */
                    Option->createDefaultUBO = gcvTRUE;
                }
            }

            /* Specify the log file name
             *
             *   VC_OPTION=-LOG:filename
             */
            gcoOS_StrStr(p, "-LOG:", &pos);
            if (pos)
            {
                gctSTRING name;
                size_t    strLen;
                gceSTATUS status;
                /* get the file name */
                pos += sizeof("-LOG:") -1;
                name = pos;
                while (*pos != ' ' && *pos != '\0') pos++;
                strLen = (size_t)(pos - name);
                if (strLen > 0)
                {
                    status = gcoOS_Allocate(gcvNULL, strLen + 1,
                                            (gctPOINTER *)&Option->logFileName);
                    if (status == gcvSTATUS_OK)
                    {
                        gcoOS_MemCopy((gctPOINTER)Option->logFileName, name, strLen);
                        Option->logFileName[strLen] ='\0';

                        /* Open debug file */
                        /*Option->debugFile = fopen(Option->logFileName, "w"); */
                        Option->debugFile = gcvNULL;
                    }
                }
                else
                {
                    Option->debugFile = gcvNULL;
                    Option->logFileName= gcvNULL;
                }
            }
            else
            {
                Option->debugFile = gcvNULL;
                Option->logFileName = gcvNULL;
            }

            /* Turn on/off patch
             *
             *   -PATCH:{0|1}[:T[-]m,n]
             *    0:  turn off shader patch (Tm,n has no effect)
             *    1:  turn on shader patch
             *        Tm:    turn on shader patch for shader id m
             *        Tm,n:  turn on shader patch for shader id is in range of [m, n]
             *        T-m:   turn off shader patch for shader id m
             *        T-m,n: turn off shader patch for shader id is in range of [m, n]
             */
            gcoOS_StrStr(p, "-PATCH:", &pos);
            if (pos)
            {
                pos += sizeof("-PATCH") -1;

                while (pos[0] == ':')
                {
                    ++pos;

                    if (*pos == '0')
                    {
                        Option->patchShader = gcvFALSE;
                        ++pos;
                    }
                    else if (*pos == '1')
                    {
                        Option->patchShader = gcvTRUE;
                        ++pos;
                    }
                    else if (*pos == 't' || *pos == 'T') /* Traige option */
                    {
                        gctBOOL exclude = gcvFALSE;
                        gctINT  m,n;
                        ++pos;

                        if (*pos == '-' )
                        {
                            exclude = gcvTRUE;
                            ++pos;
                        }

                        /* getting the range */
                        gcoOS_StrToInt(pos, &m);
                        if (m >= 0)
                        {
                            Option->_patchShaderStart = exclude ? -m : m;
                            s1 = pos;
                            /* find next ',', ' ' or '\0' */
                            while (*s1 != ',' && *s1 != ' ' && *s1 != '\0') s1++;

                            if (*s1 == ',')
                            {
                                gcoOS_StrToInt(s1+1, &n);
                                gcmASSERT(n > 0);
                                Option->_patchShaderEnd =  exclude ? -n : n;
                            }
                            else
                            {
                                /* set _patchShaderEnd to _patchShaderStart if the end
                                   range is not specified */
                                Option->_patchShaderEnd =  Option->_patchShaderStart;
                            }
                        }
                    }
                }
            }

            /* set default fragment shader floating point precision if not specified in shader
             *   VC_OPTION=-FRAGMENT_FP_PRECISION:highp:mediump:lowp
             *    highp: high precision
             *    mediump:  medium precision
             *    lowp:   low precision
             */
            gcoOS_StrStr(p, "-FRAGMENT_FP_PRECISION:", &pos);
            if (pos)
            {
                pos += sizeof("-FRAGMENT_FP_PRECISION:") - 1;
                if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "highp", sizeof("highp")-1))
                {
                    Option->fragmentFPPrecision = gcSHADER_PRECISION_HIGH;
                    pos += sizeof("highp")-1;
                }
                else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "mediump", sizeof("mediump")-1))
                {
                    Option->fragmentFPPrecision = gcSHADER_PRECISION_MEDIUM;
                    pos += sizeof("mediump")-1;
                }
                else if (gcvSTATUS_OK == gcoOS_StrNCmp(pos, "lowp", sizeof("lowp")-1))
                {
                    Option->fragmentFPPrecision = gcSHADER_PRECISION_LOW;
                    pos += sizeof("lowp")-1;
                }
            }
        }

        Option->origUseVIRCodeGen = Option->useVIRCodeGen;
        envChecked = 1;
    }
    return;
} /* gcGetOptionFromEnv */

void gcOPT_SetFeature(gctUINT FBit)
{
    gcmOPT_SetFeature(FBit);
}

void gcOPT_ResetFeature(gctUINT FBit)
{
    gcmOPT_ResetFeature(FBit);
}

/* convert the compiler flag to optimizer option:
 *  the ES1.1 driver calls gcLinkShader() without setting
 *  the loadtime optimization flag, while ES2.0 driver calls
 *  gcLinkShader() with the gcvSHADER_LOADTIME_OPTIMIZER, so
 *  we can turn off the Loadtime Optimization for ES1.1
 *
 *  TODO: set the flag from command line and environment
 *        variable
 *
 */
void
gcSetOptimizerOption(
    IN gceSHADER_FLAGS Flags
    )
{
    gceSHADER_OPTIMIZATION opt  = gcvOPTIMIZATION_NONE;

    if (Flags & gcvSHADER_RESET_INLINE_LEVEL)
    {
        gcmOPT_SetINLINELEVEL(GC_DEFAULT_INLINE_LEVEL);
    }

    /* get options from the environment variables  */
    gcGetOptionFromEnv(&theOptimizerOption);

    {
        if ((Flags & gcvSHADER_OPTIMIZER) !=0)
            opt = gcvOPTIMIZATION_FULL;

        /* check if loadtime optimization is needed */
        if ((gcvSHADER_LOADTIME_OPTIMIZER & Flags) == 0)
            opt &= ~gcvOPTIMIZATION_LOADTIME_CONSTANT;

        /* check if power optimization is needed */
        if (theOptimizerOption.needPowerOptimization)
            opt |= gcvOPTIMIZATION_POWER_OPTIMIZATION;

        /* check if image patching is needed */
        if (Flags & gcvSHADER_IMAGE_PATCHING)
            opt |= gcvOPTIMIZATION_IMAGE_PATCHING;

        if (Flags & gcvSHADER_RECOMPILER)
            opt |= gcvOPTIMIZATION_RECOMPILER;

        if (Flags & gcvSHADER_MIN_COMP_TIME)
            opt |= gcvOPTIMIZATION_MIN_COMP_TIME;
    }

    theOptimizerOption.optFlags = opt;

    if ((Flags & gcvSHADER_VIRCG_NONE) !=0)
    {
        theOptimizerOption.useVIRCodeGen = VIRCG_None;
        theOptimizerOption.virCodeGenSpecified = gcvTRUE;
    }
    else if ((Flags & gcvSHADER_VIRCG_ONE) !=0)
    {
        theOptimizerOption.useVIRCodeGen = VIRCG_WITH_TREECG;
    }
    else
    {
        theOptimizerOption.useVIRCodeGen = theOptimizerOption.origUseVIRCodeGen;
        theOptimizerOption.virCodeGenSpecified = gcvFALSE;
    }

    return;
} /* gcSetOptimizerOption */

VIRCGKind
gcGetVIRCGKind(
    IN gctBOOL              HasHalti2
    )
{
    VIRCGKind virCGKind = VIRCG_None;

    if (!gcmOPT_VirCodeGenSpecified() && HasHalti2)
    {
        /* set -VIRCG:2 to use new CG if halti2 */
        virCGKind = VIRCG_FULL;
    }
    else
    {
        virCGKind = gcmOPT_UseVIRCodeGen();
    }

    return virCGKind;
}

gctBOOL
gcUseFullNewLinker(
    IN gctBOOL              HasHalti2
    )
{
    VIRCGKind virCGKind = gcGetVIRCGKind(HasHalti2);

    return (virCGKind == VIRCG_FULL);
}

gctUINT
gcGetDualFP16Mode(
    IN gctBOOL              HasHalti2
    )
{
    gctUINT dual16Mode = gcmOPT_DualFP16Mode();

    if (!gcmOPT_DualFP16Specified() && gcUseFullNewLinker(HasHalti2))
    {
        dual16Mode = DUAL16_AUTO_ALL;
    }

    return dual16Mode;
}

gcOPTIMIZER_OPTION *
gcGetOptimizerOption(void)
{
    /* get options from the environment variables  */
    gcGetOptionFromEnv(&theOptimizerOption);

    return &theOptimizerOption;
} /* gcGetOptimizerOption */

gcOPTIMIZER_OPTION *
gcGetOptimizerOptionVariable(void)
{
    return &theOptimizerOption;
}

gctBOOL gcDebugZoneLevelEnabled(
    IN gctUINT32 Zone,
    IN gctUINT32 Level
    )
{
    gctUINT32 curDebugLevel;
    gctUINT32 curDebugZone;
    gcoOS_GetDebugLevel(&curDebugLevel);
    gcoOS_GetDebugZone(Zone, &curDebugZone);
    if ((Level > curDebugLevel) ||  !(curDebugZone & Zone & gcdZONE_MASK))
    {
      return gcvFALSE;
    }

    return gcvTRUE;
}

gctBOOL gcDumpMachineCode(void)
{
#if gcmIS_DEBUG(gcdDEBUG_TRACE)
    return gcvTRUE;
#else
    return gcvFALSE;
#endif
}

/*******************************************************************************
**  gcSHADER_SetOptimizationOption
**
**  Set optimization option of a gcSHADER object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT OptimizationOption
**          Optimization option.  Can be one of the following:
**
**              0       - No optimization.
**              1       - Full optimization.
**              Others  - Testing patterns.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcSHADER_SetOptimizationOption(
    IN gcSHADER Shader,
    IN gctUINT OptimizationOption
    )
{
    gcmHEADER_ARG("Shader=0x%x OptimizationOption=%d",
                  Shader, OptimizationOption);

    if (OptimizationOption == 1)
        Shader->optimizationOption = gcvOPTIMIZATION_FULL;
     else
        Shader->optimizationOption = OptimizationOption;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcATTRIBUTE_IsPosition
**
**  Query the isPosition state of a gcATTRIBUTE object.
**
**  INPUT:
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**  OUTPUT:
**
**      gctBOOL * IsPosition
**          Pointer to a variable receiving the isPosition state of the attribute.
*/
gceSTATUS
gcATTRIBUTE_IsPosition(
    IN gcATTRIBUTE Attribute,
    OUT gctBOOL * IsPosition,
    OUT gctBOOL * IsDirectPosition
    )
{
#if gcdUSE_WCLIP_PATCH
    gcmHEADER_ARG("Attribute=0x%x IsPosition=0x%x IsDirectPosition=0x%x", Attribute, IsPosition, IsDirectPosition);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    if (IsPosition != gcvNULL)
    {
        /* Return enabled state. */
        *IsPosition = gcmATTRIBUTE_isPosition(Attribute);
    }

    if (IsDirectPosition != gcvNULL)
    {
        /* Return enabled state. */
        *IsDirectPosition = gcmATTRIBUTE_isDirectPosition(Attribute);
    }

    gcmFOOTER_NO();
#endif
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcATTRIBUTE_SetPrecision
**
**  Set the precision of an attribute.
**
**  INPUT:
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**    gcSHADER_PRECISION Precision
**          Precision of the attribute.
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcATTRIBUTE_SetPrecision(
    IN gcATTRIBUTE Attribute,
    IN gcSHADER_PRECISION Precision
    )
{
    gcmHEADER_ARG("Attribute=0x%x Precision=%d",
                  Attribute, Precision);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    Attribute->precision = Precision;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcATTRIBUTE_GetType
**
**  Get the type and array length of a gcATTRIBUTE object.
**
**  INPUT:
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**  OUTPUT:
**
**      gcSHADER_TYPE * Type
**          Pointer to a variable receiving the type of the attribute.  'Type'
**          can be gcvNULL, in which case no type will be returned.
**
**      gctUINT32 * ArrayLength
**          Pointer to a variable receiving the length of the array if the
**          attribute was declared as an array.  If the attribute was not
**          declared as an array, the array length will be 1.  'ArrayLength' can
**          be gcvNULL, in which case no array length will be returned.
**
**
*/
gceSTATUS
gcATTRIBUTE_GetType(
    IN gcSHADER Shader,
    IN gcATTRIBUTE Attribute,
    OUT gcSHADER_TYPE * Type,
    OUT gctUINT32 * ArrayLength
    )
{
    gctUINT32 arrayLength;
    gcmHEADER_ARG("Shader=0x%x Attribute=0x%x Type=0x%x ArrayLength=0x%x",
        Shader, Attribute, Type, ArrayLength);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    if (Type != gcvNULL)
    {
        /* Return attribute type. */
        *Type = Attribute->type;
    }

    if (ArrayLength != gcvNULL)
    {
        arrayLength = Attribute->arraySize;

        if ((Shader->type == gcSHADER_TYPE_TCS ||
             Shader->type == gcSHADER_TYPE_TES) &&
            gcmATTRIBUTE_isPerVertexArray(Attribute) &&
            GetATTRNameLength(Attribute) > 0)
        {
            arrayLength = (gctUINT32)GetGLMaxTessPatchVertices();
        }

        /* Return attribute array length. */
        *ArrayLength = arrayLength;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcATTRIBUTE_GetLocation
**
**  Get the type and array length of a gcATTRIBUTE object.
**
**  INPUT:
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**  OUTPUT:
**      gctINT  * Location
**          Pointer to a variable receiving location which is defined in shader text if exist.
**
*/
gceSTATUS
gcATTRIBUTE_GetLocation(
    IN gcATTRIBUTE Attribute,
    OUT gctINT * Location
    )
{
    gcmHEADER_ARG("Attribute=0x%x Location=0x%x", Attribute, Location);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    if (Location != gcvNULL)
    {
        /* Return location if it exist. */
        *Location = Attribute->location;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
gcATTRIBUTE_GetPrecision(
    IN gcATTRIBUTE Attribute,
    OUT gcSHADER_PRECISION * Precision
    )
{
    gcmHEADER_ARG("Attribute=0x%x Precision=0x%x", Attribute, Precision);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    if (Precision != gcvNULL)
    {
        /* Return location if it exist. */
        *Precision = Attribute->precision;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  _PredefinedName
**
**  Convert a predefined name into an ASCII string.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Length
**          The predefined name.
**
**        gctBOOL UseInstanceName
**            Use instance name for a block member.
**
**  OUTPUT:
**
**      Nothing.
**
**  RETURN VALUE:
**
**      gctCONST_STRING
**          Pointer to the predefined name or gcvNULL if 'Length' does not  specify
**          a predefined name.
*/
gctCONST_STRING
_PredefinedName(
    IN gcSHADER Shader,
    IN gctUINT32 Length,
    IN gctBOOL UseInstanceName
    )
{
    switch (Length)
    {
    case gcSL_POSITION:
        if (Shader->type == gcSHADER_TYPE_TCS)
        {
            if (UseInstanceName)
            {
                return "gl_Position";
            }
            else
            {
                return "gl_PerVertex.gl_Position";
            }
        }
        else  if (Shader->type == gcSHADER_TYPE_FRAGMENT)
        {
            return "gl_FragCoord";
        }
        else
        {
            return "gl_Position";
        }


    case gcSL_POINT_SIZE:
        if (Shader->type == gcSHADER_TYPE_TCS)
        {
            if (UseInstanceName)
            {
                return "gl_PointSize";
            }
            else
            {
                return "gl_PerVertex.gl_PointSize";
            }
        }
        else
        {
            return "gl_PointSize";
        }

    case gcSL_COLOR:
        return "gl_Color";

    case gcSL_FRONT_FACING:
        return "gl_FrontFacing";

    case gcSL_POINT_COORD:
        return "gl_PointCoord";

    case gcSL_DEPTH:
        return "gl_FragDepth";

    case gcSL_FOG_COORD:
        return "gl_FogFragCoord";

    case gcSL_INSTANCE_ID:
        return "gl_VertexID";

    case gcSL_VERTEX_ID:
        return "gl_InstanceID";

    case gcSL_WORK_GROUP_ID:
        return "#group_id";

    case gcSL_LOCAL_INVOCATION_ID:
        return "#local_id";

    case gcSL_GLOBAL_INVOCATION_ID:
        return "#global_id";

    case gcSL_HELPER_INVOCATION:
        return "gl_HelperInvocation";

    case gcSL_FRONT_COLOR:
        return "gl_FrontColor";

    case gcSL_BACK_COLOR:
        return "gl_BackColor";

    case gcSL_FRONT_SECONDARY_COLOR:
        return "gl_FrontSecondaryColor";

    case gcSL_BACK_SECONDARY_COLOR:
        return "gl_BackSecondaryColor";

    case gcSL_TEX_COORD:
        return "gl_Tex_Coord";

    case gcSL_SUBSAMPLE_DEPTH:
        return "gcSL_SUBSAMPLE_DEPTH";

    case gcSL_INVOCATION_ID:
        return "gl_InvocationID";

    case gcSL_PATCH_VERTICES_IN:
        return "gl_PatchVerticesIn";

    case gcSL_PRIMITIVE_ID:
        return "gl_PrimitiveID";

    case gcSL_TESS_LEVEL_OUTER:
        return "gl_TessLevelOuter";

    case gcSL_TESS_LEVEL_INNER:
        return "gl_TessLevelInner";

    case gcSL_LAYER:
        return "gl_Layer";

    case gcSL_PRIMITIVE_ID_IN:
        return "gl_PrimitiveIDIn";

    case gcSL_TESS_COORD:
        return "gl_TessCoord";

    case gcSL_SAMPLE_ID:
        return "gl_SampleID";

    case gcSL_SAMPLE_POSITION:
        return "gl_SamplePosition";

    case gcSL_SAMPLE_MASK_IN:
        return "gl_SampleMaskIn";

    case gcSL_SAMPLE_MASK:
        return "gl_SampleMask";

    case gcSL_IN_POSITION:
        if (UseInstanceName)
        {
            return "gl_in.gl_Position";
        }
        else
        {
            return "gl_PerVertex.gl_Position";
        }

    case gcSL_IN_POINT_SIZE:
        if (UseInstanceName)
        {
            return "gl_in.gl_PointSize";
        }
        else
        {
            return "gl_PerVertex.gl_PointSize";
        }

    case gcSL_BOUNDING_BOX:
        return "gl_BoundingBox";

    case gcSL_LAST_FRAG_DATA:
        return "gl_LastFragData";
    }

    /* Not a predefined name. */
    return gcvNULL;
}

/*******************************************************************************
**  gcATTRIBUTE_GetName
**
**  Get the name of a gcATTRIBUTE object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**        gctBOOL UseInstanceName
**            Use instance name for a block member.
**
**  OUTPUT:
**
**      gctUINT32 * Length
**          Pointer to a variable receiving the length of the attribute name.
**          'Length' can be gcvNULL, in which case no length is returned.
**
**      gctCONST_STRING * Name
**          Pointer to a variable receiving the pointer to the name of the
**          attribute.  'Name' can be gcvNULL in which case no name is returned.
*/
gceSTATUS
gcATTRIBUTE_GetName(
    IN gcSHADER Shader,
    IN gcATTRIBUTE Attribute,
    IN gctBOOL UseInstanceName,
    OUT gctUINT32 * Length,
    OUT gctCONST_STRING * Name
    )
{
    gctUINT32 length;
    gctCONST_STRING name;

    gcmHEADER_ARG("Attribute=0x%x Length=0x%x Name=0x%x", Attribute, Length, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    /* Convert predefined names into ASCII. */
    name = _PredefinedName(Shader, Attribute->nameLength, UseInstanceName);

    if (name == gcvNULL)
    {
        /* Not a predefined name. */
        length = Attribute->nameLength;
        name   = Attribute->name;
    }
    else
    {
        /* Compute length of predefined name. */
        length = gcoOS_StrLen(name, gcvNULL);
    }

    if (Length != gcvNULL)
    {
        /* Return length of name. */
        *Length = length;
    }

    if (Name != gcvNULL)
    {
        /* Return pointer to name. */
        *Name = name;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcATTRIBUTE_GetNameEx
**
**  Get the name of a gcATTRIBUTE object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**  OUTPUT:
**
**      gctUINT32 * Length
**          Pointer to a variable receiving the length of the attribute name.
**          'Length' can be gcvNULL, in which case no length is returned.
**
**      gctSTRING * Name
**          Pointer to a variable receiving the pointer to the name of the
**          attribute.  'Name' can be gcvNULL in which case no name is returned.
*/
gceSTATUS
gcATTRIBUTE_GetNameEx(
    IN gcSHADER Shader,
    IN gcATTRIBUTE Attribute,
    OUT gctUINT32 * Length,
    OUT gctSTRING * Name
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctUINT32 length, fieldLength, arrayLength = 0;
    gctCONST_STRING name;
    gctSTRING retName = gcvNULL, indexName = gcvNULL;
    gcsIO_BLOCK ioBlock = gcvNULL;
    gctPOINTER pointer = gcvNULL;
    gctBOOL changeInstanceName = gcvFALSE;

    gcmHEADER_ARG("Attribute=0x%x Length=0x%x Name=0x%x", Attribute, Length, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    gcmONERROR(gcATTRIBUTE_GetName(Shader, Attribute, gcvFALSE, &length, &name));

    if (GetATTRIOBlockIndex(Attribute) != -1)
    {
        gcmONERROR(gcSHADER_GetIoBlock(Shader, (gctUINT32)GetATTRIOBlockIndex(Attribute), &ioBlock));

        if (GetSBInstanceNameLength(ioBlock) > 0)
        {
            /* Check if it is an array element. */
            if (gcoOS_StrStr(name, "[", &indexName) &&
                (name + GetSBInstanceNameLength(ioBlock) == indexName))
            {
                arrayLength = 3;
            }
            fieldLength = length - 1 - GetSBInstanceNameLength(ioBlock) - arrayLength;
            length = GetSBNameLength(ioBlock) + 1 + fieldLength;
            gcmONERROR(gcoOS_Allocate(gcvNULL, length + 1, &pointer));
            retName = (gctSTRING)pointer;
            /* Copy the Block name. */
            gcoOS_MemCopy(retName, GetSBName(ioBlock), GetSBNameLength(ioBlock) + 1);
            /* Copy the filed name. */
            retName += (GetSBNameLength(ioBlock) + 1);
            gcoOS_MemCopy(retName, name + GetSBInstanceNameLength(ioBlock) + 1 + arrayLength, fieldLength);
            retName[fieldLength] = '\0';
            /* Point to the first char. */
            retName = (gctSTRING)pointer;
            changeInstanceName = gcvTRUE;
        }
    }

    if (!changeInstanceName)
    {
        gcmONERROR(gcoOS_Allocate(gcvNULL, length + 1, &pointer));
        gcoOS_MemCopy(pointer, name, length + 1);
        retName = (gctSTRING)pointer;
    }

    if (Length != gcvNULL)
    {
        /* Return length of name. */
        *Length = length;
    }

    if (Name != gcvNULL)
    {
        /* Return pointer to name. */
        *Name = retName;
    }
    else
    {
        gcoOS_Free(gcvNULL, retName);
    }

OnError:

    gcmFOOTER_NO();
    return status;
}

/*******************************************************************************
**  gcATTRIBUTE_IsEnabled
**
**  Query the enabled state of a gcATTRIBUTE object.
**
**  INPUT:
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**  OUTPUT:
**
**      gctBOOL * Enabled
**          Pointer to a variable receiving the enabled state of the attribute.
*/
gceSTATUS
gcATTRIBUTE_IsEnabled(
    IN gcATTRIBUTE Attribute,
    OUT gctBOOL * Enabled
    )
{
    gcmHEADER_ARG("Attribute=0x%x Enabled=0x%x", Attribute, Enabled);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    if (Enabled != gcvNULL)
    {
        /* Return enabled state. */
        *Enabled = gcmATTRIBUTE_enabled(Attribute);
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
gcATTRIBUTE_GetIndex(
    IN gcATTRIBUTE Attribute,
    OUT gctUINT16 * Index
    )
{
    gcmHEADER_ARG("Attribute=0x%x Index=0x%x", Attribute, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    if (Index != gcvNULL)
    {
        *Index = Attribute->index;
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}


/*******************************************************************************
**  gcATTRIBUTE_IsPerPatch
**
**  Query the IsPerPatch state of a gcATTRIBUTE object.
**
**  INPUT:
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**  OUTPUT:
**
**      gctBOOL * IsPerPatch
**          Pointer to a variable receiving the isPerPatch state of the attribute.
*/
gceSTATUS
gcATTRIBUTE_IsPerPatch(
    IN gcATTRIBUTE Attribute,
    OUT gctBOOL * IsPerPatch
    )
{
    gcmHEADER_ARG("Attribute=0x%x IsPerPatch=0x%x", Attribute, IsPerPatch);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    if (IsPerPatch != gcvNULL)
    {
        /* Return isPerPatch state. */
        *IsPerPatch = gcmATTRIBUTE_isPerPatch(Attribute);
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}


/*******************************************************************************
**  gcATTRIBUTE_IsSample
**
**  Query the IsSample state of a gcATTRIBUTE object.
**
**  INPUT:
**
**      gcATTRIBUTE Attribute
**          Pointer to a gcATTRIBUTE object.
**
**  OUTPUT:
**
**      gctBOOL * IsSample
**          Pointer to a variable receiving the IsSample state of the attribute.
*/
gceSTATUS
gcATTRIBUTE_IsSample(
    IN gcATTRIBUTE Attribute,
    OUT gctBOOL * IsSample
    )
{
    gcmHEADER_ARG("Attribute=0x%x IsSample=0x%x", Attribute, IsSample);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Attribute, gcvOBJ_ATTRIBUTE);

    if (IsSample != gcvNULL)
    {
        /* Return isPerPatch state. */
        *IsSample = gcmATTRIBUTE_isSample(Attribute);
    }

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcUNIFORM_GetType
**
**  Get the type and array length of a gcUNIFORM object.
**
**  INPUT:
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**  OUTPUT:
**
**      gcSHADER_TYPE * Type
**          Pointer to a variable receiving the type of the uniform.  'Type' can
**          be gcvNULL, in which case no type will be returned.
**
**      gctUINT32 * ArrayLength
**          Pointer to a variable receiving the length of the array if the
**          uniform was declared as an array.  If the uniform was not declared
**          as an array, the array length will be 1.  'ArrayLength' can be gcvNULL,
**          in which case no array length will be returned.
*/
gceSTATUS
gcUNIFORM_GetType(
    IN gcUNIFORM Uniform,
    OUT gcSHADER_TYPE * Type,
    OUT gctUINT32 * ArrayLength
    )
{
    gcmHEADER_ARG("Uniform=0x%x Type=%d, ArrayLength", Uniform, Type, ArrayLength);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    if (Type != gcvNULL)
    {
        /* Return uniform type. */
        *Type = Uniform->u.type;
    }

    if (ArrayLength != gcvNULL)
    {
        /* Return uniform array length. */
        *ArrayLength = Uniform->arraySize;
    }

    /* Success. */
    gcmFOOTER_ARG("*Type=%d *ArrayLength=%lu",
                  gcmOPT_VALUE(Type), gcmOPT_VALUE(ArrayLength));

    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcUNIFORM_GetTypeEx
**
**  Get the type and array length of a gcUNIFORM object.
**
**  INPUT:
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**  OUTPUT:
**
**      gcSHADER_TYPE * Type
**          Pointer to a variable receiving the type of the uniform.  'Type' can
**          be gcvNULL, in which case no type will be returned.
**
**        gcSHADER_PRECISION * Precision
**            Pointer to a variable receiving the precision of the uniform.  'Precision' can
**            be gcvNULL, in which case no type will be returned.
**
**      gctUINT32 * ArrayLength
**          Pointer to a variable receiving the length of the array if the
**          uniform was declared as an array.  If the uniform was not declared
**          as an array, the array length will be 1.  'ArrayLength' can be gcvNULL,
**          in which case no array length will be returned.
*/
gceSTATUS
gcUNIFORM_GetTypeEx(
    IN gcUNIFORM Uniform,
    OUT gcSHADER_TYPE * Type,
    OUT gcSHADER_TYPE_KIND * Category,
    OUT gcSHADER_PRECISION * Precision,
    OUT gctUINT32 * ArrayLength
    )
{
    gcmHEADER_ARG("Uniform=0x%x Type=0x%x Category=0x%x Precision=0x%x ArrayLength=0x%x",
                   Uniform, Type, Category, Precision, ArrayLength);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    if (Type != gcvNULL)
    {
        /* Return uniform type. */
        *Type = Uniform->u.type;
    }

    if (Category != gcvNULL)
    {
        /* What's the type category? */
        *Category = gcmType_Kind(Uniform->u.type);
    }

    if (Precision != gcvNULL)
    {
        *Precision = Uniform->precision;
    }

    if (ArrayLength != gcvNULL)
    {
        /* Return uniform array length. */
        *ArrayLength = (gctUINT32) Uniform->arraySize;
    }

    /* Success. */
    gcmFOOTER_ARG("*Type=%d *Category=%d Precision=%d *ArrayLength=%u", gcmOPT_VALUE(Type),
                  gcmOPT_VALUE(Category), gcmOPT_VALUE(Precision), gcmOPT_VALUE(ArrayLength));

    return gcvSTATUS_OK;
}

/*******************************************************************************
**                              gcUNIFORM_GetFlags
********************************************************************************
**
**    Get the type and array length of a gcUNIFORM object.
**
**    INPUT:
**
**        gcUNIFORM Uniform
**            Pointer to a gcUNIFORM object.
**
**    OUTPUT:
**
**        gceUNIFORM_FLAGS * Flags
**            Pointer to a variable receiving the flags of the uniform.
**
*/
gceSTATUS
gcUNIFORM_GetFlags(
    IN gcUNIFORM Uniform,
    OUT gceUNIFORM_FLAGS * Flags
    )
{
    gcmHEADER_ARG("Uniform=0x%x Flags=0x%x", Uniform, Flags);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    if (Flags != gcvNULL)
    {
        /* Return uniform flags. */
        *Flags = GetUniformFlags(Uniform);
        gcmFOOTER_ARG("*Flags=%d", *Flags);
    }
    else
    {
        gcmFOOTER_NO();
    }

    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                              gcUNIFORM_SetFlags
********************************************************************************
**
**    Set the flags of a gcUNIFORM object.
**
**    INPUT:
**
**        gcUNIFORM Uniform
**            Pointer to a gcUNIFORM object.
**
**        gceUNIFORM_FLAGS Flags
**            Flags of the uniform to be set.
**
**    OUTPUT:
**            Nothing.
**
*/
gceSTATUS
gcUNIFORM_SetFlags(
    IN gcUNIFORM Uniform,
    IN gceUNIFORM_FLAGS Flags
    )
{
    gcmHEADER_ARG("Uniform=0x%x Flags=0x%x", Uniform, Flags);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    SetUniformFlags(Uniform, Flags);

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                              gcOUTPUT_SetLayoutQualifier
********************************************************************************
**
**    Set the layout qualifiers of a gcOUTPUT object.
**
**    INPUT:
**
**        gcOUTPUT Output
**            Pointer to a gcOUTPUT object.
**
**        gceLAYOUT_QUALIFIER LayoutQualifier
**            Layout qualifier of the output to be set.
**
**    OUTPUT:
**            Nothing.
**
*/
gceSTATUS
gcOUTPUT_SetLayoutQualifier(
    IN gcOUTPUT Output,
    IN gceLAYOUT_QUALIFIER LayoutQualifier
    )
{
    gcmHEADER_ARG("Output=0x%x LayoutQualifier=0x%x", Output, LayoutQualifier);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Output, gcvOBJ_OUTPUT);

    Output->layoutQualifier = LayoutQualifier;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                              gcOUTPUT_GetLayoutQualifier
********************************************************************************
**
**    Get the layout qualifiers of a gcOUTPUT object.
**
**    INPUT:
**
**        gcOUTPUT Output
**            Pointer to a gcOUTPUT object.
**
**    OUTPUT:
**        gceLAYOUT_QUALIFIER *LayoutQualifier
**            Pointer to a variable receiving the layout qualifier of the output.
**
*/
gceSTATUS
gcOUTPUT_GetLayoutQualifier(
    IN gcOUTPUT Output,
    OUT gceLAYOUT_QUALIFIER * LayoutQualifier
    )
{
    gcmHEADER_ARG("Output=0x%x", Output);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Output, gcvOBJ_OUTPUT);

    if (LayoutQualifier != gcvNULL)
    {
        /* Return layout qualifiers */
        *LayoutQualifier = Output->layoutQualifier;
        gcmFOOTER_ARG("*LayoutQualifier=%d", *LayoutQualifier);
    }
    else
    {
        gcmFOOTER_NO();
    }

    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcUNIFORM_GetName
**
**  Get the name of a gcUNIFORM object.
**
**  INPUT:
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**  OUTPUT:
**
**      gctUINT32 * Length
**          Pointer to a variable receiving the length of the uniform name.
**          'Length' can be gcvNULL, in which case no length will be returned.
**
**      gctCONST_STRING * Name
**          Pointer to a variable receiving the pointer to the uniform name.
**          'Name' can be gcvNULL, in which case no name will be returned.
*/
gceSTATUS
gcUNIFORM_GetName(
    IN gcUNIFORM Uniform,
    OUT gctUINT32 * Length,
    OUT gctCONST_STRING * Name
    )
{
    gcmHEADER_ARG("Uniform=0x%x Length=0x%x Name=0x%x", Uniform, Length, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    if (Length != gcvNULL)
    {
        /* Return length of name. */
        *Length = (gctUINT32) Uniform->nameLength;
    }

    if (Name != gcvNULL)
    {
        /* Return pointer to name. */
        *Name = Uniform->name;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcUNIFORM_BLOCK_GetName
**
**  Get the name of a gcsUNIFORM_BLOCK object.
**
**  INPUT:
**
**      gcsUNIFORM_BLOCK UniformBlock
**          Pointer to a gcsUNIFORM_BLOCK object.
**
**  OUTPUT:
**
**      gctUINT32 * Length
**          Pointer to a variable receiving the length of the uniform block name.
**          'Length' can be gcvNULL, in which case no length will be returned.
**
**      gctCONST_STRING * Name
**          Pointer to a variable receiving the pointer to the uniform block name.
**          'Name' can be gcvNULL, in which case no name will be returned.
*/
gceSTATUS
gcUNIFORM_BLOCK_GetName(
    IN gcsUNIFORM_BLOCK UniformBlock,
    OUT gctUINT32 * Length,
    OUT gctCONST_STRING * Name
    )
{
    gcmHEADER_ARG("UniformBlock=0x%x Length=0x%x Name=0x%x", UniformBlock, Length, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(UniformBlock, gcvOBJ_UNIFORM_BLOCK);

    if (Length != gcvNULL)
    {
        /* Return length of name. */
        *Length = UniformBlock->nameLength;
    }

    if (Name != gcvNULL)
    {
        /* Return pointer to name. */
        *Name = UniformBlock->name;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcUNIFORM_GetSampler
**
**  Get the physical sampler number for a sampler gcUNIFORM object.
**
**  INPUT:
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**  OUTPUT:
**
**      gctUINT32 * Sampler
**          Pointer to a variable receiving the physical sampler.
*/
gceSTATUS
gcUNIFORM_GetSampler(
    IN gcUNIFORM Uniform,
    OUT gctUINT32 * Sampler
    )
{
    gcmHEADER_ARG("Uniform=0x%x Sampler=0x%x", Uniform, Sampler);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    /* Make sure the uniform is a sampler. */

    if(gcmType_Kind(Uniform->u.type) != gceTK_SAMPLER)
    {
        gcmFOOTER_ARG("status=%d", gcvSTATUS_GLOBAL_TYPE_MISMATCH);
        return gcvSTATUS_GLOBAL_TYPE_MISMATCH;
    }

    if (Sampler != gcvNULL)
    {
        /* Return physical sampler. */
        if (GetUniformSamplerPhysical(Uniform) != -1)
        {
            *Sampler = GetUniformSamplerPhysical(Uniform);
        }
        else
        {
            *Sampler = GetUniformPhysical(Uniform);
        }
    }

    gcmFOOTER_ARG("*Sampler=%d", gcmOPT_VALUE(Sampler));

    /* Success. */
    return gcvSTATUS_OK;
}

gceSTATUS
gcUNIFORM_GetIndex(
    IN gcUNIFORM Uniform,
    OUT gctUINT16 * Index
    )
{
    gcmHEADER_ARG("Uniform=0x%x Index=0x%x", Uniform, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    if (Index != gcvNULL)
    {
        /* Return uniform index. */
        *Index = Uniform->index;
    }

    gcmFOOTER_NO();
    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcUNIFORM_GetFormat
**
**  Get the type and array length of a gcUNIFORM object.
**
**  INPUT:
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**  OUTPUT:
**
**      gcSL_FORMAT * Format
**          Pointer to a variable receiving the format of element of the uniform.
**          'Type' can be gcvNULL, in which case no type will be returned.
**
**      gctBOOL * IsPointer
**          Pointer to a variable receiving the state wheter the uniform is a pointer.
**          'IsPointer' can be gcvNULL, in which case no array length will be returned.
*/
gceSTATUS
gcUNIFORM_GetFormat(
    IN gcUNIFORM Uniform,
    OUT gcSL_FORMAT * Format,
    OUT gctBOOL * IsPointer
    )
{
    gcmHEADER_ARG("Uniform=0x%x Format=0x%x IsPointer=0x%x", Uniform, Format, IsPointer);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    if (Format != gcvNULL)
    {
        /* Return uniform format. */
        *Format = Uniform->format;
    }

    if (IsPointer != gcvNULL)
    {
        /* Return uniform pointer designation */
        *IsPointer = Uniform->isPointer;
        gcmFOOTER_ARG("*Format=%d *IsPointer=%d", Uniform->format, Uniform->isPointer);
    }
    else
    {
        gcmFOOTER_NO();
    }

    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcUNIFORM_SetFormat
**
**  Set the format and isPointer of a uniform.
**
**  INPUT:
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**      gcSL_FORMAT Format
**          Format of element of the uniform shaderType.
**
**      gctBOOL IsPointer
**          Wheter the uniform is a pointer.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcUNIFORM_SetFormat(
    IN gcUNIFORM Uniform,
    IN gcSL_FORMAT Format,
    IN gctBOOL IsPointer
    )
{
    gcmHEADER_ARG("Uniform=0x%x Format=%d IsPointer=%d",
                  Uniform, Format, IsPointer);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);

    Uniform->format = Format;
    Uniform->isPointer = IsPointer;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**                         gcUNIFORM_GetModelViewProjMatrix
********************************************************************************
**
**    Get the value of uniform modelViewProjMatrix ID if present.
**
**    INPUT:
**
**        gcUNIFORM Uniform
**            Pointer to a gcUNIFORM object.
**
**    OUTPUT:
**
**        Nothing.
*/
gctUINT
gcUNIFORM_GetModelViewProjMatrix(
    IN gcUNIFORM Uniform
    )
{
#if gcdNULL_DRIVER < 2
    gcmHEADER_ARG("Uniform=0x%x", Uniform);

    gcmFOOTER_NO();

    return Uniform->modelViewProjection;
#else
    return 0;
#endif
}

#if !MIN_COMPILER
/*******************************************************************************
**  gcUNIFORM_SetValue
**
**  Set the value of a uniform in integer.
**
**  INPUT:
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**      gctUINT32 Count
**          Number of entries to program if the uniform has been declared as an
**          array.
**
**      const gctINT * Value
**          Pointer to a buffer holding the integer values for the uniform.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcUNIFORM_SetValue(
    IN gcUNIFORM Uniform,
    IN gctUINT32 Count,
    IN const gctINT * Value
    )
{
#if gcdNULL_DRIVER < 2
    gceSTATUS status;
    gctUINT32 columns, rows;

    gcmHEADER_ARG("Uniform=0x%x Count=%lu Value=0x%x", Uniform, Count, Value);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);
    gcmDEBUG_VERIFY_ARGUMENT(Count > 0);
    gcmDEBUG_VERIFY_ARGUMENT(Value != gcvNULL);

    gcTYPE_GetTypeInfo(Uniform->u.type, &columns, &rows, 0);
    rows *= gcmMIN((gctINT) Count, Uniform->arraySize);

    /* Program the uniform. */
    status = gcoSHADER_ProgramUniform(gcvNULL,
                                      Uniform->address,
                                      columns, rows,
                                      (gctPOINTER) Value,
                                      gcvFALSE,
                                      gcvFALSE,
                                      Uniform->shaderKind);

    gcmFOOTER();
    return status;
#else
    return gcvSTATUS_OK;
#endif
}

gceSTATUS
gcUNIFORM_SetValue_Ex(
    IN gcUNIFORM Uniform,
    IN gctUINT32 Count,
    IN gcsHINT_PTR Hints,
    IN const gctINT * Value
    )
{
#if gcdNULL_DRIVER < 2
    gceSTATUS status;
    gctUINT32 columns, rows, physicalAddress;
    gctBOOL useFullNewLinker = gcUseFullNewLinker(gcHWCaps.hwFeatureFlags.hasHalti2);

    gcmHEADER_ARG("Uniform=0x%x Count=%lu Value=0x%x", Uniform, Count, Value);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);
    gcmDEBUG_VERIFY_ARGUMENT(Count > 0);
    gcmDEBUG_VERIFY_ARGUMENT(Value != gcvNULL);

    gcTYPE_GetTypeInfo(Uniform->u.type, &columns, &rows, 0);
    rows *= gcmMIN((gctINT) Count,
                   useFullNewLinker ? Uniform->usedArraySize : Uniform->arraySize);

    physicalAddress = Uniform->address;
    if (useFullNewLinker)
    {
        gcSHADER_ComputeUniformPhysicalAddress(Hints->hwConstRegBases,
                                               Uniform,
                                               &physicalAddress);
    }

    /* Program the uniform. */
    status = gcoSHADER_ProgramUniform(gcvNULL,
                                      physicalAddress,
                                      columns, rows,
                                      (gctPOINTER) Value,
                                      gcvFALSE,
                                      gcvFALSE,
                                      Uniform->shaderKind);

    gcmFOOTER();
    return status;
#else
    return gcvSTATUS_OK;
#endif
}

/*******************************************************************************
**  gcUNIFORM_SetValueF
**
**  Set the value of a uniform in floating point.
**
**  INPUT:
**
**      gcUNIFORM Uniform
**          Pointer to a gcUNIFORM object.
**
**      gctUINT32 Count
**          Number of entries to program if the uniform has been declared as an
**          array.
**
**      const gctFLOAT * Value
**          Pointer to a buffer holding the floating point values for the
**          uniform.
**
**  OUTPUT:
**
**      Nothing.
*/
gceSTATUS
gcUNIFORM_SetValueF(
    IN gcUNIFORM Uniform,
    IN gctUINT32 Count,
    IN const gctFLOAT * Value
    )
{
#if gcdNULL_DRIVER < 2
    gceSTATUS status;
    gctUINT32 columns, rows;

    gcmHEADER_ARG("Uniform=0x%x Count=%lu Value=0x%x", Uniform, Count, Value);

    /* Verify the argiments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);
    gcmDEBUG_VERIFY_ARGUMENT(Count > 0);
    gcmDEBUG_VERIFY_ARGUMENT(Value != gcvNULL);

    gcTYPE_GetTypeInfo(Uniform->u.type, &columns, &rows, 0);
    rows *= gcmMIN((gctINT) Count, Uniform->arraySize);

    /* Program the uniform. */
    status = gcoSHADER_ProgramUniform(gcvNULL,
                                      Uniform->address,
                                      columns, rows,
                                      (gctPOINTER) Value,
                                      gcvFALSE,
                                      gcvFALSE,
                                      Uniform->shaderKind);

    gcmFOOTER();
    return status;
#else
    return gcvSTATUS_OK;
#endif
}

gceSTATUS
gcUNIFORM_SetValueF_Ex(
    IN gcUNIFORM Uniform,
    IN gctUINT32 Count,
    IN gcsHINT_PTR Hints,
    IN const gctFLOAT * Value
    )
{
#if gcdNULL_DRIVER < 2
    gceSTATUS status;
    gctUINT32 columns, rows, physicalAddress;
    gctBOOL useFullNewLinker = gcUseFullNewLinker(gcHWCaps.hwFeatureFlags.hasHalti2);

    gcmHEADER_ARG("Uniform=0x%x Count=%lu Value=0x%x", Uniform, Count, Value);

    /* Verify the argiments. */
    gcmVERIFY_OBJECT(Uniform, gcvOBJ_UNIFORM);
    gcmDEBUG_VERIFY_ARGUMENT(Count > 0);
    gcmDEBUG_VERIFY_ARGUMENT(Value != gcvNULL);

    gcTYPE_GetTypeInfo(Uniform->u.type, &columns, &rows, 0);
    rows *= gcmMIN((gctINT) Count,
                   useFullNewLinker ? Uniform->usedArraySize : Uniform->arraySize);

    physicalAddress = Uniform->address;
    if (useFullNewLinker)
    {
        gcSHADER_ComputeUniformPhysicalAddress(Hints->hwConstRegBases,
                                               Uniform,
                                               &physicalAddress);
    }

    /* Program the uniform. */
    status = gcoSHADER_ProgramUniform(gcvNULL,
                                      physicalAddress,
                                      columns, rows,
                                      (gctPOINTER) Value,
                                      gcvFALSE,
                                      gcvFALSE,
                                      Uniform->shaderKind);

    gcmFOOTER();
    return status;
#else
    return gcvSTATUS_OK;
#endif
}
#endif /* MIN_COMPILER */

/*******************************************************************************
**  gcOUTPUT_GetType
**
**  Get the type and array length of a gcOUTPUT object.
**
**  INPUT:
**
**      gcOUTPUT Output
**          Pointer to a gcOUTPUT object.
**
**  OUTPUT:
**
**      gcSHADER_TYPE * Type
**          Pointer to a variable receiving the type of the output.  'Type' can
**          be gcvNULL, in which case no type will be returned.
**
**      gctUINT32 * ArrayLength
**          Pointer to a variable receiving the length of the array if the
**          output was declared as an array.  If the output was not declared
**          as an array, the array length will be 1.  'ArrayLength' can be gcvNULL,
**          in which case no array length will be returned.
*/
gceSTATUS
gcOUTPUT_GetType(
    IN gcOUTPUT Output,
    OUT gcSHADER_TYPE * Type,
    OUT gctUINT32 * ArrayLength
    )
{
    gcmHEADER_ARG("Output=0x%x", Output);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Output, gcvOBJ_OUTPUT);

    if (Type != gcvNULL)
    {
        /* Return output type. */
        *Type = Output->type;
        gcmFOOTER_ARG("*Type=%d", gcmOPT_VALUE(Type));
    }
    else
    {
        gcmFOOTER_NO();
    }

    if (ArrayLength != gcvNULL)
    {
        /* Return output array length. */
        *ArrayLength = Output->arraySize;
        gcmFOOTER_ARG("*ArrayLength=%lu", gcmOPT_VALUE(ArrayLength));
    }
    else
    {
        gcmFOOTER_NO();
    }

    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcOUTPUT_GetIndex
**
**  Get the index of a gcOUTPUT object.
**
**  INPUT:
**
**      gcOUTPUT Output
**          Pointer to a gcOUTPUT object.
**
**  OUTPUT:
**
**      gctUINT * Index
**          Pointer to a variable receiving the temporary register index of the
**          output.  'Index' can be gcvNULL,. in which case no index will be
**          returned.
*/
gceSTATUS
gcOUTPUT_GetIndex(
    IN gcOUTPUT Output,
    OUT gctUINT * Index
    )
{
    gcmHEADER_ARG("Output=0x%x", Output);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Output, gcvOBJ_OUTPUT);

    if (Index != gcvNULL)
    {
        /* Return output temporary register index. */
        *Index = Output->tempIndex;
    }

    gcmFOOTER_ARG("*Index=%u", gcmOPT_VALUE(Index));
    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcOUTPUT_GetName
**
**  Get the name of a gcOUTPUT object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcOUTPUT Output
**          Pointer to a gcOUTPUT object.
**
**        gctBOOL UseInstanceName
**            Use instance name for a block member..
**
**
**  OUTPUT:
**
**      gctUINT32 * Length
**          Pointer to a variable receiving the length of the output name.
**          'Length' can be gcvNULL, in which case no length will be returned.
**
**      gctCONST_STRING * Name
**          Pointer to a variable receiving the pointer to the output name.
**          'Name' can be gcvNULL, in which case no name will be returned.
*/
gceSTATUS
gcOUTPUT_GetName(
    IN gcSHADER Shader,
    IN gcOUTPUT Output,
    IN gctBOOL UseInstanceName,
    OUT gctUINT32 * Length,
    OUT gctCONST_STRING * Name
    )
{
    gctUINT32 length;
    gctCONST_STRING name;

    gcmHEADER_ARG("Shader=0x%x Output=0x%x Length=0x%x Name=0x%x", Shader, Output, Length, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Output, gcvOBJ_OUTPUT);

    /* Convert predefined names into ASCII. */
    name = _PredefinedName(Shader, Output->nameLength, UseInstanceName);

    if (name == gcvNULL)
    {
        /* Not a predefined name. */
        length = Output->nameLength;
        name   = Output->name;
    }
    else
    {
        /* Compute length of predefined name. */
        length = gcoOS_StrLen(name, gcvNULL);
    }

    if (Length != gcvNULL)
    {
        /* Return length of name. */
        *Length = length;
    }

    if (Name != gcvNULL)
    {
        /* Return pointer to name. */
        *Name = name;
    }

    /* Success. */
    gcmFOOTER_ARG("*Length=%lu *Name=0x%x",
                  gcmOPT_VALUE(Length), gcmOPT_POINTER(Name));
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcOUTPUT_GetNameEx
**
**  Get the name of a gcOUTPUT object.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gcOUTPUT Output
**          Pointer to a gcOUTPUT object.
**
**
**  OUTPUT:
**
**      gctUINT32 * Length
**          Pointer to a variable receiving the length of the output name.
**          'Length' can be gcvNULL, in which case no length will be returned.
**
**      gctSTRING * Name
**          Pointer to a variable receiving the pointer to the output name
**          stored in an allocated buffer through gcoOS_Allocate(). It is the
**          responsibility of the caller to free the buffer.
**          'Name' can be gcvNULL, in which case no name will be returned.
*/
gceSTATUS
gcOUTPUT_GetNameEx(
    IN gcSHADER Shader,
    IN gcOUTPUT Output,
    OUT gctUINT32 * Length,
    OUT gctSTRING * Name
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctUINT32 length, fieldLength, arrayLength = 0;
    gctCONST_STRING name;
    gctSTRING retName = gcvNULL, indexName = gcvNULL;
    gcsIO_BLOCK ioBlock = gcvNULL;
    gctPOINTER pointer = gcvNULL;
    gctBOOL changeInstanceName = gcvFALSE;

    gcmHEADER_ARG("Shader=0x%x Output=0x%x Length=0x%x Name=0x%x", Shader, Output, Length, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Output, gcvOBJ_OUTPUT);

    gcOUTPUT_GetName(Shader, Output, gcvFALSE, &length, &name);

    if (GetOutputIOBlockIndex(Output) != -1)
    {
        gcmONERROR(gcSHADER_GetIoBlock(Shader, (gctUINT32)GetOutputIOBlockIndex(Output), &ioBlock));

        if (GetSBInstanceNameLength(ioBlock) > 0)
        {
            /* Check if it is an array element. */
            if (gcoOS_StrStr(name, "[", &indexName) &&
                (name + GetSBInstanceNameLength(ioBlock) == indexName))
            {
                arrayLength = 3;
            }
            fieldLength = length - 1 - GetSBInstanceNameLength(ioBlock) - arrayLength;
            length = GetSBNameLength(ioBlock) + 1 + fieldLength;
            if(Name != NULL)
            {
                gcmONERROR(gcoOS_Allocate(gcvNULL, length + 1, &pointer));
                retName = (gctSTRING)pointer;
                /* Copy the Block name. */
                gcoOS_MemCopy(retName, GetSBName(ioBlock), GetSBNameLength(ioBlock) + 1);
                /* Copy the filed name. */
                retName += (GetSBNameLength(ioBlock) + 1);
                gcoOS_MemCopy(retName, name + GetSBInstanceNameLength(ioBlock) + 1 + arrayLength, fieldLength);
                retName[fieldLength] = '\0';
                /* Point to the first char. */
                retName = (gctSTRING)pointer;
                changeInstanceName = gcvTRUE;
            }
        }
    }

    if (Length != gcvNULL)
    {
        /* Return length of name. */
        *Length = length;
    }

    if (Name != gcvNULL)
    {
        if (!changeInstanceName)
        {
            gcmONERROR(gcoOS_Allocate(gcvNULL, length + 1, &pointer));
            gcoOS_MemCopy(pointer, name, length + 1);
            retName = (gctSTRING)pointer;
        }

        /* Return pointer to name. */
        *Name = retName;
    }

    /* Success. */
OnError:
    gcmFOOTER_ARG("*Length=%lu *Name=0x%x",
                  gcmOPT_VALUE(Length), gcmOPT_POINTER(Name));
    return status;
}

/*******************************************************************************
**  gcOUTPUT_GetLocation
**
**  Get the Location of a gcOUTPUT object.
**
**  INPUT:
**
**      gcOUTPUT Output
**          Pointer to a gcOUTPUT object.
**
**  OUTPUT:
**
**      gctUINT * Location
**          Pointer to a variable receiving the Location of the
**          output.
*/
gceSTATUS
gcOUTPUT_GetLocation(
    IN gcOUTPUT Output,
    OUT gctUINT * Location
    )
{
    gcmHEADER_ARG("Output=0x%x", Output);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Output, gcvOBJ_OUTPUT);

    if (Location != gcvNULL)
    {
        /* Return output location */
        *Location = Output->location;
    }

    gcmFOOTER_ARG("*Location=%u", gcmOPT_VALUE(Location));
    /* Success. */
    return gcvSTATUS_OK;
}



/*******************************************************************************
*********************************************************** F U N C T I O N S **
*******************************************************************************/

/*******************************************************************************
**  gcSHADER_ReallocateFunctions
**
**  Reallocate an array of pointers to gcFUNCTION objects.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcSHADER_ReallocateFunctions(
    IN gcSHADER Shader,
    IN gctUINT32 Count
    )
{
    gcFUNCTION * functions;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Count=%lu", Shader, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Count < Shader->functionCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Shader->functionArraySize)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcFUNCTION) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    functions = pointer;

    if (Shader->functions != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(functions,
                      Shader->functions,
                      gcmSIZEOF(gcFUNCTION)
                      * Shader->functionCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->functions));
    }

    /* Set new gcFUNCTION object pointer. */
    Shader->functionArraySize = Count;
    Shader->functions          = functions;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

/*******************************************************************************
*********************************************K E R N E L    F U N C T I O N S **
*******************************************************************************/

/*******************************************************************************
**  gcSHADER_ReallocateKernelFunctions
**
**  Reallocate an array of pointers to gcKERNEL_FUNCTION objects.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcSHADER_ReallocateKernelFunctions(
    IN gcSHADER Shader,
    IN gctUINT32 Count
    )
{
    gcKERNEL_FUNCTION * kernelFunctions;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Count=%lu", Shader, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    if (Count < Shader->kernelFunctionCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Shader->kernelFunctionArraySize)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcKERNEL_FUNCTION) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    kernelFunctions = pointer;

    if (Shader->kernelFunctions != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(kernelFunctions,
                      Shader->kernelFunctions,
                      gcmSIZEOF(gcKERNEL_FUNCTION)
                      * Shader->kernelFunctionCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->kernelFunctions));
    }

    /* Set new gcFUNCTION object pointer. */
    Shader->kernelFunctionArraySize = Count;
    Shader->kernelFunctions          = kernelFunctions;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

gceSTATUS
gcSHADER_AddFunction(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    OUT gcFUNCTION * Function
    )
{
    gceSTATUS status;
    gctUINT32 length = 0;
    gctUINT32 bytes;
    gcFUNCTION function = gcvNULL;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Name=%s", Shader, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Name != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(Function != gcvNULL);

    /* Check array count. */
    if (Shader->functionArraySize <= Shader->functionCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateFunctions(Shader, Shader->functionCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Get the length of the name. */
    length = gcoOS_StrLen(Name, gcvNULL);

    /* Compute the number of bytes required for the gcFUNCTION object. */
    bytes = gcmOFFSETOF(_gcsFUNCTION, name) + length + 1;

    /* Allocate the gcFUNCTION object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    gcoOS_ZeroMemory(pointer, bytes);
    function = pointer;

    /* Initialize the gcFUNCTION object. */
    function->object.type        = gcvOBJ_FUNCTION;

    function->intrinsicsKind     = gceINTRIN_NONE;

    function->argumentArrayCount = 0;
    function->argumentCount      = 0;
    function->packedAwayArgNo    = 0;
    function->arguments          = gcvNULL;

    function->localVariableCount      = 0;
    function->localVariables          = gcvNULL;

    function->tempIndexStart          = Shader->_tempRegCount;
    function->tempIndexCount          = 0;

    function->label              = (gctUINT32) (~0 - Shader->kernelFunctionCount - Shader->functionCount);
    function->flags              = gcvFUNC_NOATTR;

    function->codeStart          = 0;
    function->codeCount          = 0;
    function->isRecursion        = gcvFALSE;

    /* Copy the function name. */
    function->nameLength         = length;
    gcoOS_MemCopy(function->name, Name, length + 1);

    function->die = VSC_DI_INVALIDE_DIE;

    /* Set new gcFUNCTION object pointer. */
    Shader->functions[Shader->functionCount++] = function;

    /* Return the gcFUNCTION object pointer. */
    *Function = function;

    /* Success. */
    gcmFOOTER_ARG("*Function=0x%x", *Function);
    return gcvSTATUS_OK;
}

gceSTATUS
gcSHADER_DeleteFunction(
    IN gcSHADER Shader,
    IN gcFUNCTION Function
    )
{
    gceSTATUS   status = gcvSTATUS_OK;
    gctUINT32   funcIndex = 0;
    gctINT32    i = 0;

    gcmHEADER_ARG("Shader=0x%x Function=0x%d", Shader, Function);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Function != gcvNULL);

    for (funcIndex = 0; funcIndex < Shader->functionCount; funcIndex++)
    {
        if (Shader->functions[funcIndex] &&
            Function == Shader->functions[funcIndex])
        {
            break;
        }
    }

    if (funcIndex == Shader->functionCount)
    {
        gcmFOOTER();
        return gcvSTATUS_NOT_FOUND;
    }

    /* Free this function. */
    if (Function->arguments != gcvNULL)
    {
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Function->arguments));
    }
    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Function));
    Shader->functions[funcIndex] = gcvNULL;

    for (i = (gctINT32)funcIndex; i < (gctINT32)(Shader->functionCount - 1); i++)
    {
        Shader->functions[i] = Shader->functions[i + 1];
    }
    Shader->functions[Shader->functionCount - 1] = gcvNULL;

    Shader->functionCount--;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_AddKernelFunction(
    IN gcSHADER Shader,
    IN gctCONST_STRING Name,
    OUT gcKERNEL_FUNCTION * KernelFunction
    )
{
    gceSTATUS status;
    gctUINT32 length = 0;
    gctUINT32 bytes;
    gcKERNEL_FUNCTION kernelFunction = gcvNULL;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Shader=0x%x Name=%s", Shader, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Name != gcvNULL);
    gcmDEBUG_VERIFY_ARGUMENT(KernelFunction != gcvNULL);

    /* Check array count. */
    if (Shader->kernelFunctionArraySize <= Shader->kernelFunctionCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcSHADER_ReallocateKernelFunctions(Shader, Shader->kernelFunctionCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Get the length of the name. */
    length = gcoOS_StrLen(Name, gcvNULL);

    /* Compute the number of bytes required for the gcKERNEL_FUNCTION object. */
    bytes = gcmOFFSETOF(_gcsKERNEL_FUNCTION, name) + length + 1;

    /* Allocate the gcKERNEL_FUNCTION object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    gcoOS_ZeroMemory(pointer, bytes);
    kernelFunction = pointer;

    /* Initialize the gcKERNEL_FUNCTION object. */
    kernelFunction->object.type = gcvOBJ_KERNEL_FUNCTION;

    kernelFunction->shader = Shader;

    kernelFunction->argumentArrayCount = 0;
    kernelFunction->argumentCount      = 0;
    kernelFunction->arguments          = gcvNULL;
    kernelFunction->localVariableCount      = 0;
    kernelFunction->localVariables          = gcvNULL;
    kernelFunction->tempIndexStart          = Shader->_tempRegCount;
    kernelFunction->tempIndexCount          = 0;

    kernelFunction->localMemorySize = 0;

    /* Uniform args to kernel function */
    kernelFunction->uniformArgumentArrayCount = 0;
    kernelFunction->uniformArgumentCount      = 0;
    kernelFunction->uniformArguments          = gcvNULL;
    kernelFunction->samplerIndex = 0;

    /* Image-Sampler associations */
    kernelFunction->imageSamplerArrayCount = 0;
    kernelFunction->imageSamplerCount      = 0;
    kernelFunction->imageSamplers          = gcvNULL;

    /*kernel function property */
    kernelFunction->propertyArrayCount = 0;
    kernelFunction->propertyCount      = 0;
    kernelFunction->properties         = gcvNULL;
    kernelFunction->propertyValueArrayCount = 0;
    kernelFunction->propertyValueCount      = 0;
    kernelFunction->propertyValues          = gcvNULL;

    kernelFunction->label              = (gctUINT32) (~0 - Shader->kernelFunctionCount - Shader->functionCount);
    kernelFunction->flags              = gcvFUNC_NOATTR;
    kernelFunction->codeStart = 0;
    kernelFunction->codeCount = 0;
    kernelFunction->codeEnd   = 0;

    kernelFunction->isCalledByEntryKernel    = gcvFALSE;
    kernelFunction->isMain    = gcvFALSE;
    kernelFunction->die       = VSC_DI_INVALIDE_DIE;

    /* Copy the function name. */
    kernelFunction->nameLength         = length;
    gcoOS_MemCopy(kernelFunction->name, Name, length + 1);

    /* Set new gcFUNCTION object pointer. */
    Shader->kernelFunctions[Shader->kernelFunctionCount++] = kernelFunction;

    /* Return the gcFUNCTION object pointer. */
    *KernelFunction = kernelFunction;

    /* Success. */
    gcmFOOTER_ARG("*KernelFunction=0x%x", *KernelFunction);
    return gcvSTATUS_OK;
}

gceSTATUS
gcSHADER_BeginFunction(
    IN gcSHADER Shader,
    IN gcFUNCTION Function
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x Function=0x%x", Shader, Function);

    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(Function, gcvOBJ_FUNCTION);

    Shader->currentFunction = Function;

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        Shader->instrIndex       = gcSHADER_OPCODE;
        Shader->lastInstruction += 1;
    }

    Function->codeStart = Shader->lastInstruction;

    status = gcSHADER_AddLabel(Shader, Function->label);

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_EndFunction(
    IN gcSHADER Shader,
    IN gcFUNCTION Function
    )
{
    gcmHEADER_ARG("Shader=0x%x Function=0x%x", Shader, Function);

    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(Function, gcvOBJ_FUNCTION);
    gcmDEBUG_VERIFY_ARGUMENT(Shader->currentFunction == Function);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        Shader->instrIndex       = gcSHADER_OPCODE;
        Shader->lastInstruction += 1;
    }

    gcmASSERT(Shader->_tempRegCount >= Function->tempIndexStart);
    Function->tempIndexCount = Shader->_tempRegCount - Function->tempIndexStart;
    Function->codeCount = Shader->lastInstruction - Function->codeStart;

    Shader->currentFunction = gcvNULL;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
gcSHADER_BeginKernelFunction(
    IN gcSHADER Shader,
    IN gcKERNEL_FUNCTION KernelFunction
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Shader=0x%x KernelFunction=0x%x", Shader, KernelFunction);

    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);

    Shader->currentKernelFunction = KernelFunction;

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        Shader->instrIndex       = gcSHADER_OPCODE;
        Shader->lastInstruction += 1;
    }

    KernelFunction->codeStart = Shader->lastInstruction;

    status = gcSHADER_AddLabel(Shader, KernelFunction->label);

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_EndKernelFunction(
    IN gcSHADER Shader,
    IN gcKERNEL_FUNCTION KernelFunction,
    IN gctUINT32 LocalMemorySize
    )
{
    gcmHEADER_ARG("Shader=0x%x KernelFunction=0x%x LocalMemorySize=%u",
                  Shader, KernelFunction, LocalMemorySize);

    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);
    gcmDEBUG_VERIFY_ARGUMENT(Shader->currentKernelFunction == KernelFunction);

    if (Shader->instrIndex != gcSHADER_OPCODE)
    {
        Shader->instrIndex       = gcSHADER_OPCODE;
        Shader->lastInstruction += 1;
    }

    gcmASSERT(Shader->_tempRegCount >= KernelFunction->tempIndexStart);
    KernelFunction->tempIndexCount =
        Shader->_tempRegCount - KernelFunction->tempIndexStart;

    KernelFunction->codeCount = Shader->lastInstruction - KernelFunction->codeStart;
    KernelFunction->localMemorySize = LocalMemorySize;

    Shader->currentKernelFunction = gcvNULL;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcFUNCTION_ReallocateArguments
**
**  Reallocate an array of gcsFUNCTION_ARGUMENT objects.
**
**  INPUT:
**
**      gcFUNCTION Function
**          Pointer to a gcFUNCTION object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcFUNCTION_ReallocateArguments(
    IN gcFUNCTION Function,
    IN gctUINT32 Count
    )
{
    gcsFUNCTION_ARGUMENT_PTR arguments;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Function=0x%x Count=%lu", Function, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Function, gcvOBJ_FUNCTION);

    if (Count < Function->argumentCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Function->argumentArrayCount)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsFUNCTION_ARGUMENT) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    arguments = pointer;

    if (Function->arguments != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(arguments,
                                   Function->arguments,
                                   gcmSIZEOF(gcsFUNCTION_ARGUMENT)
                   * Function->argumentCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Function->arguments));
    }

    /* Set new gcFUNCTION object pointer. */
    Function->argumentArrayCount = Count;
    Function->arguments          = arguments;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

gceSTATUS
gcFUNCTION_AddArgument(
    IN gcFUNCTION Function,
    IN gctUINT16 VariableIndex,
    IN gctUINT32 TempIndex,
    IN gctUINT8 Enable,
    IN gctUINT8 Qualifier,
    IN gctUINT8 Precision,
    IN gctBOOL IsPrecise
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Function=0x%x TempIndex=%u Enable=%u Qualifier=%u",
                  Function, TempIndex, Enable, Qualifier);

    gcmVERIFY_OBJECT(Function, gcvOBJ_FUNCTION);

    if (Function->argumentArrayCount <= Function->argumentCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcFUNCTION_ReallocateArguments(Function, Function->argumentCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    Function->arguments[Function->argumentCount].index     = TempIndex;
    Function->arguments[Function->argumentCount].enable    = Enable;
    Function->arguments[Function->argumentCount].qualifier = Qualifier;
    Function->arguments[Function->argumentCount].precision = Precision;
    Function->arguments[Function->argumentCount].variableIndex = VariableIndex;
    Function->arguments[Function->argumentCount].flags = gceFUNCTION_ARGUMENT_FLAG_NONE;
    if(IsPrecise)
    {
        Function->arguments[Function->argumentCount].flags |= gceFUNCTION_ARGUMENT_FLAG_IS_PRECISE;
    }

    Function->argumentCount++;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
gcFUNCTION_GetArgument(
    IN gcFUNCTION Function,
    IN gctUINT32 Index,
    OUT gctUINT32_PTR Temp,
    OUT gctUINT8_PTR Enable,
    OUT gctUINT8_PTR Swizzle
    )
{
    gcmHEADER_ARG("Function=0x%x Index=%u", Function, Index);

    gcmVERIFY_OBJECT(Function, gcvOBJ_FUNCTION);

    if (Index >= Function->argumentCount)
    {
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Temp != gcvNULL)
    {
        *Temp = Function->arguments[Index].index;
    }

    if (Enable != gcvNULL)
    {
        *Enable = Function->arguments[Index].enable;
    }

    if (Swizzle != gcvNULL)
    {
        switch (Function->arguments[Index].enable)
        {
        case 0x1: *Swizzle = gcSL_SWIZZLE_XXXX; break;
        case 0x2: *Swizzle = gcSL_SWIZZLE_YYYY; break;
        case 0x4: *Swizzle = gcSL_SWIZZLE_ZZZZ; break;
        case 0x8: *Swizzle = gcSL_SWIZZLE_WWWW; break;
        case 0x3: *Swizzle = gcSL_SWIZZLE_XYYY; break;
        case 0x6: *Swizzle = gcSL_SWIZZLE_YZZZ; break;
        case 0xC: *Swizzle = gcSL_SWIZZLE_ZWWW; break;
        case 0x7: *Swizzle = gcSL_SWIZZLE_XYZZ; break;
        case 0xE: *Swizzle = gcSL_SWIZZLE_YZWW; break;
        case 0xF: *Swizzle = gcSL_SWIZZLE_XYZW; break;
        default:  gcmFATAL("Oops!");
        }
    }

    if ((Temp != gcvNULL) && (Enable != gcvNULL) && (Swizzle != gcvNULL))
    {
        gcmFOOTER_ARG("*Temp=%u *Enable=%u *Swizzle=%u",
                      gcmOPT_VALUE(Temp), gcmOPT_VALUE(Enable),
                      gcmOPT_VALUE(Swizzle));
    }
    else
    {
        gcmFOOTER_NO();
    }
    return gcvSTATUS_OK;
}

gceSTATUS
gcFUNCTION_GetLabel(
    IN gcFUNCTION Function,
    OUT gctUINT_PTR Label
    )
{
    gcmHEADER_ARG("Function=0x%x", Function);

    gcmVERIFY_OBJECT(Function, gcvOBJ_FUNCTION);
    gcmDEBUG_VERIFY_ARGUMENT(Label != gcvNULL);

    *Label = Function->label;

    gcmFOOTER_ARG("*Label=%u", *Label);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcKERNEL_FUNCTION_GetName
**
**  Get the name of a gcKERNEL_FUNCTION object.
**
**  INPUT:
**
**      gcKERNEL_FUNCTION KernelFunction
**          Pointer to a gcKERNEL_FUNCTION object.
**
**  OUTPUT:
**
**      gctUINT32 * Length
**          Pointer to a variable receiving the length of the kernel function name.
**          'Length' can be gcvNULL, in which case no length will be returned.
**
**      gctCONST_STRING * Name
**          Pointer to a variable receiving the pointer to the kernel function name.
**          'Name' can be gcvNULL, in which case no name will be returned.
*/
gceSTATUS
gcKERNEL_FUNCTION_GetName(
    IN gcKERNEL_FUNCTION KernelFunction,
    OUT gctUINT32 * Length,
    OUT gctCONST_STRING * Name
    )
{
    gcmHEADER_ARG("KernelFunction=0x%x Length=0x%x Name=0x%x", KernelFunction, Length, Name);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);

    if (Length != gcvNULL)
    {
        /* Return length of name. */
        *Length = KernelFunction->nameLength;
    }

    if (Name != gcvNULL)
    {
        /* Return pointer to name. */
        *Name = KernelFunction->name;
    }

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcKERNEL_FUNCTION_ReallocateUniformArguments
**
**  Reallocate an array of pointers to gcUNIFORM objects.
**
**  INPUT:
**
**      gcKERNEL_FUNCTION KernelFunction
**          Pointer to a gcKERNEL_FUNCTION object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcKERNEL_FUNCTION_ReallocateUniformArguments(
    IN gcKERNEL_FUNCTION KernelFunction,
    IN gctUINT32 Count
    )
{
    gcUNIFORM * uniformArguments;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("KernelFunction=0x%x Count=%lu", KernelFunction, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);

    if (Count < KernelFunction->uniformArgumentCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == KernelFunction->uniformArgumentArrayCount)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcUNIFORM) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    uniformArguments = pointer;

    if (KernelFunction->uniformArguments != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(uniformArguments,
                                   KernelFunction->uniformArguments,
                                   gcmSIZEOF(gcUNIFORM)
                      * KernelFunction->uniformArgumentCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, KernelFunction->uniformArguments));
    }

    /* Set new gcUNIFORM object pointer. */
    KernelFunction->uniformArgumentArrayCount = Count;
    KernelFunction->uniformArguments          = uniformArguments;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcKERNEL_FUNCTION_AddUniformArgument
**
**  Add an uniform arugment to a gcKERNEL_FUNCTION object.
**
**  INPUT:
**
**      gcKERNEL_FUNCTION KernelFunction
**          Pointer to a gcKERNEL_FUNCTION object.
**
**      gctCONST_STRING Name
**          Name of the uniform to add.
**
**      gcSHADER_TYPE Type
**          Type of the uniform to add.
**
**      gctUINT32 Length
**          Array length of the uniform to add.  'Length' must be at least 1.
**
**  OUTPUT:
**
**      gcUNIFORM * UniformArgument
**          Pointer to a variable receiving the gcUNIFORM object pointer.
*/
gceSTATUS
gcKERNEL_FUNCTION_AddUniformArgument(
    IN gcKERNEL_FUNCTION KernelFunction,
    IN gctCONST_STRING Name,
    IN gcSHADER_TYPE Type,
    IN gctUINT32 Length,
    OUT gcUNIFORM * UniformArgument
    )
{
    gctUINT32 nameLength=0, bytes;
    gcUNIFORM uniformArgument;
    gceSTATUS status;
    gctPOINTER pointer;

    gcmHEADER_ARG("KernelFunction=0x%x Name=%s Type=%d Length=%lu",
                  KernelFunction, Name, Type, Length);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);

    /* Check array count. */
    if (KernelFunction->uniformArgumentArrayCount <= KernelFunction->uniformArgumentCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcKERNEL_FUNCTION_ReallocateUniformArguments(KernelFunction,
                                                              KernelFunction->uniformArgumentCount + 10);
        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    /* Get the length of the name. */
    nameLength = gcoOS_StrLen(Name, gcvNULL);

    /* Compute the number of bytes required for the gcUNIFORM object. */
    bytes = gcmOFFSETOF(_gcUNIFORM, name) + nameLength + 1;

    /* Allocate the gcUNIFORM object. */
    status = gcoOS_Allocate(gcvNULL, bytes, &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    uniformArgument = pointer;

    /* Clear the memory in case some union member was partially written */
    gcoOS_ZeroMemory(uniformArgument, bytes);

    /* Initialize the gcUNIFORM object. */
    uniformArgument->object.type  = gcvOBJ_UNIFORM;

    uniformArgument->index        = (gctUINT16) KernelFunction->uniformArgumentCount;
    SetUniformCategory(uniformArgument, gcSHADER_VAR_CATEGORY_NORMAL);
    uniformArgument->firstChild = -1;
    uniformArgument->nextSibling = -1;
    uniformArgument->prevSibling = -1;
    uniformArgument->parent = -1;
    uniformArgument->u.type      = Type;
    uniformArgument->arraySize    = Length;
    uniformArgument->modelViewProjection = 0;
    uniformArgument->format       = gcSL_FLOAT;
    SetUniformVectorSize(uniformArgument, 0);
    SetUniformTypeNameOffset(uniformArgument, -1);
    uniformArgument->isPointer    = gcvFALSE;
    uniformArgument->nameLength   = nameLength;
    uniformArgument->physical     = -1;
    uniformArgument->address      = ~0U;
    SetUniformFlags(uniformArgument, 0);
    uniformArgument->glUniformIndex = -1;
    if (uniformArgument->arraySize > 1)
    {
        SetUniformFlags(uniformArgument, gcvUNIFORM_FLAG_IS_ARRAY);
    }
    {
        uniformArgument->arrayLengthCount = 0;
        uniformArgument->arrayLengthList = gcvNULL;
    }
    /* Halti fields */
    uniformArgument->blockIndex   = -1;
    uniformArgument->arrayStride = -1;
    uniformArgument->matrixStride = -1;
    uniformArgument->isRowMajor = 0;
    uniformArgument->offset = -1;

    if(gcmType_Kind(Type) == gceTK_SAMPLER)
    {
        uniformArgument->physical = KernelFunction->shader->samplerIndex + KernelFunction->samplerIndex++;
    }

    /* Copy the uniform name. */
    gcoOS_MemCopy(uniformArgument->name, Name, nameLength + 1);

    /* Set new gcUNIFORM object pointer. */
    KernelFunction->uniformArguments[KernelFunction->uniformArgumentCount++] = uniformArgument;

    if (UniformArgument != gcvNULL)
    {
        /* Return the gcUNIFORM object pointer. */
        *UniformArgument = uniformArgument;
        gcmFOOTER_ARG("*UniformArgument=0x%x", *UniformArgument);
    }
    else
    {
        gcmFOOTER_NO();
    }

    /* Success. */
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcKERNEL_FUNCTION_GetUniformArgumentCount
**
**  Get the number of uniform arguments for this kernel function.
**
**  INPUT:
**
**      gcKERNEL_FUNCTION KernelFunction
**          Pointer to a gcKERNEL_FUNCTION object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of uniform arguments.
*/
gceSTATUS
gcKERNEL_FUNCTION_GetUniformArgumentCount(
    IN gcKERNEL_FUNCTION KernelFunction,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("KernelFunction=0x%x", KernelFunction);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    /* Return uniform count. */
    *Count = KernelFunction->uniformArgumentCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcKERNEL_FUNCTION_GetUniformArgument
**
**  Get the gcUNIFORM object pointer for an indexed uniform for this kernel function.
**
**  INPUT:
**
**      gcKERNEL_FUNCTION KernelFunction
**          Pointer to a gcKERNEL_FUNCTION object.
**
**      gctUINT Index
**          Index of uniform to retreive the name for.
**
**  OUTPUT:
**
**      gcUNIFORM * UniformArgument
**          Pointer to a variable receiving the gcUNIFORM object pointer.
*/
gceSTATUS
gcKERNEL_FUNCTION_GetUniformArgument(
    IN gcKERNEL_FUNCTION KernelFunction,
    IN gctUINT Index,
    OUT gcUNIFORM * UniformArgument
    )
{
    gcmHEADER_ARG("KernelFunction=0x%x Index=%u", KernelFunction, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);
    gcmDEBUG_VERIFY_ARGUMENT(Index < KernelFunction->uniformArgumentCount);
    gcmDEBUG_VERIFY_ARGUMENT(UniformArgument != gcvNULL);

    /* Return the gcUNIFORM object pointer. */
    *UniformArgument = KernelFunction->uniformArguments[Index];

    /* Success. */
    gcmFOOTER_ARG("*UniformArgument=0x%x", *UniformArgument);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcKERNEL_FUNCTION_ReallocateImageSamplers
**
**  Reallocate an array of pointers to image sampler pair.
**
**  INPUT:
**
**      gcKERNEL_FUNCTION KernelFunction
**          Pointer to a gcKERNEL_FUNCTION object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcKERNEL_FUNCTION_ReallocateImageSamplers(
    IN gcKERNEL_FUNCTION KernelFunction,
    IN gctUINT32 Count
    )
{
    gcsIMAGE_SAMPLER_PTR imageSamplers;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("KernelFunction=0x%x Count=%lu", KernelFunction, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);

    if (Count < KernelFunction->imageSamplerCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == KernelFunction->imageSamplerArrayCount)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of image sampler pairs. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsIMAGE_SAMPLER) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    imageSamplers = pointer;

    if (KernelFunction->imageSamplers != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(imageSamplers,
                      KernelFunction->imageSamplers,
                      gcmSIZEOF(gcsIMAGE_SAMPLER) * KernelFunction->imageSamplerCount);

        /* Free the current array of image sampler pairs. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, KernelFunction->imageSamplers));
    }

    /* Set new image sampler pair. */
    KernelFunction->imageSamplerArrayCount = Count;
    KernelFunction->imageSamplers          = imageSamplers;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

gceSTATUS
gcKERNEL_FUNCTION_GetPropertyCount(
    IN gcKERNEL_FUNCTION KernelFunction,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("KernelFunction=0x%x", KernelFunction);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    *Count = KernelFunction->propertyCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

gceSTATUS
gcKERNEL_FUNCTION_GetProperty(
    IN gcKERNEL_FUNCTION KernelFunction,
    IN gctUINT Index,
    OUT gctUINT32 * propertySize,
    OUT gctINT * propertyType,
    OUT gctINT * propertyValues
    )
{
    gctUINT32 i, valueIndex;

    gcmHEADER_ARG("KernelFunction=0x%x Index=%u", KernelFunction, Index);

    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);
    gcmDEBUG_VERIFY_ARGUMENT(Index < KernelFunction->propertyCount);

    if (propertySize)
        *propertySize = KernelFunction->properties[Index].propertySize;

    if (propertyType)
        *propertyType = KernelFunction->properties[Index].propertyType;


    valueIndex = 0;
    for(i = 0; i < Index; i++)
    {
        valueIndex += KernelFunction->properties[i].propertySize;
    }

    if(propertyValues)
    {
        gcoOS_MemCopy(propertyValues,
            &KernelFunction->propertyValues[valueIndex],
            gcmSIZEOF(gctINT) * KernelFunction->properties[Index].propertySize);
    }

    if ((propertySize != gcvNULL) || (propertyType != gcvNULL) || (propertyValues != gcvNULL))
    {
        /* Success. */
        gcmFOOTER_ARG("*propertySizee=%u *propertyType=%d *propertyValues=%d",
            gcmOPT_VALUE(propertySize), gcmOPT_VALUE(propertyType),
            gcmOPT_VALUE(propertyValues));
    }
    else
    {
        gcmFOOTER_NO();
    }

    return gcvSTATUS_OK;

}

gceSTATUS
gcKERNEL_FUNCTION_ReallocateKernelFunctionProperties(
    IN gcKERNEL_FUNCTION KernelFunction,
    IN gctUINT32 Count,
    IN gctBOOL isPropertyValue
    )
{
    gcsKERNEL_FUNCTION_PROPERTY_PTR properties;
    gctINT_PTR propertyValues;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("KernelFunction=0x%x Count=%lu", KernelFunction, Count);

    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);

    if(!isPropertyValue)
    {
        if (Count < KernelFunction->propertyCount)
        {
            gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
            return gcvSTATUS_INVALID_ARGUMENT;
        }

        if (Count == KernelFunction->propertyArrayCount)
        {
            gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
            return gcvSTATUS_OK;
        }

        status = gcoOS_Allocate(gcvNULL,
            gcmSIZEOF(gcsKERNEL_FUNCTION_PROPERTY) * Count,
            &pointer);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }

        properties = pointer;

        if (KernelFunction->properties != gcvNULL)
        {
            gcoOS_MemCopy(properties,
                KernelFunction->properties,
                gcmSIZEOF(gcsKERNEL_FUNCTION_PROPERTY)
                * KernelFunction->propertyCount);

            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, KernelFunction->properties));
        }

        KernelFunction->propertyArrayCount    = Count;
        KernelFunction->properties            = properties;
    }
    else
    {
        if (Count < KernelFunction->propertyValueCount)
        {
            gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
            return gcvSTATUS_INVALID_ARGUMENT;
        }

        if (Count == KernelFunction->propertyValueArrayCount)
        {
            gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
            return gcvSTATUS_OK;
        }

        status = gcoOS_Allocate(gcvNULL,
            gcmSIZEOF(gctINT) * Count,
            &pointer);

        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }

        propertyValues = pointer;

        if (KernelFunction->propertyValues != gcvNULL)
        {
            gcoOS_MemCopy(propertyValues,
                KernelFunction->propertyValues,
                gcmSIZEOF(gctINT) * KernelFunction->propertyValueCount);

            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, KernelFunction->properties));
        }

        KernelFunction->propertyValueArrayCount = Count;
        KernelFunction->propertyValues = propertyValues;
    }

    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

gceSTATUS
gcKERNEL_FUNCTION_AddKernelFunctionProperties(
        IN gcKERNEL_FUNCTION KernelFunction,
        IN gctINT propertyType,
        IN gctUINT32 propertySize,
        IN gctINT * values
        )
{
    gceSTATUS status;

    gcmHEADER_ARG("KernelFunction=0x%x",
                  KernelFunction);

    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);

    if (KernelFunction->propertyArrayCount <= KernelFunction->propertyCount)
    {
        status = gcKERNEL_FUNCTION_ReallocateKernelFunctionProperties(KernelFunction,
            KernelFunction->propertyCount + 10, gcvFALSE);
        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }
    }

    KernelFunction->properties[KernelFunction->propertyCount].propertySize = propertySize;
    KernelFunction->properties[KernelFunction->propertyCount].propertyType = propertyType;

    KernelFunction->propertyCount++;

    if (KernelFunction->propertyValueArrayCount <= (KernelFunction->propertyValueCount + propertySize))
    {
        status = gcKERNEL_FUNCTION_ReallocateKernelFunctionProperties(KernelFunction,
            KernelFunction->propertyValueCount + propertySize + 16, gcvTRUE);
        if (gcmIS_ERROR(status))
        {
            gcmFOOTER();
            return status;
        }
    }

    gcoOS_MemCopy(&KernelFunction->propertyValues[KernelFunction->propertyValueCount],
        values,
        gcmSIZEOF(gctINT) * propertySize);

    KernelFunction->propertyValueCount += propertySize;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;

}

/*******************************************************************************
**  gcKERNEL_FUNCTION_AddImageSampler
**
**  Add an Image Sampler pair to a gcKERNEL_FUNCTION object.
**
**  INPUT:
**
**      gcKERNEL_FUNCTION KernelFunction
**          Pointer to a gcKERNEL_FUNCTION object.
**
**      gctUINT8    ImageNum;
**          Kernel function argument # associated with the image passed to the kernel function
**
**      gctBOOL        IsConstantSamplerType;
**          Sampler type is a constant variable inside the program
**
**    gctUINT32    SamplerType;
**          Either a kernel function argument # associated with the sampler type passed in as
**          a kernel function argument
**            or
**          defined as a constant variable as determined from IsConstantSamplerType
**          Array length of the uniform to add.  'Length' must be at least 1.
*/
gceSTATUS
gcKERNEL_FUNCTION_AddImageSampler(
    IN gcKERNEL_FUNCTION KernelFunction,
    IN gctUINT8 ImageNum,
    IN gctBOOL IsConstantSamplerType,
    IN gctUINT32 SamplerType
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("KernelFunction=0x%x ImageNum=%u IsConstantSamplerType=%d SamplerType=%lu",
                  KernelFunction, ImageNum, IsConstantSamplerType, SamplerType);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);

    /* Check array count. */
    if (KernelFunction->imageSamplerArrayCount <= KernelFunction->imageSamplerCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcKERNEL_FUNCTION_ReallocateImageSamplers(KernelFunction,
                                                           KernelFunction->imageSamplerCount + 10);
        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    KernelFunction->imageSamplers[KernelFunction->imageSamplerCount].imageNum  = ImageNum;
    KernelFunction->imageSamplers[KernelFunction->imageSamplerCount].isConstantSamplerType = IsConstantSamplerType;
    KernelFunction->imageSamplers[KernelFunction->imageSamplerCount].samplerType = SamplerType;

    KernelFunction->imageSamplerCount++;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcKERNEL_FUNCTION_GetImageSamplerCount
**
**  Get the number of image sampler pairs for this kernel function.
**
**  INPUT:
**
**      gcKERNEL_FUNCTION KernelFunction
**          Pointer to a gcKERNEL_FUNCTION object.
**
**  OUTPUT:
**
**      gctUINT32 * Count
**          Pointer to a variable receiving the number of image sampler pairs.
*/
gceSTATUS
gcKERNEL_FUNCTION_GetImageSamplerCount(
    IN gcKERNEL_FUNCTION KernelFunction,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("KernelFunction=0x%x", KernelFunction);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    /* Return image sampler pair count. */
    *Count = KernelFunction->imageSamplerCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcKERNEL_FUNCTION_GetImageSampler
**
**  Get the indexed image sampler pair for this kernel function.
**
**  INPUT:
**
**      gcKERNEL_FUNCTION KernelFunction
**          Pointer to a gcKERNEL_FUNCTION object.
**
**      gctUINT Index
**          Index into the image sampler pair array
**
**  OUTPUT:
**
**     gctUINT8    *ImageNum;
**          Pointer to variable to receive Kernel function argument # associated with the image
**
**      gctBOOL    *IsConstantSamplerType;
**          Pointer to varaible to indicate whethger sampler type is a constant variable
**
**    gctUINT32 *SamplerType;
**          Pointer to sampler type
*/
gceSTATUS
gcKERNEL_FUNCTION_GetImageSampler(
    IN gcKERNEL_FUNCTION KernelFunction,
    IN gctUINT Index,
    OUT gctUINT8 *ImageNum,
    OUT gctBOOL *IsConstantSamplerType,
    OUT gctUINT32 *SamplerType
    )
{
    gcmHEADER_ARG("KernelFunction=0x%x Index=%u", KernelFunction, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);
    gcmDEBUG_VERIFY_ARGUMENT(Index < KernelFunction->imageSamplerCount);

    if(ImageNum) {
       *ImageNum = KernelFunction->imageSamplers[Index].imageNum;
    }
    if(IsConstantSamplerType) {
       *IsConstantSamplerType = KernelFunction->imageSamplers[Index].isConstantSamplerType;
    }
    if(SamplerType) {
       *SamplerType = KernelFunction->imageSamplers[Index].samplerType;
    }

    /* Success. */
    if ((ImageNum != gcvNULL) || (IsConstantSamplerType != gcvNULL) || (SamplerType != gcvNULL))
    {
        gcmFOOTER_ARG("*ImageNum=%u *IsConstantSamplerType=%d *SamplerType=%u",
                      gcmOPT_VALUE(ImageNum), gcmOPT_VALUE(IsConstantSamplerType),
                      gcmOPT_VALUE(SamplerType));
    }
    else
    {
        gcmFOOTER_NO();
    }
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcKERNEL_FUNCTION_ReallocateArguments
**
**  Reallocate an array of gcsFUNCTION_ARGUMENT objects in a kernel function.
**
**  INPUT:
**
**      gcKERNEL_FUNCTION Function
**          Pointer to a gcKERNEL_FUNCTION object.
**
**      gctUINT32 Count
**          Array count to reallocate.  'Count' must be at least 1.
*/
gceSTATUS
gcKERNEL_FUNCTION_ReallocateArguments(
    IN gcKERNEL_FUNCTION Function,
    IN gctUINT32 Count
    )
{
    gcsFUNCTION_ARGUMENT_PTR arguments;
    gceSTATUS status;
    gctPOINTER pointer = gcvNULL;

    gcmHEADER_ARG("Function=0x%x Count=%lu", Function, Count);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Function, gcvOBJ_KERNEL_FUNCTION);

    if (Count < Function->argumentCount)
    {
        /* Error. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Count == Function->argumentArrayCount)
    {
        /* No action needed. */
        gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
        return gcvSTATUS_OK;
    }

    /* Allocate a new array of object pointers. */
    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsFUNCTION_ARGUMENT) * Count,
                            &pointer);

    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFOOTER();
        return status;
    }

    arguments = pointer;

    if (Function->arguments != gcvNULL)
    {
        /* Copy the current object pointers. */
        gcoOS_MemCopy(arguments,
                      Function->arguments,
                                   gcmSIZEOF(gcsFUNCTION_ARGUMENT)
                      * Function->argumentCount);

        /* Free the current array of object pointers. */
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Function->arguments));
    }

    /* Set new gcFUNCTION object pointer. */
    Function->argumentArrayCount = Count;
    Function->arguments          = arguments;

    /* Success. */
    gcmFOOTER_ARG("status=%d", gcvSTATUS_OK);
    return gcvSTATUS_OK;
}

gceSTATUS
gcKERNEL_FUNCTION_AddArgument(
    IN gcKERNEL_FUNCTION Function,
    IN gctUINT16 VariableIndex,
    IN gctUINT32 TempIndex,
    IN gctUINT8 Enable,
    IN gctUINT8 Qualifier
    )
{
    gceSTATUS status;

    gcmHEADER_ARG("Function=0x%x TempIndex=%u Enable=%u Qualifier=%u",
                  Function, TempIndex, Enable, Qualifier);

    gcmVERIFY_OBJECT(Function, gcvOBJ_KERNEL_FUNCTION);

    if (Function->argumentArrayCount <= Function->argumentCount)
    {
        /* Reallocate a new array of object pointers. */
        status = gcKERNEL_FUNCTION_ReallocateArguments(Function, Function->argumentCount + 10);

        if (gcmIS_ERROR(status))
        {
            /* Error. */
            gcmFOOTER();
            return status;
        }
    }

    Function->arguments[Function->argumentCount].index     = TempIndex;
    Function->arguments[Function->argumentCount].enable    = Enable;
    Function->arguments[Function->argumentCount].qualifier = Qualifier;
    Function->arguments[Function->argumentCount].precision = gcSHADER_PRECISION_DEFAULT;
    Function->arguments[Function->argumentCount].variableIndex = VariableIndex;

    Function->argumentCount++;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

gceSTATUS
gcKERNEL_FUNCTION_GetArgument(
    IN gcKERNEL_FUNCTION Function,
    IN gctUINT32 Index,
    OUT gctUINT32_PTR Temp,
    OUT gctUINT8_PTR Enable,
    OUT gctUINT8_PTR Swizzle
    )
{
    gcmHEADER_ARG("Function=0x%x Index=%u", Function, Index);

    gcmVERIFY_OBJECT(Function, gcvOBJ_KERNEL_FUNCTION);

    if (Index >= Function->argumentCount)
    {
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    if (Temp != gcvNULL)
    {
        *Temp = Function->arguments[Index].index;
    }

    if (Enable != gcvNULL)
    {
        *Enable = Function->arguments[Index].enable;
    }

    if (Swizzle != gcvNULL)
    {
        switch (Function->arguments[Index].enable)
        {
        case 0x1: *Swizzle = gcSL_SWIZZLE_XXXX; break;
        case 0x2: *Swizzle = gcSL_SWIZZLE_YYYY; break;
        case 0x4: *Swizzle = gcSL_SWIZZLE_ZZZZ; break;
        case 0x8: *Swizzle = gcSL_SWIZZLE_WWWW; break;
        case 0x3: *Swizzle = gcSL_SWIZZLE_XYYY; break;
        case 0x6: *Swizzle = gcSL_SWIZZLE_YZZZ; break;
        case 0xC: *Swizzle = gcSL_SWIZZLE_ZWWW; break;
        case 0x7: *Swizzle = gcSL_SWIZZLE_XYZZ; break;
        case 0xE: *Swizzle = gcSL_SWIZZLE_YZWW; break;
        case 0xF: *Swizzle = gcSL_SWIZZLE_XYZW; break;
        default:  gcmFATAL("Oops!");
        }
    }

    if ((Temp != gcvNULL) || (Enable != gcvNULL) || (Swizzle != gcvNULL))
    {
        gcmFOOTER_ARG("*Temp=%u *Enable=%u *Swizzle=%u",
                      gcmOPT_VALUE(Temp), gcmOPT_VALUE(Enable),
                      gcmOPT_VALUE(Swizzle));
    }
    else
    {
        gcmFOOTER_NO();
    }
    return gcvSTATUS_OK;
}

gceSTATUS
gcKERNEL_FUNCTION_GetLabel(
    IN gcKERNEL_FUNCTION Function,
    OUT gctUINT_PTR Label
    )
{
    gcmHEADER_ARG("Function=0x%x", Function);

    gcmVERIFY_OBJECT(Function, gcvOBJ_KERNEL_FUNCTION);
    gcmDEBUG_VERIFY_ARGUMENT(Label != gcvNULL);

    *Label = Function->label;

    gcmFOOTER_ARG("*Label=%u", *Label);
    return gcvSTATUS_OK;
}

gceSTATUS
gcKERNEL_FUNCTION_SetCodeEnd(
    IN gcKERNEL_FUNCTION KernelFunction
    )
{
    gcSHADER shader;

    gcmHEADER_ARG("KernelFunction=0x%x", KernelFunction);

    gcmVERIFY_OBJECT(KernelFunction, gcvOBJ_KERNEL_FUNCTION);

    gcmASSERT(KernelFunction->shader);
    shader = KernelFunction->shader;
    gcmDEBUG_VERIFY_ARGUMENT(shader->currentKernelFunction == KernelFunction);

    if (shader->instrIndex != gcSHADER_OPCODE)
    {
        shader->instrIndex       = gcSHADER_OPCODE;
        shader->lastInstruction += 1;
    }

    KernelFunction->codeEnd = shader->lastInstruction;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}

static void
_findNameDotAndBracket(
    IN gctCONST_STRING    Name,
    OUT gctCONST_STRING * Dot,
    OUT gctCONST_STRING * Bracket
    )
{
    gctCONST_STRING dot     = gcvNULL;
    gctCONST_STRING bracket = gcvNULL;

    gcoOS_StrStr(Name, ".", (gctSTRING *)&dot);
    gcoOS_StrStr(Name, "[", (gctSTRING *)&bracket);

    *Dot      = dot;
    *Bracket  = bracket;
    return;
}

gceSTATUS
gcSHADER_SetTransformFeedbackVarying(
    IN gcSHADER Shader,
    IN gctUINT32 Count,
    IN gctCONST_STRING *Varyings,
    IN gceFEEDBACK_BUFFER_MODE BufferMode
    )
{
    gceSTATUS status;
    gctUINT32 i, j;

    gcmHEADER_ARG("Shader=0x%x Count=%u Varyings=0x%x BufferMode=%d",
                  Shader, Count, Varyings, BufferMode);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);

    gcmASSERT(Count && Varyings);
    gcmASSERT(Shader->type == gcSHADER_TYPE_VERTEX ||
              Shader->type == gcSHADER_TYPE_TES ||
              Shader->type == gcSHADER_TYPE_GEOMETRY);

    if (Shader->transformFeedback.varyings) {
        for (i = 0; i < Shader->transformFeedback.varyingCount; ++i) {
            if (Shader->transformFeedback.varyings[i].name) {
                gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->transformFeedback.varyings[i].name));
            }
        }
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->transformFeedback.varyings));
        Shader->transformFeedback.varyings = gcvNULL;
        Shader->transformFeedback.varyingCount = 0;
    }

    /* Allocate a new array of varying object pointers. */
    gcmONERROR(gcoOS_Allocate(gcvNULL,
                              gcmSIZEOF(gcsTFBVarying) * Count,
                              (gctPOINTER*)&Shader->transformFeedback.varyings));
    gcoOS_ZeroMemory(Shader->transformFeedback.varyings, gcmSIZEOF(gcsTFBVarying) * Count);

    Shader->transformFeedback.varyingCount = Count;
    Shader->transformFeedback.bufferMode = BufferMode;

    for (i = 0; i < Count; i++) {
        gctUINT32 nameLen;
        gctBOOL found = gcvFALSE;
        gcOUTPUT output = gcvNULL;
        gctINT    index   = -1;

        Shader->transformFeedback.varyings[i].isArray = gcvFALSE;

        if (gcmIS_SUCCESS(gcoOS_StrNCmp(Varyings[i], "gl_", sizeof("gl_")-1))) { /* check for built-ins */
           gctUINT32 kind;

           gcSHADER_GetBuiltinNameKind(Shader, Varyings[i], &kind);
           if (kind != gcSL_NONBUILTINGNAME) {
               for (j = 0; j < Shader->outputCount; j++) {
                  output = Shader->outputs[j];
                  if (Shader->outputs[j]->nameLength == (gctINT) kind) {
                     Shader->transformFeedback.varyings[i].output = output;
                     Shader->transformFeedback.varyings[i].arraySize = output->arraySize;
                     Shader->transformFeedback.varyings[i].isWholeTFBed = gcvTRUE;
                     found = gcvTRUE;
                     break;
                  }
               }
           }
        }
        else {
           gctCONST_STRING varyingDot     = gcvNULL;
           gctCONST_STRING varyingBracket = gcvNULL;
           gctINT varyingNameLength;

           _findNameDotAndBracket(Varyings[i], &varyingDot, &varyingBracket);
           varyingNameLength = gcoOS_StrLen(Varyings[i], gcvNULL);

           if (varyingBracket != gcvNULL)
           {
                const gctCHAR *ptr = varyingBracket + 1;
                index = 0;
                while (*ptr >= '0' && *ptr <= '9')
                {
                    index = index*10 + (*ptr++ - '0');
                }
                if (*ptr != ']')
                {
                    /* error format */
                    index = -1;
                }
            }
            for(j = 0; j < Shader->outputCount; j++) {
               gctINT nameLength;
               gctCONST_STRING outputName;
               gctCONST_STRING outputDot     = gcvNULL;
               gctCONST_STRING outputBracket = gcvNULL;

               output = Shader->outputs[j];
               nameLength = (gctINT)output->nameLength;
               outputName    = output->name;

               /* Before using name, we MUST check nameLength, as when it's negative, name pointer to random data */
               if (nameLength < 0) continue;

               _findNameDotAndBracket(outputName, &outputDot, &outputBracket);
               if (gcmIS_SUCCESS(gcoOS_StrCmp(output->name, Varyings[i])))
               {
                   Shader->transformFeedback.varyings[i].output = output;
                   /* If output is array, whole array will be outputed */
                   Shader->transformFeedback.varyings[i].arraySize = output->arraySize;
                   Shader->transformFeedback.varyings[i].isWholeTFBed = gcvTRUE;

                   if (gcmOUTPUT_isArray(output))
                   {
                       Shader->transformFeedback.varyings[i].isArray = gcvTRUE;
                   }
                   found = gcvTRUE;
                   break;
               }
               /* check if the type of the varying is struct:
                * For an active variable declared as a structure, a separate
                * entry will be generated for each active structure member.
                * The name of each entry is formed by concatenating the name
                * of the structure, the "." character, and the name of the
                * structure member. If a structure member to enumerate is
                * itself a structure or array, these enumeration rules are
                * applied recursively. [ES3.1 spec 7.3. PROGRAM OBJECTS]
                *
                *  struct B { int b0; vec3 b1;};
                *  out A {
                *      vec4  a0;
                *      int   a1[4];
                *      float a2;
                *      struct B a3[2];
                *  } a;
                *
                *  case 1:  variable name "a",
                *           all active entries: a.a0, a.a1[0], a.a2, a.a3[0].b0, a.a3[1].b0
                *
                *  case 2:  variable name "a.a0", only one active entry a.a0
                *
                *  case 3:  variable name "a.a1[2]", only one active entry a.a1[2]
                *
                *  case 4:  variable name "a.a3[1]", only one active entry a.a3[1].b
                *
                *  case 5:  variable name "a.a3", active entries: a.a3[0].b, a.a3[1].b
                *
                */
               if (outputDot != gcvNULL)
               {
                   /* output is member of ioBock or structure */
                   if (gcmIS_SUCCESS(gcoOS_StrNCmp(Varyings[i], output->name, varyingNameLength)) &&
                       (output->name[varyingNameLength] == '.' || output->name[varyingNameLength] == '['))
                   {
                       Shader->transformFeedback.varyings[i].output = output;
                       /* If output is array, whole array will be outputed */
                       Shader->transformFeedback.varyings[i].arraySize = output->arraySize;
                       Shader->transformFeedback.varyings[i].isWholeTFBed = gcvTRUE;

                       if (gcmOUTPUT_isArray(output))
                       {
                           Shader->transformFeedback.varyings[i].isArray = gcvTRUE;
                       }
                       found = gcvTRUE;
                       break;
                   }
               }
               if (gcmOUTPUT_isArray(output) &&
                        index >= 0 &&
                        (gcmIS_SUCCESS(gcoOS_StrNCmp(output->name, Varyings[i], nameLength))))
               {
                   /* handle output array */
                   if (index == output->arrayIndex)
                   {
                       Shader->transformFeedback.varyings[i].output = output;
                       /* Only one element of an array will be outputed */
                       Shader->transformFeedback.varyings[i].arraySize = 1;
                       Shader->transformFeedback.varyings[i].isWholeTFBed = gcvFALSE;
                       found = gcvTRUE;
                       break;
                   }
               }
               /* out Vertex {
                *     vec4 Position; // API transform/feedback will use vertex.Position?
                *     vec2 Texture;
                * } Coords;          // shader will use Coords.Position?
                */
               if (gcmOUTPUT_isIOBLockMember(output) && varyingDot != gcvNULL)
               {
                   /* find the IO Block and check if the name match with
                    * varying name  before the varyingDot */
                   gcsIO_BLOCK ioBlock;

                   gcmASSERT(GetOutputIOBlockIndex(output) < (gctINT)Shader->ioBlockCount);
                   ioBlock = Shader->ioBlocks[GetOutputIOBlockIndex(output)];
                   if (ioBlock->nameLength > 0)
                   {
                       if (gcmIS_SUCCESS(gcoOS_StrNCmp(Varyings[i], ioBlock->name,
                                                       varyingDot - Varyings[i])) &&
                           (ioBlock->name[varyingDot - Varyings[i]] == '\0' || ioBlock->name[varyingDot - Varyings[i]] == '.'))
                       {
                           /* ioBlock matches, check if member name matches */
                           gctSTRING dot1 = gcvNULL;
                           gcoOS_StrStr(output->name, ".", &dot1);
                           if (dot1 != gcvNULL && gcmIS_SUCCESS(gcoOS_StrCmp(dot1, varyingDot)))
                           {
                               Shader->transformFeedback.varyings[i].output = output;
                               /* If output is array, whole array will be outputed */
                               Shader->transformFeedback.varyings[i].arraySize = output->arraySize;
                               Shader->transformFeedback.varyings[i].isWholeTFBed = gcvTRUE;

                               if (gcmOUTPUT_isArray(output))
                               {
                                   Shader->transformFeedback.varyings[i].isArray = gcvTRUE;
                               }
                               found = gcvTRUE;
                               break;
                           }
                           /* check if it is array element */
                           if (gcmOUTPUT_isArray(output) &&
                                    index >= 0 &&
                                    gcmIS_SUCCESS(gcoOS_StrNCmp(varyingDot, dot1,
                                                                (varyingBracket - varyingDot))))
                           {
                               /* handle output array */
                               if (index == output->arrayIndex)
                               {
                                   Shader->transformFeedback.varyings[i].output = output;
                                   /* Only one element of an array will be outputed */
                                   Shader->transformFeedback.varyings[i].arraySize = 1;
                                   Shader->transformFeedback.varyings[i].isWholeTFBed = gcvFALSE;
                                   found = gcvTRUE;
                                   break;
                               }
                           }
                       }
                   }
                   else
                   {
                       /* should be handle in builtin name checks */
                       gcmASSERT(gcvFALSE);
                   }
               }
            }
        }

        if (!found) {
            gcmONERROR(gcvSTATUS_NOT_FOUND);
        }
        else
        {
            gctCONST_STRING name;
            gctSTRING s;
            gctINT origNameLen;
            gcmASSERT(output);
            name = (output->nameLength >= 0) ? output->name : Varyings[i];
            origNameLen = gcoOS_StrLen(name, gcvNULL);
            nameLen = origNameLen + 1;
            if (index >= 0)
            {
                nameLen += 6; /* adding "[0]" to the end of name */
            }
        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  nameLen,
                                      (gctPOINTER*)&s));
            gcoOS_MemCopy(s, name, origNameLen);
            s[origNameLen] = '\0';
            Shader->transformFeedback.varyings[i].name = s;
            if (index >= 0)
            {
                gctUINT offset = origNameLen;
                /* adding "[%d]" to the end of name */
                gcmASSERT(output->arrayIndex >= 0);
                gcmVERIFY_OK(gcoOS_PrintStrSafe(s,
                             nameLen,
                             &offset,
                             "[%d]",
                             output->arrayIndex));
            }
            Shader->transformFeedback.varyings[i].name[nameLen - 1] = '\0';
        }
    }

OnError:
    if (gcmIS_ERROR(status))
    {
        if (Shader->transformFeedback.varyings)
        {
            for (i = 0; i < Shader->transformFeedback.varyingCount; ++i)
            {
                if (Shader->transformFeedback.varyings[i].name)
                {
                    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->transformFeedback.varyings[i].name));
                }
            }
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, Shader->transformFeedback.varyings));
            Shader->transformFeedback.varyings = gcvNULL;
        }

        Shader->transformFeedback.varyingCount = 0;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetTransformFeedbackVaryingCount(
    IN gcSHADER Shader,
    OUT gctUINT32 * Count
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmDEBUG_VERIFY_ARGUMENT(Count != gcvNULL);

    if (Shader == gcvNULL)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    /* Return transform feedback varying count. */
    *Count = Shader->transformFeedback.varyingCount;

    /* Success. */
    gcmFOOTER_ARG("*Count=%lu", *Count);
    return gcvSTATUS_OK;
}

/*******************************************************************************
**  gcSHADER_GetTransformFeedbackVarying
**
**  Get transform feedback varying information.
**
**  INPUT:
**
**      gcSHADER Shader
**          Pointer to a gcSHADER object.
**
**      gctUINT32 Index
**          Index to transform feedback varying.
**
**  OUTPUT:
**
**      gctSTRING Name
**          Pointer to varying name.
**
**      gctUINT32 * Length
**          Pointer to a variable receiving the length of the varying name, if not null.
**
**      gcSHADER_TYPE * Type
**          Pointer to a variable receiving the type of the varying.
**
**      gcBOOL * IsArray
**          Pointer to a variable receiving whether the varying is of array type.
**
**      gctUINT32 * Size
**          Pointer to a variable receiving the size of the varying in units of its type.
*/
gceSTATUS
gcSHADER_GetTransformFeedbackVarying(
    IN gcSHADER Shader,
    IN gctUINT32 Index,
    OUT gctCONST_STRING * Name,
    OUT gctUINT *  Length,
    OUT gcSHADER_TYPE * Type,
    OUT gctBOOL * IsArray,
    OUT gctUINT * Size
    )
{
    gcsTFBVarying* varying;
    gctSIZE_T len;

    gcmHEADER_ARG("Shader=0x%x Index=%u", Shader, Index);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmASSERT(Shader->type == gcSHADER_TYPE_VERTEX ||
              Shader->type == gcSHADER_TYPE_TES ||
              Shader->type == gcSHADER_TYPE_GEOMETRY);
    gcmDEBUG_VERIFY_ARGUMENT(Index < Shader->transformFeedback.varyingCount);
    gcmASSERT(Type);
    gcmASSERT(Size);
    gcmASSERT(Name);

    varying = &Shader->transformFeedback.varyings[Index];

    *Type = varying->output->origType;
    *Name = varying->name;
    *IsArray = varying->isArray;

    /* If this varying is an array, set the array size. */
    if (varying->isArray)
    {
        *Size = varying->arraySize;
    }
    else
    {
        *Size = 1;
    }

    gcoOS_StrLen(*Name, &len);
    *Length = (gctUINT)len;

    /* Success. */
    gcmFOOTER_ARG("Name=%s *Length=%d *Type=%d *Size=%u", Name, gcmOPT_VALUE(Length), *Type, *Size);
    return gcvSTATUS_OK;
}

static gctUINT32
_gcConvShaderTypeToBytes(
    IN gcSHADER_TYPE Type
    )
{
    switch (Type)
    {
    case gcSHADER_BOOLEAN_X1:
    case gcSHADER_FLOAT_X1:
    case gcSHADER_INTEGER_X1:
    case gcSHADER_UINT_X1:
       return 4;

    case gcSHADER_INT64_X1:
    case gcSHADER_UINT64_X1:
       return 8;

    case gcSHADER_BOOLEAN_X2:
    case gcSHADER_FLOAT_X2:
    case gcSHADER_INTEGER_X2:
    case gcSHADER_UINT_X2:
       return 8;

    case gcSHADER_INT64_X2:
    case gcSHADER_UINT64_X2:
       return 16;

    case gcSHADER_BOOLEAN_X3:
    case gcSHADER_FLOAT_X3:
    case gcSHADER_INTEGER_X3:
    case gcSHADER_UINT_X3:
       return 12;

    case gcSHADER_INT64_X3:
    case gcSHADER_UINT64_X3:
       return 24;

    case gcSHADER_BOOLEAN_X4:
    case gcSHADER_FLOAT_X4:
    case gcSHADER_INTEGER_X4:
    case gcSHADER_UINT_X4:
       return 16;

    case gcSHADER_INT64_X4:
    case gcSHADER_UINT64_X4:
       return 32;

    case gcSHADER_FLOAT_2X2:
       return 16;

    case gcSHADER_FLOAT_3X3:
       return 36;

    case gcSHADER_FLOAT_4X4:
       return 64;

    case gcSHADER_FLOAT_2X3:
    case gcSHADER_FLOAT_3X2:
       return (2 * 3 * sizeof(gctFLOAT));

    case gcSHADER_FLOAT_3X4:
    case gcSHADER_FLOAT_4X3:
       return (3 * 4 * sizeof(gctFLOAT));

    case gcSHADER_FLOAT_2X4:
    case gcSHADER_FLOAT_4X2:
       return (4 * 2 * sizeof(gctFLOAT));

    default:
       gcmASSERT(0);
       return 0;
    }
}

gceSTATUS
gcSHADER_GetTransformFeedbackVaryingStride(
    IN gcSHADER Shader,
    OUT gctUINT32 * Stride
    )
{
    gctUINT32 i, stride = 0, numBytes;
    gcOUTPUT varying;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmASSERT(Shader->type == gcSHADER_TYPE_VERTEX ||
              Shader->type == gcSHADER_TYPE_TES||
              Shader->type == gcSHADER_TYPE_GEOMETRY);
    gcmASSERT(Stride);

    *Stride = 0;
    if (!Shader->transformFeedback.varyingCount) {
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    for (i = 0; i < Shader->transformFeedback.varyingCount; i++) {
        varying = Shader->transformFeedback.varyings[i].output;
        numBytes = _gcConvShaderTypeToBytes(varying->origType);

        if (Shader->transformFeedback.varyings[i].isArray)
        {
            numBytes *= Shader->transformFeedback.varyings[i].arraySize;
        }

        stride += numBytes;
    }

    *Stride = stride;

    gcmFOOTER_ARG("*Stride=%u", *Stride);
    return gcvSTATUS_OK;
}

gceSTATUS
gcSHADER_GetTransformFeedbackVaryingStrideSeparate(
    IN gcSHADER Shader,
    IN gctUINT VaryingIndex,
    OUT gctUINT32 * Stride
    )
{
    gcsTFBVarying *xfbVarying;

    gcmHEADER_ARG("Shader=0x%x VaryingIndex=%u", Shader, VaryingIndex);

    /* Verify the arguments. */
    gcmVERIFY_OBJECT(Shader, gcvOBJ_SHADER);
    gcmASSERT(Shader->type == gcSHADER_TYPE_VERTEX ||
              Shader->type == gcSHADER_TYPE_TES ||
              Shader->type == gcSHADER_TYPE_GEOMETRY);
    gcmASSERT(Stride);

    *Stride = 0;
    if (VaryingIndex >= Shader->transformFeedback.varyingCount) {
        gcmFOOTER_ARG("status=%d", gcvSTATUS_INVALID_DATA);
        return gcvSTATUS_INVALID_DATA;
    }

    xfbVarying = &Shader->transformFeedback.varyings[VaryingIndex];
    *Stride = _gcConvShaderTypeToBytes(xfbVarying->output->origType) * xfbVarying->arraySize;

    gcmFOOTER_ARG("*Stride=%u", *Stride);
    return gcvSTATUS_OK;
}

static void
_findBuiltinVariableTempIndex(
    IN  gcSHADER                   Shader,
    IN OUT gcBuiltinsTempIndex *   BuiltinsTempIndex

    )
{
    gctUINT i;

    for (i=0; i < Shader->attributeCount; i++)
    {
        gcATTRIBUTE attribute = Shader->attributes[i];
        if (attribute && (gctINT)attribute->nameLength < 0)
        {
            switch (attribute->nameLength)
            {
            case gcSL_POSITION:
                BuiltinsTempIndex->PositionTempIndex = attribute->index;
                break;
            case gcSL_POINT_SIZE:
                BuiltinsTempIndex->PointSizeTempIndex = attribute->index;
                break;
            case gcSL_FRONT_FACING:
                BuiltinsTempIndex->FrontFacingTempIndex = attribute->index;
                break;
            case gcSL_POINT_COORD:
                BuiltinsTempIndex->PointCoordTempIndex = attribute->index;
                break;
            case gcSL_POSITION_W:
                BuiltinsTempIndex->PositionWTempIndex = attribute->index;
                break;
            case gcSL_FOG_COORD:
                BuiltinsTempIndex->FogCoordTempIndex = attribute->index;
                break;
            case gcSL_WORK_GROUP_ID:
                BuiltinsTempIndex->WorkGroupIDTempIndex = attribute->index;
                break;
            case gcSL_LOCAL_INVOCATION_ID:
                BuiltinsTempIndex->LocalInvocationIDTempIndex = attribute->index;
                break;
            case gcSL_GLOBAL_INVOCATION_ID:
                BuiltinsTempIndex->GlobalInvocationIDTempIndex = attribute->index;
                break;
            case gcSL_HELPER_INVOCATION:
                BuiltinsTempIndex->HelperInvocationTempIndex = attribute->index;
                break;
            case gcSL_FRONT_COLOR:
                BuiltinsTempIndex->FrontColorTempIndex = attribute->index;
                break;
            case gcSL_BACK_COLOR:
                BuiltinsTempIndex->BackColorTempIndex = attribute->index;
                break;
            case gcSL_FRONT_SECONDARY_COLOR:
                BuiltinsTempIndex->FrontColorSecondaryTempIndex = attribute->index;
                break;
            case gcSL_BACK_SECONDARY_COLOR:
                BuiltinsTempIndex->BackColorSecondaryTempIndex = attribute->index;
                break;
            case gcSL_INVOCATION_ID:
                BuiltinsTempIndex->InvocationIDTempIndex = attribute->index;
                break;
            case gcSL_PATCH_VERTICES_IN:
                BuiltinsTempIndex->PatchVerticesInTempIndex = attribute->index;
                break;
            case gcSL_PRIMITIVE_ID:
                BuiltinsTempIndex->PrimitiveIDTempIndex = attribute->index;
                break;
            case gcSL_TESS_LEVEL_OUTER:
                BuiltinsTempIndex->TessLevelOuterTempIndex = attribute->index;
                break;
            case gcSL_TESS_LEVEL_INNER:
                BuiltinsTempIndex->TessLevelInnerTempIndex = attribute->index;
                break;
            case gcSL_LAYER:
                BuiltinsTempIndex->LayerTempIndex = attribute->index;
                break;
            case gcSL_PRIMITIVE_ID_IN:
                BuiltinsTempIndex->PrimitiveIDInTempIndex = attribute->index;
                break;
            case gcSL_TESS_COORD:
                BuiltinsTempIndex->TessCoordTempIndex = attribute->index;
                break;
            case gcSL_SAMPLE_ID:
                BuiltinsTempIndex->SampleIdTempIndex = attribute->index;
                break;
            case gcSL_SAMPLE_POSITION:
                BuiltinsTempIndex->SamplePositionTempIndex = attribute->index;
                break;
            case gcSL_SAMPLE_MASK_IN:
                BuiltinsTempIndex->SampleMaskInTempIndex = attribute->index;
                break;
            case gcSL_IN_POSITION:
                BuiltinsTempIndex->InPositionTempIndex = attribute->index;
                break;
            case gcSL_IN_POINT_SIZE:
                BuiltinsTempIndex->InPointSizeTempIndex = attribute->index;
                break;
            case gcSL_LAST_FRAG_DATA:
                BuiltinsTempIndex->LastFragDataTempIndex = attribute->index;
                break;
            default:
                gcmASSERT(gcvFALSE);
                break;
            }
        }
    }
    for (i=0; i < Shader->outputCount; i++)
    {
        gcOUTPUT output = Shader->outputs[i];
        if (output && (gctINT)output->nameLength < 0)
        {
            switch (output->nameLength)
            {
            case gcSL_POSITION:
                BuiltinsTempIndex->PositionTempIndex = output->tempIndex;
                break;
            case gcSL_POINT_SIZE:
                BuiltinsTempIndex->PointSizeTempIndex = output->tempIndex;
                break;
            case gcSL_COLOR:
                BuiltinsTempIndex->ColorTempIndex = output->tempIndex;
                break;
            case gcSL_DEPTH:
                BuiltinsTempIndex->DepthTempIndex = output->tempIndex;
                break;
            case gcSL_POSITION_W:
            case gcSL_POINT_COORD: /* do nothing as this is patched-in in PatchShaders() */
                break;
            case gcSL_FOG_COORD:
                BuiltinsTempIndex->FogCoordTempIndex = output->tempIndex;
                break;
            case gcSL_FRONT_COLOR:
                BuiltinsTempIndex->FrontColorTempIndex = output->tempIndex;
                break;
            case gcSL_BACK_COLOR:
                BuiltinsTempIndex->BackColorTempIndex = output->tempIndex;
                break;
            case gcSL_FRONT_SECONDARY_COLOR:
                BuiltinsTempIndex->FrontColorSecondaryTempIndex = output->tempIndex;
                break;
            case gcSL_BACK_SECONDARY_COLOR:
                BuiltinsTempIndex->BackColorSecondaryTempIndex = output->tempIndex;
                break;
            /*case gcSL_TEX_COORD:
                break;*/
            case gcSL_SUBSAMPLE_DEPTH:
                BuiltinsTempIndex->SubsampleDepthTempIndex = output->tempIndex;
                break;
            case gcSL_INVOCATION_ID:
                BuiltinsTempIndex->InvocationIDTempIndex = output->tempIndex;
                break;
            case gcSL_PATCH_VERTICES_IN:
                BuiltinsTempIndex->PatchVerticesInTempIndex = output->tempIndex;
                break;
            case gcSL_PRIMITIVE_ID:
                BuiltinsTempIndex->PrimitiveIDTempIndex = output->tempIndex;
                break;
            case gcSL_TESS_LEVEL_OUTER:
                BuiltinsTempIndex->TessLevelOuterTempIndex = output->tempIndex;
                break;
            case gcSL_TESS_LEVEL_INNER:
                BuiltinsTempIndex->TessLevelInnerTempIndex = output->tempIndex;
                break;
            case gcSL_LAYER:
                BuiltinsTempIndex->LayerTempIndex = output->tempIndex;
                break;
            case gcSL_PRIMITIVE_ID_IN:
                BuiltinsTempIndex->PrimitiveIDInTempIndex = output->tempIndex;
                break;
            case gcSL_TESS_COORD:
                BuiltinsTempIndex->TessCoordTempIndex = output->tempIndex;
                break;
            case gcSL_SAMPLE_MASK:
                BuiltinsTempIndex->SampleMaskTempIndex = output->tempIndex;
                break;
            case gcSL_IN_POSITION:
                BuiltinsTempIndex->InPositionTempIndex = output->tempIndex;
                break;
            case gcSL_IN_POINT_SIZE:
                BuiltinsTempIndex->InPointSizeTempIndex = output->tempIndex;
                break;
            case gcSL_BOUNDING_BOX:
                BuiltinsTempIndex->BoundingBoxTempIndex = output->tempIndex;
                break;
            default:
                gcmASSERT(gcvFALSE);
                break;
            }
        }
    }
    for (i=0; i < Shader->variableCount; i++)
    {
        gcVARIABLE variable = Shader->variables[i];
        if (variable && (gctINT)variable->nameLength < 0)
        {
            switch (variable->nameLength)
            {
            case gcSL_POSITION:
                BuiltinsTempIndex->PositionTempIndex = variable->tempIndex;
                break;
            case gcSL_POINT_SIZE:
                BuiltinsTempIndex->PointSizeTempIndex = variable->tempIndex;
                break;
            case gcSL_POSITION_W:
                BuiltinsTempIndex->PositionWTempIndex = variable->tempIndex;
                break;
            case gcSL_VERTEX_ID:
                BuiltinsTempIndex->InstanceIDTempIndex = variable->tempIndex;
                break;
            case gcSL_INSTANCE_ID:
                BuiltinsTempIndex->VertexIDTempIndex = variable->tempIndex;
                break;
            case gcSL_FRONT_COLOR:
                BuiltinsTempIndex->FrontColorTempIndex = variable->tempIndex;
                break;
            case gcSL_BACK_COLOR:
                BuiltinsTempIndex->BackColorTempIndex = variable->tempIndex;
                break;
            case gcSL_FRONT_SECONDARY_COLOR:
                BuiltinsTempIndex->FrontColorSecondaryTempIndex = variable->tempIndex;
                break;
            case gcSL_BACK_SECONDARY_COLOR:
                BuiltinsTempIndex->BackColorSecondaryTempIndex = variable->tempIndex;
                break;
            case gcSL_INVOCATION_ID:
                BuiltinsTempIndex->InvocationIDTempIndex = variable->tempIndex;
                break;
            case gcSL_PATCH_VERTICES_IN:
                BuiltinsTempIndex->PatchVerticesInTempIndex = variable->tempIndex;
                break;
            case gcSL_PRIMITIVE_ID:
                BuiltinsTempIndex->PrimitiveIDTempIndex = variable->tempIndex;
                break;
            case gcSL_TESS_LEVEL_OUTER:
                BuiltinsTempIndex->TessLevelOuterTempIndex = variable->tempIndex;
                break;
            case gcSL_TESS_LEVEL_INNER:
                BuiltinsTempIndex->TessLevelInnerTempIndex = variable->tempIndex;
                break;
            case gcSL_LAYER:
                BuiltinsTempIndex->LayerTempIndex = variable->tempIndex;
                break;
            case gcSL_PRIMITIVE_ID_IN:
                BuiltinsTempIndex->PrimitiveIDInTempIndex = variable->tempIndex;
                break;
            case gcSL_TESS_COORD:
                BuiltinsTempIndex->TessCoordTempIndex = variable->tempIndex;
                break;
            case gcSL_SAMPLE_ID:
                BuiltinsTempIndex->SampleIdTempIndex = variable->tempIndex;
                break;
            case gcSL_SAMPLE_POSITION:
                BuiltinsTempIndex->SamplePositionTempIndex = variable->tempIndex;
                break;
            case gcSL_SAMPLE_MASK_IN:
                BuiltinsTempIndex->SampleMaskInTempIndex = variable->tempIndex;
                break;
            case gcSL_SAMPLE_MASK:
                BuiltinsTempIndex->SampleMaskTempIndex = variable->tempIndex;
                break;
            case gcSL_IN:
            case gcSL_OUT:
            case gcSL_PERVERTEX:
                break;
            case gcSL_IN_POSITION:
                BuiltinsTempIndex->InPositionTempIndex = variable->tempIndex;
                break;
            case gcSL_IN_POINT_SIZE:
                BuiltinsTempIndex->InPointSizeTempIndex = variable->tempIndex;
                break;
            case gcSL_BOUNDING_BOX:
                BuiltinsTempIndex->BoundingBoxTempIndex = variable->tempIndex;
                break;
            case gcSL_FOG_COORD:
                BuiltinsTempIndex->FogCoordTempIndex = variable->tempIndex;
                break;
            default:
                gcmASSERT(gcvFALSE);
                break;
            }
        }
    }
}

static void
_initBuiltinsTempIndex(
    IN OUT gcBuiltinsTempIndex *   BuiltinsTempIndex
    )
{
    BuiltinsTempIndex->PositionTempIndex    =
    BuiltinsTempIndex->PointSizeTempIndex   =
    BuiltinsTempIndex->ColorTempIndex       =
    BuiltinsTempIndex->FrontFacingTempIndex =
    BuiltinsTempIndex->PointCoordTempIndex  =
    BuiltinsTempIndex->PositionWTempIndex   =
    BuiltinsTempIndex->DepthTempIndex       =
    BuiltinsTempIndex->FogCoordTempIndex    =
    BuiltinsTempIndex->InstanceIDTempIndex  =
    BuiltinsTempIndex->VertexIDTempIndex    =
    BuiltinsTempIndex->WorkGroupIDTempIndex  =
    BuiltinsTempIndex->LocalInvocationIDTempIndex  =
    BuiltinsTempIndex->GlobalInvocationIDTempIndex  =
    BuiltinsTempIndex->FrontColorTempIndex  =
    BuiltinsTempIndex->BackColorTempIndex   =
    BuiltinsTempIndex->FrontColorSecondaryTempIndex =
    BuiltinsTempIndex->BackColorSecondaryTempIndex  =
    BuiltinsTempIndex->SubsampleDepthTempIndex = -1;
}

static void
_checkIndexForBuiltinVariable(
    IN  gctINT                  TempIndex,
    OUT gcShaderCodeInfo *      CodeInfo
    )
{
    if (TempIndex == CodeInfo->builtinsTempIndex.InstanceIDTempIndex)
    {
        CodeInfo->useInstanceID = gcvTRUE;
    }
    else if (TempIndex == CodeInfo->builtinsTempIndex.VertexIDTempIndex)
    {
        CodeInfo->useVertexID = gcvTRUE;
    }
    else if (TempIndex == CodeInfo->builtinsTempIndex.DepthTempIndex)
    {
        CodeInfo->hasFragDepth = gcvTRUE;
    }
    else if (TempIndex == CodeInfo->builtinsTempIndex.SubsampleDepthTempIndex)
    {
        CodeInfo->useSubsampleDepth = gcvTRUE;
    }

}

static void
_checkIndexForBuiltinAttribute(
    IN  gctINT                  Index,
    OUT gcShaderCodeInfo *      CodeInfo
    )
{
    if (Index == CodeInfo->builtinsTempIndex.PositionTempIndex)
    {
        CodeInfo->usePosition = gcvTRUE;
    }
    else if (Index == CodeInfo->builtinsTempIndex.FrontFacingTempIndex)
    {
        CodeInfo->useFace = gcvTRUE;
    }
}

gctBOOL
gcHasNewTexld(void)
{
    static gctBOOL firstTime   = gcvTRUE;
    static gctBOOL hasNewTexld;

    if (firstTime)
    {
        hasNewTexld = gcHWCaps.hwFeatureFlags.hasHalti2;
        firstTime   = gcvFALSE;
    }

    return hasNewTexld;
}

static void _checkSrcHighp(gcSL_INSTRUCTION code, gctINT srcIdx, gcShaderCodeInfo * CodeInfo)
{
    gcSL_OPCODE opcode = gcmSL_OPCODE_GET(code->opcode, Opcode);

    gctINT      otherSrcIdx = (srcIdx == 0) ? 1 : 0;

    gctSOURCE_t source  = (srcIdx == 0) ? code->source0 : code->source1;
    gctINT      index   = (srcIdx == 0) ? code->source0Index : code->source1Index;
    gcSL_TYPE   srcType = gcmSL_SOURCE_GET(source, Type);

    gctSOURCE_t otherSource  = (otherSrcIdx == 0) ? code->source0 : code->source1;

    gctBOOL     targetHp = gcvFALSE, otherSrcHp = gcvFALSE;

    /* No need go on */
    if (srcType == gcSL_NONE)
    {
        return;
    }

    if (gcmSL_TARGET_GET(code->temp, Enable) != gcSL_ENABLE_NONE &&
        gcmSL_TARGET_GET(code->temp, Precision) == gcSL_PRECISION_HIGH)
    {
        targetHp = gcvTRUE;
    }

    if (gcmSL_SOURCE_GET(otherSource, Type) != gcSL_NONE &&
        gcmSL_SOURCE_GET(otherSource, Precision) == gcSL_PRECISION_HIGH)
    {
        otherSrcHp = gcvTRUE;
    }

    if (gcmSL_SOURCE_GET(source, Precision) == gcSL_PRECISION_HIGH &&
        (srcType != gcSL_ATTRIBUTE || /* exclude position */
         gcmSL_INDEX_GET(index, Index) != (gctUINT32)CodeInfo->builtinsTempIndex.PositionTempIndex) &&
        opcode != gcSL_NORM /* we support highp NORM */)
    {
        if (srcType == gcSL_UNIFORM || srcType == gcSL_CONSTANT)
        {
            /* Dual-t mode needs us more cares */
            if (!targetHp && !otherSrcHp)
            {
                if (srcType == gcSL_CONSTANT)
                {
                    /* TODO: Need check whether we can convert it to FP16 without precision lost */
                    return;
                }

                CodeInfo->useHighPrecision = gcvTRUE;
            }
        }
        else
        {
            CodeInfo->useHighPrecision = gcvTRUE;
        }
    }
}

/* get the code info by go through the each function and instruction */
gceSTATUS
gcSHADER_CountCode(
    IN  gcSHADER           Shader,
    OUT gcShaderCodeInfo * CodeInfo
    )
{
    gctUINT32        instIdx;
    gcSL_INSTRUCTION code;
    gcSL_OPCODE      opcode;
    gctINT           i;
    gceSTATUS        status = gcvSTATUS_OK;

    gcmHEADER_ARG("Shader=0x%x, CodeInfo=0x%x", Shader, CodeInfo);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL && CodeInfo != gcvNULL);

    _initBuiltinsTempIndex(&CodeInfo->builtinsTempIndex);
    _findBuiltinVariableTempIndex(Shader, &CodeInfo->builtinsTempIndex);

    for (instIdx = 0; instIdx < Shader->codeCount; instIdx ++)
    {
        code = &Shader->code[instIdx];
        opcode = gcmSL_OPCODE_GET(code->opcode, Opcode);
        CodeInfo->codeCounter[opcode]++;   /*increase the code count for the opcode */

        /* If there is a texld on vs and the previous code is not texlod,
        ** we need to increase the code count for texlod.
        */
        if ((Shader->type == gcSHADER_TYPE_VERTEX) && gcSL_isOpcodeTexld(opcode))
        {
            if (instIdx == 0 && !gcHasNewTexld())
            {
                CodeInfo->codeCounter[gcSL_TEXLOD]++;
            }
            else
            {
                if (!gcHasNewTexld())
                {
                    gcSL_OPCODE preOpcode = gcmSL_OPCODE_GET(Shader->code[instIdx - 1].opcode, Opcode);
                    if (preOpcode != gcSL_TEXLOD)
                    {
                        CodeInfo->codeCounter[gcSL_TEXLOD]++;
                    }
                }
            }
        }

        /* check destination */
        if (gcmSL_TARGET_GET(code->temp, Enable) != gcSL_ENABLE_NONE)
        {
            gcSL_FORMAT format;

            if (gcmSL_TARGET_GET(code->temp, Precision) == gcSL_PRECISION_HIGH )
            {
                CodeInfo->useHighPrecision = gcvTRUE;
            }

            format = gcmSL_TARGET_GET(code->temp, Format);
            if (format == gcSL_INT32 || format == gcSL_UINT32)
            {
                CodeInfo->hasInt32OrUint32 = gcvTRUE;
            }

            if (gcmSL_TARGET_GET(code->temp, Indexed) != gcSL_NOT_INDEXED)
            {
                _checkIndexForBuiltinVariable(code->tempIndexed,
                                              CodeInfo);
            }

        }

        /* check sources */
        for (i=0; i < 2; i++)
        {
            gctSOURCE_t source  = (i == 0) ? code->source0 : code->source1;
            gctINT      index   = (i == 0) ? code->source0Index
                                           : code->source1Index;
            gctINT      indexed = (i == 0) ? code->source0Indexed
                                           : code->source1Indexed;
            gcSL_TYPE   srcType = gcmSL_SOURCE_GET(source, Type);
            if (srcType != gcSL_NONE)
            {
                _checkSrcHighp(code, i, CodeInfo);

                if (srcType == gcSL_TEMP)
                {
                    _checkIndexForBuiltinVariable(index,
                                                  CodeInfo);
                }
                else if (srcType == gcSL_ATTRIBUTE)
                {
                    _checkIndexForBuiltinAttribute(gcmSL_INDEX_GET(index, Index),
                                                   CodeInfo);
                }
            }
            if (gcmSL_SOURCE_GET(source, Indexed) != gcSL_NOT_INDEXED)
            {
                _checkIndexForBuiltinVariable(indexed,
                                              CodeInfo);
            }
        }
        /* TODO: count estimated machine instruction count */
    }

    gcmFOOTER();
    return status;
}

gctBOOL
gcSHADER_IsDual16Shader(
    IN  gcSHADER           Shader,
    IN  gcShaderCodeInfo * CodeInfoPtr
    )
{
    gcShaderCodeInfo codeInfo;
    gctUINT          dual16Mode;
    gctBOOL          autoMode = gcvFALSE;

    dual16Mode = gcGetDualFP16Mode(gcHWCaps.hwFeatureFlags.hasHalti2);

    /* only fragment shader can be dual16 shader,
    ** and exclude OpenVG shader due to precision issue
    */
    if ((Shader->type != gcSHADER_TYPE_FRAGMENT) ||
        (dual16Mode == DUAL16_FORCE_OFF)         ||
        gcShaderIsOpenVG(Shader))
        return gcvFALSE;

    /* if forced to use dual16 by VC_OPTION */
    if (dual16Mode == DUAL16_FORCE_ON)
        return gcvTRUE;


    if (dual16Mode == DUAL16_AUTO_ALL)
    {
        autoMode = gcvTRUE;
    }
    else if (dual16Mode == DUAL16_AUTO_BENCH)
    {
        /* Enable dual16 auto-on mode for following games. */
        switch (gcPatchId)
        {
        case gcvPATCH_GLBM21:
        case gcvPATCH_GLBM25:
        case gcvPATCH_GLBM27:
        case gcvPATCH_GFXBENCH:
        case gcvPATCH_MM07:
        case gcvPATCH_NENAMARK2:
            autoMode = gcvTRUE;
            break;
        case gcvPATCH_LEANBACK:
        case gcvPATCH_ANGRYBIRDS:
            return gcvTRUE;
        default:
            break;
        }
    }

    if (gcvFALSE == autoMode)
    {
        return gcvFALSE;
    }

    if (CodeInfoPtr == gcvNULL)
    {
        CodeInfoPtr = &codeInfo;
        gcoOS_ZeroMemory(&codeInfo, gcmSIZEOF(codeInfo));

        /* otherwise check the shader code */
        gcSHADER_CountCode(Shader, &codeInfo);
    }


    if (CodeInfoPtr->useHighPrecision           ||
        CodeInfoPtr->hasInt32OrUint32           ||
        CodeInfoPtr->useInstanceID              ||
        CodeInfoPtr->useVertexID                ||
        CodeInfoPtr->useLocalStorage            ||
        CodeInfoPtr->estimatedInst > 1023       ||
        (CodeInfoPtr->codeCounter[gcSL_CALL] != 0))
        return gcvFALSE;

    return gcvTRUE;
}

void
gcSHADER_SetFlag(
    IN OUT  gcSHADER           Shader,
    IN      gcSHADER_FLAGS     Flag
    )
{
    Shader->flags  |= Flag;
}

void
gcSHADER_ResetFlag(
    IN OUT  gcSHADER           Shader,
    IN      gcSHADER_FLAGS     Flag
    )
{
        Shader->flags  &= ~Flag;
}

gcUNIFORM
gcSHADER_GetUniformBySamplerIndex(
    IN gcSHADER             Shader,
    IN gctUINT              SamplerIndex,
    OUT gctINT *            ArrayIndex
    )
{
    gcUNIFORM samplerUniform = gcvNULL;
    gctUINT    i;

    for (i = 0; i < Shader->uniformCount; i++)
    {
        gcUNIFORM uniform = Shader->uniforms[i];
        gctUINT    minIndex, maxIndex;

        if (isUniformSampler(uniform))
        {
            minIndex = (gctUINT)GetUniformPhysical(uniform);
            maxIndex = (gctUINT)GetUniformPhysical(uniform) + (gctUINT)GetUniformArraySize(uniform) - 1;

            if (SamplerIndex >= minIndex && SamplerIndex <= maxIndex)
            {
                samplerUniform = uniform;
                if (ArrayIndex != gcvNULL)
                {
                    if (isUniformArray(uniform))
                    {
                        *ArrayIndex = (gctINT)(SamplerIndex - minIndex);
                    }
                }
                break;
            }
        }
    }
    return samplerUniform;
}

static void
_CheckCodeUniformUsage(
    IN OUT gcSHADER           Shader,
    IN     gcSL_INSTRUCTION   Code,
    IN     gctBOOL            InLTC,
    IN     gctBOOL            HasTexgatherModifier
    )
{
    gctINT           i, j;

    /* check sources */
    for (i=0; i < 2; i++)
    {
        gctSOURCE_t source  = (i == 0) ? Code->source0 : Code->source1;

        if (gcmSL_SOURCE_GET(source, Type) == gcSL_UNIFORM)
        {
            gctINT32  indexVal = (i == 0) ? Code->source0Index
                                          : Code->source1Index;
            gctINT    index    = gcmSL_INDEX_GET(indexVal, Index);
            gctINT    lastUniformIndex = index;
            gctBOOL   isMLSampler = gcvFALSE;
            gcUNIFORM uniform = Shader->uniforms[index];
            gcmASSERT(index < (gctINT)Shader->uniformCount &&
                      uniform != gcvNULL);

            isMLSampler = isUniformMLSampler(uniform);

            if (gcmSL_SOURCE_GET(source, Indexed) != gcSL_NOT_INDEXED)
            {
                gcSHADER_GetUniformIndexingRange(Shader,
                                                 index,
                                                 -1,
                                                 &lastUniformIndex,
                                                 gcvNULL,
                                                 gcvNULL);
            }

            for (j = index; j <= lastUniformIndex; j ++)
            {
                uniform = Shader->uniforms[j];

                if (!uniform || isUniformStruct(uniform))
                {
                    continue;
                }

                if (InLTC)
                {
                    SetUniformUsedInLTC(uniform);
                    if (isMLSampler)
                    {
                        SetUniformUsedInLTC(Shader->uniforms[uniform->parent]);
                    }
                }
                else
                {
                    SetUniformUsedInShader(uniform);
                    if (isMLSampler)
                    {
                        SetUniformUsedInShader(Shader->uniforms[uniform->parent]);
                    }
                }

                if (HasTexgatherModifier && (i == 0) &&
                    gcSL_isOpcodeTexld(gcmSL_OPCODE_GET(Code->opcode, Opcode)))
                {
                    /* sampler is used as source0, mark it as be used in texgather */
                    SetUniformFlag(uniform, gcvUNIFORM_FLAG_USED_AS_TEXGATHER_SAMPLER);
                }

                /* If this uniform belongs to a UBO, mark this UBO as used. */
                if (uniform->blockIndex != -1 &&
                    !isUniformStorageBlockAddress(uniform))
                {
                    gctUINT32 count = 0;
                    gcUNIFORM uboUniform;
                    gcsUNIFORM_BLOCK ubo;

                    gcSHADER_GetUniformBlockCount(Shader, &count);
                    gcmASSERT(uniform->blockIndex < (gctINT16)count);

                    gcSHADER_GetUniformBlock(Shader, uniform->blockIndex, &ubo);
                    gcmASSERT(ubo != gcvNULL && GetUBIndex(ubo) != -1);

                    gcSHADER_GetUniform(Shader, GetUBIndex(ubo), &uboUniform);
                    gcmASSERT(uboUniform != gcvNULL);

                    if (InLTC)
                    {
                        SetUniformUsedInLTC(uboUniform);
                    }
                    else
                    {
                        SetUniformUsedInShader(uboUniform);
                    }
                }

                /* TODO: Add support for arrays of arrays. */
                if (isUniformMatrix(uniform) ||
                    isUniformArraysOfArrays(uniform))
                {
                    SetUniformUsedArraySize(uniform, GetUniformArraySize(uniform));
                }
                /* record the usedArraySize for non-matrix array uniform*/
                else if (isUniformArray(uniform))
                {
                    if (isUniformIndirectlyAddressed(uniform) ||
                        gcmSL_SOURCE_GET(source, Indexed) != gcSL_NOT_INDEXED)
                    {
                        SetUniformUsedArraySize(uniform, GetUniformArraySize(uniform));
                    }
                    else
                    {
                        gctINT    indexed = (i == 0) ? Code->source0Indexed
                                         : Code->source1Indexed;

                        gctINT constVal = gcmSL_INDEX_GET(indexVal, ConstValue) + indexed + 1;

                        if(GetShaderType(Shader) == gcSHADER_TYPE_CL &&
                           isUniformCompiletimeInitialized(uniform))
                        {
                            gctUINT32  components, rows;

                            gcTYPE_GetTypeInfo(GetUniformType(uniform),
                                               &components,
                                               &rows,
                                               gcvNULL);

                            constVal /= rows;
                        }

                        if (constVal <= GetUniformArraySize(uniform))
                        {
                            SetUniformUsedArraySize(uniform, (constVal > uniform->usedArraySize) ?
                                                               constVal : uniform->usedArraySize);
                        }
                        else
                        {
                            gcmASSERT(gcvFALSE);
                            SetUniformUsedArraySize(uniform, GetUniformArraySize(uniform));
                        }
                    }
                }
            }
        }
        else if (gcmSL_SOURCE_GET(source, Type) == gcSL_SAMPLER)
        {
            if (gcmSL_SOURCE_GET(source, Indexed) == gcSL_NOT_INDEXED)
            {
                gctBOOL     usedInTexgather = HasTexgatherModifier &&
                                              (i == 0) &&
                                              gcSL_isOpcodeTexld(gcmSL_OPCODE_GET(Code->opcode, Opcode));
                gcUNIFORM   uniform;
                gctINT32    indexVal = (i == 0) ? Code->source0Index
                                                : Code->source1Index;
                gctINT      index    = gcmSL_INDEX_GET(indexVal, Index);
                gctBOOL     isMLSampler = gcvFALSE;

                /* sampler is used as source0, mark it as be used in texgather */
                uniform = gcSHADER_GetUniformBySamplerIndex(Shader, index, gcvNULL);
                if (uniform == gcvNULL)
                {
                    gcmASSERT(gcvFALSE);
                    return;
                }
                isMLSampler = isUniformMLSampler(uniform);

                if (uniform)
                {
                    if (usedInTexgather)
                    {
                        SetUniformFlag(uniform, gcvUNIFORM_FLAG_USED_AS_TEXGATHER_SAMPLER);
                    }
                    if (InLTC)
                    {
                        SetUniformUsedInLTC(uniform);
                        if (isMLSampler)
                        {
                            SetUniformUsedInLTC(Shader->uniforms[uniform->parent]);
                        }
                    }
                    else
                    {
                        SetUniformUsedInShader(uniform);
                        if (isMLSampler)
                        {
                            SetUniformUsedInShader(Shader->uniforms[uniform->parent]);
                        }
                    }
                }
                else
                {
                    gcmASSERT(gcvFALSE);
                }
            }
        }
    }
    return ;
}

gceSTATUS
gcSHADER_CheckUniformUsage(
    IN OUT gcSHADER           Shader,
    IN gceSHADER_FLAGS        Flags
    )
{
    gctUINT32    instIdx;
    gctUINT32    i;
    gcSL_INSTRUCTION code;
    gceSTATUS    status = gcvSTATUS_OK;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Verify the arguments. */
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    for (i = 0; i < Shader->uniformBlockCount; i++)
    {
        if (Shader->uniformBlocks[i] != gcvNULL)
        {
            gcUNIFORM blockUniform;

            gcmASSERT(GetUBIndex(Shader->uniformBlocks[i]) != -1);
            status = gcSHADER_GetUniform(Shader,
                                         GetUBIndex(Shader->uniformBlocks[i]),
                                         &blockUniform);
            if(gcmIS_ERROR(status))
            {
                gcmFOOTER();
                return status;
            }

            /* Don't change the usage of user-defined UBO when doing recompiler. */
            if (Flags & gcvSHADER_RECOMPILER &&
                !isUniformLoadtimeConstant(blockUniform) &&
                !isUniformCompiletimeInitialized(blockUniform) &&
                !isUniformCompilerGen(blockUniform))
            {
                continue;
            }

            /* always use LOAD for constant UBO, since it is only created
            * when there is no enough uniform */
            if ((gctINT)i != Shader->constUniformBlockIndex)
            {
                ResetUniformFlag(blockUniform, gcvUNIFORM_FLAG_USED_IN_SHADER);
                ResetUniformFlag(blockUniform, gcvUNIFORM_FLAG_USED_IN_LTC);
            }
        }
    }

    for (i = 0; i < Shader->uniformCount; i++)
    {
        gcUNIFORM uniform = Shader->uniforms[i];

        /*
        ** We don't know the usage of uniforms that used LOAD to access,
        ** including UBO and atomic uniforms, so we don't clean usage for such uniforms.
        */
        if (uniform != gcvNULL &&
            gcmType_Kind(uniform->u.type) != gceTK_ATOMIC &&
            !isUniformBlockAddress(uniform))
        {
            /* Don't change the usage of user-defined uniforms when doing recompiler. */
            if (Flags & gcvSHADER_RECOMPILER &&
                !isUniformLoadtimeConstant(uniform) &&
                !isUniformCompiletimeInitialized(uniform) &&
                !isUniformCompilerGen(uniform))
            {
                continue;
            }

            ResetUniformFlag(uniform, gcvUNIFORM_FLAG_USED_IN_SHADER);
            ResetUniformFlag(uniform, gcvUNIFORM_FLAG_USED_IN_LTC);
        }
    }

    for (instIdx = 0; instIdx < Shader->codeCount; instIdx ++)
    {
        gctBOOL             hasTexGatherModifer;
        gcSL_INSTRUCTION    prevCode;

        code = &Shader->code[instIdx];
        hasTexGatherModifer = gcvFALSE;

        if (instIdx > 0)
        {
            prevCode = &Shader->code[instIdx - 1];
            if (gcmSL_OPCODE_GET(prevCode->opcode, Opcode) == gcSL_TEXGATHER)
                hasTexGatherModifer = gcvTRUE;
        }

        _CheckCodeUniformUsage(Shader, code, gcvFALSE, hasTexGatherModifer);
    }

    for (instIdx = 0; instIdx < Shader->ltcInstructionCount; instIdx ++)
    {
        code = &Shader->ltcExpressions[instIdx];
        _CheckCodeUniformUsage(Shader, code, gcvTRUE, gcvFALSE);
    }

    gcmFOOTER();
    return status;
}

gctUINT
_getTempCount(
    IN gcSHADER         Shader
    )
{
    return Shader->_tempRegCount;
}

/* return true if a function named as FunctionName is defined in Shader */
gctBOOL
isFunctionDefined(
    IN gcSHADER              Shader,
    IN gctCONST_STRING       FunctionName)
{
    gctUINT i;

    for (i=0; i<Shader->functionCount; i++)
    {
        if (gcmIS_SUCCESS(gcoOS_StrCmp(FunctionName,
                                       Shader->functions[i]->name) ))
        {
            return gcvTRUE;
        }
    }
    return gcvFALSE;
}


gctUINT8
gcSL_ConvertSwizzle2Enable(
    IN gcSL_SWIZZLE X,
    IN gcSL_SWIZZLE Y,
    IN gcSL_SWIZZLE Z,
    IN gcSL_SWIZZLE W
    )
{
    static const gctUINT8 _enable[] =
    {
        gcSL_ENABLE_X,
        gcSL_ENABLE_Y,
        gcSL_ENABLE_Z,
        gcSL_ENABLE_W
    };

    /* Return combined enables for each swizzle. */
    return _enable[X] | _enable[Y] | _enable[Z] | _enable[W];
}


void
gcSL_SetInst2NOP(
    IN OUT gcSL_INSTRUCTION      Code
    )
{
    gcmASSERT(Code != gcvNULL);

    Code->opcode         = 0;
    Code->temp           = 0;
    Code->tempIndex      = 0;
    Code->tempIndexed    = 0;
    Code->source0        = 0;
    Code->source0Index   = 0;
    Code->source0Indexed = 0;
    Code->source1        = 0;
    Code->source1Index   = 0;
    Code->source1Indexed = 0;
    Code->srcLoc         = 0;
}

const gctCONST_STRING gcTexldFlavor[gceTF_COUNT] =
{
    "", /* gceTF_TEXLD, */
    "_proj", /* gceTF_PROJ, */
    "_pcf", /* gceTF_PCF, */
    "_pcfproj", /* gceTF_PCFPROJ, */
    "_bias", /* gceTF_BIAS_TEXLD, */
    "_bias_proj", /* gceTF_BIAS_PROJ, */
    "_bias_pcf", /* gceTF_BIAS_PCF, */
    "_bias_pcfproj", /* gceTF_BIAS_PCFPROJ, */
    "_lod", /* gceTF_LOD_TEXLD, */
    "_lod_proj", /* gceTF_LOD_PROJ, */
    "_lod_pcf", /* gceTF_LOD_PCF, */
    "_lod_pcfproj", /* gceTF_LOD_PCFPROJ, */
    "_grad", /* gceTF_GRAD_TEXLD, */
    "_grad_proj", /* gceTF_GRAD_PROJ, */
    "_grad_pcf", /* gceTF_GRAD_PCF, */
    "_grad_pcfproj", /* gceTF_GRAD_PCFPROJ, */
    "_gather", /* gceTF_GATHER_TEXLD, */
    "_gather_proj", /* gceTF_GATHER_PROJ, */
    "_gather_pcf", /* gceTF_GATHER_PCF, */
    "_gather_pcfproj", /* gceTF_GATHER_PCFPROJ, */
    "_fetch_ms", /* gceTF_FETCH_MS_TEXLD, */
    "_fetch_ms_proj", /* gceTF_FETCH_MS_PROJ, */
    "_fetch_ms_pcf", /* gceTF_FETCH_MS_PCF, */
    "_fetch_ms_pcfproj", /* gceTF_FETCH_MS_PCFPROJ, */
};

void
gcSetGLSLCompiler(
    IN gctGLSLCompiler Compiler
    )
{
    gcGLSLCompiler = Compiler;
}

void
gcSetCLCompiler(
    IN gctCLCompiler Compiler
    )
{
    gcCLCompiler = Compiler;
}

gcePATCH_ID gcPatchId;
gcePATCH_ID *
gcGetPatchId(void)
{
    return &gcPatchId;
}

gcsHWCaps gcHWCaps;
gcsHWCaps *
gcGetHWCaps(void)
{
    return &gcHWCaps;
}

gcsGLSLCaps gcGLSLCaps;
gcsGLSLCaps *
gcGetGLSLCaps(void)
{
    return &gcGLSLCaps;
}

gceSTATUS
gcInitGLSLCaps(
    OUT gcsGLSLCaps         *Caps
    )
{
    gceSTATUS       status = gcvSTATUS_OK;
    gctUINT         maxVertexAttribs            = 8;
    gctUINT         maxVertexUniformVectors     = 128;
    gctUINT         maxVaryingVectors           = 8;
    gctUINT         maxVertexTextureImageUnits  = 0;
    gctUINT         maxTextureImageUnits        = 8;
    gctUINT         maxFragmentUniformVectors   = 16;
    gctUINT         maxDrawBuffers              = 1;
    gctUINT         maxSamples                  = 1;
    gctBOOL         tsAvailable = gcvFALSE;
    gctBOOL         gsAvailable = gcvFALSE;

    gcmASSERT(Caps != gcvNULL);
    /* Setup the constant values */
    gcmVERIFY_OK(
        gcoHAL_QueryStreamCaps(gcvNULL,
                               &maxVertexAttribs,
                               gcvNULL,
                               gcvNULL,
                               gcvNULL,
                               gcvNULL));

    gcmVERIFY_OK(
        gcoHAL_QueryShaderCaps(gcvNULL,
                               gcvNULL,
                               &maxVertexUniformVectors,
                               &maxFragmentUniformVectors,
                               &maxVaryingVectors,
                               gcvNULL,
                               gcvNULL,
                               gcvNULL,
                               gcvNULL));

    gcmVERIFY_OK(
        gcoHAL_QueryTextureCaps(gcvNULL,
                                gcvNULL,
                                gcvNULL,
                                gcvNULL,
                                gcvNULL,
                                gcvNULL,
                                &maxVertexTextureImageUnits,
                                &maxTextureImageUnits));

    if (maxTextureImageUnits < 8)
        maxTextureImageUnits = 8;

    gcmVERIFY_OK(
        gcoHAL_QueryTargetCaps(gcvNULL,
                               gcvNULL,
                               gcvNULL,
                               &maxDrawBuffers,
                               &maxSamples));

    tsAvailable = GetHWHasTS();
    gsAvailable = GetHWHasGS();

    Caps->maxDrawBuffers = maxDrawBuffers;
    Caps->maxSamples     = maxSamples;
    Caps->maxVertTextureImageUnits = maxVertexTextureImageUnits;
    Caps->maxCmptTextureImageUnits = maxTextureImageUnits;
    Caps->maxFragTextureImageUnits = maxTextureImageUnits;
    Caps->maxTcsTextureImageUnits = tsAvailable ? 16 : 0;
    Caps->maxTesTextureImageUnits = tsAvailable ? 16 : 0;
    Caps->maxGsTextureImageUnits = gsAvailable ? 16 : 0;
    Caps->maxCombinedTextureImageUnits = Caps->maxVertTextureImageUnits + Caps->maxFragTextureImageUnits + Caps->maxCmptTextureImageUnits +
                                         Caps->maxGsTextureImageUnits + Caps->maxTcsTextureImageUnits + Caps->maxTesTextureImageUnits;
    Caps->minProgramTexelOffset = -8;
    Caps->maxProgramTexelOffset = 7;
    Caps->minProgramTexGatherOffset = -8;
    Caps->maxProgramTexGatherOffset =  7;

    Caps->maxVertAttributes = maxVertexAttribs + 2;
    Caps->maxUserVertAttributes = maxVertexAttribs;
    Caps->maxBuildInVertAttributes = 2;
    Caps->maxVaryingVectors = maxVaryingVectors;
    Caps->maxVertOutVectors = maxVaryingVectors + 1;
    Caps->maxFragInVectors = maxVaryingVectors + 1;
    Caps->maxTcsOutVectors = tsAvailable ? 32 : 0;
    Caps->maxTcsOutPatchVectors = tsAvailable ? 30 : 0;
    Caps->maxTcsOutTotalVectors = tsAvailable ? 1024 : 0;
    Caps->maxTesOutVectors = tsAvailable ? 32 : 0;
    Caps->maxTcsInVectors = tsAvailable ? 32 : 0;
    Caps->maxTesInVectors = tsAvailable ? 32 : 0;
    Caps->maxGsOutVectors = gsAvailable ? 32 : 0;
    Caps->maxGsOutTotalVectors = gsAvailable ? 64 : 0;
    Caps->maxGsInVectors = gsAvailable ? 16 : 0;


    /* buffer bindings */
    Caps->uniformBufferOffsetAlignment = 4;
    Caps->maxVertUniformBlocks = 16;
    Caps->maxFragUniformBlocks = 16;
    Caps->maxCmptUniformBlocks = 16;
    Caps->maxTcsUniformBlocks = tsAvailable ? 12 : 0;
    Caps->maxTesUniformBlocks = tsAvailable ? 12 : 0;
    Caps->maxGsUniformBlocks = gsAvailable ? 12 : 0;
    Caps->maxCombinedUniformBlocks = gcmMAX((Caps->maxVertUniformBlocks +
                                             Caps->maxFragUniformBlocks +
                                             Caps->maxTcsUniformBlocks  +
                                             Caps->maxTesUniformBlocks),
                                             Caps->maxCmptUniformBlocks);
    /* In basic machine unit */
    Caps->maxUniformBlockSize = 65536;
    Caps->maxUniformBufferBindings = Caps->maxCombinedUniformBlocks;

    Caps->maxVertAtomicCounterBuffers = 16;
    Caps->maxFragAtomicCounterBuffers = 16;
    Caps->maxCmptAtomicCounterBuffers = 16;
    /*glsl spec implicilty requied one atomic counter buffer has at least 8 atomic counters */
    Caps->maxVertAtomicCounters = Caps->maxVertAtomicCounterBuffers * 8;
    Caps->maxFragAtomicCounters = Caps->maxFragAtomicCounterBuffers * 8;
    Caps->maxCmptAtomicCounters = Caps->maxCmptAtomicCounterBuffers * 8;
    Caps->maxTcsAtomicCounterBuffers = tsAvailable ? 16 : 0;
    Caps->maxTesAtomicCounterBuffers = tsAvailable ? 16 : 0;
    Caps->maxGsAtomicCounterBuffers = gsAvailable ? 16 : 0;
    Caps->maxTcsAtomicCounters = Caps->maxVertAtomicCounterBuffers * 8;
    Caps->maxTesAtomicCounters = Caps->maxFragAtomicCounterBuffers * 8;
    Caps->maxGsAtomicCounters = Caps->maxCmptAtomicCounterBuffers * 8;
    Caps->maxCombinedAtomicCounterBuffers = gcmMAX(Caps->maxVertAtomicCounterBuffers +
                                                   Caps->maxFragAtomicCounterBuffers +
                                                   Caps->maxGsAtomicCounterBuffers +
                                                   Caps->maxTcsAtomicCounterBuffers +
                                                   Caps->maxTesAtomicCounterBuffers,
                                                   Caps->maxCmptAtomicCounterBuffers);

    Caps->maxCombinedAtomicCounters = Caps->maxCombinedAtomicCounterBuffers * 8;
    Caps->maxAtomicCounterBufferBindings = 16;
    Caps->maxAtomicCounterBufferSize = Caps->maxCombinedAtomicCounters * gcmSIZEOF(gctUINT32);

    Caps->shaderStorageBufferOffsetAlignment = 4;
    Caps->maxVertShaderStorageBlocks = 16;
    Caps->maxFragShaderStorageBlocks = 16;
    Caps->maxCmptShaderStorageBlocks = 16;
    Caps->maxTcsShaderStorageBlocks = tsAvailable ? 16 : 0;
    Caps->maxTesShaderStorageBlocks = tsAvailable ? 16 : 0;
    Caps->maxGsShaderStorageBlocks = gsAvailable ? 16 : 0;
    Caps->maxCombinedShaderStorageBlocks = gcmMAX(Caps->maxVertShaderStorageBlocks + Caps->maxFragShaderStorageBlocks +
                                                  Caps->maxTcsShaderStorageBlocks + Caps->maxTesShaderStorageBlocks,
                                                  Caps->maxCmptShaderStorageBlocks);
    Caps->maxShaderStorageBufferBindings = Caps->maxCombinedShaderStorageBlocks;
    Caps->maxShaderBlockSize = 1 << 27;

    Caps->maxXfbInterleavedComponents = 64;
    Caps->maxXfbSeparateComponents = 64;
    Caps->maxXfbSeparateAttribs = 4;

    Caps->maxProgErrStrLen = 256;

    /* Image limits  */
    Caps->maxVertexImageUniform = 8;
    Caps->maxFragImageUniform = 8;
    Caps->maxCmptImageUniform = 8;
    Caps->maxTcsImageUniform = 0;
    Caps->maxTesImageUniform = 0;
    Caps->maxGsImageUniform = 0;
    Caps->maxImageUnit = 32;
    Caps->maxCombinedImageUniform = gcmMAX(Caps->maxVertexImageUniform + Caps->maxFragImageUniform +
                                           Caps->maxTcsImageUniform + Caps->maxTesImageUniform,
                                           Caps->maxCmptImageUniform);
    Caps->maxCombinedShaderOutputResource = Caps->maxCombinedShaderStorageBlocks + Caps->maxCombinedImageUniform;

    /* Compute limits */
    Caps->maxWorkGroupCount[0] =
    Caps->maxWorkGroupCount[1] =
    Caps->maxWorkGroupCount[2] = 65535;
    Caps->maxWorkGroupSize[0] = 128;
    Caps->maxWorkGroupSize[1] = 128;
    Caps->maxWorkGroupSize[2] = 64;
    /*modify the max WorkGroupInvocation from 128 to 256
    when do barrier in cs, the max value should be 128*/
    Caps->maxWorkGroupInvocation = 256;
    Caps->maxShareMemorySize = 32768;

    /* TS-only limits */
    Caps->maxTessPatchVertices = tsAvailable ? 32 : 0;
    Caps->maxTessGenLevel = tsAvailable ? 64 : 0;
    Caps->tessPatchPR = tsAvailable ? gcvTRUE : gcvFALSE;

    Caps->maxVertUniformVectors = maxVertexUniformVectors;
    Caps->maxFragUniformVectors = maxFragmentUniformVectors;
    Caps->maxCmptUniformVectors = maxFragmentUniformVectors;
    Caps->maxTcsUniformVectors = tsAvailable ? maxVertexUniformVectors : 0;
    Caps->maxTesUniformVectors = tsAvailable ? maxVertexUniformVectors : 0;
    Caps->maxGsUniformVectors = gsAvailable ? maxVertexUniformVectors : 0;


    Caps->maxCombinedVertUniformComponents = Caps->maxVertUniformVectors * 4
                                                + Caps->maxVertUniformBlocks * Caps->maxUniformBlockSize / 4;

    Caps->maxCombinedFragUniformComponents = Caps->maxFragUniformVectors * 4
                                                + Caps->maxFragUniformBlocks * Caps->maxUniformBlockSize / 4;

    Caps->maxCombinedCmptUniformComponents = Caps->maxCmptUniformVectors * 4
                                                + Caps->maxCmptUniformBlocks * Caps->maxUniformBlockSize / 4;

    Caps->maxCombinedTcsUniformComponents = Caps->maxTcsUniformVectors * 4
                                                + Caps->maxTcsUniformBlocks * Caps->maxUniformBlockSize / 4;

    Caps->maxCombinedTesUniformComponents = Caps->maxTesUniformVectors * 4
                                                + Caps->maxTesUniformBlocks * Caps->maxUniformBlockSize / 4;

    /* Determine the maximum uniform locations.
    ** Should work if all locatable uniforms are used as float/int/sampler/image.
    */
    Caps->maxUniformLocations = Caps->maxCombinedTextureImageUnits
                              + Caps->maxCombinedImageUniform
                              + 4 * gcmMAX(Caps->maxCmptUniformVectors,
                                           Caps->maxVertUniformVectors + Caps->maxFragUniformVectors +
                                           Caps->maxTcsUniformVectors + Caps->maxTesUniformVectors);

    /* Should meet spec minimum 1024 requirements */
    Caps->maxUniformLocations = gcmMAX(Caps->maxUniformLocations, 1024);

    /* GS-only limits. */
    Caps->maxGsOutVertices = gsAvailable ? 256 : 0;
    Caps->maxGsInvocationCount = 32;
    Caps->provokingVertex = gcvPROVOKING_VERTEX_LAST;

    /* GLSL extension string. */
    Caps->extensions = __DEFAULT_GLSL_EXTENSION_STRING__;
    return status;
}
/* interface for driver to create recompile patch directives */

/* create a format covertion directive with specified sampler name
 * and sampler info, *PatchDirectivePtr must point to NULL at the
 * first call to this routine, each subsequent call to this routine
 * create a new directive and link with the previous one
 *
 *  Multiple-Layer support:
 *    for some format, it is splited to multiple layers, the  SplitLayers
 *    is the extra layers it splits to, 0 means no extra layer to split,
 *    the multi-layer sampler uniform will be created later when doing
 *    dynmaic shader patch, and the driver need to  bind the split
 *    multi-layer texture objects to the multi-layer sampler uniforms
 */
gceSTATUS
gcCreateInputConversionDirective(
    IN gcUNIFORM               Sampler,
    IN gctINT                  ArrayIndex,
    IN gcsSURF_FORMAT_INFO_PTR FormatInfo,
    IN gceTEXTURE_SWIZZLE *    Swizzle,
    IN gctUINT                 Layers,
    IN gcTEXTURE_MODE          MipFilter,
    IN gcTEXTURE_MODE          MagFilter,
    IN gcTEXTURE_MODE          MinFilter,
    IN gctFLOAT                LODBias,
    IN gctINT                  Projected,
    IN gctINT                  Width,
    IN gctINT                  Height,
    IN gctINT                  Depth,
    IN gctINT                  Dimension,
    IN gctINT                  MipLevelMax,
    IN gctINT                  MipLevelMin,
    IN gctBOOL                 SRGB,
    IN gctBOOL                 AppendToLast,
    IN gctBOOL                 DepthStencilMode,
    IN gctBOOL                 NeedFormatConvert,
    IN gcSHADER_KIND           ShaderKind,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS           status = gcvSTATUS_OK;
    gcPatchDirective   *pointer;
    gcsInputConversion *fc;

    gcmHEADER_ARG("SamplerName=%s PatchDirectivePtr=0x%x", Sampler->name,
                                                         PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcSHADER_CreateFormatConvertionDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    if (AppendToLast)
    {
        gcPatchDirective *node = (*PatchDirectivePtr);
        while(node && node->next != gcvNULL)
        {
            node = node->next;
        }

        if (node)
        {
            node->next = pointer;
        }
        else
        {
            *PatchDirectivePtr = pointer;
        }
        pointer->next = gcvNULL;
    }
    else
    {
        pointer->next      = *PatchDirectivePtr;
        *PatchDirectivePtr = pointer;
    }

    pointer->kind      = gceRK_PATCH_TEXLD_FORMAT_CONVERSION;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsInputConversion),
                            (gctPOINTER *)&fc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcSHADER_CreateFormatConvertionDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.formatConversion = fc;

    if (Layers == 0)
    {
#if __LOCAL_TESTING__
    fc->layers                = 1;
#else
    fc->layers                = FormatInfo->layers;
#endif
    }
    else
    {
        fc->layers = Layers;
    }

    fc->orgShaderSampler      = Sampler;
    fc->samplers[0]           = Sampler;
    fc->samplers[1]           = fc->samplers[2] = fc->samplers[3] = gcvNULL;
    fc->arrayIndex            = ArrayIndex;
    fc->samplerInfo           = *FormatInfo;
    fc->mipFilter             = MipFilter;
    fc->magFilter             = MagFilter;
    fc->minFilter             = MinFilter;
    fc->LODBias               = LODBias;
    fc->projected             = Projected;
    fc->width                 = Width;
    fc->height                = Height;
    fc->depth                 = Depth;
    fc->dimension             = Dimension;
    fc->mipLevelMax           = MipLevelMax;
    fc->mipLevelMin           = MipLevelMin;
    fc->srgb                  = SRGB;
    fc->depthStencilMode      = DepthStencilMode;
    fc->shaderKind            = ShaderKind;
    fc->needSwizzle           = (Swizzle[gcvTEXTURE_COMPONENT_R] != gcvTEXTURE_SWIZZLE_R) ||
                                (Swizzle[gcvTEXTURE_COMPONENT_G] != gcvTEXTURE_SWIZZLE_G) ||
                                (Swizzle[gcvTEXTURE_COMPONENT_B] != gcvTEXTURE_SWIZZLE_B) ||
                                (Swizzle[gcvTEXTURE_COMPONENT_A] != gcvTEXTURE_SWIZZLE_A);
    fc->needFormatConvert     = NeedFormatConvert;
    gcoOS_MemCopy(fc->swizzle, Swizzle, gcvTEXTURE_COMPONENT_NUM * sizeof(gceTEXTURE_SWIZZLE));

    gcmFOOTER();
    return status;
}

/* create a output covertion directive with specified output index
 * and sampler info, *PatchDirectivePtr must point to NULL at the
 * first call to this routine, each subsequent call to this routine create
 *  a new directive and link with the previous one
 *
 *  Multiple-Layer support:
 *    for some format, it is splitted to multiple layers, the  SplitLayers
 *    is the extra layers it splits to, 0 means no extra layer to split,
 *    the multi-layer surface will be created later when doing
 *    dynamic shader patch
 */
gceSTATUS
gcCreateOutputConversionDirective(
    IN gctINT                  OutputLocation,
    IN gcsSURF_FORMAT_INFO_PTR FormatInfo,
    IN gctUINT                 Layers,
    IN gctBOOL                 AppendToLast,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS             status = gcvSTATUS_OK;
    gcPatchDirective    * pointer;
    gcsOutputConversion * fc;

    gcmHEADER_ARG("FormatName=%s PatchDirectivePtr=0x%x", FormatInfo->formatName,
                                                         PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcSHADER_CreateFormatConvertionDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    if (AppendToLast)
    {
        gcPatchDirective *node = (*PatchDirectivePtr);
        while(node && node->next != gcvNULL)
        {
            node = node->next;
        }

        if (node)
        {
            node->next = pointer;
        }
        else
        {
            *PatchDirectivePtr = pointer;
        }
        pointer->next = gcvNULL;
    }
    else
    {
        pointer->next      = *PatchDirectivePtr;
        *PatchDirectivePtr = pointer;
    }

    /* link the new directive to existing directive */
    pointer->kind      = gceRK_PATCH_OUTPUT_FORMAT_CONVERSION;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsOutputConversion),
                            (gctPOINTER *)&fc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateOutputConvertionDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.outputConversion = fc;
    if (Layers == 0)
    {
#if __LOCAL_TESTING__
    fc->layers             = 1;
#else
    fc->layers             = FormatInfo->layers;
#endif
    }
    else
    {
        fc->layers = Layers;
    }
    fc->outputLocation     = OutputLocation;
    fc->outputs[0]         = fc->outputs[1] = fc->outputs[2] = fc->outputs[3] = gcvNULL;
    fc->formatInfo         = *FormatInfo;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateDepthComparisonDirective(
    IN gcsSURF_FORMAT_INFO_PTR FormatrInfo,
    IN gcUNIFORM               Sampler,
    IN gctINT                  ArrayIndex,
    IN gctUINT                 CompMode,
    IN gctUINT                 CompFunction,
    OUT gcPatchDirective **    PatchDirectivePtr
    )
{
    gceSTATUS               status = gcvSTATUS_OK;
    gcPatchDirective *      pointer;
    gcsDepthComparison *    dc;

    gcmHEADER_ARG("SamplerName=%s PatchDirectivePtr=0x%x",
                  Sampler->name, PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL && FormatrInfo != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcSHADER_CreateFormatConvertionDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_DEPTH_COMPARISON;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsDepthComparison),
                            (gctPOINTER *)&dc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcSHADER_CreateFormatConvertionDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.depthComparison = dc;
    dc->sampler      = Sampler;
    dc->formatInfo   = *FormatrInfo;
    dc->arrayIndex   = ArrayIndex;
    dc->compMode     = CompMode;
    dc->convertD32F  = gcvFALSE;
    dc->compFunction = CompFunction;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcIsSameDepthComparisonDirectiveExist(
    IN gcsSURF_FORMAT_INFO_PTR SamplerInfo,
    IN gcUNIFORM               Sampler,
    IN gctINT                  ArrayIndex,
    IN gctUINT                 CompMode,
    IN gctUINT                 CompFunction,
    IN gcPatchDirective *    PatchDirectivePtr
    )
{
    gceSTATUS               status = gcvSTATUS_FALSE;
    gcPatchDirective *  curDirective = PatchDirectivePtr;

    gcmHEADER_ARG("SamplerName=%s PatchDirectivePtr=0x%x",
                  Sampler->name, PatchDirectivePtr);

    for (; curDirective; curDirective = curDirective->next)
    {
        if (curDirective->kind == gceRK_PATCH_DEPTH_COMPARISON)
        {
            gcsDepthComparison * dc = curDirective->patchValue.depthComparison;
            if (dc->sampler == Sampler
                && dc->arrayIndex == ArrayIndex
                && dc->compMode == CompMode
                && dc->compFunction == CompFunction)
            {
                return gcvSTATUS_TRUE;
            }
        }
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcIsSameInputDirectiveExist(
    IN gcUNIFORM               Sampler,
    IN gctINT                  ArrayIndex,
    IN gcPatchDirective *      PatchDirectivePtr
    )
{
    gceSTATUS               status = gcvSTATUS_FALSE;
    gcPatchDirective *  curDirective = PatchDirectivePtr;

    gcmHEADER_ARG("SamplerName=%s PatchDirectivePtr=0x%x",
                  Sampler->name, PatchDirectivePtr);

    for (; curDirective; curDirective = curDirective->next)
    {
        if (curDirective->kind == gceRK_PATCH_TEXLD_FORMAT_CONVERSION)
        {
            gcsInputConversion * fc = curDirective->patchValue.formatConversion;
            if (fc->orgShaderSampler == Sampler
                && fc->arrayIndex == ArrayIndex)
            {
                return gcvSTATUS_TRUE;
            }
        }
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateColorFactoringDirective(
    IN gctINT                  OutputLocation,
    IN gctINT                  FactorCount,
    IN gctFLOAT *              FactorValue,
    IN gctBOOL                 AppendToLast,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS                 status = gcvSTATUS_OK;
    gcPatchDirective *        pointer;
    gcsPatchColorFactoring *  cf;
    gctINT                    i;

    gcmHEADER_ARG("PatchDirectivePtr=0x%x",PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateColorFactoringDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    if (AppendToLast)
    {
        gcPatchDirective *node = (*PatchDirectivePtr);
        while(node && node->next != gcvNULL)
        {
            node = node->next;
        }

        if (node)
        {
            node->next = pointer;
        }
        else
        {
            *PatchDirectivePtr = pointer;
        }
        pointer->next = gcvNULL;
    }
    else
    {
        pointer->next      = *PatchDirectivePtr;
        *PatchDirectivePtr = pointer;
    }

    /* link the new directive to existing directive */
    pointer->kind      = gceRK_PATCH_COLOR_FACTORING;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchColorFactoring),
                            (gctPOINTER *)&cf);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateColorFactoringDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.colorFactoring = cf;
    cf->outputLocation        = OutputLocation;
    for (i = 0; i < 4; i++)
    {
        if (i < FactorCount)
        {
            cf->value[i] = FactorValue[i];
        }
        else
        {
            cf->value[i] = 1.0f;
        }
    }

    gcmFOOTER();
    return status;
}

/* directive to blend color:
 *    gl_FragColor.rgba *= gl_FragColor.a
 */
gceSTATUS
gcCreateAlphaBlendingDirective(
    IN gctINT                  OutputLocation,
    IN gctBOOL                 AppendToLast,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS                 status = gcvSTATUS_OK;
    gcPatchDirective *        pointer;
    gcsPatchAlphaBlending *   cf;

    gcmHEADER_ARG("PatchDirectivePtr=0x%x",PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateColorFactoringDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    if (AppendToLast)
    {
        gcPatchDirective *node = (*PatchDirectivePtr);
        while(node && node->next != gcvNULL)
        {
            node = node->next;
        }

        if (node)
        {
            node->next = pointer;
        }
        else
        {
            *PatchDirectivePtr = pointer;
        }
        pointer->next = gcvNULL;
    }
    else
    {
        pointer->next      = *PatchDirectivePtr;
        *PatchDirectivePtr = pointer;
    }

    /* link the new directive to existing directive */
    pointer->kind      = gceRK_PATCH_ALPHA_BLENDING;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchAlphaBlending),
                            (gctPOINTER *)&cf);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateColorFactoringDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.alphaBlending = cf;
    cf->outputLocation        = OutputLocation;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateDepthBiasDirective(
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS                 status = gcvSTATUS_OK;
    gcPatchDirective *        pointer;
    gcsPatchDepthBias *       cf;

    gcmHEADER_ARG("PatchDirectivePtr=0x%x",PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateColorFactoringDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_DEPTH_BIAS;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchDepthBias),
                            (gctPOINTER *)&cf);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateColorFactoringDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.depthBias = cf;
    cf->depthBiasUniform          = gcvNULL;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateNP2TextureDirective(
    IN gctINT TextureCount,
    IN gcNPOT_PATCH_PARAM_PTR NP2Texture,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS                 status = gcvSTATUS_OK;
    gcPatchDirective *        pointer;
    gcsPatchNP2Texture *      cf = gcvNULL;
    gcNPOT_PATCH_PARAM_PTR np2Texture = gcvNULL;
    gctINT i;

    gcmHEADER_ARG("PatchDirectivePtr=0x%x",PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateNP2TextureDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_NP2TEXTURE;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchNP2Texture),
                            (gctPOINTER *)&cf);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFATAL("gcCreateNP2TextureDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    status = gcoOS_Allocate(gcvNULL,
                            TextureCount * gcmSIZEOF(gcNPOT_PATCH_PARAM),
                            (gctPOINTER *)&np2Texture);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFATAL("gcCreateNP2TextureDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));

        if (cf != gcvNULL)
        {
            gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, cf));
        }
        gcmFOOTER();
        return status;
    }

    for (i = 0; i < TextureCount; i++)
    {
        np2Texture[i].texDimension = NP2Texture[i].texDimension;
        np2Texture[i].samplerSlot = NP2Texture[i].samplerSlot;
        np2Texture[i].addressMode[0] = NP2Texture[i].addressMode[0];
        np2Texture[i].addressMode[1] = NP2Texture[i].addressMode[1];
        np2Texture[i].addressMode[2] = NP2Texture[i].addressMode[2];
    }

    pointer->patchValue.np2Texture  = cf;
    cf->textureCount = TextureCount;
    cf->np2Texture = np2Texture;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateGlobalWorkSizeDirective(
    IN gcUNIFORM                GlobalWidth,
    IN gcUNIFORM                GroupWidth,
    IN gctBOOL                  PatchRealGlobalWorkSize,
    OUT gcPatchDirective  **    PatchDirectivePtr
    )
{
    gceSTATUS                   status = gcvSTATUS_OK;
    gcPatchDirective *          pointer;
    gcsPatchGlobalWorkSize *    globalWorkSize;

    gcmHEADER_ARG("PatchDirectivePtr=0x%x", PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateGlobalWorkSizeDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_GLOBAL_WORK_SIZE;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchGlobalWorkSize),
                            (gctPOINTER *)&globalWorkSize);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateGlobalWorkSizeDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    gcoOS_ZeroMemory(globalWorkSize, gcmSIZEOF(gcsPatchGlobalWorkSize));

    pointer->patchValue.globalWorkSize  = globalWorkSize;
    globalWorkSize->globalWidth = GlobalWidth;
    globalWorkSize->groupWidth  = GroupWidth;
    globalWorkSize->patchRealGlobalWorkSize  = PatchRealGlobalWorkSize;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateCLLongULongDirective(
    IN  gctUINT                 InstructionIndex,
    IN  gctUINT                 ChannelCount,
    OUT gcPatchDirective  **    PatchDirectivePtr
)
{
    gceSTATUS                   status = gcvSTATUS_OK;

    gcPatchDirective *          pointer;
    gcsPatchLongULong *         longULong;

    gcmHEADER();
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFATAL("gcCreateCLLongULongDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_CL_LONGULONG;
    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchLongULong),
                            (gctPOINTER *) &longULong);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFATAL("gcSHADER_CreateReadImageDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    pointer->patchValue.longULong = longULong;
    longULong->instructionIndex   = InstructionIndex;
    longULong->channelCount  = ChannelCount;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateReadImageDirective(
    IN gctUINT                  SamplerNum,
    IN gctUINT                  ImageDataIndex,
    IN gctUINT                  ImageSizeIndex,
    IN gctUINT                  SamplerValue,
    IN gctUINT                  ChannelDataType,
    IN gctUINT                  ChannelOrder,
    IN gctUINT                  ImageType,
    IN gctBOOL                  PatchUnnormReadImage,
    IN gctBOOL                  imageLoad,
    OUT gcPatchDirective  **    PatchDirectivePtr
    )
{
    gceSTATUS                   status = gcvSTATUS_OK;
    gcPatchDirective *          pointer;
    gcsPatchReadImage *         readImage;

    gcmHEADER_ARG("SamplerNum=%d ImageDataIndex=%d ImageSizeIndex=%d ISamplerValue=0x%x PatchDirectivePtr=0x%x",
                  SamplerNum, ImageDataIndex, ImageSizeIndex, SamplerValue, PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFATAL("gcSHADER_CreateReadImageDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = PatchUnnormReadImage ? gceRK_PATCH_READ_IMAGE_UNNORM
                                              : gceRK_PATCH_READ_IMAGE;
    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchReadImage),
                            (gctPOINTER *) &readImage);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFATAL("gcSHADER_CreateReadImageDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    pointer->patchValue.readImage = readImage;
    readImage->samplerNum         = SamplerNum;
    readImage->imageDataIndex     = ImageDataIndex;
    readImage->imageSizeIndex     = ImageSizeIndex;
    readImage->samplerValue       = SamplerValue;
    readImage->channelDataType    = ChannelDataType;
    readImage->channelOrder       = ChannelOrder;
    readImage->imageType          = ImageType;
    readImage->useImageLoad       = imageLoad;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateWriteImageDirective(
    IN gctUINT                  SamplerNum,
    IN gctUINT                  ImageDataIndex,
    IN gctUINT                  ImageSizeIndex,
    IN gctUINT                  ChannelDataType,
    IN gctUINT                  ChannelOrder,
    IN gctUINT                  ImageType,
    IN gctBOOL                  imageStore,
    OUT gcPatchDirective  **    PatchDirectivePtr
    )
{
    gceSTATUS                   status = gcvSTATUS_OK;
    gcPatchDirective *          pointer;
    gcsPatchWriteImage *        writeImage;

    gcmHEADER_ARG("ChannelOrder=%d DataType=%d PatchDirectivePtr=0x%x",
                  ChannelOrder, ChannelDataType, PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFATAL("gcSHADER_CreateWriteImageDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_WRITE_IMAGE;
    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchReadImage),
                            (gctPOINTER *) &writeImage);
    if (gcmIS_ERROR(status))
    {
        /* Error. */
        gcmFATAL("gcSHADER_CreateWriteImageDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    pointer->patchValue.writeImage = writeImage;
    writeImage->samplerNum         = SamplerNum;
    writeImage->imageDataIndex     = ImageDataIndex;
    writeImage->imageSizeIndex     = ImageSizeIndex;
    writeImage->channelDataType    = ChannelDataType;
    writeImage->channelOrder       = ChannelOrder;
    writeImage->imageType          = ImageType;
    writeImage->imageStore         = imageStore;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateYFlippedTextureDirective(
    IN gcUNIFORM               Sampler,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS          status = gcvSTATUS_OK;
    gcPatchDirective * pointer;
    gcsPatchYFlippedTexture *fc;

    gcmHEADER_ARG("SamplerName=%s PatchDirectivePtr=0x%x", Sampler->name,
                                                         PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateYFlippedTextureDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_Y_FLIPPED_TEXTURE;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchYFlippedTexture),
                            (gctPOINTER *)&fc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateYFlippedTextureDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.yFlippedTexture = fc;
    fc->yFlippedTexture = Sampler;
    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateRemoveAssignmentForAlphaChannel(
    IN gctBOOL *               RemoveOutputAlpha,
    IN gctUINT                 OutputCount,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS          status = gcvSTATUS_OK;
    gcPatchDirective * pointer;
    gcsPatchRemoveAssignmentForAlphaChannel *fc;
    gctUINT i;

    gcmHEADER_ARG("PatchDirectivePtr=0x%x", PatchDirectivePtr);
    gcmASSERT(PatchDirectivePtr != gcvNULL);
    gcmASSERT(OutputCount <= gcdMAX_DRAW_BUFFERS);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gceRK_PATCH_REMOVE_ASSIGNMENT_FOR_ALPHA: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_REMOVE_ASSIGNMENT_FOR_ALPHA;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchRemoveAssignmentForAlphaChannel),
                            (gctPOINTER *)&fc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gceRK_PATCH_REMOVE_ASSIGNMENT_FOR_ALPHA: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    gcoOS_ZeroMemory(fc, gcmSIZEOF(gcsPatchRemoveAssignmentForAlphaChannel));

    pointer->patchValue.removeOutputAlpha = fc;

    for (i = 0; i < gcmMIN(OutputCount, gcdMAX_DRAW_BUFFERS); i++)
    {
        pointer->patchValue.removeOutputAlpha->removeOutputAlpha[i] = RemoveOutputAlpha[i];
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateYFlippedShaderDirective(
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS          status = gcvSTATUS_OK;
    gcPatchDirective * pointer;
    gcsPatchYFlippedShader *fc;

    gcmHEADER();
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateYFlippedShaderDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_Y_FLIPPED_SHADER;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchYFlippedShader),
                            (gctPOINTER *)&fc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateYFlippedTextureDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.yFlippedShader = fc;
    fc->rtHeight         = gcvNULL;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateSampleMaskDirective(
    IN gctBOOL                 AlphaToConverageEnabled,
    IN gctBOOL                 SampleConverageEnabled,
    IN gctBOOL                 SampleMaskEnabled,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS           status = gcvSTATUS_OK;
    gcPatchDirective *  pointer;
    gcsPatchSampleMask *fc;

    gcmHEADER();
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateSampleMaskDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_SAMPLE_MASK;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchSampleMask),
                            (gctPOINTER *)&fc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateSampleMaskDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.sampleMask = fc;

    fc->alphaToConverageEnabled = AlphaToConverageEnabled;
    fc->sampleConverageEnabled  = SampleConverageEnabled;
    fc->sampleMaskEnabled       = SampleMaskEnabled;
    fc->sampleCoverageValue_Invert  = gcvNULL;
    fc->sampleMaskValue             = gcvNULL;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateSignExtent(
    IN gcUNIFORM               Uniform,
    IN gctUINT16               ArrayIndex,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS                  status = gcvSTATUS_OK;
    gcPatchDirective *         pointer;
    gcsPatchSignExtent *       fc;

    gcmHEADER();
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateSignExtent: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_SIGNEXTENT;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchSignExtent),
                            (gctPOINTER *)&fc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateSignExtent: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.signExtent = fc;

    fc->uniform = Uniform;
    fc->arrayIndex = ArrayIndex;

    gcmFOOTER();
    return status;
}


gceSTATUS
gcCreateTcsInputMismatch(
    IN  gctINT                  InputCount,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS                       status = gcvSTATUS_OK;
    gcPatchDirective *              pointer;
    gcsPatchTCSInputCountMismatch * fc;

    gcmHEADER();
    gcmASSERT(PatchDirectivePtr != gcvNULL);

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateTcsInputMismatch: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_TCS_INPUT_COUNT_MISMATCH;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchSignExtent),
                            (gctPOINTER *)&fc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateTcsInputMismatch: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.inputMismatch = fc;

    fc->inputVertexCount = InputCount;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateColorKillDirective(
    IN gctFLOAT                Value,
    OUT gcPatchDirective  **   PatchDirectivePtr
    )
{
    gceSTATUS           status = gcvSTATUS_OK;
    gcPatchDirective *  pointer;
    gcsPatchColorKill * fc;

    gcmHEADER();

    if (PatchDirectivePtr == gcvNULL)
    {
        gcmASSERT(gcvFALSE);
        gcmFOOTER();
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcPatchDirective),
                            (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateColorKillDirective: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next      = *PatchDirectivePtr;
    pointer->kind      = gceRK_PATCH_COLOR_KILL;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
                            gcmSIZEOF(gcsPatchColorKill),
                            (gctPOINTER *)&fc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateColorKill: gcoOS_Allocate failed status=%d(%s)",
                 status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.colorKill = fc;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcCreateAlphaBlendDirective(
IN  gctINT                 OutputLocation,
OUT gcPatchDirective  **   PatchDirectivePtr
)
{
    gceSTATUS           status = gcvSTATUS_OK;
    gcPatchDirective *  pointer;
    gcsPatchAlphaBlend * fc;

    if (PatchDirectivePtr == gcvNULL)
    {
        gcmASSERT(gcvFALSE);
        return gcvSTATUS_INVALID_ARGUMENT;
    }

    status = gcoOS_Allocate(gcvNULL,
        gcmSIZEOF(gcPatchDirective),
        (gctPOINTER *)&pointer);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateColorKillDirective: gcoOS_Allocate failed status=%d(%s)",
            status, gcoOS_DebugStatus2Name(status));
        return status;
    }

    /* link the new directive to existing directive */
    pointer->next = *PatchDirectivePtr;
    pointer->kind = gceRK_PATCH_ALPHA_BLEND;

    *PatchDirectivePtr = pointer;

    status = gcoOS_Allocate(gcvNULL,
        gcmSIZEOF(gcsPatchAlphaBlend),
        (gctPOINTER *)&fc);
    if (gcmIS_ERROR(status)) {
        /* Error. */
        gcmFATAL("gcCreateColorKill: gcoOS_Allocate failed status=%d(%s)",
            status, gcoOS_DebugStatus2Name(status));
        gcmFOOTER();
        return status;
    }
    pointer->patchValue.alphaBlend = fc;
    fc->outputLocation = OutputLocation;
    fc->outputs[0] = fc->outputs[1] = fc->outputs[2] = fc->outputs[3] = gcvNULL;
    fc->alphaBlendEquation = gcvNULL;
    fc->rtWidthHeight = gcvNULL;
    fc->blendConstColor = gcvNULL;
    fc->rtSampler = gcvNULL;

    return status;
}


gceSTATUS
gcDestroyPatchDirective(
    IN OUT gcPatchDirective **   PatchDirectivePtr
    )
{
    gceSTATUS          status        = gcvSTATUS_OK;
    gcPatchDirective * curDirective  = *PatchDirectivePtr;
    gcPatchDirective * nextDirective;

    while (curDirective)
    {
        nextDirective = curDirective->next;

        switch(curDirective->kind)
        {
        case gceRK_PATCH_TEXLD_FORMAT_CONVERSION:
            gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.formatConversion));
            break;
        case gceRK_PATCH_OUTPUT_FORMAT_CONVERSION:
            gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.outputConversion));
            break;
        case gceRK_PATCH_DEPTH_COMPARISON:
            gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.depthComparison));
            break;
        case gceRK_PATCH_COLOR_FACTORING:
            gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.colorFactoring));
            break;
        case gceRK_PATCH_ALPHA_BLENDING:
            gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.alphaBlending));
            break;
        case gceRK_PATCH_DEPTH_BIAS:
            gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.depthBias));
            break;
        case gceRK_PATCH_NP2TEXTURE:
            gcmONERROR(gcmOS_SAFE_FREE(gcvNULL, curDirective->patchValue.np2Texture->np2Texture));

            gcmONERROR(gcoOS_Free(gcvNULL,
                curDirective->patchValue.np2Texture));
            break;
        case gceRK_PATCH_GLOBAL_WORK_SIZE:
            gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.globalWorkSize));
            break;
        case gceRK_PATCH_READ_IMAGE:
        case gceRK_PATCH_READ_IMAGE_UNNORM:
            gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.readImage));
            break;
        case gceRK_PATCH_WRITE_IMAGE:
            gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.writeImage));
            break;
        case gceRK_PATCH_Y_FLIPPED_TEXTURE:
           gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.yFlippedTexture));
            break;
        case gceRK_PATCH_REMOVE_ASSIGNMENT_FOR_ALPHA:
           gcmONERROR(gcoOS_Free(gcvNULL,
                           curDirective->patchValue.removeOutputAlpha));
            break;

        case gceRK_PATCH_Y_FLIPPED_SHADER:
            gcmONERROR(gcoOS_Free(gcvNULL,
                            curDirective->patchValue.yFlippedShader));
            break;
        case gceRK_PATCH_SAMPLE_MASK:
             gcmONERROR(gcoOS_Free(gcvNULL,
                            curDirective->patchValue.sampleMask));
             break;
        case gceRK_PATCH_SIGNEXTENT:
             gcmONERROR(gcoOS_Free(gcvNULL,
                            curDirective->patchValue.signExtent));
             break;
        case gceRK_PATCH_TCS_INPUT_COUNT_MISMATCH:
             gcmONERROR(gcoOS_Free(gcvNULL,
                            curDirective->patchValue.inputMismatch));
             break;
        case gceRK_PATCH_CL_LONGULONG:
             gcmONERROR(gcoOS_Free(gcvNULL,
                            curDirective->patchValue.longULong));
             break;
        case gceRK_PATCH_ALPHA_BLEND:
            gcmONERROR(gcoOS_Free(gcvNULL,
                curDirective->patchValue.alphaBlend));
            break;
        default:
            gcmASSERT(gcvFALSE);  /* not implemented yet */
            break;
        }
        gcmONERROR(gcoOS_Free(gcvNULL, curDirective));

        curDirective = nextDirective;
    }
    *PatchDirectivePtr = gcvNULL;

OnError:
    /* Return the status. */
    return status;
}


/* Query samplers ids for PrimarySamplerID in PatchDirectivePtr
 * if found PrimarySamplerID in the directive, return layers
 * in *Layers, all sampler id (physical) in SamplersID
 */
gceSTATUS
gcQueryFormatConvertionDirectiveSampler(
    IN   gcPatchDirective *   PatchDirectivePtr,
    IN   gcUNIFORM            Sampler,
    IN   gctINT               ArrayIndex,
    IN   gctUINT              SamplerBaseOffset,
    OUT  gctUINT *            SamplersID,
    OUT  gctUINT *            Layers,
    OUT  gctBOOL *            Swizzled
    )
{
    gcmASSERT(SamplersID != gcvNULL && Layers != gcvNULL);
    while (PatchDirectivePtr)
    {
        if (PatchDirectivePtr->kind == gceRK_PATCH_TEXLD_FORMAT_CONVERSION)
        {
            gcsInputConversion * formatConversion =
                      PatchDirectivePtr->patchValue.formatConversion;

            if (formatConversion->orgShaderSampler == Sampler
                && formatConversion->arrayIndex == ArrayIndex)
            {
                gctINT i;
                /* found the primary sampler id */
                *Layers = formatConversion->layers;
                gcmASSERT(formatConversion->layers <= 4 && formatConversion->layers >=1 );
                if (Swizzled)
                {
                    *Swizzled = formatConversion->needSwizzle;
                }
                /* the first sampler may be from an array, so need to add arrayIndex */
                SamplersID[0] = (gctUINT)(formatConversion->samplers[0]->physical + ArrayIndex + SamplerBaseOffset);

                for (i = 1; i < formatConversion->layers; i++)
                {
                    if (isUniformInactive(formatConversion->samplers[i]) ||
                        GetUniformPhysical(formatConversion->samplers[i]) == -1)
                    {
                        SamplersID[i] = (gctUINT)-1;
                    }
                    else
                    {
                        SamplersID[i] = (gctUINT)GetUniformPhysical(formatConversion->samplers[i]) + SamplerBaseOffset;
                    }
                }
                return gcvSTATUS_OK;
            }
        }
        PatchDirectivePtr = PatchDirectivePtr->next;
    }
    return gcvSTATUS_NOT_FOUND;
}

/* Query compiler generated output locations for PrimaryOutputLocation
 * in PatchDirectivePtr, if PrimaryOutputLocation is found in the directive,
 * return layers in *Layers, all outputs location in OutputsLocation
 */
gceSTATUS
gcQueryOutputConversionDirective(
    IN   gcPatchDirective *   PatchDirectivePtr,
    IN   gctUINT              PrimaryOutputLocation,
    OUT  gctUINT *            OutputsLocation,
    OUT  gctUINT *            Layers
    )
{
    gceSTATUS status = gcvSTATUS_NOT_FOUND;

    gcmASSERT(OutputsLocation != gcvNULL && Layers != gcvNULL);
    while (PatchDirectivePtr)
    {
        if (PatchDirectivePtr->kind == gceRK_PATCH_OUTPUT_FORMAT_CONVERSION)
        {
            gcsOutputConversion * outputConversion =
                      PatchDirectivePtr->patchValue.outputConversion;
            if (outputConversion->outputLocation == (gctINT)PrimaryOutputLocation)
            {
                gctINT i;
                /* found the primary sampler id */
                *Layers = outputConversion->layers;
                gcmASSERT(outputConversion->layers <= 4 && outputConversion->layers >=1 );
                for (i=0; i < outputConversion->layers; i++)
                {
                    if(outputConversion->outputs[i])
                    {
                        gcmASSERT(outputConversion->outputs[i]->location >= 0);
                        OutputsLocation[i] = (gctUINT)outputConversion->outputs[i]->location;
                    }
                    else
                    {
                        gcmONERROR(gcvSTATUS_NOT_FOUND);
                    }
                }
                status =  gcvSTATUS_OK;
            }
        }
        PatchDirectivePtr = PatchDirectivePtr->next;
    }
OnError:
    return status;
}

gceSTATUS
gcSHADER_InsertNOP2BeforeCode(
    IN OUT gcSHADER                Shader,
    OUT gctUINT                    CodeIndex,
    OUT gctUINT                    AddCodeCount,
    IN  gctBOOL                    ReplaceJmp,
    IN  gctBOOL                    MergeWithCodeIndexFunc
    )
{
    gceSTATUS status;
    gctUINT origCodeCount = Shader->lastInstruction;
    gctUINT newCodeCount = origCodeCount + AddCodeCount;
    gctINT i, j;
    gcSL_INSTRUCTION code;
    gcSL_OPCODE  opcode;
    gcSHADER_LABEL label;

    gcmHEADER_ARG("Shader=0x%x CodeIndex=%d AddCodeCount=%d", Shader, CodeIndex, AddCodeCount);

    if (((gctINT)CodeIndex) < 0 || ((gctINT)AddCodeCount) <= 0)
    {
        gcmFOOTER_NO();
        return gcvSTATUS_OK;
    }

    /* add NOPs to the end of the shader */
    Shader->instrIndex = gcSHADER_SOURCE0;
    for (i=0; i < (gctINT)AddCodeCount; i++)
    {
        gcmONERROR(gcSHADER_AddOpcode(Shader, gcSL_NOP, 0, 0, 0, 0, 0));
    }

    /* move the code down by Num code */
    for (i = origCodeCount - 1, j = 0; i >= (gctINT)CodeIndex; i--, j++)
    {
        Shader->code[newCodeCount - 1 - j] = Shader->code[i];
        gcSL_SetInst2NOP(&Shader->code[i]);
    }

    /* 3. update the call and jump index. */
    for (i = 0; i < (gctINT)newCodeCount; i++)
    {
        code = &Shader->code[i];
        opcode = gcmSL_OPCODE_GET(code->opcode, Opcode);

        if (opcode == gcSL_CALL)
        {
            if ((code->tempIndex > CodeIndex &&
                 code->tempIndex < (origCodeCount + 10))
                ||
                (code->tempIndex == CodeIndex &&
                 !MergeWithCodeIndexFunc))
            {
                code->tempIndex += AddCodeCount;
            }
        }

        if (opcode == gcSL_JMP)
        {
            /* Jmp to the new instruction. */
            if (ReplaceJmp)
            {
                if (code->tempIndex > CodeIndex &&
                    code->tempIndex < (origCodeCount + 10))
                {
                    code->tempIndex += AddCodeCount;
                }
            }
            /* Jmp to the original instruction. */
            else
            {
                if (code->tempIndex >= CodeIndex &&
                    code->tempIndex < (origCodeCount + 10))
                {
                    code->tempIndex += AddCodeCount;
                }
            }
        }
    }

    /* TODO: modify jump/call target index on function _insertNOP2BeforeCode. */
    for (i = 0; i < (gctINT)Shader->functionCount; ++i)
    {
        /* Skip empty function. */
        if (Shader->functions[i]->codeCount == 0)
        {
            continue;
        }

        /* If the index is the head of function, check if we need to update the function head. */
        if (Shader->functions[i]->codeStart == CodeIndex)
        {
            if (MergeWithCodeIndexFunc)
            {
                Shader->functions[i]->codeCount += AddCodeCount;
            }
            else
            {
                Shader->functions[i]->codeStart += AddCodeCount;
            }
        }
        /* If the index is the tail of function, check if we need to update the function head. */
        else if (Shader->functions[i]->codeStart + Shader->functions[i]->codeCount - 1 == CodeIndex)
        {
            if (MergeWithCodeIndexFunc)
            {
                Shader->functions[i]->codeCount += AddCodeCount;
            }
        }
        /* If the code is inside the function, update the code count. */
        else if (Shader->functions[i]->codeStart < CodeIndex &&
                 Shader->functions[i]->codeStart + Shader->functions[i]->codeCount - 1 > CodeIndex)
        {
            Shader->functions[i]->codeCount += AddCodeCount;
        }
        /* If the code is before the function, update the code start index. */
        else if (Shader->functions[i]->codeStart > CodeIndex)
        {
            Shader->functions[i]->codeStart += AddCodeCount;
        }
    }

    for (i = 0; i < (gctINT)Shader->kernelFunctionCount; ++i)
    {
        if (Shader->kernelFunctions[i]->codeStart <= CodeIndex &&
            Shader->kernelFunctions[i]->codeEnd >= CodeIndex &&
            Shader->kernelFunctions[i]->codeCount > 0)
        {
            Shader->kernelFunctions[i]->codeCount += AddCodeCount;
            Shader->kernelFunctions[i]->codeEnd += AddCodeCount;
        }

        if (Shader->kernelFunctions[i]->codeStart > CodeIndex &&
            Shader->kernelFunctions[i]->codeCount > 0)
        {
            Shader->kernelFunctions[i]->codeStart += AddCodeCount;
            Shader->kernelFunctions[i]->codeEnd += AddCodeCount;
        }
    }

    /* 5. adjust shader label's defined */
    for (label = Shader->labels; label != gcvNULL; label = label->next)
    {
        gcSHADER_LINK link;

        if (label->defined > CodeIndex)
            label->defined += AddCodeCount;
        link = label->referenced;
        while (link)
        {
            if (link->referenced > CodeIndex)
                link->referenced += AddCodeCount;
            link = link->next;
        }
    }
    Shader->instrIndex = gcSHADER_OPCODE;

    /* Success. */
    gcmFOOTER_NO();
    return gcvSTATUS_OK;

OnError:
    gcmFOOTER_NO();
    return status;
}

gceSTATUS
gcSHADER_MoveCodeListBeforeCode(
    IN OUT gcSHADER                 Shader,
    IN  gctUINT                     CodeIndex,
    IN  gctUINT                     CodeHead,
    IN  gctUINT                     CodeTail
    )
{
    gceSTATUS                       status = gcvSTATUS_OK;
    gcSL_INSTRUCTION                code;
    gcSL_OPCODE                     opcode;
    gctUINT                         i;
    gctUINT                         codeCount = CodeTail - CodeHead + 1;
    gctINT16                        idxOffset = (gctINT16)CodeIndex - (gctINT16)CodeHead;
    gctUINT                         codeOffset = (CodeHead < CodeIndex) ? 0 : codeCount;

    gcmHEADER_ARG("Shader=0x%x CodeIndex=%d CodeHead=%d CodeTail", Shader, CodeIndex, CodeHead, CodeTail);

    /* Insert NOPs first. */
    gcmONERROR(gcSHADER_InsertNOP2BeforeCode(Shader,
                                             CodeIndex,
                                             codeCount,
                                             gcvTRUE,
                                             gcvTRUE));

    /* Copy the code list into these NOPs. */
    gcoOS_MemCopy(Shader->code + CodeIndex,
                  Shader->code + CodeHead + codeOffset,
                  codeCount * gcmSIZEOF(struct _gcSL_INSTRUCTION));

    /* Zero the original code list. */
    gcoOS_ZeroMemory(Shader->code + CodeHead + codeOffset,
                     codeCount * gcmSIZEOF(struct _gcSL_INSTRUCTION));

    /* Modify the target of CALL/JMP. */
    for (i = 0; i < Shader->codeCount; i++)
    {
        code = &Shader->code[i];
        opcode = (gcSL_OPCODE)gcmSL_OPCODE_GET(code->opcode, Opcode);

        if (opcode != gcSL_CALL && opcode != gcSL_JMP)
        {
            continue;
        }

        /* If the target is in the original code list, update it with offset. */
        if (code->tempIndex >= CodeHead && code->tempIndex <= CodeTail)
        {
            code->tempIndex = code->tempIndex + idxOffset;
        }
    }

OnError:
    gcmFOOTER_NO();
    return status;
}

gceSTATUS
gcSHADER_EvaluateLTCValueWithinLinkTime(
    IN gcSHADER              Shader
    )
{
    gceSTATUS          status = gcvSTATUS_OK;
    LTCValue *         ltcUniformResults = gcvNULL;
    LTCValue *         ltcInstructionresults = gcvNULL;
    gcUNIFORM          ltcUniform = gcvNULL;
    gctUINT            ltcInstructionCount, ltcUniformCount;
    gctUINT            i, j;
    gctPOINTER         pointer;
    gcSL_INSTRUCTION   inst;
    gcSL_TYPE          type0, type1;
    gcSL_ENABLE        enable0, enable1;

    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* do nothing if there is no Loadtime Constant Expression */
    if (GetShaderLtcUniformCount(Shader) == 0)
    {
        gcmFOOTER();
        return status;
    }

    /* Only need to evaluate it once. */
    if (Shader->ltcUniformValues != gcvNULL)
    {
        gcmFOOTER();
        return status;
    }

    /* Save the uniform result. */
    ltcUniformCount = GetShaderLtcUniformCount(Shader);
    gcmONERROR(gcoOS_Allocate(gcvNULL,
                              ltcUniformCount * sizeof(LTCValue),
                              &pointer));
    gcoOS_ZeroMemory(pointer, ltcUniformCount * sizeof(LTCValue));
    ltcUniformResults = (LTCValue *)pointer;
    Shader->ltcUniformValues = ltcUniformResults;

    /* Save the instruction result. */
    ltcInstructionCount = GetShaderLtcInstructionCount(Shader);
    gcmONERROR(gcoOS_Allocate(gcvNULL,
                              ltcInstructionCount * sizeof(LTCValue),
                              &pointer));
    gcoOS_ZeroMemory(pointer, ltcInstructionCount * sizeof(LTCValue));
    ltcInstructionresults = (LTCValue *)pointer;

    for (i = 0; i < ltcInstructionCount; i++)
    {
        gctBOOL hasSource2 = gcvFALSE;
        LTCValue  resultValue;

        ltcInstructionresults[i].instructionIndex = i;
        inst = &Shader->ltcExpressions[i];

        type0 = gcmSL_SOURCE_GET(inst->source0, Type);
        type1 = gcmSL_SOURCE_GET(inst->source1, Type);

        enable0 = gcSL_ConvertSwizzle2Enable((gcSL_SWIZZLE) gcmSL_SOURCE_GET(inst->source0, SwizzleX),
                                             (gcSL_SWIZZLE) gcmSL_SOURCE_GET(inst->source0, SwizzleY),
                                             (gcSL_SWIZZLE) gcmSL_SOURCE_GET(inst->source0, SwizzleZ),
                                             (gcSL_SWIZZLE) gcmSL_SOURCE_GET(inst->source0, SwizzleW));

        enable1 = gcSL_ConvertSwizzle2Enable((gcSL_SWIZZLE) gcmSL_SOURCE_GET(inst->source1, SwizzleX),
                                             (gcSL_SWIZZLE) gcmSL_SOURCE_GET(inst->source1, SwizzleY),
                                             (gcSL_SWIZZLE) gcmSL_SOURCE_GET(inst->source1, SwizzleZ),
                                             (gcSL_SWIZZLE) gcmSL_SOURCE_GET(inst->source1, SwizzleW));

        /*
        ** If one of sources is user defined uniform,
        ** then this instruction can't be evaluated within link time.
        */
        if (type0 == gcSL_UNIFORM || type1 == gcSL_UNIFORM)
        {
            ltcInstructionresults[i].instructionIndex = -1;
            continue;
        }

        /*
        ** If one of sources can't be evaluated within link time,
        ** then this instruction can't be evaluated within link time.
        */
        if (type0 == gcSL_TEMP)
        {
            /* The entire register can't be evaluated. */
            if (ltcInstructionresults[inst->source0Index].instructionIndex == -1)
            {
                ltcInstructionresults[i].instructionIndex = -1;
                continue;
            }
            /* Some components of this register can be evaluated. */
            else
            {
                gctBOOL missSomeComponent = gcvFALSE;

                for (j = 0; j < MAX_LTC_COMPONENTS; j++)
                {
                    if ((enable0 & (1 << j)) &&
                        (!(ltcInstructionresults[inst->source0Index].enable & (1 << j))))
                    {
                        missSomeComponent = gcvTRUE;
                        break;
                    }
                }

                if (missSomeComponent)
                {
                    ltcInstructionresults[i].instructionIndex = -1;
                    continue;
                }
            }
        }
        if (type1 == gcSL_TEMP)
        {
            if (ltcInstructionresults[inst->source1Index].instructionIndex == -1)
            {
                ltcInstructionresults[i].instructionIndex = -1;
                continue;
            }
            else
            {
                gctBOOL missSomeComponent = gcvFALSE;

                for (j = 0; j < MAX_LTC_COMPONENTS; j++)
                {
                    if ((enable1 & (1 << j)) &&
                        (!(ltcInstructionresults[inst->source1Index].enable & (1 << j))))
                    {
                        missSomeComponent = gcvTRUE;
                        break;
                    }
                }

                if (missSomeComponent)
                {
                    ltcInstructionresults[i].instructionIndex = -1;
                    continue;
                }
            }
        }

        /* If it is a SET instruction, we need to check the next instruction. */
        if (gcmSL_OPCODE_GET(inst->opcode, Opcode) == gcSL_SET)
        {
            gcSL_INSTRUCTION nextInst = &Shader->ltcExpressions[i + 1];

            type1 = gcmSL_SOURCE_GET(nextInst->source1, Type);

            if (type1 == gcSL_UNIFORM)
            {
                i++;
                ltcInstructionresults[i].instructionIndex = -1;
                continue;
            }
            if (type1 == gcSL_TEMP)
            {
                if (ltcInstructionresults[nextInst->source1].instructionIndex == -1)
                {
                    i++;
                    ltcInstructionresults[i].instructionIndex = -1;
                    continue;
                }
            }
            hasSource2 = gcvTRUE;
        }

        /* Call compiler code to do LTC constant folding */
        gcmONERROR(gcOPT_DoConstantFoldingLTC(Shader,
                                              i,
                                              gcvNULL,
                                              gcvNULL,
                                              gcvNULL,
                                              hasSource2,
                                              &resultValue,
                                              ltcInstructionresults));

        if (GetShaderLtcCodeUniformIndex(Shader, i) >= 0)
        {
            ltcUniform = Shader->uniforms[GetShaderLtcCodeUniformIndex(Shader, i)];
            gcmASSERT(GetUniformDummyUniformIndex(ltcUniform) >= 0);
            ltcUniformResults[GetUniformDummyUniformIndex(ltcUniform)] = resultValue;
        }

        if (gcmSL_OPCODE_GET(inst->opcode, Opcode) == gcSL_SET)
        {
            ltcInstructionresults[i + 1] = ltcInstructionresults[i];
            i++;
            if (GetShaderLtcCodeUniformIndex(Shader, i) >= 0)
            {
                ltcUniform = Shader->uniforms[GetShaderLtcCodeUniformIndex(Shader, i)];
                gcmASSERT(GetUniformDummyUniformIndex(ltcUniform) >= 0);
                ltcUniformResults[GetUniformDummyUniformIndex(ltcUniform)] = resultValue;
            }
        }
    }

OnError:
    gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, ltcInstructionresults));

    gcmFOOTER_NO();
    return status;
}

gceSTATUS
gcSHADER_InsertList(
    IN gcSHADER                    Shader,
    IN gcSHADER_LIST *             Root,
    IN gctINT                      Index,
    IN gctINT                      Data0,
    IN gctINT                      Data1
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcSHADER_LIST list = gcvNULL;
    gctPOINTER pointer = gcvNULL;

    for (list = *Root; list; list = list->next)
    {
        if (Index == list->index)
        {
            return status;
        }
    }

    gcmONERROR(gcoOS_Allocate(gcvNULL, gcmSIZEOF(struct _gcSHADER_LIST), &pointer));

    list = pointer;
    list->next = *Root;
    list->index = Index;
    list->data0 = Data0;
    list->data1 = Data1;

    *Root = list;

OnError:
    return status;
}

gceSTATUS
gcSHADER_UpdateList(
    IN gcSHADER                    Shader,
    IN gcSHADER_LIST               Root,
    IN gctINT                      Index,
    IN gctINT                      NewIndex
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcSHADER_LIST list = gcvNULL;

    for (list = Root; list; list = list->next)
    {
        if (Index == list->index)
        {
            list->index = NewIndex;
            return status;
        }
    }

    return status;
}

gceSTATUS
gcSHADER_DeleteList(
    IN gcSHADER                    Shader,
    IN gcSHADER_LIST *             Root,
    IN gctINT                      Index
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcSHADER_LIST list = gcvNULL;
    gcSHADER_LIST prevList = gcvNULL;

    for (list = *Root; list; list = list->next)
    {
        if (Index == list->index)
        {
            break;
        }
        prevList = list;
    }

    if (list)
    {
        if (prevList)
        {
            prevList->next = list->next;
        }
        else
        {
            *Root = list->next;
        }
        gcmVERIFY_OK(gcmOS_SAFE_FREE(gcvNULL, list));
    }

    return status;
}

gceSTATUS
gcSHADER_FindList(
    IN gcSHADER                    Shader,
    IN gcSHADER_LIST               Root,
    IN gctINT                      Index,
    IN gcSHADER_LIST *             List
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcSHADER_LIST list = gcvNULL;

    for (list = Root; list; list = list->next)
    {
        if (Index == list->index)
        {
            if (List)
            {
                *List = list;
            }
            return gcvSTATUS_TRUE;
        }
    }

    return status;
}

gceSTATUS
gcSHADER_FindListByData(
    IN gcSHADER                    Shader,
    IN gcSHADER_LIST               Root,
    IN gctINT                      Data0,
    IN gctINT                      Data1,
    IN gcSHADER_LIST *             List
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcSHADER_LIST list = gcvNULL;

    for (list = Root; list; list = list->next)
    {
        if (Data0 == list->data0 && Data1 == list->data1)
        {
            if (List)
            {
                *List = list;
            }
            return gcvSTATUS_TRUE;
        }
    }

    return status;
}

gceSTATUS
gcSHADER_QueryValueOrder(
    IN gcSHADER         Shader,
    OUT gctUINT_PTR     ValueOrder
    )
{
    gceSTATUS       status;
    gctUINT         i, j, k;
    gcATTRIBUTE     attribute;
    gctCONST_STRING attributeName;
    gctUINT         map[3] = {0, 0, 0};
    const gctSTRING id[3] = {"#global_id", "#group_id", "#local_id"};

    gcmHEADER_ARG("Shader=0x%x", Shader);

    for (i = 0, j = 0; (i < Shader->attributeCount) && (j < 3); i++)
    {
        gcmONERROR(gcSHADER_GetAttribute(Shader, i, &attribute));
        gcmONERROR(gcATTRIBUTE_GetName(Shader, attribute, gcvTRUE, gcvNULL, &attributeName));
        for (k = 0; k < 3; k++)
        {
            if (gcmIS_SUCCESS(gcoOS_StrCmp(attributeName, id[k])))
            {
                map[j] = k;
                j++;
                break;
            }
        }
    }

    switch (map[0])
    {
    case 0:
        if (map[1] == 1)
        {
            *ValueOrder = 2; /* GWL -> LGW */
        }
        else
        {
            *ValueOrder = 3; /* GLW -> WGL */
        }
        break;

    case 1:
        if (map[1] == 0)
        {
            *ValueOrder = 4; /* WGL -> LWG */
        }
        else
        {
            *ValueOrder = 1; /* WLG -> GWL */
        }
        break;

    case 2:
        if (map[1] == 0)
        {
            *ValueOrder = 5; /* LGW -> WLG */
        }
        else
        {
            *ValueOrder = 0; /* LWG -> GLW */
        }
        break;

    default:
        *ValueOrder = 0;     /* LWG -> GLW */
        break;
    }

    status = gcvSTATUS_OK;

OnError:
    gcmFOOTER_ARG("%d", status);
    return status;
}

gctBOOL
gcIsSBUnsized(
    IN gcsSTORAGE_BLOCK  StorageBlock
    )
{
    gcmASSERT(StorageBlock);

    return GetSBFlag(StorageBlock) & gceIB_FLAG_UNSIZED;
}

/*
 * return the last block member of a storage block
 */
gcVARIABLE
gcGetSBLastVariable(
    IN gcSHADER Shader,
    IN gcsSTORAGE_BLOCK StorageBlock
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcVARIABLE variable = gcvNULL;
    gctINT numBlockElement;
    gctINT firstChild, sibling;

    gcmASSERT(Shader);

    numBlockElement = GetSBNumBlockElement(StorageBlock);
    firstChild = GetSBFirstChild(StorageBlock);
    if(firstChild == -1) return gcvNULL;

    gcmONERROR(gcSHADER_GetVariable(Shader,
                                    firstChild,
                                    &variable));

    while(--numBlockElement) {
        sibling = variable->nextSibling;
        gcmASSERT(sibling != -1);
        if(sibling != -1) {
           variable = gcvNULL;
           gcmONERROR(gcSHADER_GetVariable(Shader,
                                           sibling,
                                           &variable));
        }
        else break;
    }

OnError:
    return variable;
}

/* return unsized array leng for StorageBlock in *UnsizedArrayLength
 * if it's last block member is unsized array variable
 * otherwise return status = gcvSTATUS_INVALID_REQUEST, and length set to 0
 */
gceSTATUS
gcGetSBUnsizedArrayLength(
    IN gcSHADER          Shader,
    IN gcsSTORAGE_BLOCK  StorageBlock,
    IN gctINT            TotalSizeInBytes,
    OUT gctINT *         UnsizedArrayLength
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcVARIABLE var = gcvNULL;

    gcmASSERT(StorageBlock);
    gcmASSERT(UnsizedArrayLength);

    if(gcIsSBUnsized(StorageBlock))
    {
        var = gcGetSBLastVariable(Shader, StorageBlock);
    }

    if (var != gcvNULL)
    {
        gctINT sz = GetVariableOffset(var);
        gcmASSERT(var->arraySize <= 0 && TotalSizeInBytes >= sz );
        gcmASSERT(var->arrayStride > 0 );
        *UnsizedArrayLength = (TotalSizeInBytes - sz) / var->arrayStride;
    }
    else
    {
        *UnsizedArrayLength = 0;
        status = gcvSTATUS_INVALID_REQUEST;
    }
    return status;
}

gctUINT
gcHINTS_GetSamplerBaseOffset(
    IN gcsHINT_PTR Hints,
    IN gcSHADER Shader
    )
{
    gctUINT samplerBaseOffset = 0;
    gctUINT stageIndex = 0;

    switch (GetShaderType(Shader))
    {
    case gcSHADER_TYPE_VERTEX:
        stageIndex = gcvPROGRAM_STAGE_VERTEX;
        break;

    case gcSHADER_TYPE_TCS:
        stageIndex = gcvPROGRAM_STAGE_TCS;
        break;

    case gcSHADER_TYPE_TES:
        stageIndex = gcvPROGRAM_STAGE_TES;
        break;

    case gcSHADER_TYPE_GEOMETRY:
        stageIndex = gcvPROGRAM_STAGE_GEOMETRY;
        break;

    case gcSHADER_TYPE_FRAGMENT:
        stageIndex = gcvPROGRAM_STAGE_FRAGMENT;
        break;

    case gcSHADER_TYPE_COMPUTE:
        stageIndex = gcvPROGRAM_STAGE_COMPUTE;
        break;

    case gcSHADER_TYPE_CL:
        stageIndex = gcvPROGRAM_STAGE_OPENCL;
        break;

    default:
        gcmASSERT(gcvFALSE);
        break;
    }

    samplerBaseOffset = Hints->samplerBaseOffset[stageIndex];

    return samplerBaseOffset;
}

void
gcoSHADER_AllocateVidMemForNoKernel(
    gctPOINTER context,
    gceSURF_TYPE type,
    gctSTRING tag,
    gctSIZE_T size,
    gctUINT32 align,
    gctPOINTER *vidMem,
    gctPOINTER *memory,
    gctUINT32 *physical,
    gctPOINTER initialData,
    gctBOOL zeroMemory
    )
{
    gceSTATUS           status = gcvSTATUS_OK;
    gctPOINTER          pointer = gcvNULL;
    gctPOINTER          data = gcvNULL;

    gcmHEADER_ARG("context=%p type=%d ta%s size=%zu align=%u vidMem=%p"
                  "memory=%p physical=%p initialData=%p zeroMemory=%d",
                  context, type, tag, size, align, vidMem,
                  memory, physical, initialData, zeroMemory);

    gcmASSERT(physical);
    gcmASSERT(vidMem);
    if (size)
    {

        gcmONERROR(gcoOS_Allocate(gcvNULL,
                                  gcmSIZEOF(gctUINT32) + size,
                                  &pointer));
        *((gctUINT32*)pointer) = size;

        data = (gctUINT8*)pointer + gcmSIZEOF(gctUINT32);

        if (initialData)
        {
#if gcdENDIAN_BIG
            gctSIZE_T i;
            gctUINT_PTR pDst = (gctUINT_PTR)data;
            gctUINT_PTR pSrc = (gctUINT_PTR)initialData;

            gcmASSERT(size % 4 == 0);

            for (i = 0; i < size / 4; ++i)
            {
                gctUINT src = *pSrc++;
                *pDst++ = gcmBSWAP32(src);
            }
#else
            gcoOS_MemCopy(data, initialData, size);
#endif
        }
        else if (zeroMemory)
        {
            gcoOS_ZeroMemory(data, size);
        }
    }

    if (vidMem)
    {
        *vidMem = pointer;
    }
    else if (pointer != gcvNULL)
    {
        gcoOS_Free(gcvNULL, pointer);
        pointer = gcvNULL;
    }

    if (memory)
    {
        *memory = 0;
    }

    if (physical)
    {
        *physical = 0;
    }

OnError:
    if (gcmIS_ERROR(status) && pointer != gcvNULL)
    {
        gcoOS_Free(gcvNULL, pointer);
    }

    gcmFOOTER();
    return;
}

void
gcoSHADER_FreeVidMemForNoKernel(
    gctPOINTER context,
    gceSURF_TYPE type,
    gctSTRING tag,
    gctPOINTER vidMem
    )
{
    gceSTATUS           status = gcvSTATUS_OK;

    gcmHEADER_ARG("context=%p type=%d tag=%s vidMem=%p", context, type, tag, vidMem);

    if (vidMem)
    {
        gcmONERROR(gcmOS_SAFE_FREE(gcvNULL, vidMem));
    }

OnError:
    gcmFOOTER();
    return;
}

gceSTATUS
gcFreeProgramState(
    IN gcsPROGRAM_STATE ProgramState
    )
{
    gcmHEADER();
    if (ProgramState.hints)
    {
        gcmVERIFY_OK(gcHINTS_Destroy(ProgramState.hints));
        gcmOS_SAFE_FREE(gcvNULL, ProgramState.hints);
    }

    if (ProgramState.stateBuffer)
    {
        gcmOS_SAFE_FREE(gcvNULL, ProgramState.stateBuffer);
    }

    ProgramState.stateBufferSize = 0;

    gcmFOOTER_NO();
    return gcvSTATUS_OK;
}



#if !DX_SHADER
gceSTATUS
gcHINTS_Destroy(
    IN gcsHINT_PTR Hints
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gctUINT i;

    gcmHEADER_ARG("Hints=%p", Hints);

    /* Destroy vid mems for i-caches */
    for (i = 0; i < gcMAX_SHADERS_IN_LINK_GOURP; i ++)
    {
        if (Hints->shaderVidNodes.instVidmemNode[i])
        {
            gcoSHADER_FreeVidMem(gcvNULL, gcvSURF_ICACHE, "instruction memory", Hints->shaderVidNodes.instVidmemNode[i]);
            Hints->shaderVidNodes.instVidmemNode[i] = gcvNULL;
        }

        if (Hints->shaderVidNodes.gprSpillVidmemNode[i])
        {
            gcoSHADER_FreeVidMem(gcvNULL, gcvSURF_VERTEX, "temp register spill memory", (gctPOINTER)Hints->shaderVidNodes.gprSpillVidmemNode[i]);
            Hints->shaderVidNodes.gprSpillVidmemNode[i] = gcvNULL;
        }

        if (Hints->shaderVidNodes.crSpillVidmemNode[i])
        {
            gcoSHADER_FreeVidMem(gcvNULL, gcvSURF_VERTEX, "immediate constant spill memory", (gctPOINTER)Hints->shaderVidNodes.crSpillVidmemNode[i]);
            Hints->shaderVidNodes.crSpillVidmemNode[i] = gcvNULL;
        }

        if (Hints->shaderVidNodes.sharedMemVidMemNode)
        {
            gcoSHADER_FreeVidMem(gcvNULL, gcvSURF_VERTEX, "share variable memory", (gctPOINTER)Hints->shaderVidNodes.sharedMemVidMemNode);
            Hints->shaderVidNodes.sharedMemVidMemNode = gcvNULL;
        }
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_SetEarlyFragTest(
    IN gcSHADER                    Shader,
    IN gctBOOL                     UseEarlyFragTest
    )
{
    gcmHEADER_ARG("Shader=0x%x", Shader);

    /* Only affect fragment shader. */
    if (Shader->type == gcSHADER_TYPE_FRAGMENT)
    {
        Shader->useEarlyFragTest = UseEarlyFragTest;
    }

    gcmFOOTER_ARG("UseEarlyFragTest=%d", UseEarlyFragTest);
    return gcvSTATUS_OK;
}

gceSTATUS
gcSHADER_GetEarlyFragTest(
    IN gcSHADER                    Shader,
    IN gctBOOL *                   UseEarlyFragTest
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, UseEarlyFragTest=0x%x", Shader, UseEarlyFragTest);

    if (UseEarlyFragTest)
    {
        *UseEarlyFragTest = Shader->useEarlyFragTest;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetTCSPatchOutputVertices(
    IN  gcSHADER                    Shader,
    OUT gctINT *                    TCSPatchOutputVertices
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, TCSPatchOutputVertices=0x%x", Shader, TCSPatchOutputVertices);

    if (TCSPatchOutputVertices)
    {
        gcmASSERT(GetShaderType(Shader) == gcSHADER_TYPE_TCS);
        *TCSPatchOutputVertices = Shader->shaderLayout.tcs.tcsPatchOutputVertices;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetTCSPatchInputVertices(
    IN  gcSHADER                    Shader,
    OUT gctINT *                    TCSPatchInputVertices
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, TCSPatchInputVertices=0x%x", Shader, TCSPatchInputVertices);

    if (TCSPatchInputVertices)
    {
        gcmASSERT(GetShaderType(Shader) == gcSHADER_TYPE_TCS);
        *TCSPatchInputVertices = Shader->shaderLayout.tcs.tcsPatchInputVertices;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetTCSInputVerticesUniform(
    IN  gcSHADER                    Shader,
    OUT gcUNIFORM *                 TCSInputVerticesUniform
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, TCSInputVerticesUniform=0x%x", Shader, TCSInputVerticesUniform);

    if (TCSInputVerticesUniform)
    {
        gcmASSERT(GetShaderType(Shader) == gcSHADER_TYPE_TCS);
        *TCSInputVerticesUniform = Shader->shaderLayout.tcs.tcsInputVerticesUniform;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetTESPrimitiveMode(
    IN  gcSHADER                    Shader,
    OUT gcTessPrimitiveMode *       TESPrimitiveMode
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, TESPrimitiveMode=0x%x", Shader, TESPrimitiveMode);

    if (TESPrimitiveMode)
    {
        gcmASSERT(GetShaderType(Shader) == gcSHADER_TYPE_TES);
        *TESPrimitiveMode = Shader->shaderLayout.tes.tessPrimitiveMode;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetTESVertexSpacing(
    IN  gcSHADER                    Shader,
    OUT gcTessVertexSpacing *       TESVertexSpacing
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, TESVertexSpacing=0x%x", Shader, TESVertexSpacing);

    if (TESVertexSpacing)
    {
        gcmASSERT(GetShaderType(Shader) == gcSHADER_TYPE_TES);
        *TESVertexSpacing = Shader->shaderLayout.tes.tessVertexSpacing;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetTESOrdering(
    IN  gcSHADER                    Shader,
    OUT gcTessOrdering *            TESOrdering
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, TESOrdering=0x%x", Shader, TESOrdering);

    if (TESOrdering)
    {
        gcmASSERT(GetShaderType(Shader) == gcSHADER_TYPE_TES);
        *TESOrdering = Shader->shaderLayout.tes.tessOrdering;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetTESPointMode(
    IN  gcSHADER                    Shader,
    OUT gctBOOL *                   TESPointMode
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, TESPointMode=0x%x", Shader, TESPointMode);

    if (TESPointMode)
    {
        gcmASSERT(GetShaderType(Shader) == gcSHADER_TYPE_TES);
        *TESPointMode = Shader->shaderLayout.tes.tessPointMode;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetTESPatchInputVertices(
    IN  gcSHADER                    Shader,
    OUT gctINT *                    TESPatchInputVertices
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, TESPatchInputVertices=0x%x", Shader, TESPatchInputVertices);

    if (TESPatchInputVertices)
    {
        gcmASSERT(GetShaderType(Shader) == gcSHADER_TYPE_TES);
        *TESPatchInputVertices = Shader->shaderLayout.tes.tessPatchInputVertices;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetGSLayout(
    IN  gcSHADER                    Shader,
    OUT gcGEOLayout *               Layout
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, Layout=0x%x", Shader, Layout);

    if (Layout)
    {
        gcmASSERT(GetShaderType(Shader) == gcSHADER_TYPE_GEOMETRY);
        *Layout = Shader->shaderLayout.geo;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetInstructionCount(
    IN gcSHADER                    Shader,
    IN gctUINT *                   InstructionCount
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, InstructionCount=0x%x", Shader, InstructionCount);

    if (InstructionCount)
    {
        *InstructionCount = Shader->lastInstruction;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_GetNotStagesRelatedLinkError(
    IN gcSHADER                    Shader,
    OUT gceSTATUS *                NotStagesRelatedLinkError
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, NotStagesRelatedLinkError=0x%x", Shader, NotStagesRelatedLinkError);
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    if (NotStagesRelatedLinkError)
    {
        *NotStagesRelatedLinkError = Shader->hasNotStagesRelatedLinkError;
    }

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_SetNotStagesRelatedLinkError(
    IN gcSHADER                    Shader,
    IN gceSTATUS                   NotStagesRelatedLinkError
    )
{
    gceSTATUS status = gcvSTATUS_OK;
    gcmHEADER_ARG("Shader=0x%x, NotStagesRelatedLinkError=0x%x", Shader, NotStagesRelatedLinkError);
    gcmDEBUG_VERIFY_ARGUMENT(Shader != gcvNULL);

    Shader->hasNotStagesRelatedLinkError = NotStagesRelatedLinkError;

    gcmFOOTER();
    return status;
}

gceSTATUS
gcSHADER_Has64BitOperation(
    IN gcSHADER                    Shader
    )
{
    gceSTATUS status = gcvSTATUS_FALSE;
    gctUINT32 i;

    gcmHEADER_ARG("Shader=0x%x", Shader);
    gcmASSERT(Shader);

    for (i = 0; i < Shader->codeCount; i++)
    {
        gcSL_INSTRUCTION code = &Shader->code[i];
        gcSL_OPCODE opcode;
        gcSL_FORMAT format;

        if (code == gcvNULL) continue;

        opcode = (gcSL_OPCODE)gcmSL_OPCODE_GET(code->opcode, Opcode);
        if (opcode == gcSL_NOP || opcode == gcSL_CALL ||
            opcode == gcSL_JMP || opcode == gcSL_RET)
        {
            continue;
        }

        format = (gcSL_FORMAT)gcmSL_TARGET_GET(code->temp, Format);
        if (format == gcSL_FLOAT64 || format == gcSL_INT64 || format == gcSL_UINT64)
        {
            status = gcvSTATUS_TRUE;
            break;
        }

        format = (gcSL_FORMAT)gcmSL_SOURCE_GET(code->source0, Format);
        if (format == gcSL_FLOAT64 || format == gcSL_INT64 || format == gcSL_UINT64)
        {
            status = gcvSTATUS_TRUE;
            break;
        }

        format = (gcSL_FORMAT)gcmSL_SOURCE_GET(code->source1, Format);
        if (format == gcSL_FLOAT64 || format == gcSL_INT64 || format == gcSL_UINT64)
        {
            status = gcvSTATUS_TRUE;
            break;
        }
    }

    gcmFOOTER();
    return status;
}

#endif
#endif


