/****************************************************************************
*
*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
*
*    The material in this file is confidential and contains trade secrets
*    of Vivante Corporation. This is proprietary information owned by
*    Vivante Corporation. No part of this work may be disclosed,
*    reproduced, copied, transmitted, or used in any way for any purpose,
*    without the express written permission of Vivante Corporation.
*
*****************************************************************************/


#include "gc_vsc.h"

#define NL "\n"

gctSTRING gcLibFunc_Extension =
"#version 310 es\n"
"#extension GL_VIV_asm: enable\n"
;

gctSTRING gcLibFunc_Extension_For_GL =
"#version 400\n"
"#extension GL_VIV_asm: enable\n"
;

gctSTRING gcLibFunc_Extension_For_TexMS2DArray =
"#extension GL_OES_texture_storage_multisample_2d_array:    enable\n"
;

gctSTRING gcLibFunc_Extension_For_CubeMapArray =
"#extension GL_EXT_texture_cube_map_array :                 require\n"
;

gctSTRING gcLibFunc_Extension_For_TextureBuffer =
"#extension GL_EXT_texture_buffer :                         require\n"
;

gctSTRING gcLibFunc_Extension_For_MSShading     =
"#extension GL_OES_shader_multisample_interpolation :       require\n"
"#extension GL_OES_sample_variables :                       require\n"
;

gctSTRING gcLibFunc_TextureBufferSize_For_OES =
"#extension GL_EXT_texture_buffer:    enable\n"
"#define MAX_TEXTURE_BUFFER_SIZE                            (16 * 1024) \n"
;

gctSTRING gcLibFunc_MathMacros =
/* The rounding mode must be the same as VIR_RoundMode. */
"#define ROUNDING_DEFAULT                                   0\n"
"#define ROUNDING_RTE                                       1\n"
"#define ROUNDING_RTZ                                       2\n"
"#define ROUNDING_RTP                                       3\n"
"#define ROUNDING_RTN                                       4\n"
;

gctSTRING gcLibFunc_TextureBufferSize_For_VK  =
"#extension GL_EXT_texture_buffer:    enable\n"
"#define MAX_TEXTURE_BUFFER_SIZE                            (8 * 1024) \n"
;

gctSTRING gcLibFunc_BuiltinHeader =
"#define MIN_PROGRAM_TEXTURE_GATHER_OFFSET                  (-8) \n"
"#define MAX_PROGRAM_TEXTURE_GATHER_OFFSET                  (7) \n"
"#define IMAGE_ADDRESSING_NONE                              0u  \n"
"#define IMAGE_ADDRESSING_BORDER0                           1u  \n"
"#define IMAGE_ADDRESSING_BORDER1                           2u  \n"
"#define IMAGE_ADDRESSING_CLAMP                             3u  \n"
"out vec4 fragColor;\n"
"void main(void)\n"
"{\n"
"    fragColor = vec4(0.0);\n"
"}\n"
"\n";

gctSTRING gcLibFunc_BlendEquationHeader =
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_MULTIPLY         0x1 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_OVERLAY          0x2 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DARKEN           0x4 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_LIGHTEN          0x8 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE       0x10 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN        0x20 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HARDLIGHT        0x40 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT        0x80 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DIFFERENCE       0x100 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_EXCLUSION        0x200 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE          0x400 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION   0x800 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR        0x1000 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY   0x2000 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SCREEN           0x4000 \n"
"precision highp float;\n"
"precision highp sampler2D;\n"
"precision highp sampler3D;\n"
"precision highp isampler2D;\n"
"precision highp isampler3D;\n"
"precision highp usampler2D;\n"
"precision highp usampler3D;\n"
"out vec4 fragColor;\n"
"void main(void)\n"
"{\n"
"    fragColor = vec4(0.0);\n"
"}\n"
"\n";

/* To meet the dQEP asin/acos/acosh/atan/atan2 accuracy, we have to use the following builtint function */
gctSTRING gcLibASIN_ACOS_Funcs_Common =
"float _viv_asin_base_1(float a)\n"
"{\n"
"   float temp  = a * a;\n"
"   float result = a * (1.0004488056969831f+ temp*(0.15295127520390661f + temp* 0.13409603620943705f));\n"
"   return result;\n"
"}\n"
"vec2 _viv_asin_base_2(vec2 a)\n"
"{\n"
"   vec2 temp  = a * a;\n"
"   vec2 result = a * (vec2(1.0004488056969831f) + temp*(vec2(0.15295127520390661f) + temp* vec2(0.13409603620943705f)));\n"
"   return result;\n"
"}\n"
"vec3 _viv_asin_base_3(vec3 a)\n"
"{\n"
"   vec3 temp  = a * a;\n"
"   vec3 result = a * (vec3(1.0004488056969831f)+ temp*(vec3(0.15295127520390661f) + temp* vec3(0.13409603620943705f)));\n"
"   return result;\n"
"}\n"
"vec4 _viv_asin_base_4(vec4 a)\n"
"{\n"
"   vec4 temp  = a * a;\n"
"   vec4 result = a * (vec4(1.0004488056969831f) + temp*(vec4(0.15295127520390661f) + temp* vec4(0.13409603620943705f)));\n"
"   return result;\n"
"}\n"
"float _viv_asin_float(float a)\n"
"{\n"
"   float result;\n"
"   if (abs(a) < 0.7072f)\n"
"   {\n"
"       result = _viv_asin_base_1(a);\n"
"   } else {\n"
"       result = (3.14159265358979323846f/2.0f - _viv_asin_base_1(sqrt(1.0f - a * a))) * sign(a);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibASIN_Funcs_halti0 =
"vec2 _viv_asin_vec2(vec2 a)\n"
"{\n"
"   vec2 result, result1;\n"
"   bvec2 sel = lessThan(abs(a), vec2(0.7072f));\n"
"   result1 = (vec2(3.14159265358979323846f/2.0f) - _viv_asin_base_2(sqrt(vec2(1.0f) - a * a))) * sign(a);\n"
"   result = mix(result1, _viv_asin_base_2(a), sel);\n"
"   return result;\n"
"}\n"
"vec3 _viv_asin_vec3(vec3 a)\n"
"{\n"
"   vec3 result, result1;\n"
"   bvec3 sel = lessThan(abs(a), vec3(0.7072f));\n"
"   result1 = (vec3(3.14159265358979323846f/2.0f) - _viv_asin_base_3(sqrt(vec3(1.0f) - a * a))) * sign(a);\n"
"   result = mix(result1, _viv_asin_base_3(a), sel);\n"
"   return result;\n"
"}\n"
"vec4 _viv_asin_vec4(vec4 a)\n"
"{\n"
"   vec4 result, result1;\n"
"   bvec4 sel = lessThan(abs(a), vec4(0.7072f));\n"
"   result1 = (vec4(3.14159265358979323846f/2.0f) - _viv_asin_base_4(sqrt(vec4(1.0f) - a * a))) * sign(a);\n"
"   result = mix(result1, _viv_asin_base_4(a), sel);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibASIN_Funcs =
"vec2 _viv_asin_vec2(vec2 a)\n"
"{\n"
"   vec2 result, result1;\n"
"   result = (vec2(3.14159265358979323846f/2.0f) - _viv_asin_base_2(sqrt(vec2(1.0f) - a * a))) * sign(a);\n"
"   result1 = _viv_asin_base_2(a);\n"
"   if (abs(a.x) < 0.7072f)\n"
"       result.x = result1.x;\n"
"   if (abs(a.y) < 0.7072f)\n"
"       result.y = result1.y;\n"
"   return result;\n"
"}\n"
"vec3 _viv_asin_vec3(vec3 a)\n"
"{\n"
"   vec3 result, result1;\n"
"   result = (vec3(3.14159265358979323846f/2.0f) - _viv_asin_base_3(sqrt(vec3(1.0f) - a * a))) * sign(a);\n"
"   result1 = _viv_asin_base_3(a);\n"
"   if (abs(a.x) < 0.7072f)\n"
"       result.x = result1.x;\n"
"   if (abs(a.y) < 0.7072f)\n"
"       result.y = result1.y;\n"
"   if (abs(a.z) < 0.7072f)\n"
"       result.z = result1.z;\n"
"   return result;\n"
"}\n"
"vec4 _viv_asin_vec4(vec4 a)\n"
"{\n"
"   vec4 result, result1;\n"
"   result = (vec4(3.14159265358979323846f/2.0f) - _viv_asin_base_4(sqrt(vec4(1.0f) - a * a))) * sign(a);\n"
"   result1 = _viv_asin_base_4(a);\n"
"   if (abs(a.x) < 0.7072f)\n"
"       result.x = result1.x;\n"
"   if (abs(a.y) < 0.7072f)\n"
"       result.y = result1.y;\n"
"   if (abs(a.z) < 0.7072f)\n"
"       result.z = result1.z;\n"
"   if (abs(a.w) < 0.7072f)\n"
"       result.w = result1.w;\n"
"   return result;\n"
"}\n";

gctSTRING gcLibACOS_Funcs =
"float _viv_acos_float(float a)\n"
"{\n"
"   float result = 3.14159265358979323846f/2.0f - _viv_asin_float(a);\n"
"   return result;\n"
"}\n"
"vec2 _viv_acos_vec2(vec2 a)\n"
"{\n"
"   vec2 result = vec2(3.14159265358979323846f/2.0f) -  _viv_asin_vec2(a);\n"
"   return result;\n"
"}\n"
"vec3 _viv_acos_vec3(vec3 a)\n"
"{\n"
"   vec3 result = vec3(3.14159265358979323846f/2.0f) -  _viv_asin_vec3(a);\n"
"   return result;\n"
"}\n"
"vec4 _viv_acos_vec4(vec4 a)\n"
"{\n"
"   vec4 result = vec4(3.14159265358979323846f/2.0f) -  _viv_asin_vec4(a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibATAN_Funcs =
"float _viv_atan_float(float a)\n"
"{\n"
"   float result;\n"
"   _viv_asm(ATAN, result, a);\n"
"   return result;\n"
"}\n"
"vec2 _viv_atan_vec2(vec2 a)\n"
"{\n"
"   vec2 result;\n"
"   _viv_asm(ATAN, result, a);\n"
"   return result;\n"
"}\n"
"vec3 _viv_atan_vec3(vec3 a)\n"
"{\n"
"   vec3 result;\n"
"   _viv_asm(ATAN, result, a);\n"
"   return result;\n"
"}\n"
"vec4 _viv_atan_vec4(vec4 a)\n"
"{\n"
"   vec4 result;\n"
"   _viv_asm(ATAN, result, a);\n"
"   return result;\n"
"}\n"
;

/* CL spec:
 * atan2pi (+-0, -0 ) = +-1.
 * atan2pi (+-0, +0 ) = +- 0.
 * atan2pi (+-0, x ) returns +- 1 for x < 0.
 * atan2pi (+-0, x ) returns +- 0 for x > 0.
 * atan2pi (y, +-0 ) returns -0.5 for y < 0.
 * atan2pi (y, +-0 ) returns 0.5 for y > 0.
*/
gctSTRING gcLibATAN2_Funcs =
"float _viv_atan2_float(float y, float x)\n"
"{\n"
"    float result;\n"
"    if (x == -0.0)\n"
"    {\n"
"         if (y == 0.0)  return  3.14159265358979323846f;\n"
"         if (y == -0.0) return -3.14159265358979323846f;\n"
"         if (y < 0.0)   return -1.5707963267948966f;\n"
"         return 1.5707963267948966f;\n"
"    }\n"
"    else if (x == 0.0)\n"
"    {\n"
"         if (y == 0.0)  return  0.0;\n"
"         if (y == -0.0) return -0.0;\n"
"         if (y < 0.0)   return -1.5707963267948966f;\n"
"         return 1.5707963267948966f;\n"
"    }\n"
"    \n"
"    _viv_asm(ATAN, result, y / x);\n"
"    if(sign(x) < 0.0)\n"
"    {\n"
"        if(result <= 0.0)\n"
"        {\n"
"            result = result + 3.14159265358979323846f;\n"
"        }\n"
"        else if(result >= -0.0)\n"
"        {\n"
"            result = result - 3.14159265358979323846f;\n"
"        }\n"
"    }\n"
"   return result;\n"
"}\n"
"vec2 _viv_atan2_vec2(vec2 y, vec2 x)\n"
"{\n"
"    vec2 result;\n"
"    result.x = _viv_atan2_float(y.x, x.x);\n"
"    result.y = _viv_atan2_float(y.y, x.y);\n"
"    return result;\n"
"}\n"
"vec3 _viv_atan2_vec3(vec3 y, vec3 x)\n"
"{\n"
"    vec3 result;\n"
"    result.x = _viv_atan2_float(y.x, x.x);\n"
"    result.y = _viv_atan2_float(y.y, x.y);\n"
"    result.z = _viv_atan2_float(y.z, x.z);\n"
"    return result;\n"
"}\n"
"vec4 _viv_atan2_vec4(vec4 y, vec4 x)\n"
"{\n"
"    vec4 result;\n"
"    result.x = _viv_atan2_float(y.x, x.x);\n"
"    result.y = _viv_atan2_float(y.y, x.y);\n"
"    result.z = _viv_atan2_float(y.z, x.z);\n"
"    result.w = _viv_atan2_float(y.w, x.w);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibASIN_ACOS_Funcs_halti2 =
"float _viv_asin_float(float a)\n"
"{\n"
"   float result = 0.0f;\n"
"   float s = sqrt(1.0 - a * a);\n"
"   float t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * a;\n"
"   return result;\n"
"}\n"
"vec2 _viv_asin_vec2(vec2 a)\n"
"{\n"
"   vec2 result = vec2(0.0f);\n"
"   vec2 s = sqrt(1.0 - a * a);\n"
"   vec2 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * a;\n"
"   return result;\n"
"}\n"
"vec3 _viv_asin_vec3(vec3 a)\n"
"{\n"
"   vec3 result = vec3(0.0f);\n"
"   vec3 s = sqrt(1.0 - a * a);\n"
"   vec3 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * a;\n"
"   return result;\n"
"}\n"
"vec4 _viv_asin_vec4(vec4 a)\n"
"{\n"
"   vec4 result = vec4(0.0f);\n"
"   vec4 s = sqrt(1.0 - a * a);\n"
"   vec4 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * a;\n"
"   return result;\n"
"}\n"
"float _viv_acos_float(float a)\n"
"{\n"
"   float result = 0.0f;\n"
"   float s = sqrt((1.0 - a) * (1.0 + a));\n"
"   float t = abs(a) - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s;\n"
"   if(a < 0.0)\n"
"   {\n"
"       result = 3.14159265358979323846f - result;\n"
"   }\n"
"   return result;\n"
"}\n"
"vec2 _viv_acos_vec2(vec2 a)\n"
"{\n"
"   vec2 result = vec2(0.0f);\n"
"   vec2 s = sqrt((1.0 - a) * (1.0 + a));\n"
"   vec2 t = abs(a) - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s;\n"
"   bvec2 sel = lessThan(a, vec2(0.0));\n"
"   result = mix(result, 3.14159265358979323846f - result, sel);\n"
"   return result;\n"
"}\n"
"vec3 _viv_acos_vec3(vec3 a)\n"
"{\n"
"   vec3 result = vec3(0.0f);\n"
"   vec3 s = sqrt((1.0 - a) * (1.0 + a));\n"
"   vec3 t = abs(a) - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s;\n"
"   bvec3 sel = lessThan(a, vec3(0.0));\n"
"   result = mix(result, 3.14159265358979323846f - result, sel);\n"
"   return result;\n"
"}\n"
"vec4 _viv_acos_vec4(vec4 a)\n"
"{\n"
"   vec4 result = vec4(0.0f);\n"
"   vec4 s = sqrt((1.0 - a) * (1.0 + a));\n"
"   vec4 t = abs(a) - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s;\n"
"   bvec4 sel = lessThan(a, vec4(0.0));\n"
"   result = mix(result, 3.14159265358979323846f - result, sel);\n"
"   return result;\n"
"}\n"
;

gctSTRING gcLibACOSH_Funcs =
"float _viv_acosh_1(float a)\n"
"{\n"
"   return log(a + sqrt((a + 1.0) * (a - 1.0)));\n"
"}\n"
"vec2 _viv_acosh_2(vec2 a)\n"
"{\n"
"   return log(a + sqrt((a + 1.0) * (a - 1.0)));\n"
"}\n"
"vec3 _viv_acosh_3(vec3 a)\n"
"{\n"
"   return log(a + sqrt((a + 1.0) * (a - 1.0)));\n"
"}\n"
"vec4 _viv_acosh_4(vec4 a)\n"
"{\n"
"   return log(a + sqrt((a + 1.0) * (a - 1.0)));\n"
"}\n"
;

gctSTRING gcLibTAN_Funcs_Halti =
NL "float _viv_tan_1(float x)"
NL "{"
NL "    highp float result;"
NL "    _viv_asm(TAN, result, x);"
NL "    return result;"
NL "}"
NL "vec2 _viv_tan_2(vec2 x)"
NL "{"
NL "    highp vec2 result;"
NL "    _viv_asm(TAN, result, x);"
NL "    return result;"
NL "}"
NL "vec3 _viv_tan_3(vec3 x)"
NL "{"
NL "    highp vec3 result;"
NL "    _viv_asm(TAN, result, x);"
NL "    return result;"
NL "}"
NL "vec4 _viv_tan_4(vec4 x)"
NL "{"
NL "    highp vec4 result;"
NL "    _viv_asm(TAN, result, x);"
NL "    return result;"
NL "}"
;

gctSTRING gcLibTAN_Funcs_Common =
NL "float _viv_tan_1(float x)"
NL "{"
NL "    highp float x1 = sin(x);"
NL "    highp float x2 = cos(x);"
NL "    return x1 / x2;"
NL "}"
NL "vec2 _viv_tan_2(vec2 x)"
NL "{"
NL "    highp vec2 x1 = sin(x);"
NL "    highp vec2 x2 = cos(x);"
NL "    return x1 / x2;"
NL "}"
NL "vec3 _viv_tan_3(vec3 x)"
NL "{"
NL "    highp vec3 x1 = sin(x);"
NL "    highp vec3 x2 = cos(x);"
NL "    return x1 / x2;"
NL "}"
NL "vec4 _viv_tan_4(vec4 x)"
NL "{"
NL "    highp vec4 x1 = sin(x);"
NL "    highp vec4 x2 = cos(x);"
NL "    return x1 / x2;"
NL "}"
;

gctSTRING gcLibATAN_Funcs_halti2 =
"float _viv_atan_float(float a)\n"
"{\n"
"   highp float hp_a = a;\n"
"   float result = 0.0f;\n"
"   float s;\n"
"   if(abs(hp_a) > 1152921504606846976.0f)\n"
"   {\n"
"       return 3.14159265358979323846f / 2.0 * sign(hp_a);\n"
"   }\n"
"   else\n"
"   {\n"
"       s = inversesqrt(1.0 + hp_a * hp_a);\n"
"   }\n"
"   float t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s * hp_a;\n"
"   return result;\n"
"}\n"
"vec2 _viv_atan_vec2(vec2 a)\n"
"{\n"
"   highp vec2 hp_a = a;\n"
"   vec2 result = vec2(0.0f);\n"
"   vec2 s = inversesqrt(1.0 + hp_a * hp_a);\n"
"   vec2 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s * hp_a;\n"
"   bvec2 sel = greaterThan(abs(hp_a), vec2(1152921504606846976.0f));\n"
"   result = mix(result, 3.14159265358979323846f / 2.0 * sign(hp_a), sel);\n"
"   return result;\n"
"}\n"
"vec3 _viv_atan_vec3(vec3 a)\n"
"{\n"
"   highp vec3 hp_a = a;\n"
"   vec3 result = vec3(0.0f);\n"
"   vec3 s = inversesqrt(1.0 + hp_a * hp_a);\n"
"   vec3 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s * hp_a;\n"
"   bvec3 sel = greaterThan(abs(hp_a), vec3(1152921504606846976.0f));\n"
"   result = mix(result, 3.14159265358979323846f / 2.0 * sign(hp_a), sel);\n"
"   return result;\n"
"}\n"
"vec4 _viv_atan_vec4(vec4 a)\n"
"{\n"
"   highp vec4 hp_a = a;\n"
"   vec4 result = vec4(0.0f);\n"
"   vec4 s = inversesqrt(1.0 + hp_a * hp_a);\n"
"   vec4 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s * hp_a;\n"
"   bvec4 sel = greaterThan(abs(hp_a), vec4(1152921504606846976.0f));\n"
"   result = mix(result, 3.14159265358979323846f / 2.0 * sign(hp_a), sel);\n"
"   return result;\n"
"}\n"
;

gctSTRING gcLibATAN2_Funcs_halti2 =
"float _viv_sign_1(float a)\n"
"{\n"
"    uint t = floatBitsToUint(a);\n"
"    t &= 0x80000000u;\n"
"    t |= 0x3f800000u;\n"
"    float result = uintBitsToFloat(t);\n"
"    return result;\n"
"}\n"
"vec2 _viv_sign_2(vec2 a)\n"
"{\n"
"    uvec2 t = floatBitsToUint(a);\n"
"    t &= 0x80000000u;\n"
"    t |= 0x3f800000u;\n"
"    vec2 result = uintBitsToFloat(t);\n"
"    return result;\n"
"}\n"
"vec3 _viv_sign_3(vec3 a)\n"
"{\n"
"    uvec3 t = floatBitsToUint(a);\n"
"    t &= 0x80000000u;\n"
"    t |= 0x3f800000u;\n"
"    vec3 result = uintBitsToFloat(t);\n"
"    return result;\n"
"}\n"
"vec4 _viv_sign_4(vec4 a)\n"
"{\n"
"    uvec4 t = floatBitsToUint(a);\n"
"    t &= 0x80000000u;\n"
"    t |= 0x3f800000u;\n"
"    vec4 result = uintBitsToFloat(t);\n"
"    return result;\n"
"}\n"
"float _viv_atan2_float(float y, float x)\n"
"{\n"
"    highp float tiny    = 1.0e-30;\n"
"    highp float zero    = 0.0;\n"
"    highp float pi_o_4  = 7.8539818525e-01; /* 0x3f490fdb */\n"
"    highp float pi_o_2  = 1.5707963705e+00; /* 0x3fc90fdb */\n"
"    highp float pi      = 3.1415927410e+00; /* 0x40490fdb */\n"
"    highp float pi_lo   = -8.7422776573e-08; /* 0xb3bbbd2e */\n"
"    highp float z;\n"
"    highp int k,m,hx,hy,ix,iy;\n"
"    if(floatBitsToUint(y) == 0x80000000u)\n"
"    {\n"
"        y = 0.0;\n"
"    }\n"
"    hx = floatBitsToInt(x);\n"
"    ix = floatBitsToInt(abs(x));\n"
"    hy = floatBitsToInt(y);\n"
"    iy = floatBitsToInt(abs(y));\n"
"    if ((ix>0x7f800000)||\n"
"        (iy>0x7f800000)) /* x or y is NaN */\n"
"        return x+y;\n"
"    if (hx==0x3f800000) return _viv_atan_float(y);   /* x=1.0 */\n"
"    m = ((hy>>31)&1)|((hx>>30)&2);  /* 2*sign(x)+sign(y) */\n"
"    /* when y = 0 */\n"
"    if (iy==0) {\n"
"        switch (m) {\n"
"        case 0:\n"
"        case 1: return y;   /* atan(+-0,+anything)=+-0 */\n"
"        case 2: return  pi+tiny;/* atan(+0,-anything) = pi */\n"
"        case 3: return -pi-tiny;/* atan(-0,-anything) =-pi */\n"
"        }\n"
"    }\n"
"    /* when x = 0 */\n"
"    if (ix==0) return (hy<0)?  -pi_o_2-tiny: pi_o_2+tiny;\n"
"    /* when x is INF */\n"
"    if (ix==0x7f800000) {\n"
"        if (iy==0x7f800000) {\n"
"            switch (m) {\n"
"            case 0: return  pi_o_4+tiny;/* atan(+INF,+INF) */\n"
"            case 1: return -pi_o_4-tiny;/* atan(-INF,+INF) */\n"
"            case 2: return  3.0*pi_o_4+tiny;/*atan(+INF,-INF)*/\n"
"            case 3: return -3.0*pi_o_4-tiny;/*atan(-INF,-INF)*/\n"
"            }\n"
"        } else {\n"
"            switch(m) {\n"
"            case 0: return  zero  ; /* atan(+...,+INF) */\n"
"            case 1: return -zero  ; /* atan(-...,+INF) */\n"
"            case 2: return  pi+tiny  ;  /* atan(+...,-INF) */\n"
"            case 3: return -pi-tiny  ;  /* atan(-...,-INF) */\n"
"            }\n"
"        }\n"
"    }\n"
"    /* when y is INF */\n"
"    if (iy==0x7f800000) return (hy<0)? -pi_o_2-tiny: pi_o_2+tiny;\n"
"    /* compute y/x */\n"
"    k = (iy-ix)>>23;\n"
"    if (k > 26) {            /* |y/x| >  2**26 */\n"
"        z=pi_o_2+0.5*pi_lo;\n"
"        m&=1;\n"
"    }\n"
"    else if (k<-26&&hx<0) z=0.0;     /* 0 > |y|/x > -2**-26 */\n"
"    else z=_viv_atan_float(abs(y/x));   /* safe to do y/x */\n"
"    switch (m) {\n"
"        case 0: return       z  ;   /* atan(+,+) */\n"
"        case 1: return      -z  ;   /* atan(-,+) */\n"
"        case 2: return  pi-(z-pi_lo);/* atan(+,-) */\n"
"        default: /* case 3 */\n"
"                return  (z-pi_lo)-pi;/* atan(-,-) */\n"
"    }\n"
"}\n"
"vec2 _viv_atan2_vec2(vec2 y, vec2 x)\n"
"{\n"
"    return vec2(_viv_atan2_float(y.x, x.x), \n"
"                _viv_atan2_float(y.y, x.y));\n"
"}\n"
"vec3 _viv_atan2_vec3(vec3 y, vec3 x)\n"
"{\n"
"    return vec3(_viv_atan2_float(y.x, x.x), \n"
"                _viv_atan2_float(y.y, x.y), \n"
"                _viv_atan2_float(y.z, x.z));\n"
"}\n"
"vec4 _viv_atan2_vec4(vec4 y, vec4 x)\n"
"{\n"
"    return vec4(_viv_atan2_float(y.x, x.x), \n"
"                _viv_atan2_float(y.y, x.y), \n"
"                _viv_atan2_float(y.z, x.z), \n"
"                _viv_atan2_float(y.w, x.w));\n"
"}\n"
;

gctSTRING gcLibASIN_ACOS_Funcs_halti5_fmaSupported =
"float _viv_fma_float(float a, float b, float c);\n"
"float _viv_asin_float(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, result;\n"
"    floatTemp0 = _viv_fma_float(a, -a, 1.0);\n"
"    floatTemp0 = sqrt(floatTemp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, floatTemp0, floatTemp0);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    result = a * vec2Temp0.x;\n"
"    return result;\n"
"}\n"
"vec2 _viv_fma_vec2(vec2 a, vec2 b, vec2 c);\n"
"vec2 _viv_asin_vec2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, result;\n"
"    vec2Temp2 = _viv_fma_vec2(a, -a, vec2(1.0));\n"
"    vec2Temp2 = sqrt(vec2Temp2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec2Temp2.x, vec2Temp2.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec2Temp2.y, vec2Temp2.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    result = a * vec2(vec2Temp0.x, vec2Temp1.x);\n"
"    return result;\n"
"}\n"
"vec3 _viv_fma_vec3(vec3 a, vec3 b, vec3 c);\n"
"vec3 _viv_asin_vec3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, result;\n"
"    vec3Temp0 = _viv_fma_vec3(a, -a, vec3(1.0));\n"
"    vec3Temp0 = sqrt(vec3Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec3Temp0.x, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec3Temp0.y, vec3Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec3Temp0.z, vec3Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x1);\n"
"    result = a * vec3(vec2Temp0.x, vec2Temp1.x, vec2Temp2.x);\n"
"    return result;\n"
"}\n"
"vec4 _viv_fma_vec4(vec4 a, vec4 b, vec4 c);\n"
"vec4 _viv_asin_vec4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, result;\n"
"    vec4Temp0 = _viv_fma_vec4(a, -a, vec4(1.0));\n"
"    vec4Temp0 = sqrt(vec4Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec4Temp0.x, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec4Temp0.y, vec4Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec4Temp0.z, vec4Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, vec4Temp0.w, vec4Temp0.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x1);\n"
"    result = a * vec4(vec2Temp0.x, vec2Temp1.x, vec2Temp2.x, vec2Temp3.x);\n"
"    return result;\n"
"}\n"
"float _viv_fma_float(float a, float b, float c);\n"
"float _viv_acos_float(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, result;\n"
"    floatTemp0 = _viv_fma_float(a, -a, 1.0);\n"
"    floatTemp0 = sqrt(floatTemp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a, floatTemp0);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    result = _viv_fma_float(floatTemp0, vec2Temp0.x, vec2Temp0.y);\n"
"    return result;\n"
"}\n"
"vec2 _viv_fma_vec2(vec2 a, vec2 b, vec2 c);\n"
"vec2 _viv_acos_vec2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, result;\n"
"    vec2Temp2 = _viv_fma_vec2(a, -a, vec2(1.0));\n"
"    vec2Temp2 = sqrt(vec2Temp2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec2Temp2.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec2Temp2.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    result.x = _viv_fma_float(vec2Temp2.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_float(vec2Temp2.y, vec2Temp1.x, vec2Temp1.y);\n"
"    return result;\n"
"}\n"
"vec3 _viv_fma_vec3(vec3 a, vec3 b, vec3 c);\n"
"vec3 _viv_acos_vec3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, result;\n"
"    vec3Temp0 = _viv_fma_vec3(a, -a, vec3(1.0));\n"
"    vec3Temp0 = sqrt(vec3Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec3Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, a.z, vec3Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x0);\n"
"    result.x = _viv_fma_float(vec3Temp0.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_float(vec3Temp0.y, vec2Temp1.x, vec2Temp1.y);\n"
"    result.z = _viv_fma_float(vec3Temp0.z, vec2Temp2.x, vec2Temp2.y);\n"
"    return result;\n"
"}\n"
"vec4 _viv_fma_vec4(vec4 a, vec4 b, vec4 c);\n"
"vec4 _viv_acos_vec4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, result;\n"
"    vec4Temp0 = _viv_fma_vec4(a, -a, vec4(1.0));\n"
"    vec4Temp0 = sqrt(vec4Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec4Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, a.z, vec4Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, a.w, vec4Temp0.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x0);\n"
"    result.x = _viv_fma_float(vec4Temp0.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_float(vec4Temp0.y, vec2Temp1.x, vec2Temp1.y);\n"
"    result.z = _viv_fma_float(vec4Temp0.z, vec2Temp2.x, vec2Temp2.y);\n"
"    result.w = _viv_fma_float(vec4Temp0.w, vec2Temp3.x, vec2Temp3.y);\n"
"    return result;\n"
"}\n"
;

gctSTRING gcLibASIN_ACOS_Funcs_halti5 =
"float _viv_asin_float(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, result;\n"
"    floatTemp0 = 1.0 - a * a;\n"
"    floatTemp0 = sqrt(floatTemp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, floatTemp0, floatTemp0);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    result = a * vec2Temp0.x;\n"
"    return result;\n"
"}\n"
"vec2 _viv_asin_vec2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, result;\n"
"    vec2Temp2 = vec2(1.0) - a * a;\n"
"    vec2Temp2 = sqrt(vec2Temp2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec2Temp2.x, vec2Temp2.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec2Temp2.y, vec2Temp2.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    result = a * vec2(vec2Temp0.x, vec2Temp1.x);\n"
"    return result;\n"
"}\n"
"vec3 _viv_asin_vec3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, result;\n"
"    vec3Temp0 = vec3(1.0) - a * a;\n"
"    vec3Temp0 = sqrt(vec3Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec3Temp0.x, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec3Temp0.y, vec3Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec3Temp0.z, vec3Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x1);\n"
"    result = a * vec3(vec2Temp0.x, vec2Temp1.x, vec2Temp2.x);\n"
"    return result;\n"
"}\n"
"vec4 _viv_asin_vec4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, result;\n"
"    vec4Temp0 = vec4(1.0) - a * a;\n"
"    vec4Temp0 = sqrt(vec4Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec4Temp0.x, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec4Temp0.y, vec4Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec4Temp0.z, vec4Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, vec4Temp0.w, vec4Temp0.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x1);\n"
"    result = a * vec4(vec2Temp0.x, vec2Temp1.x, vec2Temp2.x, vec2Temp3.x);\n"
"    return result;\n"
"}\n"
"float _viv_acos_float(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, floatTemp1, result;\n"
"    floatTemp0 = 1.0 + a;\n"
"    floatTemp1 = 1.0 - a;\n"
"    floatTemp0 = floatTemp0 * floatTemp1;\n"
"    floatTemp0 = sqrt(floatTemp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a, floatTemp0);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    result = floatTemp0 * vec2Temp0.x + vec2Temp0.y;\n"
"    return result;\n"
"}\n"
"vec2 _viv_acos_vec2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, result;\n"
"    vec2Temp0 = vec2(1.0) + a;\n"
"    vec2Temp1 = vec2(1.0) - a;\n"
"    vec2Temp2 = vec2Temp0 * vec2Temp1;\n"
"    vec2Temp2 = sqrt(vec2Temp2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec2Temp2.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec2Temp2.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    result.x = vec2Temp2.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec2Temp2.y * vec2Temp1.x + vec2Temp1.y;\n"
"    return result;\n"
"}\n"
"vec3 _viv_acos_vec3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, vec3Temp1, result;\n"
"    vec3Temp0 = vec3(1.0) + a;\n"
"    vec3Temp1 = vec3(1.0) - a;\n"
"    vec3Temp0 = vec3Temp0 * vec3Temp1;\n"
"    vec3Temp0 = sqrt(vec3Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec3Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, a.z, vec3Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x0);\n"
"    result.x = vec3Temp0.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec3Temp0.y * vec2Temp1.x + vec2Temp1.y;\n"
"    result.z = vec3Temp0.z * vec2Temp2.x + vec2Temp2.y;\n"
"    return result;\n"
"}\n"
"vec4 _viv_acos_vec4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, vec4Temp1, result;\n"
"    vec4Temp0 = vec4(1.0) + a;\n"
"    vec4Temp1 = vec4(1.0) - a;\n"
"    vec4Temp0 = vec4Temp0 * vec4Temp1;\n"
"    vec4Temp0 = sqrt(vec4Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec4Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, a.z, vec4Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, a.w, vec4Temp0.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x0);\n"
"    result.x = vec4Temp0.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec4Temp0.y * vec2Temp1.x + vec2Temp1.y;\n"
"    result.z = vec4Temp0.z * vec2Temp2.x + vec2Temp2.y;\n"
"    result.w = vec4Temp0.w * vec2Temp3.x + vec2Temp3.y;\n"
"    return result;\n"
"}\n"
;

gctSTRING gcLibATAN_Funcs_halti5_fmaSupported =
"float _viv_fma_float(float a, float b, float c);\n"
"float _viv_atan_float(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, floatTemp1, result;\n"
"    floatTemp0 = _viv_fma_float(a, a, 1.0);\n"
"    floatTemp0 = inversesqrt(floatTemp0);\n"
"    _viv_asm(MUL_Z, floatTemp1, floatTemp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, floatTemp0, floatTemp1);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    result = _viv_fma_float(floatTemp1, vec2Temp0.x, vec2Temp0.y);\n"
"    return result;\n"
"}\n"
"vec2 _viv_fma_vec2(vec2 a, vec2 b, vec2 c);\n"
"vec2 _viv_atan_vec2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, vec2Temp3, result;\n"
"    vec2Temp2 = _viv_fma_vec2(a, a, vec2(1.0));\n"
"    vec2Temp2 = inversesqrt(vec2Temp2);\n"
"    _viv_asm(MUL_Z, vec2Temp3, vec2Temp2, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec2Temp2.x, vec2Temp3.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec2Temp2.y, vec2Temp3.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    result.x = _viv_fma_float(vec2Temp3.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_float(vec2Temp3.y, vec2Temp1.x, vec2Temp1.y);\n"
"    return result;\n"
"}\n"
"vec3 _viv_fma_vec3(vec3 a, vec3 b, vec3 c);\n"
"vec3 _viv_atan_vec3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, vec3Temp1, result;\n"
"    vec3Temp0 = _viv_fma_vec3(a, a, vec3(1.0));\n"
"    vec3Temp0 = inversesqrt(vec3Temp0);\n"
"    _viv_asm(MUL_Z, vec3Temp1, vec3Temp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec3Temp0.x, vec3Temp1.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec3Temp0.y, vec3Temp1.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec3Temp0.z, vec3Temp1.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x2);\n"
"    result.x = _viv_fma_float(vec3Temp1.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_float(vec3Temp1.y, vec2Temp1.x, vec2Temp1.y);\n"
"    result.z = _viv_fma_float(vec3Temp1.z, vec2Temp2.x, vec2Temp2.y);\n"
"    return result;\n"
"}\n"
"vec4 _viv_fma_vec4(vec4 a, vec4 b, vec4 c);\n"
"vec4 _viv_atan_vec4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, vec4Temp1, result;\n"
"    vec4Temp0 = _viv_fma_vec4(a, a, vec4(1.0));\n"
"    vec4Temp0 = inversesqrt(vec4Temp0);\n"
"    _viv_asm(MUL_Z, vec4Temp1, vec4Temp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec4Temp0.x, vec4Temp1.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec4Temp0.y, vec4Temp1.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec4Temp0.z, vec4Temp1.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, vec4Temp0.w, vec4Temp1.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x2);\n"
"    result.x = _viv_fma_float(vec4Temp1.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_float(vec4Temp1.y, vec2Temp1.x, vec2Temp1.y);\n"
"    result.z = _viv_fma_float(vec4Temp1.z, vec2Temp2.x, vec2Temp2.y);\n"
"    result.w = _viv_fma_float(vec4Temp1.w, vec2Temp3.x, vec2Temp3.y);\n"
"    return result;\n"
"}\n"
;

gctSTRING gcLibATAN_Funcs_halti5 =
"float _viv_atan_float(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, floatTemp1, result;\n"
"    floatTemp0 = a * a + 1.0;\n"
"    floatTemp0 = inversesqrt(floatTemp0);\n"
"    _viv_asm(MUL_Z, floatTemp1, floatTemp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, floatTemp0, floatTemp1);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    result = floatTemp1 * vec2Temp0.x + vec2Temp0.y;\n"
"    return result;\n"
"}\n"
"vec2 _viv_atan_vec2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, vec2Temp3, result;\n"
"    vec2Temp2 = a * a + vec2(1.0);\n"
"    vec2Temp2 = inversesqrt(vec2Temp2);\n"
"    _viv_asm(MUL_Z, vec2Temp3, vec2Temp2, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec2Temp2.x, vec2Temp3.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec2Temp2.y, vec2Temp3.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    result.x = vec2Temp3.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec2Temp3.y * vec2Temp1.x + vec2Temp1.y;\n"
"    return result;\n"
"}\n"
"vec3 _viv_atan_vec3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, vec3Temp1, result;\n"
"    vec3Temp0 = a * a + vec3(1.0);\n"
"    vec3Temp0 = inversesqrt(vec3Temp0);\n"
"    _viv_asm(MUL_Z, vec3Temp1, vec3Temp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec3Temp0.x, vec3Temp1.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec3Temp0.y, vec3Temp1.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec3Temp0.z, vec3Temp1.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x2);\n"
"    result.x = vec3Temp1.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec3Temp1.y * vec2Temp1.x + vec2Temp1.y;\n"
"    result.z = vec3Temp1.z * vec2Temp2.x + vec2Temp2.y;\n"
"    return result;\n"
"}\n"
"vec4 _viv_atan_vec4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, vec4Temp1, result;\n"
"    vec4Temp0 = a * a + vec4(1.0);\n"
"    vec4Temp0 = inversesqrt(vec4Temp0);\n"
"    _viv_asm(MUL_Z, vec4Temp1, vec4Temp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec4Temp0.x, vec4Temp1.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec4Temp0.y, vec4Temp1.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec4Temp0.z, vec4Temp1.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, vec4Temp0.w, vec4Temp1.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x2);\n"
"    result.x = vec4Temp1.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec4Temp1.y * vec2Temp1.x + vec2Temp1.y;\n"
"    result.z = vec4Temp1.z * vec2Temp2.x + vec2Temp2.y;\n"
"    result.w = vec4Temp1.w * vec2Temp3.x + vec2Temp3.y;\n"
"    return result;\n"
"}\n"
;

gctSTRING gcLibATAN2_Funcs_halti5_fmaSupported =
"float _viv_fma_float(float a, float b, float c);\n"
"float _viv_atan2_float(float y, float x)\n"
"{\n"
"    vec2 arctrig0, vec2Temp0;\n"
"    float dot0, rsq0, result;\n"
"    if(floatBitsToUint(y) == 0x80000000u)\n"
"    {\n"
"        y = 0.0;\n"
"    }\n"
"    _viv_asm(ARCTRIG0, arctrig0, y, x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    dot0 = dot(arctrig0, arctrig0);\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec2Temp0 = arctrig0 * rsq0;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec2Temp0.y, vec2Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    result = _viv_fma_float(arctrig0.x, vec2Temp0.x, arctrig0.y);\n"
"    return result;\n"
"}\n"
"vec2 _viv_fma_vec2(vec2 a, vec2 b, vec2 c);\n"
"vec2 _viv_atan2_vec2(vec2 y, vec2 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, vec2Temp0, vec2Temp1;\n"
"    vec2 dot0, rsq0, result;\n"
"    bvec2 sel = equal(floatBitsToUint(y), uvec2(0x80000000u));\n"
"    y = mix(y, vec2(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    dot0.x = dot(arctrig0, arctrig0);\n"
"    dot0.y = dot(arctrig1, arctrig1);\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec2Temp0 = arctrig0 * rsq0.x;\n"
"    vec2Temp1 = arctrig1 * rsq0.y;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec2Temp0.y, vec2Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec2Temp1.y, vec2Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    result.x = _viv_fma_float(arctrig0.x, vec2Temp0.x, arctrig0.y);\n"
"    result.y = _viv_fma_float(arctrig1.x, vec2Temp1.x, arctrig1.y);\n"
"    return result;\n"
"}\n"
"vec3 _viv_fma_vec3(vec3 a, vec3 b, vec3 c);\n"
"vec3 _viv_atan2_vec3(vec3 y, vec3 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, arctrig2, vec3Temp0, vec3Temp1, vec3Temp2;\n"
"    vec3 dot0, rsq0, result;\n"
"    bvec3 sel = equal(floatBitsToUint(y), uvec3(0x80000000u));\n"
"    y = mix(y, vec3(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig2, y.z, x.z);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x83);\n"
"    dot0.x = dot(arctrig0, arctrig0);\n"
"    dot0.y = dot(arctrig1, arctrig1);\n"
"    dot0.z = dot(arctrig2, arctrig2);\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec3Temp0 = arctrig0 * rsq0.x;\n"
"    vec3Temp1 = arctrig1 * rsq0.y;\n"
"    vec3Temp2 = arctrig2 * rsq0.z;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec3Temp0.y, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec3Temp1.y, vec3Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig2, vec3Temp2.y, vec3Temp2.x);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x3);\n"
"    result.x = _viv_fma_float(arctrig0.x, vec3Temp0.x, arctrig0.y);\n"
"    result.y = _viv_fma_float(arctrig1.x, vec3Temp1.x, arctrig1.y);\n"
"    result.z = _viv_fma_float(arctrig2.x, vec3Temp2.x, arctrig2.y);\n"
"    return result;\n"
"}\n"
"vec4 _viv_fma_vec4(vec4 a, vec4 b, vec4 c);\n"
"vec4 _viv_atan2_vec4(vec4 y, vec4 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, arctrig2, arctrig3, vec4Temp0, vec4Temp1, vec4Temp2, vec4Temp3;\n"
"    vec4 dot0, rsq0, result;\n"
"    bvec4 sel = equal(floatBitsToUint(y), uvec4(0x80000000u));\n"
"    y = mix(y, vec4(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig2, y.z, x.z);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig3, y.w, x.w);\n"
"    _viv_asm(ARCTRIG1, arctrig3, arctrig3, 0x83);\n"
"    dot0.x = dot(arctrig0, arctrig0);\n"
"    dot0.y = dot(arctrig1, arctrig1);\n"
"    dot0.z = dot(arctrig2, arctrig2);\n"
"    dot0.w = dot(arctrig3, arctrig3);\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec4Temp0 = arctrig0 * rsq0.x;\n"
"    vec4Temp1 = arctrig1 * rsq0.y;\n"
"    vec4Temp2 = arctrig2 * rsq0.z;\n"
"    vec4Temp3 = arctrig3 * rsq0.w;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec4Temp0.y, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec4Temp1.y, vec4Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig2, vec4Temp2.y, vec4Temp2.x);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig3, vec4Temp3.y, vec4Temp3.x);\n"
"    _viv_asm(ARCTRIG1, arctrig3, arctrig3, 0x3);\n"
"    result.x = _viv_fma_float(arctrig0.x, vec4Temp0.x, arctrig0.y);\n"
"    result.y = _viv_fma_float(arctrig1.x, vec4Temp1.x, arctrig1.y);\n"
"    result.z = _viv_fma_float(arctrig2.x, vec4Temp2.x, arctrig2.y);\n"
"    result.w = _viv_fma_float(arctrig3.x, vec4Temp3.x, arctrig3.y);\n"
"    return result;\n"
"}\n"
;

gctSTRING gcLibATAN2_Funcs_halti5 =
"float _viv_atan2_float(float y, float x)\n"
"{\n"
"    vec2 arctrig0, vec2Temp0;\n"
"    float dot0, rsq0, result;\n"
"    if(floatBitsToUint(y) == 0x80000000u)\n"
"    {\n"
"        y = 0.0;\n"
"    }\n"
"    _viv_asm(ARCTRIG0, arctrig0, y, x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    dot0 = arctrig0.x * arctrig0.x + arctrig0.y * arctrig0.y;\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec2Temp0 = arctrig0 * rsq0;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec2Temp0.y, vec2Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    result = arctrig0.x * vec2Temp0.x + arctrig0.y;\n"
"    return result;\n"
"}\n"
"vec2 _viv_atan2_vec2(vec2 y, vec2 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, vec2Temp0, vec2Temp1;\n"
"    vec2 dot0, rsq0, result;\n"
"    bvec2 sel = equal(floatBitsToUint(y), uvec2(0x80000000u));\n"
"    y = mix(y, vec2(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    dot0.x = arctrig0.x * arctrig0.x + arctrig0.y * arctrig0.y;\n"
"    dot0.y = arctrig1.x * arctrig1.x + arctrig1.y * arctrig1.y;\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec2Temp0 = arctrig0 * rsq0.x;\n"
"    vec2Temp1 = arctrig1 * rsq0.y;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec2Temp0.y, vec2Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec2Temp1.y, vec2Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    result.x = arctrig0.x * vec2Temp0.x + arctrig0.y;\n"
"    result.y = arctrig1.x * vec2Temp1.x + arctrig1.y;\n"
"    return result;\n"
"}\n"
"vec3 _viv_atan2_vec3(vec3 y, vec3 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, arctrig2, vec3Temp0, vec3Temp1, vec3Temp2;\n"
"    vec3 dot0, rsq0, result;\n"
"    bvec3 sel = equal(floatBitsToUint(y), uvec3(0x80000000u));\n"
"    y = mix(y, vec3(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig2, y.z, x.z);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x83);\n"
"    dot0.x = arctrig0.x * arctrig0.x + arctrig0.y * arctrig0.y;\n"
"    dot0.y = arctrig1.x * arctrig1.x + arctrig1.y * arctrig1.y;\n"
"    dot0.z = arctrig2.x * arctrig2.x + arctrig2.y * arctrig2.y;\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec3Temp0 = arctrig0 * rsq0.x;\n"
"    vec3Temp1 = arctrig1 * rsq0.y;\n"
"    vec3Temp2 = arctrig2 * rsq0.z;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec3Temp0.y, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec3Temp1.y, vec3Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig2, vec3Temp2.y, vec3Temp2.x);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x3);\n"
"    result.x = arctrig0.x * vec3Temp0.x + arctrig0.y;\n"
"    result.y = arctrig1.x * vec3Temp1.x + arctrig1.y;\n"
"    result.z = arctrig2.x * vec3Temp2.x + arctrig2.y;\n"
"    return result;\n"
"}\n"
"vec4 _viv_atan2_vec4(vec4 y, vec4 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, arctrig2, arctrig3, vec4Temp0, vec4Temp1, vec4Temp2, vec4Temp3;\n"
"    vec4 dot0, rsq0, result;\n"
"    bvec4 sel = equal(floatBitsToUint(y), uvec4(0x80000000u));\n"
"    y = mix(y, vec4(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig2, y.z, x.z);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig3, y.w, x.w);\n"
"    _viv_asm(ARCTRIG1, arctrig3, arctrig3, 0x83);\n"
"    dot0.x = arctrig0.x * arctrig0.x + arctrig0.y * arctrig0.y;\n"
"    dot0.y = arctrig1.x * arctrig1.x + arctrig1.y * arctrig1.y;\n"
"    dot0.z = arctrig2.x * arctrig2.x + arctrig2.y * arctrig2.y;\n"
"    dot0.w = arctrig3.x * arctrig3.x + arctrig3.y * arctrig3.y;\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec4Temp0 = arctrig0 * rsq0.x;\n"
"    vec4Temp1 = arctrig1 * rsq0.y;\n"
"    vec4Temp2 = arctrig2 * rsq0.z;\n"
"    vec4Temp3 = arctrig3 * rsq0.w;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec4Temp0.y, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec4Temp1.y, vec4Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig2, vec4Temp2.y, vec4Temp2.x);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig3, vec4Temp3.y, vec4Temp3.x);\n"
"    _viv_asm(ARCTRIG1, arctrig3, arctrig3, 0x3);\n"
"    result.x = arctrig0.x * vec4Temp0.x + arctrig0.y;\n"
"    result.y = arctrig1.x * vec4Temp1.x + arctrig1.y;\n"
"    result.z = arctrig2.x * vec4Temp2.x + arctrig2.y;\n"
"    result.w = arctrig3.x * vec4Temp3.x + arctrig3.y;\n"
"    return result;\n"
"}\n"
;

gctSTRING gcLibConvF32ToF16_Funcs =
"float _viv_convF32ToF16_float(float x, int roundingMode)\n"
"{\n"
"   float result;\n"
"   if (x != 0.0 && x != -0.0 && !isnan(x) && !isinf(x))\n"
"   {\n"
"       highp uint bits = floatBitsToUint(x);\n"
"       highp uint sign16 = (bits >> 16u) & 0x00008000u;\n"
"       highp uint exp32 = (bits >> 23u) & 0xFFu;\n"
"       highp int exp16 = (int(exp32) - 127 + 15);\n"
"       highp uint mantissa = bits & 0x007fffffu;\n"
"       if (exp16 > 31)\n"
"       {\n"
"           if (roundingMode == ROUNDING_RTZ)\n"
"               return uintBitsToFloat(sign16 | 0x7bffu);\n"
"           else\n"
"               return uintBitsToFloat(sign16 | (0x1fu << 10));\n"
"       }\n"
"       else if (exp16 > 0 && exp16 <= 30 && roundingMode == ROUNDING_RTZ)\n"
"       {\n"
"           return uintBitsToFloat(sign16 | uint(exp16 << 10u) | (mantissa >> 13u));\n"
"       }\n"
"   }\n"
"   _viv_asm(CONV, result!<f:FLOAT16>, x, 0);\n"
"   return result;\n"
"}\n"
"vec2 _viv_convF32ToF16_vec2(vec2 x, int roundingMode)\n"
"{\n"
"   vec2 result;\n"
"   result.x = _viv_convF32ToF16_float(x.x, roundingMode);\n"
"   result.y = _viv_convF32ToF16_float(x.y, roundingMode);\n"
"   return result;\n"
"}\n"
"vec3 _viv_convF32ToF16_vec3(vec3 x, int roundingMode)\n"
"{\n"
"   vec3 result;\n"
"   result.x = _viv_convF32ToF16_float(x.x, roundingMode);\n"
"   result.y = _viv_convF32ToF16_float(x.y, roundingMode);\n"
"   result.z = _viv_convF32ToF16_float(x.z, roundingMode);\n"
"   return result;\n"
"}\n"
"vec4 _viv_convF32ToF16_vec4(vec4 x, int roundingMode)\n"
"{\n"
"   vec4 result;\n"
"   result.x = _viv_convF32ToF16_float(x.x, roundingMode);\n"
"   result.y = _viv_convF32ToF16_float(x.y, roundingMode);\n"
"   result.z = _viv_convF32ToF16_float(x.z, roundingMode);\n"
"   result.w = _viv_convF32ToF16_float(x.w, roundingMode);\n"
"   return result;\n"
"}\n"
;

gctSTRING gcLibQuantizeToF16_Funcs =
"float _viv_quantizeToF16_float(float x)\n"
"{\n"
"   float result;\n"
"   highp uint bits = floatBitsToUint(x);\n"
"   highp uint signBit = bits >> 31u;\n"
"   highp uint exponentBit = (bits >> 23u) & 0xFFu;\n"
"   highp uint mantissaBit = bits & 0x7FFFFFu;\n"
/* Always flush a denormalized number to zero with sign. */
"   if (exponentBit == 0u && mantissaBit != 0u)\n"
"       return uintBitsToFloat(bits & 0x80000000u);\n"
"   _viv_asm(CONV, result!<f:FLOAT16>, x, 0);\n"
"   _viv_asm(CONV, result, result, 12);\n"
"   return result;\n"
"}\n"
"vec2 _viv_quantizeToF16_vec2(vec2 x)\n"
"{\n"
"   vec2 result;\n"
"   result.x = _viv_quantizeToF16_float(x.x);\n"
"   result.y = _viv_quantizeToF16_float(x.y);\n"
"   return result;\n"
"}\n"
"vec3 _viv_quantizeToF16_vec3(vec3 x)\n"
"{\n"
"   vec3 result;\n"
"   result.x = _viv_quantizeToF16_float(x.x);\n"
"   result.y = _viv_quantizeToF16_float(x.y);\n"
"   result.z = _viv_quantizeToF16_float(x.z);\n"
"   return result;\n"
"}\n"
"vec4 _viv_quantizeToF16_vec4(vec4 x)\n"
"{\n"
"   vec4 result;\n"
"   result.x = _viv_quantizeToF16_float(x.x);\n"
"   result.y = _viv_quantizeToF16_float(x.y);\n"
"   result.z = _viv_quantizeToF16_float(x.z);\n"
"   result.w = _viv_quantizeToF16_float(x.w);\n"
"   return result;\n"
"}\n"
;

/* findLSB gc3000/5000 implementation */
gctSTRING gcLibFindLSB_Func_1 =
"lowp int _viv_findLSB_1(int a)\n"
"{\n"
"   lowp int result = -1;\n"
"   lowp int i;\n"
"   highp int mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a & mask)  != 0) { result = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_2 =
"lowp ivec2 _viv_findLSB_2(ivec2 a)\n"
"{\n"
"   lowp ivec2 result = ivec2(-1, -1);\n"
"   lowp int i;\n"
"   highp int mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_3 =
"lowp ivec3 _viv_findLSB_3(ivec3 a)\n"
"{\n"
"   lowp ivec3 result = ivec3(-1, -1, -1);\n"
"   lowp int i;\n"
"   highp int mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.z & mask)  != 0) { result.z = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_4 =
"lowp ivec4 _viv_findLSB_4(ivec4 a)\n"
"{\n"
"   lowp ivec4 result = ivec4(-1, -1, -1, -1);\n"
"   lowp int i;\n"
"   highp int mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.z & mask)  != 0) { result.z = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.w & mask)  != 0) { result.w = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";


gctSTRING gcLibFindLSB_Func_5 =
"lowp int _viv_findLSB_5(uint a)\n"
"{\n"
"   lowp int result = -1;\n"
"   lowp int i;\n"
"   highp uint mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a & mask)  != 0u) { result = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_6 =
"lowp ivec2 _viv_findLSB_6(uvec2 a)\n"
"{\n"
"   lowp ivec2 result = ivec2(-1,-1);\n"
"   lowp int i;\n"
"   highp uint mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0u) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0u) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_7 =
"lowp ivec3 _viv_findLSB_7(uvec3 a)\n"
"{\n"
"   lowp ivec3 result = ivec3(-1, -1, -1);\n"
"   lowp int i;\n"
"   highp uint mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0u) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0u) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.z & mask)  != 0u) { result.z = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_8 =
"lowp ivec4 _viv_findLSB_8(uvec4 a)\n"
"{\n"
"   lowp ivec4 result = ivec4(-1, -1, -1, -1);\n"
"   lowp int i;\n"
"   highp uint mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0u) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0u) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.z & mask)  != 0u) { result.z = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.w & mask)  != 0u) { result.w = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

/* findLSB gc7000 implementation */
gctSTRING gcLibFindLSB_Func_1_hati4 =
"lowp int _viv_findLSB_1(int a)\n"
"{\n"
"   lowp int result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_2_hati4 =
"lowp ivec2 _viv_findLSB_2(ivec2 a)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_3_hati4 =
"lowp ivec3 _viv_findLSB_3(ivec3 a)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_4_hati4 =
"lowp ivec4 _viv_findLSB_4(ivec4 a)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_5_hati4 =
"lowp int _viv_findLSB_5(uint a)\n"
"{\n"
"   int result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_6_hati4 =
"lowp ivec2 _viv_findLSB_6(uvec2 a)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_7_hati4 =
"lowp ivec3 _viv_findLSB_7(uvec3 a)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindLSB_Func_8_hati4 =
"lowp ivec4 _viv_findLSB_8(uvec4 a)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

/* findMSB gc3000/5000 implementation */
gctSTRING gcLibFindMSB_Func_1 =
"lowp int _viv_findMSB_1(highp int a)\n"
"{\n"
"   lowp int result = -1;\n"
"   lowp int i;\n"
"   highp int mask = 1 << 30;\n"
"   if (a < 0) { a = ~a; } \n"
"   for (i = 30; i >= 0 ; i--)\n"
"   {\n"
"       if ((a & mask)  != 0) { result = i; break; } \n"
"       mask = mask >> 1;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindMSB_Func_2 =
"lowp ivec2 _viv_findMSB_2(highp ivec2 a)\n"
"{\n"
"   lowp ivec2 result;\n"
"   if (a.x != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.x < 0) { a.x = ~a.x; } \n"
"       for (result.x = 30; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.y < 0) { a.y = ~a.y; } \n"
"       for (result.y = 30; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   return result;\n"
"}\n";


gctSTRING gcLibFindMSB_Func_3 =
"lowp ivec3 _viv_findMSB_3(highp ivec3 a)\n"
"{\n"
"   lowp ivec3 result;\n"
"   if (a.x != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.x < 0) { a.x = ~a.x; } \n"
"       for (result.x = 30; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.y < 0) { a.y = ~a.y; } \n"
"       for (result.y = 30; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   if (a.z != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.z < 0) { a.z = ~a.z; } \n"
"       for (result.z = 30; result.z >= 0 ; result.z--)\n"
"       {\n"
"           if ((a.z & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.z = -1;\n"
"   }\n"
"   return result;\n"
"}\n";


gctSTRING gcLibFindMSB_Func_4 =
"lowp ivec4 _viv_findMSB_4(highp ivec4 a)\n"
"{\n"
"   lowp ivec4 result;\n"
"   if (a.x != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.x < 0) { a.x = ~a.x; } \n"
"       for (result.x = 30; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.y < 0) { a.y = ~a.y; } \n"
"       for (result.y = 30; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   if (a.z != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.z < 0) { a.z = ~a.z; } \n"
"       for (result.z = 30; result.z >= 0 ; result.z--)\n"
"       {\n"
"           if ((a.z & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.z = -1;\n"
"   }\n"
"   if (a.w != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.w < 0) { a.w = ~a.w; } \n"
"       for (result.w = 30; result.w >= 0 ; result.w--)\n"
"       {\n"
"           if ((a.w & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.w = -1;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindMSB_Func_5 =
"lowp int _viv_findMSB_5(highp uint a)\n"
"{\n"
"   lowp int result = -1;\n"
"   lowp int i;\n"
"   highp uint mask = 1u << 31;\n"
"   for (i = 31; i >= 0 ; i--)\n"
"   {\n"
"       if ((a & mask)  != 0u) { result = i; break; } \n"
"       mask = mask >> 1;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindMSB_Func_6 =
"lowp ivec2 _viv_findMSB_6(highp uvec2 a)\n"
"{\n"
"   lowp ivec2 result;\n"
"   highp uint mask;\n"
"   if (a.x != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.x = 31; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.y = 31; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   return result;\n"
"}\n";


gctSTRING gcLibFindMSB_Func_7 =
"lowp ivec3 _viv_findMSB_7(highp uvec3 a)\n"
"{\n"
"   lowp ivec3 result;\n"
"   highp uint mask;\n"
"   if (a.x != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.x = 31; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.y = 31; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   if (a.z != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.z = 31; result.z >= 0 ; result.z--)\n"
"       {\n"
"           if ((a.z & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.z = -1;\n"
"   }\n"
"   return result;\n"
"}\n";


gctSTRING gcLibFindMSB_Func_8 =
"lowp ivec4 _viv_findMSB_8(highp uvec4 a)\n"
"{\n"
"   lowp ivec4 result;\n"
"   highp uint mask;\n"
"   if (a.x != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.x = 31; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.y = 31; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   if (a.z != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.z = 31; result.z >= 0 ; result.z--)\n"
"       {\n"
"           if ((a.z & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.z = -1;\n"
"   }\n"
"   if (a.w != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.w = 31; result.w >= 0 ; result.w--)\n"
"       {\n"
"           if ((a.w & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.w = -1;\n"
"   }\n"
"   return result;\n"
"}\n";


/* findMSB gc7000 implementation */
gctSTRING gcLibFindMSB_Func_1_hati4 =
"lowp int _viv_findMSB_1(highp int a)\n"
"{\n"
"   lowp int result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindMSB_Func_2_hati4 =
"lowp ivec2 _viv_findMSB_2(highp ivec2 a)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindMSB_Func_3_hati4 =
"lowp ivec3 _viv_findMSB_3(highp ivec3 a)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindMSB_Func_4_hati4 =
"lowp ivec4 _viv_findMSB_4(highp ivec4 a)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindMSB_Func_5_hati4 =
"lowp int _viv_findMSB_5(highp uint a)\n"
"{\n"
"   int result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindMSB_Func_6_hati4 =
"lowp ivec2 _viv_findMSB_6(highp uvec2 a)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindMSB_Func_7_hati4 =
"lowp ivec3 _viv_findMSB_7(highp uvec3 a)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFindMSB_Func_8_hati4 =
"lowp ivec4 _viv_findMSB_8(highp uvec4 a)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

/* bitfieldReverse gc3000/5000 implementation */
gctSTRING gcLibBitfieldReverse_Func_1 =
"highp int _viv_bitfieldReverse_1(highp int a)\n"
"{\n"
"   highp uint temp = uint(a);\n"
"   highp uint result = ((temp >> 1) & 0x55555555u) | ((temp & 0x55555555u) << 1);\n"
"   result  = ((result >> 2) & 0x33333333u) | ((result & 0x33333333u) << 2);\n"
"   result = ((result >> 4) & 0x0F0F0F0Fu) | ((result & 0x0F0F0F0Fu) << 4);\n"
"   result = ((result >> 8) & 0x00FF00FFu) | ((result & 0x00FF00FFu) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return int(result);\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_2 =
"highp ivec2 _viv_bitfieldReverse_2(highp ivec2 a)\n"
"{\n"
"   highp uvec2 temp = uvec2(a);\n"
"   highp uvec2 result = ((temp >> 1) & uvec2(0x55555555u)) | ((temp & uvec2(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec2(0x33333333u)) | ((result & uvec2(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec2(0x0F0F0F0Fu)) | ((result & uvec2(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec2(0x00FF00FFu)) | ((result & uvec2(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return ivec2(result);\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_3 =
"highp ivec3 _viv_bitfieldReverse_3(highp ivec3 a)\n"
"{\n"
"   highp uvec3 temp = uvec3(a);\n"
"   highp uvec3 result = ((temp >> 1) & uvec3(0x55555555u)) | ((temp & uvec3(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec3(0x33333333u)) | ((result & uvec3(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec3(0x0F0F0F0Fu)) | ((result & uvec3(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec3(0x00FF00FFu)) | ((result & uvec3(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return ivec3(result);\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_4 =
"highp ivec4 _viv_bitfieldReverse_4(highp ivec4 a)\n"
"{\n"
"   highp uvec4 temp = uvec4(a);\n"
"   highp uvec4 result = ((temp >> 1) & uvec4(0x55555555u)) | ((temp & uvec4(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec4(0x33333333u)) | ((result & uvec4(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec4(0x0F0F0F0Fu)) | ((result & uvec4(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec4(0x00FF00FFu)) | ((result & uvec4(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return ivec4(result);\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_5 =
"highp uint _viv_bitfieldReverse_5(highp uint a)\n"
"{\n"
"   highp uint result = ((a >> 1) & 0x55555555u) | ((a & 0x55555555u) << 1);\n"
"   result  = ((result >> 2) & 0x33333333u) | ((result & 0x33333333u) << 2);\n"
"   result = ((result >> 4) & 0x0F0F0F0Fu) | ((result & 0x0F0F0F0Fu) << 4);\n"
"   result = ((result >> 8) & 0x00FF00FFu) | ((result & 0x00FF00FFu) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_6 =
"highp uvec2 _viv_bitfieldReverse_6(highp uvec2 a)\n"
"{\n"
"   highp uvec2 result = ((a >> 1) & uvec2(0x55555555u)) | ((a & uvec2(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec2(0x33333333u)) | ((result & uvec2(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec2(0x0F0F0F0Fu)) | ((result & uvec2(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec2(0x00FF00FFu)) | ((result & uvec2(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_7 =
"highp uvec3 _viv_bitfieldReverse_7(highp uvec3 a)\n"
"{\n"
"   highp uvec3 result = ((a >> 1) & uvec3(0x55555555u)) | ((a & uvec3(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec3(0x33333333u)) | ((result & uvec3(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec3(0x0F0F0F0Fu)) | ((result & uvec3(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec3(0x00FF00FFu)) | ((result & uvec3(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_8 =
"highp uvec4 _viv_bitfieldReverse_8(highp uvec4 a)\n"
"{\n"
"   highp uvec4 result = ((a >> 1) & uvec4(0x55555555u)) | ((a & uvec4(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec4(0x33333333u)) | ((result & uvec4(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec4(0x0F0F0F0Fu)) | ((result & uvec4(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec4(0x00FF00FFu)) | ((result & uvec4(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return result;\n"
"}\n";

/* bitfieldReverse gc7000 implementation */
gctSTRING gcLibBitfieldReverse_Func_1_hati4 =
"highp int _viv_bitfieldReverse_1(highp int a)\n"
"{\n"
"   highp int result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_2_hati4 =
"highp ivec2 _viv_bitfieldReverse_2(highp ivec2 a)\n"
"{\n"
"   highp ivec2 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_3_hati4 =
"highp ivec3 _viv_bitfieldReverse_3(highp ivec3 a)\n"
"{\n"
"   highp ivec3 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";


gctSTRING gcLibBitfieldReverse_Func_4_hati4 =
"highp ivec4 _viv_bitfieldReverse_4(highp ivec4 a)\n"
"{\n"
"   highp ivec4 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_5_hati4 =
"highp uint _viv_bitfieldReverse_5(highp uint a)\n"
"{\n"
"   highp uint result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_6_hati4 =
"highp uvec2 _viv_bitfieldReverse_6(highp uvec2 a)\n"
"{\n"
"   highp uvec2 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";


gctSTRING gcLibBitfieldReverse_Func_7_hati4 =
"highp uvec3 _viv_bitfieldReverse_7(highp uvec3 a)\n"
"{\n"
"   highp uvec3 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibBitfieldReverse_Func_8_hati4 =
"highp uvec4 _viv_bitfieldReverse_8(highp uvec4 a)\n"
"{\n"
"   highp uvec4 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

/* bitfieldExtract gc3000/5000 implementation */
gctSTRING gcLibBitfieldExtract_Func =
"int _viv_bitfieldExtract_int(int a, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   if (offset >= 32) { result = 0u; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uint mask = (~0u >> (32 - bits));\n"
"           highp uint aa = uint(a);\n"
"           result = (aa >> offset) & mask;\n"
"           if (((result >> (bits -1)) & 0x1u) != 0u) {\n"
"               /* sign extension */\n"
"               mask = (~0u << (bits -1));\n"
"               result = result | mask;\n"
"           }\n"
"       } else { \n"
"           result = 0u;\n"
"       }\n"
"   }\n"
"   return int(result);\n"
"}\n"
"int _viv_bitfieldExtract_int_const(int a, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   highp uint mask = (~0u >> (32 - bits));\n"
"   result = (uint(a) >> offset) & mask;\n"
"   if (((result >> (bits -1)) & 0x1u) != 0u) {\n"
"       /* sign extension */\n"
"       mask = (~0u << (bits -1));\n"
"       result = result | mask;\n"
"   }\n"
"   return int(result);\n"
"}\n"
"ivec2 _viv_bitfieldExtract_ivec2(ivec2 a, int offset, int bits)\n"
"{\n"
"   highp uvec2 result;\n"
"   if (offset >= 32) { result = uvec2(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec2 mask = (uvec2(~0u) >> (32 - bits));\n"
"           highp uvec2 aa = uvec2(a);\n"
"           result = (aa >> offset) & mask;\n"
"           bvec2 sel = notEqual(((result >> (bits -1)) & uvec2(0x1u)), uvec2(0u));\n"
"           mask = (uvec2(~0u) << (bits - 1));\n"
"           result = mix(result, (result | mask), sel);\n"
"       } else { \n"
"           result = uvec2(0u);\n"
"       }\n"
"   }\n"
"   return ivec2(result);\n"
"}\n"
"ivec3 _viv_bitfieldExtract_ivec3(ivec3 a, int offset, int bits)\n"
"{\n"
"   highp uvec3 result;\n"
"   if (offset >= 32) { result = uvec3(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec3 mask = (uvec3(~0u) >> (32 - bits));\n"
"           highp uvec3 aa = uvec3(a);\n"
"           result = (aa >> offset) & mask;\n"
"           bvec3 sel = notEqual(((result >> (bits -1)) & uvec3(0x1u)), uvec3(0u));\n"
"           mask = (uvec3(~0u) << (bits-1));\n"
"           result = mix(result, (result | mask), sel);\n"
"       } else { \n"
"           result = uvec3(0u);\n"
"       }\n"
"   }\n"
"   return ivec3(result);\n"
"}\n"
"ivec4 _viv_bitfieldExtract_ivec4(ivec4 a, int offset, int bits)\n"
"{\n"
"   highp uvec4 result;\n"
"   if (offset >= 32) { result = uvec4(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec4 mask = (uvec4(~0u) >> (32 - bits));\n"
"           highp uvec4 aa = uvec4(a);\n"
"           result = (aa >> offset) & mask;\n"
"           bvec4 sel = notEqual(((result >> (bits -1)) & uvec4(0x1u)), uvec4(0u));\n"
"           mask = (uvec4(~0u) << (bits-1));\n"
"           result = mix(result, (result | mask), sel);\n"
"       } else { \n"
"           result = uvec4(0u);\n"
"       }\n"
"   }\n"
"   return ivec4(result);\n"
"}\n"
"uint _viv_bitfieldExtract_uint(uint a, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   if (offset >= 32) { result = 0u; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uint mask = (~0u >> (32 - bits));\n"
"           result = (a >> offset) & mask;\n"
"       } else { \n"
"           result = 0u;\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n"
"highp uint _viv_bitfieldExtract_uint_const(highp uint a, int offset, int bits)\n"
"{\n"
"   highp uint mask = (~0u >> (32 - bits));\n"
"   highp uint result = (a >> offset) & mask;\n"
"   return result;\n"
"}\n"
"uvec2 _viv_bitfieldExtract_uvec2(uvec2 a, int offset, int bits)\n"
"{\n"
"   highp uvec2 result;\n"
"   if (offset >= 32) { result = uvec2(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec2 mask = (uvec2(~0u) >> (32 - bits));\n"
"           result = (a >> offset) & mask;\n"
"       } else { \n"
"           result = uvec2(0u);\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n"
"uvec3 _viv_bitfieldExtract_uvec3(uvec3 a, int offset, int bits)\n"
"{\n"
"   highp uvec3 result;\n"
"   if (offset >= 32) { result = uvec3(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec3 mask = (uvec3(~0u) >> (32 - bits));\n"
"           result = (a >> offset) & mask;\n"
"       } else { \n"
"           result = uvec3(0u);\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n"
"uvec4 _viv_bitfieldExtract_uvec4(uvec4 a, int offset, int bits)\n"
"{\n"
"   highp uvec4 result;\n"
"   if (offset >= 32) { result = uvec4(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec4 mask = (uvec4(~0u) >> (32 - bits));\n"
"           result = (a >> offset) & mask;\n"
"       } else { \n"
"           result = uvec4(0u);\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n";

/* bitfieldExtract gc7000 implementation */
gctSTRING gcLibBitfieldExtract_Func_halti4 =
"int _viv_bitfieldExtract_int(int a, int offset, int bits)\n"
"{\n"
"   int result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"int _viv_bitfieldExtract_int_const(int a, int offset, int bits)\n"
"{\n"
"   int result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"ivec2 _viv_bitfieldExtract_ivec2(ivec2 a, int offset, int bits)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"ivec3 _viv_bitfieldExtract_ivec3(ivec3 a, int offset, int bits)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"ivec4 _viv_bitfieldExtract_ivec4(ivec4 a, int offset, int bits)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"uint _viv_bitfieldExtract_uint(uint a, int offset, int bits)\n"
"{\n"
"   uint result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"highp uint _viv_bitfieldExtract_uint_const(highp uint a, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"uvec2 _viv_bitfieldExtract_uvec2(uvec2 a, int offset, int bits)\n"
"{\n"
"   uvec2 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"uvec3 _viv_bitfieldExtract_uvec3(uvec3 a, int offset, int bits)\n"
"{\n"
"   uvec3 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"uvec4 _viv_bitfieldExtract_uvec4(uvec4 a, int offset, int bits)\n"
"{\n"
"   uvec4 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n";

/* bitfieldInsert gc3000/5000 implementation */
gctSTRING gcLibBitfieldInsert_Func =
"int _viv_bitfieldInsert_int(int a, int b, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   if (offset >= 32) { result = uint(a); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = uint(a);\n"
"           highp uint mask = (~0u >> (32 - bits)) << offset;\n"
"           result = result & ~mask;\n"
"           result = result | ((uint(b) << offset) & mask);\n"
"       } else { \n"
"           result = uint(a);\n"
"       }\n"
"   }\n"
"   return int(result);\n"
"}\n"
"ivec2 _viv_bitfieldInsert_ivec2(ivec2 a, ivec2 b, int offset, int bits)\n"
"{\n"
"   highp uvec2 result;\n"
"   if (offset >= 32) { result = uvec2(a); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = uvec2(a);\n"
"           highp uvec2 mask = (uvec2(~0u) >> (32 - bits)) << offset;\n"
"           result = result & ~mask;\n"
"           result = result | ((uvec2(b) << offset) & mask);\n"
"       } else { \n"
"           result = uvec2(a);\n"
"       }\n"
"   }\n"
"   return ivec2(result);\n"
"}\n"
"ivec3 _viv_bitfieldInsert_ivec3(ivec3 a, ivec3 b, int offset, int bits)\n"
"{\n"
"   highp uvec3 result;\n"
"   if (offset >= 32) { result = uvec3(a); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = uvec3(a);\n"
"           highp uvec3 mask = (uvec3(~0u) >> (32 - bits)) << offset;\n"
"           result = result & ~mask;\n"
"           result = result | ((uvec3(b) << offset) & mask);\n"
"       } else { \n"
"           result = uvec3(a);\n"
"       }\n"
"   }\n"
"   return ivec3(result);\n"
"}\n"
"ivec4 _viv_bitfieldInsert_ivec4(ivec4 a, ivec4 b, int offset, int bits)\n"
"{\n"
"   highp uvec4 result;\n"
"   if (offset >= 32) { result = uvec4(a); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = uvec4(a);\n"
"           highp uvec4 mask = (uvec4(~0u) >> (32 - bits)) << offset;\n"
"           result = result & ~mask;\n"
"           result = result | ((uvec4(b) << offset) & mask);\n"
"       } else { \n"
"           result = uvec4(a);\n"
"       }\n"
"   }\n"
"   return ivec4(result);\n"
"}\n"
"uint _viv_bitfieldInsert_uint(uint a, uint b, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   if (offset >= 32) { result = a; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = a;\n"
"           highp uint aa = ~0u >> (32 - bits); \n"
"           highp uint mask = aa << offset;\n"
"           result = result & ~mask;\n"
"           highp uint bb = b << offset; \n"
"           result = result | (bb & mask);\n"
"       } else { \n"
"           result = a;\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n"
"highp uint _viv_bitfieldInsert_uint_const(highp uint a, highp uint b, int offset, int bits)\n"
"{\n"
"   highp uint result = a;\n"
"   highp uint mask = (~0u >> (32 - bits)) << offset;\n"
"   result = result & ~mask;\n"
"   result = result | ((b << offset) & mask);\n"
"   return result;\n"
"}\n"
"uvec2 _viv_bitfieldInsert_uvec2(uvec2 a, uvec2 b, int offset, int bits)\n"
"{\n"
"   highp uvec2 result;\n"
"   if (offset >= 32) { result = a; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = a;\n"
"           highp uvec2 aa = uvec2(~0u) >> (32 - bits); \n"
"           highp uvec2 mask = aa << offset;\n"
"           result = result & ~mask;\n"
"           highp uvec2 bb = b << offset; \n"
"           result = result | (bb & mask);\n"
"       } else { \n"
"           result = a;\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n"
"uvec3 _viv_bitfieldInsert_uvec3(uvec3 a, uvec3 b, int offset, int bits)\n"
"{\n"
"   highp uvec3 result;\n"
"   if (offset >= 32) { result = a; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = a;\n"
"           highp uvec3 aa = uvec3(~0u) >> (32 - bits); \n"
"           highp uvec3 mask = aa << offset;\n"
"           result = result & ~mask;\n"
"           highp uvec3 bb = b << offset; \n"
"           result = result | (bb & mask);\n"
"       } else { \n"
"           result = a;\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n"
"uvec4 _viv_bitfieldInsert_uvec4(uvec4 a, uvec4 b, int offset, int bits)\n"
"{\n"
"   highp uvec4 result;\n"
"   if (offset >= 32) { result = a; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = a;\n"
"           highp uvec4 aa = uvec4(~0u) >> (32 - bits); \n"
"           highp uvec4 mask = aa << offset;\n"
"           result = result & ~mask;\n"
"           highp uvec4 bb = b << offset; \n"
"           result = result | (bb & mask);\n"
"       } else { \n"
"           result = a;\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n";

/* bitfieldInsert gc7000 implementation */
gctSTRING gcLibBitfieldInsert_Func_halti4 =
"int _viv_bitfieldInsert_int(int a, int b, int offset, int bits)\n"
"{\n"
"   int result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n"
"ivec2 _viv_bitfieldInsert_ivec2(ivec2 a, ivec2 b, int offset, int bits)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n"
"ivec3 _viv_bitfieldInsert_ivec3(ivec3 a, ivec3 b, int offset, int bits)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n"
"ivec4 _viv_bitfieldInsert_ivec4(ivec4 a, ivec4 b, int offset, int bits)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n"
"uint _viv_bitfieldInsert_uint(uint a, uint b, int offset, int bits)\n"
"{\n"
"   uint result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n"
"highp uint _viv_bitfieldInsert_uint_const(highp uint a, highp uint b, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n"
"uvec2 _viv_bitfieldInsert_uvec2(uvec2 a, uvec2 b, int offset, int bits)\n"
"{\n"
"   uvec2 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n"
"uvec3 _viv_bitfieldInsert_uvec3(uvec3 a, uvec3 b, int offset, int bits)\n"
"{\n"
"   uvec3 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n"
"uvec4 _viv_bitfieldInsert_uvec4(uvec4 a, uvec4 b, int offset, int bits)\n"
"{\n"
"   uvec4 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n";

/* uaddCarry gc3000/gc5000 implementation */
gctSTRING gcLibUaddCarry_Func =
"highp uint _viv_uaddCarry_uint(highp uint a, highp uint b, out lowp uint c)\n"
"{\n"
"   highp uint result = a + b;\n"
"   highp uint temp = min(a, b);\n"
"   c = result < temp ? 1u : 0u;\n"
"   return result;\n"
"}\n"
"highp uvec2 _viv_uaddCarry_uvec2(highp uvec2 a, highp uvec2 b, out lowp uvec2 c)\n"
"{\n"
"   highp uvec2 result = a + b;\n"
"   highp uvec2 temp = min(a, b);\n"
"   bvec2 sel = lessThan(result, temp);\n"
"   c = mix(uvec2(0u), uvec2(1u), sel);\n"
"   return result;\n"
"}\n"
"highp uvec3 _viv_uaddCarry_uvec3(highp uvec3 a, highp uvec3 b, out lowp uvec3 c)\n"
"{\n"
"   highp uvec3 result = a + b;\n"
"   highp uvec3 temp = min(a, b);\n"
"   bvec3 sel = lessThan(result, temp);\n"
"   c = mix(uvec3(0u), uvec3(1u), sel);\n"
"   return result;\n"
"}\n"
"highp uvec4 _viv_uaddCarry_uvec4(highp uvec4 a, highp uvec4 b, out lowp uvec4 c)\n"
"{\n"
"   highp uvec4 result = a + b;\n"
"   highp uvec4 temp = min(a, b);\n"
"   bvec4 sel = lessThan(result, temp);\n"
"   c = mix(uvec4(0u), uvec4(1u), sel);\n"
"   return result;\n"
"}\n";

/* uaddCarry gc7000 implementation */
gctSTRING gcLibUaddCarry_Func_hati4 =
"highp uint _viv_uaddCarry_uint(highp uint a, highp uint b, out lowp uint c)\n"
"{\n"
"   highp uint result = a + b;\n"
"   _viv_asm(UCARRY, c, a, b);\n"
"   return result;\n"
"}\n"
"highp uvec2 _viv_uaddCarry_uvec2(highp uvec2 a, highp uvec2 b, out lowp uvec2 c)\n"
"{\n"
"   highp uvec2 result = a + b;\n"
"   _viv_asm(UCARRY, c, a, b);\n"
"   return result;\n"
"}\n"
"highp uvec3 _viv_uaddCarry_uvec3(highp uvec3 a, highp uvec3 b, out lowp uvec3 c)\n"
"{\n"
"   highp uvec3 result = a + b;\n"
"   _viv_asm(UCARRY, c, a, b);\n"
"   return result;\n"
"}\n"
"highp uvec4 _viv_uaddCarry_uvec4(highp uvec4 a, highp uvec4 b, out lowp uvec4 c)\n"
"{\n"
"   highp uvec4 result = a + b;\n"
"   _viv_asm(UCARRY, c, a, b);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibUaddCarry_Func_VK_hati4 =
"struct uaddTy {uint sum; uint carry; };\n"
"uaddTy _viv_uaddCarry_uint(highp uint a, highp uint b)\n"
"{\n"
"   uaddTy result;\n"
"   result.sum = a + b;\n"
"   _viv_asm(UCARRY, result.carry, a, b);\n"
"   return result;\n"
"}\n"
"struct uaddTy2 {uvec2 sum; uvec2 carry; };\n"
"uaddTy2 _viv_uaddCarry_uvec2(highp uvec2 a, highp uvec2 b)\n"
"{\n"
"   uaddTy2 result;\n"
"   result.sum = a + b;\n"
"   _viv_asm(UCARRY, result.carry, a, b);\n"
"   return result;\n"
"}\n"
"struct uaddTy3 {uvec3 sum; uvec3 carry; };\n"
"uaddTy3 _viv_uaddCarry_uvec3(highp uvec3 a, highp uvec3 b)\n"
"{\n"
"   uaddTy3 result;\n"
"   result.sum = a + b;\n"
"   _viv_asm(UCARRY, result.carry, a, b);\n"
"   return result;\n"
"}\n"
"struct uaddTy4 {uvec4 sum; uvec4 carry; };\n"
"uaddTy4 _viv_uaddCarry_uvec4(highp uvec4 a, highp uvec4 b)\n"
"{\n"
"   uaddTy4 result;\n"
"   result.sum = a + b;\n"
"   _viv_asm(UCARRY, result.carry, a, b);\n"
"   return result;\n"
"}\n"
;

/* high level source for buitin function ldexp */
/* The function ldexp() builds a single-precision floatingpoint
    number from each significand component in x and
    the corresponding integral exponent of two in exp,
    returning:
       x = significand* 2 ^ exponent

    If exponent is greater than +128, the value returned is
    undefined. If exponent is less than -126, the value
    returned may be flushed to zero. Additionally, splitting
    the value into a significand and exponent using frexp()
    and then reconstructing a floating-point value using
    ldexp() should yield the original input for zero and all
    finite non-subnormal values.
    If the input x is a vector, this operation is performed in a
    component-wise manner; the value passed in exp and
    returned by the function are vectors with the same
    number of components as x.
*/
gctSTRING gcLibLDEXP_Func =
"highp float _viv_ldexp_float(highp float a, highp int b)\n"
"{\n"
"   highp int temp, exp0, exp;\n"
"   highp float result;\n"
"   highp uint bits = floatBitsToUint(a);\n"
"   exp0 = int(_viv_bitfieldExtract_uint_const(bits, 23, 8));\n"
"   exp = exp0 + b;\n"
"   if (a == 0.0) {\n"
"       result = ((bits & 0x80000000u) != 0U) ? -0.0 : 0.0; /* denorm flushed to 0.0 */\n"
"   }\n"
"   else if (isnan(a) || isinf(a) || b == 0) result = a;\n"
"   else if (exp <= 0) result = 0.0;\n"
"   else if (exp >= 255) {\n"
"       /* +/- inf */\n"
"       result = (a>0.0) ? uintBitsToFloat(0x7F800000u) : uintBitsToFloat(0xFF800000u);\n"
"   }\n"
"   else {\n"
    "   temp = _viv_bitfieldInsert_int(floatBitsToInt(a), exp, 23, 8);\n"
    "   result = intBitsToFloat(temp);\n"
"   }\n"
"   return result;\n"
"}\n"
"highp vec2 _viv_ldexp_vec2(highp vec2 a, highp ivec2 b)\n"
"{\n"
"   highp vec2 result;\n"
"   result.x = _viv_ldexp_float(a.x, b.x);\n"
"   result.y = _viv_ldexp_float(a.y, b.y);\n"
"   return result;\n"
"}\n"
"highp vec3 _viv_ldexp_vec3(highp vec3 a, highp ivec3 b)\n"
"{\n"
"   highp vec3 result;\n"
"   result.x = _viv_ldexp_float(a.x, b.x);\n"
"   result.y = _viv_ldexp_float(a.y, b.y);\n"
"   result.z = _viv_ldexp_float(a.z, b.z);\n"
"   return result;\n"
"}\n"
"highp vec4 _viv_ldexp_vec4(highp vec4 a, highp ivec4 b)\n"
"{\n"
"   highp vec4 result;\n"
"   result.x = _viv_ldexp_float(a.x, b.x);\n"
"   result.y = _viv_ldexp_float(a.y, b.y);\n"
"   result.z = _viv_ldexp_float(a.z, b.z);\n"
"   result.w = _viv_ldexp_float(a.w, b.w);\n"
"   return result;\n"
"}\n";
gctSTRING gcLibLDEXP_GL_Func =
"highp double _viv_ldexp_double(highp double a, highp int b)\n"
"{\n"
"   highp int temp, exp0, exp;\n"
"   highp double result;\n"
"   highp uint bits;\n"
"   _viv_asm(MOV, bits, a);\n"
"   exp0 = int(_viv_bitfieldExtract_uint_const(bits, 23, 8));\n"
"   exp = exp0 + b;\n"
"   if (a == double(0.0)) {\n"
"       result = ((bits & 0x80000000u) != 0U) ? double(-0.0) : double(0.0); /* denorm flushed to 0.0 */\n"
"   }\n"
"   else if (isnan(a) || isinf(a) || b == 0) result = a;\n"
"   else if (exp <= 0) result = double(0.0);\n"
"   else if (exp >= 255) {\n"
"       /* +/- inf */\n"
"       highp double negInf, posInf;\n"
"       _viv_asm(MOV, negInf, 0xFF800000u);\n"
"       _viv_asm(MOV, posInf, 0x7F800000u);\n"
"       result = (a> double(0.0)) ? posInf : negInf;\n"
"   }\n"
"   else {\n"
"       _viv_asm(MOV, temp, a);\n"
"       temp = _viv_bitfieldInsert_int(temp, exp, 23, 8);\n"
"       _viv_asm(MOV, result, temp);\n"
"   }\n"
"   return result;\n"
"}\n"
"highp dvec2 _viv_ldexp_dvec2(highp dvec2 a, highp ivec2 b)\n"
"{\n"
"   highp dvec2 result;\n"
"   result.x = _viv_ldexp_double(a.x, b.x);\n"
"   result.y = _viv_ldexp_double(a.y, b.y);\n"
"   return result;\n"
"}\n"
"highp dvec3 _viv_ldexp_dvec3(highp dvec3 a, highp ivec3 b)\n"
"{\n"
"   highp dvec3 result;\n"
"   result.x = _viv_ldexp_double(a.x, b.x);\n"
"   result.y = _viv_ldexp_double(a.y, b.y);\n"
"   result.z = _viv_ldexp_double(a.z, b.z);\n"
"   return result;\n"
"}\n"
"highp dvec4 _viv_ldexp_dvec4(highp dvec4 a, highp ivec4 b)\n"
"{\n"
"   highp dvec4 result;\n"
"   result.x = _viv_ldexp_double(a.x, b.x);\n"
"   result.y = _viv_ldexp_double(a.y, b.y);\n"
"   result.z = _viv_ldexp_double(a.z, b.z);\n"
"   result.w = _viv_ldexp_double(a.w, b.w);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function frexp */
gctSTRING gcLibFREXP_Func =
"highp float _viv_frexp_float(highp float a, out highp int b)\n"
"{\n"
"   highp uint exp = _viv_bitfieldExtract_uint_const(floatBitsToUint(a), 23, 8);\n"
"   b = int(exp) - 126;\n"
"   b = (a == 0.0)? 0 : b;\n"
"   highp int temp = _viv_bitfieldInsert_int(floatBitsToInt(a), 126, 23, 8);\n"
"   highp float result = intBitsToFloat(temp);\n"
"   result = (a == 0.0)? a : result;\n"
"   return result;\n"
"}\n"
"highp vec2 _viv_frexp_vec2(highp vec2 a, out highp ivec2 b)\n"
"{\n"
"   highp uvec2 exp = _viv_bitfieldExtract_uvec2(floatBitsToUint(a), 23, 8);\n"
"   b = ivec2(exp) - ivec2(126);\n"
"   bvec2 sel = notEqual(a, vec2(0.0));\n"
"   b = mix(ivec2(0), b, sel);\n"
"   highp ivec2 temp = _viv_bitfieldInsert_ivec2(floatBitsToInt(a), ivec2(126), 23, 8);\n"
"   highp vec2 result = intBitsToFloat(temp);\n"
"   result = mix(a, result, sel);\n"
"   return result;\n"
"}\n"
"highp vec3 _viv_frexp_vec3(highp vec3 a, out highp ivec3 b)\n"
"{\n"
"   highp uvec3 exp = _viv_bitfieldExtract_uvec3(floatBitsToUint(a), 23, 8);\n"
"   b = ivec3(exp) - ivec3(126);\n"
"   bvec3 sel = notEqual(a, vec3(0.0));\n"
"   b = mix(ivec3(0), b, sel);\n"
"   highp ivec3 temp = _viv_bitfieldInsert_ivec3(floatBitsToInt(a), ivec3(126), 23, 8);\n"
"   highp vec3 result = intBitsToFloat(temp);\n"
"   result = mix(a, result, sel);\n"
"   return result;\n"
"}\n"
"highp vec4 _viv_frexp_vec4(highp vec4 a, out highp ivec4 b)\n"
"{\n"
"   highp uvec4 exp = _viv_bitfieldExtract_uvec4(floatBitsToUint(a), 23, 8);\n"
"   b = ivec4(exp) - ivec4(126);\n"
"   bvec4 sel = notEqual(a, vec4(0.0));\n"
"   b = mix(ivec4(0), b, sel);\n"
"   highp ivec4 temp = _viv_bitfieldInsert_ivec4(floatBitsToInt(a), ivec4(126), 23, 8);\n"
"   highp vec4 result = intBitsToFloat(temp);\n"
"   result = mix(a, result, sel);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFREXP_GL_Func =
"highp double _viv_frexp_double(highp double a, out highp int b)\n"
"{\n"
"   highp uint bits;\n"
"   highp uint exp;\n"
"   _viv_asm(MOV, exp, a);\n"
"   exp = _viv_bitfieldExtract_uint_const(exp, 23, 8);\n"
"   b = int(exp) - 126;\n"
"   b = (a == double(0.0))? 0 : b;\n"
"   highp int temp;\n"
"   _viv_asm(MOV, temp, a);\n"
"   temp = _viv_bitfieldInsert_int(temp, 126, 23, 8);\n"
"   highp double result;\n"
"   _viv_asm(MOV, result, temp);\n"
"   result = (a == double(0.0))? a : result;\n"
"   return result;\n"
"}\n"
"highp dvec2 _viv_frexp_dvec2(highp dvec2 a, out highp ivec2 b)\n"
"{\n"
"   highp uvec2 exp;\n"
"   _viv_asm(MOV, exp, a);\n"
"   exp = _viv_bitfieldExtract_uvec2(exp, 23, 8);\n"
"   b = ivec2(exp) - ivec2(126);\n"
"   bvec2 sel = notEqual(a, dvec2(0.0));\n"
"   b = mix(ivec2(0), b, sel);\n"
"   highp ivec2 temp;\n"
"   _viv_asm(MOV, temp, a);\n"
"   temp = _viv_bitfieldInsert_ivec2(temp, ivec2(126), 23, 8);\n"
"   highp dvec2 result;\n"
"   _viv_asm(MOV, result, temp);\n"
"   result = mix(a, result, sel);\n"
"   return result;\n"
"}\n"
"highp dvec3 _viv_frexp_dvec3(highp dvec3 a, out highp ivec3 b)\n"
"{\n"
"   highp uvec3 exp;\n"
"   _viv_asm(MOV, exp, a);\n"
"   exp = _viv_bitfieldExtract_uvec3(exp, 23, 8);\n"
"   b = ivec3(exp) - ivec3(126);\n"
"   bvec3 sel = notEqual(a, dvec3(0.0));\n"
"   b = mix(ivec3(0), b, sel);\n"
"   highp ivec3 temp;\n"
"   _viv_asm(MOV, temp, a);\n"
"   temp = _viv_bitfieldInsert_ivec3(temp, ivec3(126), 23, 8);\n"
"   highp dvec3 result;\n"
"   _viv_asm(MOV, result, temp);\n"
"   result = mix(a, result, sel);\n"
"   return result;\n"
"}\n"
"highp dvec4 _viv_frexp_dvec4(highp dvec4 a, out highp ivec4 b)\n"
"{\n"
"   highp uvec4 exp;\n"
"   _viv_asm(MOV, exp, a);\n"
"   exp = _viv_bitfieldExtract_uvec4(exp, 23, 8);\n"
"   b = ivec4(exp) - ivec4(126);\n"
"   bvec4 sel = notEqual(a, dvec4(0.0));\n"
"   b = mix(ivec4(0), b, sel);\n"
"   highp ivec4 temp;\n"
"   _viv_asm(MOV, temp, a);\n"
"   temp = _viv_bitfieldInsert_ivec4(temp, ivec4(126), 23, 8);\n"
"   highp dvec4 result;\n"
"   _viv_asm(MOV, result, temp);\n"
"   result = mix(a, result, sel);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFREXPSTRUCT_Func =
"struct ResTy {float out0; int out1; };\n"
"ResTy _viv_frexpstruct_float(highp float a)\n"
"{\n"
"   highp uint exp = _viv_bitfieldExtract_uint_const(floatBitsToUint(a), 23, 8);\n"
"   int b = int(exp) - 126;\n"
"   b = (a == 0.0)? 0 : b;\n"
"   highp int temp = _viv_bitfieldInsert_int(floatBitsToInt(a), 126, 23, 8);\n"
"   ResTy result;\n"
"   result.out1 = b;\n"
"   result.out0 = intBitsToFloat(temp);\n"
"   result.out0 = (a == 0.0)? a : result.out0;\n"
"   return result;\n"
"}\n"
"struct ResTy2 {vec2 out0; ivec2 out1; };\n"
"ResTy2 _viv_frexpstruct_vec2(highp vec2 a)\n"
"{\n"
"   highp uvec2 exp = _viv_bitfieldExtract_uvec2(floatBitsToUint(a), 23, 8);\n"
"   ivec2 b = ivec2(exp) - ivec2(126);\n"
"   bvec2 sel = notEqual(a, vec2(0.0));\n"
"   b = mix(ivec2(0), b, sel);\n"
"   highp ivec2 temp = _viv_bitfieldInsert_ivec2(floatBitsToInt(a), ivec2(126), 23, 8);\n"
"   ResTy2 result;\n"
"   result.out1 = b;\n"
"   result.out0 = intBitsToFloat(temp);\n"
"   result.out0 = mix(a, result.out0, sel);\n"
"   return result;\n"
"}\n"
"struct ResTy3 {vec3 out0; ivec3 out1; };\n"
"ResTy3 _viv_frexpstruct_vec3(highp vec3 a)\n"
"{\n"
"   highp uvec3 exp = _viv_bitfieldExtract_uvec3(floatBitsToUint(a), 23, 8);\n"
"   ivec3 b = ivec3(exp) - ivec3(126);\n"
"   bvec3 sel = notEqual(a, vec3(0.0));\n"
"   b = mix(ivec3(0), b, sel);\n"
"   highp ivec3 temp = _viv_bitfieldInsert_ivec3(floatBitsToInt(a), ivec3(126), 23, 8);\n"
"   ResTy3 result;\n"
"   result.out1 = b;\n"
"   result.out0 = intBitsToFloat(temp);\n"
"   result.out0 = mix(a, result.out0, sel);\n"
"   return result;\n"
"}\n"
"struct ResTy4 {vec4 out0; ivec4 out1; };\n"
"ResTy4 _viv_frexpstruct_vec4(highp vec4 a)\n"
"{\n"
"   highp uvec4 exp = _viv_bitfieldExtract_uvec4(floatBitsToUint(a), 23, 8);\n"
"   ivec4 b = ivec4(exp) - ivec4(126);\n"
"   bvec4 sel = notEqual(a, vec4(0.0));\n"
"   b = mix(ivec4(0), b, sel);\n"
"   highp ivec4 temp = _viv_bitfieldInsert_ivec4(floatBitsToInt(a), ivec4(126), 23, 8);\n"
"   ResTy4 result;\n"
"   result.out1 = b;\n"
"   result.out0 = intBitsToFloat(temp);\n"
"   result.out0 = mix(a, result.out0, sel);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function usubBorrow */
gctSTRING gcLibUsubBorrow_Func =
"highp uint _viv_usubBorrow_uint(highp uint a, highp uint b, out lowp uint c)\n"
"{\n"
"   highp uint result = a - b;\n"
"   c = a >= b ? 0u : 1u;\n"
"   return result;\n"
"}\n"
"highp uvec2 _viv_usubBorrow_uvec2(highp uvec2 a, highp uvec2 b, out lowp uvec2 c)\n"
"{\n"
"   highp uvec2 result = a - b;\n"
"   bvec2 sel = greaterThanEqual(a, b);\n"
"   c = mix (uvec2(1u), uvec2(0u), sel);\n"
"   return result;\n"
"}\n"
"highp uvec3 _viv_usubBorrow_uvec3(highp uvec3 a, highp uvec3 b, out lowp uvec3 c)\n"
"{\n"
"   highp uvec3 result = a - b;\n"
"   bvec3 sel = greaterThanEqual(a, b);\n"
"   c = mix (uvec3(1u), uvec3(0u), sel);\n"
"   return result;\n"
"}\n"
"highp uvec4 _viv_usubBorrow_uvec4(highp uvec4 a, highp uvec4 b, out lowp uvec4 c)\n"
"{\n"
"   highp uvec4 result = a - b;\n"
"   bvec4 sel = greaterThanEqual(a, b);\n"
"   c = mix (uvec4(1u), uvec4(0u), sel);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibUsubBorrow_Func_VK =
"struct usubRy {uint sub; uint borrow; };\n"
"usubRy _viv_usubBorrow_uint(highp uint a, highp uint b)\n"
"{\n"
"   usubRy result;\n"
"   result.sub = a - b;\n"
"   result.borrow = a >= b ? 0u : 1u;\n"
"   return result;\n"
"}\n"
"struct usubRy2 {uvec2 sub; uvec2 borrow; };\n"
"usubRy2 _viv_usubBorrow_uvec2(highp uvec2 a, highp uvec2 b)\n"
"{\n"
"   usubRy2 result;\n"
"   result.sub = a - b;\n"
"   bvec2 sel = greaterThanEqual(a, b);\n"
"   result.borrow = mix (uvec2(1u), uvec2(0u), sel);\n"
"   return result;\n"
"}\n"
"struct usubRy3 {uvec3 sub; uvec3 borrow; };\n"
"usubRy3 _viv_usubBorrow_uvec3(highp uvec3 a, highp uvec3 b)\n"
"{\n"
"   usubRy3 result;\n"
"   result.sub = a - b;\n"
"   bvec3 sel = greaterThanEqual(a, b);\n"
"   result.borrow = mix (uvec3(1u), uvec3(0u), sel);\n"
"   return result;\n"
"}\n"
"struct usubRy4 {uvec4 sub; uvec4 borrow; };\n"
"usubRy4 _viv_usubBorrow_uvec4(highp uvec4 a, highp uvec4 b)\n"
"{\n"
"   usubRy4 result;\n"
"   result.sub = a - b;\n"
"   bvec4 sel = greaterThanEqual(a, b);\n"
"   result.borrow = mix (uvec4(1u), uvec4(0u), sel);\n"
"   return result;\n"
"}\n";

/* high level function for Pack/Unpack */
gctSTRING gcLibPack_Func =
"highp uint _viv_packUnorm4x8_vec4(mediump vec4 a)\n"
"{\n"
"   vec4 temp;\n"
"   temp = _viv_round_vec4(clamp(a, vec4(0.0), vec4(1.0)) * vec4(255.0));\n"
"   highp uint result = uint(temp.x) & 0xFFu;\n"
"   result = result | ((uint(temp.y) & 0xFFu) << 8 );\n"
"   result = result | ((uint(temp.z) & 0xFFu) << 16 );\n"
"   result = result | ((uint(temp.w) & 0xFFu) << 24 );\n"
"   return result;\n"
"}\n"
"highp uint _viv_packUnorm2x16_vec2(vec2 a)\n"
"{\n"
"   vec2 temp;\n"
"   temp = _viv_round_vec2(clamp(a, vec2(0.0), vec2(1.0)) * vec2(65535.0));\n"
"   highp uint result = uint(temp.x) & 0xFFFFu;\n"
"   result = result | ((uint(temp.y) & 0xFFFFu) << 16 );\n"
"   return result;\n"
"}\n"
"highp uint _viv_packSnorm4x8_vec4(mediump vec4 a)\n"
"{\n"
"   vec4 temp;\n"
"   temp = _viv_round_vec4(clamp(a, vec4(-1.0), vec4(1.0)) * vec4(127.0));\n"
"   highp int result = int(temp.x) & 0xFF;\n"
"   result = result | ((int(temp.y) & 0xFF) << 8 );\n"
"   result = result | ((int(temp.z) & 0xFF) << 16 );\n"
"   result = result | ((int(temp.w) & 0xFF) << 24 );\n"
"   return uint(result);\n"
"}\n"
"highp uint _viv_packSnorm2x16_vec2(vec2 a)\n"
"{\n"
"   vec2 temp;\n"
"   temp = _viv_round_vec2(clamp(a, vec2(-1.0), vec2(1.0)) * vec2(32767.0));\n"
"   highp int result = int(temp.x) & 0xFFFF;\n"
"   result = result | ((int(temp.y) & 0xFFFF) << 16 );\n"
"   return uint(result);\n"
"}\n"
"highp uint _viv_packHalf2x16_vec2(mediump vec2 a)\n"
"{\n"
"   mediump vec2 temp;\n"
/* conv source1 is the source data type, here it is float*/
"   _viv_asm(CONV, temp!<f:FLOAT16>, a, 0);\n"
"   highp uint result = (floatBitsToUint(temp.x) & 0xFFFFu);\n"
"   result = result | ((floatBitsToUint(temp.y) & 0xFFFFu) << 16);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibUnpack_Func =
"mediump vec4 _viv_unpackUnorm4x8_uint(highp uint a)\n"
"{\n"
"   highp uint temp = _viv_bitfieldExtract_uint_const(a, 0, 8);\n"
"   vec4 result;\n"
"   result.x = float(temp) / 255.0;\n"
"   temp = _viv_bitfieldExtract_uint_const(a, 8, 8);\n"
"   result.y = float(temp) / 255.0;\n"
"   temp = _viv_bitfieldExtract_uint_const(a, 16, 8);\n"
"   result.z = float(temp) / 255.0;\n"
"   temp = _viv_bitfieldExtract_uint_const(a, 24, 8);\n"
"   result.w = float(temp) / 255.0;\n"
"   return result;\n"
"}\n"
"highp vec2 _viv_unpackUnorm2x16_uint(highp uint a)\n"
"{\n"
"   highp uint temp = _viv_bitfieldExtract_uint_const(a, 0, 16);\n"
"   highp vec2 result;\n"
"   result.x = float(temp) / 65535.0;\n"
"   temp = _viv_bitfieldExtract_uint_const(a, 16, 16);\n"
"   result.y = float(temp) / 65535.0;\n"
"   return result;\n"
"}\n"
"mediump vec4 _viv_unpackSnorm4x8_uint(highp uint a)\n"
"{\n"
"   highp int temp = _viv_bitfieldExtract_int_const(int(a), 0, 8);\n"
"   vec4 result;\n"
"   result.x = clamp(float(temp) / 127.0, -1.0, 1.0);\n"
"   temp = _viv_bitfieldExtract_int_const(int(a), 8, 8);\n"
"   result.y = clamp(float(temp) / 127.0, -1.0, 1.0);\n"
"   temp = _viv_bitfieldExtract_int_const(int(a), 16, 8);\n"
"   result.z = clamp(float(temp) / 127.0, -1.0, 1.0);\n"
"   temp = _viv_bitfieldExtract_int_const(int(a), 24, 8);\n"
"   result.w = clamp(float(temp) / 127.0, -1.0, 1.0);\n"
"   return result;\n"
"}\n"
"highp vec2 _viv_unpackSnorm2x16_uint(highp uint a)\n"
"{\n"
"   highp int temp = _viv_bitfieldExtract_int_const(int(a), 0, 16);\n"
"   highp vec2 result;\n"
"   result.x = clamp(float(temp) / 32767.0, -1.0, 1.0);\n"
"   temp = _viv_bitfieldExtract_int_const(int(a), 16, 16);\n"
"   result.y = clamp(float(temp) / 32767.0, -1.0, 1.0);\n"
"   return result;\n"
"}\n"
"mediump vec2 _viv_unpackHalf2x16_uint(highp uint a)\n"
"{\n"
"   highp vec2 result;\n"
"   highp uint temp = a & 0xFFFFu;\n"
"   highp float tempx, tempy;\n"
/* conv source1 is the source data type, here it is float16*/
"   _viv_asm(CONV, tempx, uintBitsToFloat(temp)!<f:FLOAT16>, 12);\n"
"   temp = a >> 16;\n"
"   _viv_asm(CONV, tempy, uintBitsToFloat(temp)!<f:FLOAT16>, 12);\n"
"   result.x = tempx;\n"
"   result.y = tempy;\n"
"   return result;\n"
"}\n";

gctSTRING gcLibPackUnpack_GL_Func =
"highp double _viv_packDouble2x32_uvec2(uvec2 a)\n"
"{\n"
"   highp double result;\n"
"   _viv_asm(MOV, result, a);\n"
"   return result;\n"
"}\n"
"highp uvec2 _viv_unpackDouble2x32_double(double a)\n"
"{\n"
"   uvec2 result;\n"
"   _viv_asm(MOV, result, a);\n"
"   return result;\n"
"}\n";

/* use inline assembly to write these functions */
gctSTRING gcLibUmulExtended_Func =
"void _viv_umulExtended_uint(highp uint a, highp uint b, out highp uint msb, out highp uint lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_umulExtended_uvec2(highp uvec2 a, highp uvec2 b, out highp uvec2 msb, out highp uvec2 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_umulExtended_uvec3(highp uvec3 a, highp uvec3 b, out highp uvec3 msb, out highp uvec3 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_umulExtended_uvec4(highp uvec4 a, highp uvec4 b, out highp uvec4 msb, out highp uvec4 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

/* according to VK order */
gctSTRING gcLibUmulExtended_Func_VK =
"void _viv_umulExtended_uint(highp uint a, highp uint b, out highp uint lsb, out highp uint msb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_umulExtended_uvec2(highp uvec2 a, highp uvec2 b, out highp uvec2 lsb, out highp uvec2 msb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_umulExtended_uvec3(highp uvec3 a, highp uvec3 b, out highp uvec3 lsb, out highp uvec3 msb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_umulExtended_uvec4(highp uvec4 a, highp uvec4 b, out highp uvec4 lsb, out highp uvec4 msb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

gctSTRING gcLibImulExtended_Func =
"void _viv_imulExtended_int(highp int a, highp int b, out highp int msb, out highp int lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_imulExtended_ivec2(highp ivec2 a, highp ivec2 b, out highp ivec2 msb, out highp ivec2 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_imulExtended_ivec3(highp ivec3 a, highp ivec3 b, out highp ivec3 msb, out highp ivec3 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_imulExtended_ivec4(highp ivec4 a, highp ivec4 b, out highp ivec4 msb, out highp ivec4 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

gctSTRING gcLibImulExtended_Func_VK =
"void _viv_imulExtended_int(highp int a, highp int b, out highp int lsb, out highp int msb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_imulExtended_ivec2(highp ivec2 a, highp ivec2 b, out highp ivec2 lsb, out highp ivec2 msb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_imulExtended_ivec3(highp ivec3 a, highp ivec3 b, out highp ivec3 lsb, out highp ivec3 msb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n"
"void _viv_imulExtended_ivec4(highp ivec4 a, highp ivec4 b, out highp ivec4 lsb, out highp ivec4 msb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

/* high level source for buitin function modf */
gctSTRING gcLibMODF_Func =
"float _viv_modf_float(float a, out float b)\n"
"{\n"
"   uint temp_u = floatBitsToUint(a) & 0x7fffffffu;\n"
"   float a_abs = abs(a);\n"
"   float a_sign = sign(a);\n"
"   float a_floor = floor(a_abs);\n"
"   float temp_f;\n"
"   if(temp_u == 0x7f800000u)\n"
"   {\n"
"       temp_f = 0.0;\n"
"   }\n"
"   else\n"
"   {\n"
"       temp_f = a_abs - a_floor;\n"
"   }\n"
"   b = a_floor * a_sign;\n"
"   return temp_f * a_sign;\n"
"}\n"
"vec2 _viv_modf_vec2(vec2 a, out vec2 b)\n"
"{\n"
"   uvec2 temp_u = floatBitsToUint(a) & 0x7fffffffu;\n"
"   vec2 a_abs = abs(a);\n"
"   vec2 a_sign = sign(a);\n"
"   vec2 a_floor = floor(a_abs);\n"
"   vec2 temp_f;\n"
"   bvec2 sel = equal(temp_u, uvec2(0x7f800000u));\n"
"   temp_f = mix(a_abs - a_floor, vec2(0.0), sel);\n"
"   b = a_floor * a_sign;\n"
"   return temp_f * a_sign;\n"
"}\n"
"vec3 _viv_modf_vec3(vec3 a, out vec3 b)\n"
"{\n"
"   uvec3 temp_u = floatBitsToUint(a) & 0x7fffffffu;\n"
"   vec3 a_abs = abs(a);\n"
"   vec3 a_sign = sign(a);\n"
"   vec3 a_floor = floor(a_abs);\n"
"   vec3 temp_f;\n"
"   bvec3 sel = equal(temp_u, uvec3(0x7f800000u));\n"
"   temp_f = mix(a_abs - a_floor, vec3(0.0), sel);\n"
"   b = a_floor * a_sign;\n"
"   return temp_f * a_sign;\n"
"}\n"
"vec4 _viv_modf_vec4(vec4 a, out vec4 b)\n"
"{\n"
"   uvec4 temp_u = floatBitsToUint(a) & 0x7fffffffu;\n"
"   vec4 a_abs = abs(a);\n"
"   vec4 a_sign = sign(a);\n"
"   vec4 a_floor = floor(a_abs);\n"
"   vec4 temp_f;\n"
"   bvec4 sel = equal(temp_u, uvec4(0x7f800000u));\n"
"   temp_f = mix(a_abs - a_floor, vec4(0.0), sel);\n"
"   b = a_floor * a_sign;\n"
"   return temp_f * a_sign;\n"
"}\n";

/* high level source for buitin function fma */
gctSTRING gcLibFMA_Func_fmaNotSupported =
"float _viv_fma_float(float a, float b, float c)\n"
"{\n"
"   float temp, result;\n"
"   _viv_asm(MUL, temp, a, b);\n"
"   _viv_asm(ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"vec2 _viv_fma_vec2(vec2 a, vec2 b, vec2 c)\n"
"{\n"
"   vec2 temp, result;\n"
"   _viv_asm(MUL, temp, a, b);\n"
"   _viv_asm(ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"vec3 _viv_fma_vec3(vec3 a, vec3 b, vec3 c)\n"
"{\n"
"   vec3 temp, result;\n"
"   _viv_asm(MUL, temp, a, b);\n"
"   _viv_asm(ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"vec4 _viv_fma_vec4(vec4 a, vec4 b, vec4 c)\n"
"{\n"
"   vec4 temp, result;\n"
"   _viv_asm(MUL, temp, a, b);\n"
"   _viv_asm(ADD, result, temp, c);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFMA_GL_Func_fmaNotSupported =
"float _viv_fma_double(double a, double b, double c)\n"
"{\n"
"   double temp, result;\n"
"   _viv_asm(MUL, temp, a, b);\n"
"   _viv_asm(ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"dvec2 _viv_fma_dvec2(dvec2 a, dvec2 b, dvec2 c)\n"
"{\n"
"   dvec2 temp, result;\n"
"   _viv_asm(MUL, temp, a, b);\n"
"   _viv_asm(ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"dvec3 _viv_fma_dvec3(dvec3 a, dvec3 b, dvec3 c)\n"
"{\n"
"   dvec3 temp, result;\n"
"   _viv_asm(MUL, temp, a, b);\n"
"   _viv_asm(ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"dvec4 _viv_fma_dvec4(dvec4 a, dvec4 b, dvec4 c)\n"
"{\n"
"   vec4 temp, result;\n"
"   _viv_asm(MUL, temp, a, b);\n"
"   _viv_asm(ADD, result, temp, c);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFMA_Func_fmaSupported =
"float _viv_fma_float(float a, float b, float c)\n"
"{\n"
"   float temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"vec2 _viv_fma_vec2(vec2 a, vec2 b, vec2 c)\n"
"{\n"
"   vec2 temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"vec3 _viv_fma_vec3(vec3 a, vec3 b, vec3 c)\n"
"{\n"
"   vec3 temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"vec4 _viv_fma_vec4(vec4 a, vec4 b, vec4 c)\n"
"{\n"
"   vec4 temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibFMA_GL_Func_fmaSupported =
"double _viv_fma_double(double a, double b, double c)\n"
"{\n"
"   double temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"dvec2 _viv_fma_dvec2(dvec2 a, dvec2 b, dvec2 c)\n"
"{\n"
"   dvec2 temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"dvec3 _viv_fma_dvec3(dvec3 a, dvec3 b, dvec3 c)\n"
"{\n"
"   dvec3 temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n"
"dvec4 _viv_fma_dvec4(dvec4 a, dvec4 b, dvec4 c)\n"
"{\n"
"   dvec4 temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function reflect */
gctSTRING gcLibREFLECT_Func_float =
"float _viv_reflect_float(float I, float N)\n"
"{\n"
"   float temp0 = N * dot(N, I);\n"
"   return -2.0 * temp0 + I;\n"
"}\n";
gctSTRING gcLibREFLECT_Func_vec2 =
"vec2 _viv_reflect_vec2(vec2 I, vec2 N)\n"
"{\n"
"   vec2 temp0 = N * dot(N, I);\n"
"   return -2.0 * temp0 + I;\n"
"}\n";
gctSTRING gcLibREFLECT_Func_vec3 =
"vec3 _viv_reflect_vec3(vec3 I, vec3 N)\n"
"{\n"
"   vec3 temp0 = N * dot(N, I);\n"
"   return -2.0 * temp0 + I;\n"
"}\n";
gctSTRING gcLibREFLECT_Func_vec4 =
"vec4 _viv_reflect_vec4(vec4 I, vec4 N)\n"
"{\n"
"   vec4 temp0 = N * dot(N, I);\n"
"   return -2.0 * temp0 + I;\n"
"}\n";
gctSTRING gcLibREFLECT_Func_float_fmaSupported =
"float _viv_reflect_float(float I, float N)\n"
"{\n"
"   float temp0 = N * dot(N, I);\n"
"   return _viv_fma_float(-2.0, temp0, I);\n"
"}\n";
gctSTRING gcLibREFLECT_Func_vec2_fmaSupported =
"vec2 _viv_reflect_vec2(vec2 I, vec2 N)\n"
"{\n"
"   vec2 temp0 = N * dot(N, I);\n"
"   return _viv_fma_vec2(vec2(-2.0), temp0, I);\n"
"}\n";
gctSTRING gcLibREFLECT_Func_vec3_fmaSupported =
"vec3 _viv_reflect_vec3(vec3 I, vec3 N)\n"
"{\n"
"   vec3 temp0 = N * dot(N, I);\n"
"   return _viv_fma_vec3(vec3(-2.0), temp0, I);\n"
"}\n";
gctSTRING gcLibREFLECT_Func_vec4_fmaSupported =
"vec4 _viv_reflect_vec4(vec4 I, vec4 N)\n"
"{\n"
"   vec4 temp0 = N * dot(N, I);\n"
"   return _viv_fma_vec4(vec4(-2.0), temp0, I);\n"
"}\n";

gctSTRING gcLibMatrixTranspose_Func =
"mat2 _viv_transpose_mat2(vec2 m1, vec2 m2)\n"
"{\n"
"   mat2 temp;\n"
"   temp[0].x = m1.x;\n"
"   temp[0].y = m2.x;\n"
"   temp[1].x = m1.y;\n"
"   temp[1].y = m2.y;\n"
"   return temp;\n"
"}\n"
"mat3 _viv_transpose_mat3(vec3 m1, vec3 m2, vec3 m3)\n"
"{\n"
"   mat3 temp;\n"
"   temp[0].x = m1.x;\n"
"   temp[0].y = m2.x;\n"
"   temp[0].z = m3.x;\n"
"   temp[1].x = m1.y;\n"
"   temp[1].y = m2.y;\n"
"   temp[1].z = m3.y;\n"
"   temp[2].x = m1.z;\n"
"   temp[2].y = m2.z;\n"
"   temp[2].z = m3.z;\n"
"   return temp;\n"
"}\n"
"mat4 _viv_transpose_mat4(vec4 m1, vec4 m2, vec4 m3, vec4 m4)\n"
"{\n"
"   mat4 temp;\n"
"   temp[0].x = m1.x;\n"
"   temp[0].y = m2.x;\n"
"   temp[0].z = m3.x;\n"
"   temp[0].w = m4.x;\n"
"   temp[1].x = m1.y;\n"
"   temp[1].y = m2.y;\n"
"   temp[1].z = m3.y;\n"
"   temp[1].w = m4.y;\n"
"   temp[2].x = m1.z;\n"
"   temp[2].y = m2.z;\n"
"   temp[2].z = m3.z;\n"
"   temp[2].w = m4.z;\n"
"   temp[3].x = m1.w;\n"
"   temp[3].y = m2.w;\n"
"   temp[3].z = m3.w;\n"
"   temp[3].w = m4.w;\n"
"   return temp;\n"
"}\n"
"mat2x3 _viv_transpose_mat2X3(vec2 m1, vec2 m2, vec2 m3)\n"
"{\n"
"   mat2x3 temp;\n"
"   temp[0].x = m1.x;\n"
"   temp[0].y = m2.x;\n"
"   temp[0].z = m3.x;\n"
"   temp[1].x = m1.y;\n"
"   temp[1].y = m2.y;\n"
"   temp[1].z = m3.y;\n"
"   return temp;\n"
"}\n"
"mat2x4 _viv_transpose_mat2X4(vec2 m1, vec2 m2, vec2 m3, vec2 m4)\n"
"{\n"
"   mat2x4 temp;\n"
"   temp[0].x = m1.x;\n"
"   temp[0].y = m2.x;\n"
"   temp[0].z = m3.x;\n"
"   temp[0].w = m4.x;\n"
"   temp[1].x = m1.y;\n"
"   temp[1].y = m2.y;\n"
"   temp[1].z = m3.y;\n"
"   temp[1].w = m4.y;\n"
"   return temp;\n"
"}\n"
"mat3x2 _viv_transpose_mat3X2(vec3 m1, vec3 m2)\n"
"{\n"
"   mat3x2 temp;\n"
"   temp[0].x = m1.x;\n"
"   temp[0].y = m2.x;\n"
"   temp[1].x = m1.y;\n"
"   temp[1].y = m2.y;\n"
"   temp[2].x = m1.z;\n"
"   temp[2].y = m2.z;\n"
"   return temp;\n"
"}\n"
"mat3x4 _viv_transpose_mat3X4(vec3 m1, vec3 m2, vec3 m3, vec3 m4)\n"
"{\n"
"   mat3x4 temp;\n"
"   temp[0].x = m1.x;\n"
"   temp[0].y = m2.x;\n"
"   temp[0].z = m3.x;\n"
"   temp[0].w = m4.x;\n"
"   temp[1].x = m1.y;\n"
"   temp[1].y = m2.y;\n"
"   temp[1].z = m3.y;\n"
"   temp[1].w = m4.y;\n"
"   temp[2].x = m1.z;\n"
"   temp[2].y = m2.z;\n"
"   temp[2].z = m3.z;\n"
"   temp[2].w = m4.z;\n"
"   return temp;\n"
"}\n"
"mat4x2 _viv_transpose_mat4X2(vec4 m1, vec4 m2)\n"
"{\n"
"   mat4x2 temp;\n"
"   temp[0].x = m1.x;\n"
"   temp[0].y = m2.x;\n"
"   temp[1].x = m1.y;\n"
"   temp[1].y = m2.y;\n"
"   temp[2].x = m1.z;\n"
"   temp[2].y = m2.z;\n"
"   temp[3].x = m1.w;\n"
"   temp[3].y = m2.w;\n"
"   return temp;\n"
"}\n"
"mat4x3 _viv_transpose_mat4X3(vec4 m1, vec4 m2, vec4 m3)\n"
"{\n"
"   mat4x3 temp;\n"
"   temp[0].x = m1.x;\n"
"   temp[0].y = m2.x;\n"
"   temp[0].z = m3.x;\n"
"   temp[1].x = m1.y;\n"
"   temp[1].y = m2.y;\n"
"   temp[1].z = m3.y;\n"
"   temp[2].x = m1.z;\n"
"   temp[2].y = m2.z;\n"
"   temp[2].z = m3.z;\n"
"   temp[3].x = m1.w;\n"
"   temp[3].y = m2.w;\n"
"   temp[3].z = m3.w;\n"
"   return temp;\n"
"}\n";

/* NMin, NMax and Nclamp. */
gctSTRING gcLibNMin_Func =
"float _viv_nmin_float(float a, float b)\n"
"{\n"
"   if (isnan(a))\n"
"       return b;\n"
"   else if (isnan(b))\n"
"       return a;\n"
"   else\n"
"       return min(a, b);\n"
"}\n"
"vec2 _viv_nmin_vec2(vec2 a, vec2 b)\n"
"{\n"
"   return vec2(_viv_nmin_float(a.x, b.x), _viv_nmin_float(a.y, b.y));\n"
"}\n"
"vec3 _viv_nmin_vec3(vec3 a, vec3 b)\n"
"{\n"
"   return vec3(_viv_nmin_float(a.x, b.x), _viv_nmin_float(a.y, b.y), _viv_nmin_float(a.z, b.z));\n"
"}\n"
"vec4 _viv_nmin_vec4(vec4 a, vec4 b)\n"
"{\n"
"   return vec4(_viv_nmin_float(a.x, b.x), _viv_nmin_float(a.y, b.y), _viv_nmin_float(a.z, b.z), _viv_nmin_float(a.w, b.w));\n"
"}\n";

gctSTRING gcLibNMax_Func =
"float _viv_nmax_float(float a, float b)\n"
"{\n"
"   if (isnan(a))\n"
"       return b;\n"
"   else if (isnan(b))\n"
"       return a;\n"
"   else\n"
"       return max(a, b);\n"
"}\n"
"vec2 _viv_nmax_vec2(vec2 a, vec2 b)\n"
"{\n"
"   return vec2(_viv_nmax_float(a.x, b.x), _viv_nmax_float(a.y, b.y));\n"
"}\n"
"vec3 _viv_nmax_vec3(vec3 a, vec3 b)\n"
"{\n"
"   return vec3(_viv_nmax_float(a.x, b.x), _viv_nmax_float(a.y, b.y), _viv_nmax_float(a.z, b.z));\n"
"}\n"
"vec4 _viv_nmax_vec4(vec4 a, vec4 b)\n"
"{\n"
"   return vec4(_viv_nmax_float(a.x, b.x), _viv_nmax_float(a.y, b.y), _viv_nmax_float(a.z, b.z), _viv_nmax_float(a.w, b.w));\n"
"}\n";

gctSTRING gcLibNClamp_Func =
"float _viv_nclamp_float(float a, float b, float c)\n"
"{\n"
"   return _viv_nmin_float(_viv_nmax_float(a, b), c);\n"
"}\n"
"vec2 _viv_nclamp_vec2(vec2 a, vec2 b, vec2 c)\n"
"{\n"
"   return _viv_nmin_vec2(_viv_nmax_vec2(a, b), c);\n"
"}\n"
"vec3 _viv_nclamp_vec3(vec3 a, vec3 b, vec3 c)\n"
"{\n"
"   return _viv_nmin_vec3(_viv_nmax_vec3(a, b), c);\n"
"}\n"
"vec4 _viv_nclamp_vec4(vec4 a, vec4 b, vec4 c)\n"
"{\n"
"   return _viv_nmin_vec4(_viv_nmax_vec4(a, b), c);\n"
"}\n";

/*********************************texture size implementation*********************************/
/* For the 2D sampler. */
gctSTRING gcLibTextureSize_Func_1 =
"ivec2 _viv_textureSize_float_2D(sampler2D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the cube sampler. */
gctSTRING gcLibTextureSize_Func_2 =
"ivec2 _viv_textureSize_float_Cube(samplerCube sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D shadow sampler. */
gctSTRING gcLibTextureSize_Func_3 =
"ivec2 _viv_textureSize_float_2DShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the cube shadow sampler. */
gctSTRING gcLibTextureSize_Func_4 =
"ivec2 _viv_textureSize_float_CubeShadow(samplerCubeShadow sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 3D sampler. */
gctSTRING gcLibTextureSize_Func_5 =
"ivec3 _viv_textureSize_float_3D(sampler3D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D array sampler. */
gctSTRING gcLibTextureSize_Func_6 =
"ivec3 _viv_textureSize_float_2DArray(sampler2DArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D array shadow sampler. */
gctSTRING gcLibTextureSize_Func_7 =
"ivec3 _viv_textureSize_float_ArrayShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D sampler. */
gctSTRING gcLibTextureSize_Func_8 =
"ivec2 _viv_textureSize_int_2D(isampler2D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the cube sampler. */
gctSTRING gcLibTextureSize_Func_9 =
"ivec2 _viv_textureSize_int_Cube(isamplerCube sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 3D sampler. */
gctSTRING gcLibTextureSize_Func_10 =
"ivec3 _viv_textureSize_int_3D(isampler3D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D array sampler. */
gctSTRING gcLibTextureSize_Func_11 =
"ivec3 _viv_textureSize_int_2DArray(isampler2DArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D sampler. */
gctSTRING gcLibTextureSize_Func_12 =
"ivec2 _viv_textureSize_uint_2D(usampler2D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the cube sampler. */
gctSTRING gcLibTextureSize_Func_13 =
"ivec2 _viv_textureSize_uint_Cube(usamplerCube sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 3D sampler. */
gctSTRING gcLibTextureSize_Func_14 =
"ivec3 _viv_textureSize_uint_3D(usampler3D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D array sampler. */
gctSTRING gcLibTextureSize_Func_15 =
"ivec3 _viv_textureSize_uint_2DArray(usampler2DArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D MS sampler. */
gctSTRING gcLibTextureSize_Func_16 =
"ivec2 _viv_textureSize_float_2DMS(sampler2DMS sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec2 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_17 =
"ivec2 _viv_textureSize_int_2DMS(isampler2DMS sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec2 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_18 =
"ivec2 _viv_textureSize_uint_2DMS(usampler2DMS sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec2 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D MS array sampler. */
gctSTRING gcLibTextureSize_Func_19 =
"ivec3 _viv_textureSize_float_MSArray(sampler2DMSArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec3 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_20 =
"ivec3 _viv_textureSize_int_MSArray(isampler2DMSArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec3 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_21 =
"ivec3 _viv_textureSize_uint_MSArray(usampler2DMSArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec3 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_22 =
"ivec3 _viv_textureSize_float_CubeArray(samplerCubeArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_23 =
"ivec3 _viv_textureSize_float_CubeArrayShadow(samplerCubeArrayShadow sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_24 =
"ivec3 _viv_textureSize_int_CubeArray(isamplerCubeArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_25 =
"ivec3 _viv_textureSize_uint_CubeArray(usamplerCubeArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_26 =
"int _viv_textureSize_float_buffer(samplerBuffer sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    return max(levelBaseSize.x, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_27 =
"int _viv_textureSize_int_buffer(isamplerBuffer sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    return max(levelBaseSize.x, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_28 =
"int _viv_textureSize_uint_buffer(usamplerBuffer sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    return max(levelBaseSize.x, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_29 =
"int _viv_textureSize_float_1D(sampler2D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    int result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.x >> lod;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_30 =
"ivec2 _viv_textureSize_float_2DRect(sampler2D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    return max(levelBaseSize.xy, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_31 =
"ivec2 _viv_textureSize_int_2DRect(isampler2D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    return max(levelBaseSize.xy, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_32 =
"ivec2 _viv_textureSize_uint_2DRect(usampler2D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    return max(levelBaseSize.xy, 1);\n"
"}\n";

/* For the 1D array sampler. */
gctSTRING gcLibTextureSize_Func_33 =
"ivec2 _viv_textureSize_float_1DArray(sampler2DArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.x = levelBaseSize.x >> lod;\n"
"    result.x = max(result.x, 1);\n"
"    result.y = levelBaseSize.z;\n"
"    return result.xy;\n"
"}\n";

gctSTRING gcLibTextureSize_Func_34 =
"ivec2 _viv_textureSize_int_1DArray(isampler2DArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.x = levelBaseSize.x >> lod;\n"
"    result.x = max(result.x, 1);\n"
"    result.y = levelBaseSize.z;\n"
"    return result.xy;\n"
"}\n";

gctSTRING gcLibTextureSize_Func_35 =
"ivec2 _viv_textureSize_uint_1DArray(usampler2DArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.x = levelBaseSize.x >> lod;\n"
"    result.x = max(result.x, 1);\n"
"    result.y = levelBaseSize.z;\n"
"    return result.xy;\n"
"}\n";

/* For the 2D MS sampler. */
gctSTRING gcLibTextureSize_Func_36 =
"ivec2 _viv_textureSize_float_2DMSArray(sampler2DMSArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec2 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_37 =
"ivec2 _viv_textureSize_int_2DMSArray(isampler2DMSArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec2 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

gctSTRING gcLibTextureSize_Func_38 =
"ivec2 _viv_textureSize_uint_2DMSArray(usampler2DMSArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec2 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/***********************texture common functions***********************/
gctSTRING gcLibTextureCommon_Func =
"vec2 _viv_evaluate_UV(int face, float maxCoord, vec2 coord, float size)\n"
"{\n"
"    float s, t;\n"
"    float x = coord.x, y = coord.y;\n"
"    switch(face)\n"
"    {\n"
"        case 0:\n"
"            s = -y;\n"
"            t = -x;\n"
"            break;\n"
"        case 1:\n"
"            s = y;\n"
"            t = -x;\n"
"            break;\n"
"        case 2:\n"
"            s = x;\n"
"            t = y;\n"
"            break;\n"
"        case 3:\n"
"            s = x;\n"
"            t = -y;\n"
"            break;\n"
"        case 4:\n"
"            s = x;\n"
"            t = -y;\n"
"            break;\n"
"        default:\n"
"            s = -x;\n"
"            t = -y;\n"
"            break;\n"
"    }\n"
"    vec2 temp = vec2(s, t);\n"
"    temp = (temp/maxCoord + 1.0) / 2.0 * size;\n"
"    return temp;\n"
"}\n";

/***********************textureGather* implementation that HW can directly support***********************/
gctSTRING gcLibTextureGatherCommon_Func_1 =
"vec2 _viv_textureGatherCommon_ComputeOffset(mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    vec2 offset1 = vec2(clamp(offset, MIN_PROGRAM_TEXTURE_GATHER_OFFSET, MAX_PROGRAM_TEXTURE_GATHER_OFFSET));\n"
"    vec2 size = vec2(max(levelBaseSize.xy, 1));\n"
"    return (p + offset1 / size);\n"
"}\n";

/***********************textureGather implementation***********************/
/* 2D sampler. */
gctSTRING gcLibTextureGather_Func_1 =
"vec4 _viv_textureGather_float_2D_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2 =
"vec4 _viv_textureGather_float_2D_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
gctSTRING gcLibTextureGather_Func_3 =
"vec4 _viv_textureGather_float_2DArray_NoComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_4 =
"vec4 _viv_textureGather_float_2DArray_WithComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
gctSTRING gcLibTextureGather_Func_5 =
"vec4 _viv_textureGather_float_Cube_NoComp(samplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_6 =
"vec4 _viv_textureGather_float_Cube_WithComp(samplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2D shadow sampler. */
gctSTRING gcLibTextureGather_Func_7 =
"vec4 _viv_textureGather_2DShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, refZ);\n"
"    _viv_asm(TEXLDPCF, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2D array shadow sampler. */
gctSTRING gcLibTextureGather_Func_8 =
"vec4 _viv_textureGather_2DArrayShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, refZ);\n"
"    _viv_asm(TEXLDPCF, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* Cube shadow sampler. */
gctSTRING gcLibTextureGather_Func_9 =
"vec4 _viv_textureGather_CubeShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, refZ);\n"
"    _viv_asm(TEXLDPCF, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2D sampler. */
gctSTRING gcLibTextureGather_Func_10 =
"ivec4 _viv_textureGather_int_2D_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_11 =
"ivec4 _viv_textureGather_int_2D_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
gctSTRING gcLibTextureGather_Func_12 =
"ivec4 _viv_textureGather_int_2DArray_NoComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_13 =
"ivec4 _viv_textureGather_int_2DArray_WithComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
gctSTRING gcLibTextureGather_Func_14 =
"ivec4 _viv_textureGather_int_Cube_NoComp(isamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_15 =
"ivec4 _viv_textureGather_int_Cube_WithComp(isamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2D sampler. */
gctSTRING gcLibTextureGather_Func_16 =
"uvec4 _viv_textureGather_uint_2D_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_17 =
"uvec4 _viv_textureGather_uint_2D_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
gctSTRING gcLibTextureGather_Func_18 =
"uvec4 _viv_textureGather_uint_2DArray_NoComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_19 =
"uvec4 _viv_textureGather_uint_2DArray_WithComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
gctSTRING gcLibTextureGather_Func_20 =
"uvec4 _viv_textureGather_uint_Cube_NoComp(usamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_21 =
"uvec4 _viv_textureGather_uint_Cube_WithComp(usamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* CubeArray sampler. */
gctSTRING gcLibTextureGather_Func_22 =
"vec4 _viv_textureGather_foat_CubeArray_NoComp(samplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_23 =
"vec4 _viv_textureGather_float_CubeArray_WithComp(samplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p, int comp)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_24 =
"ivec4 _viv_textureGather_int_CubeArray_NoComp(isamplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_25 =
"ivec4 _viv_textureGather_int_CubeArray_WithComp(isamplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p, int comp)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_26 =
"uvec4 _viv_textureGather_uint_CubeArray_NoComp(usamplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_27 =
"uvec4 _viv_textureGather_uint_CubeArray_WithComp(usamplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p, int comp)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_28 =
"vec4 _viv_textureGather_float_CubeArrayShadow(samplerCubeArrayShadow sampler, mediump ivec3 levelBaseSize, vec4 p, float refZ)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, refZ);\n"
"    _viv_asm(TEXLDPCF, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_29 =
"uvec4 _viv_textureGather_uint_2DRect_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGather_uint_2D_NoComp(sampler, levelBaseSize, p);\n"
"}\n";

gctSTRING gcLibTextureGather_Func_30 =
"ivec4 _viv_textureGather_int_2DRect_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGather_int_2D_NoComp(sampler, levelBaseSize, p);\n"
"}\n";

gctSTRING gcLibTextureGather_Func_31 =
"vec4 _viv_textureGather_float_2DRect_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGather_float_2D_NoComp(sampler, levelBaseSize, p);\n"
"}\n";

gctSTRING gcLibTextureGather_Func_32 =
"uvec4 _viv_textureGather_uint_2DRect_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGather_uint_2D_WithComp(sampler, levelBaseSize, p, comp);\n"
"}\n";

gctSTRING gcLibTextureGather_Func_33 =
"ivec4 _viv_textureGather_int_2DRect_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGather_int_2D_WithComp(sampler, levelBaseSize, p, comp);\n"
"}\n";

gctSTRING gcLibTextureGather_Func_34 =
"vec4 _viv_textureGather_float_2DRect_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGather_float_2D_WithComp(sampler, levelBaseSize, p, comp);\n"
"}\n";

gctSTRING gcLibTextureGather_Func_35 =
"vec4 _viv_textureGather_2DRectShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGather_2DShadow(sampler, levelBaseSize, p, refZ);\n"
"}\n";

/***********************textureGather implementation that HW can't directly support***********************/
/* 2D sampler. */
gctSTRING gcLibTextureGather_Func_2_0 =
"bool _viv_inBounds(int x, int a)\n"
"{\n"
"    return (x >= 0) && x < a;\n"
"}\n"
"ivec3 _viv_remapCubeCoord(int face, ivec2 coords, int size)\n"
"{\n"
"    bool uInBounds = _viv_inBounds(coords.x, size);\n"
"    bool vInBounds = _viv_inBounds(coords.y, size);\n"
"    if (uInBounds && vInBounds)\n"
"        return ivec3(face, coords);\n"
"    ivec3 canonizedCoords;\n"
"    switch (face)\n"
"    {\n"
"        case 0:  canonizedCoords = ivec3(size-1, size-1-coords.y, size-1-coords.x); break;\n"
"        case 1:  canonizedCoords = ivec3(0, size-1-coords.y, coords.x); break;\n"
"        case 2:  canonizedCoords = ivec3(coords.x, size-1, coords.y); break;\n"
"        case 3:  canonizedCoords = ivec3(coords.x, 0, size-1-coords.y); break;\n"
"        case 4:  canonizedCoords = ivec3(coords.x, size-1-coords.y, size-1); break;\n"
"        default: canonizedCoords = ivec3(size-1-coords.x, size-1-coords.y, 0); break;\n"
"    }\n"
"    if (canonizedCoords.x == -1)\n"
"        return ivec3(1, ivec2(canonizedCoords.z, size-1-canonizedCoords.y));\n"
"    if (canonizedCoords.x == size)\n"
"        return ivec3(0, ivec2(size-1-canonizedCoords.z, size-1-canonizedCoords.y));\n"
"    if (canonizedCoords.y == -1)\n"
"        return ivec3(3, ivec2(canonizedCoords.x, size-1-canonizedCoords.z));\n"
"    if (canonizedCoords.y == size)\n"
"        return ivec3(2, ivec2(canonizedCoords.x, canonizedCoords.z));\n"
"    if (canonizedCoords.z == -1)\n"
"        return ivec3(5, ivec2(size-1-canonizedCoords.x, size-1-canonizedCoords.y));\n"
"    if (canonizedCoords.z == size)\n"
"        return ivec3(4, ivec2(canonizedCoords.x, size-1-canonizedCoords.y));\n"
"}\n"
"vec3 _viv_recomputeCoord(ivec2 UV, int face, float size)\n"
"{\n"
"    vec3 newCoord;\n"
"    ivec3 canonizedCoords = _viv_remapCubeCoord(face, UV, int(size));\n"
"    float offset = 0.5/size;\n"
"    float s = float(canonizedCoords.y) + offset;\n"
"    float t = float(canonizedCoords.z) + offset;\n"
"    float temp = offset - 1.0;\n"
"    s = (2.0 * s) / size - 1.0;\n"
"    t = (2.0 * t) / size - 1.0;\n"
     /* If s/t is 0, it may change face, so we need to add a small offset. */
"    switch (canonizedCoords.x)\n"
"    {\n"
"        case 0:\n"
"            if (canonizedCoords.y == 0)\n"
"                s = temp;\n"
"            if (canonizedCoords.z == 0)\n"
"                t = temp;\n"
"            newCoord = vec3(1.0, -t, -s); break;\n"
"        case 1:\n"
"            if (canonizedCoords.y == 0)\n"
"                s = temp;\n"
"            if (canonizedCoords.z == 0)\n"
"                t = temp;\n"
"            newCoord = vec3(-1.0, -t, s); break;\n"
"        case 2:\n"
"            if (canonizedCoords.z == 0)\n"
"                t = temp;\n"
"            newCoord = vec3(s, 1.0, t); break;\n"
"        case 3:\n"
"            if (canonizedCoords.z == 0)\n"
"                t = temp;\n"
"            newCoord = vec3(s, -1.0, -t); break;\n"
"        case 4: newCoord = vec3(s, -t, 1.0); break;\n"
"        default: newCoord = vec3(-s, -t, -1.0); break;\n"
"    }\n"
"    return newCoord;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2_1 =
"vec4 _viv_textureGather_float_2D_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result;\n"
"    result.x = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.y = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.z = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    result.w = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2_2 =
"vec4 _viv_textureGather_float_2D_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultG = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultB = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    resultA = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = vec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = vec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = vec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
gctSTRING gcLibTextureGather_Func_2_3 =
"vec4 _viv_textureGather_float_2DArray_NoComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result;\n"
"    result.x = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.y = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.z = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    result.w = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2_4 =
"vec4 _viv_textureGather_float_2DArray_WithComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultG = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultB = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    resultA = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = vec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = vec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = vec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
gctSTRING gcLibTextureGather_Func_2_5 =
"vec4 _viv_textureGather_float_Cube_NoComp(samplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    vec4 result;\n"
"    vec2 orgST, orgUV;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    result.x = texture(sampler, _viv_recomputeCoord(i0j1, face, size))[0];\n"
"    result.y = texture(sampler, _viv_recomputeCoord(i1j1, face, size))[0];\n"
"    result.z = texture(sampler, _viv_recomputeCoord(i1j0, face, size))[0];\n"
"    result.w = texture(sampler, _viv_recomputeCoord(i0j0, face, size))[0];\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2_6 =
"vec4 _viv_textureGather_float_Cube_WithComp(samplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    vec2 orgST, orgUV;\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    resultR = texture(sampler, _viv_recomputeCoord(i0j1, face, size));\n"
"    resultG = texture(sampler, _viv_recomputeCoord(i1j1, face, size));\n"
"    resultB = texture(sampler, _viv_recomputeCoord(i1j0, face, size));\n"
"    resultA = texture(sampler, _viv_recomputeCoord(i0j0, face, size));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = vec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = vec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = vec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* 2D shadow sampler. */
gctSTRING gcLibTextureGather_Func_2_7 =
"vec4 _viv_textureGather_2DShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result;\n"
"    result.x = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), refZ));\n"
"    result.y = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), refZ));\n"
"    result.z = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), refZ));\n"
"    result.w = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), refZ));\n"
"    return result;\n"
"}\n";

/* 2D array shadow sampler. */
gctSTRING gcLibTextureGather_Func_2_8 =
"vec4 _viv_textureGather_2DArrayShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result;\n"
"    result.x = texture(sampler, vec4(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z, refZ));\n"
"    result.y = texture(sampler, vec4(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z, refZ));\n"
"    result.z = texture(sampler, vec4(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z, refZ));\n"
"    result.w = texture(sampler, vec4(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z, refZ));\n"
"    return result;\n"
"}\n";

/* Cube shadow sampler. */
gctSTRING gcLibTextureGather_Func_2_9 =
"vec4 _viv_textureGather_CubeShadow(samplerCubeShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    vec4 result;\n"
"    vec2 orgST, orgUV;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    result.x = texture(sampler, vec4(_viv_recomputeCoord(i0j1, face, size), refZ));\n"
"    result.y = texture(sampler, vec4(_viv_recomputeCoord(i1j1, face, size), refZ));\n"
"    result.z = texture(sampler, vec4(_viv_recomputeCoord(i1j0, face, size), refZ));\n"
"    result.w = texture(sampler, vec4(_viv_recomputeCoord(i0j0, face, size), refZ));\n"
"    return result;\n"
"}\n";

/* 2D sampler. */
gctSTRING gcLibTextureGather_Func_2_10 =
"ivec4 _viv_textureGather_int_2D_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    ivec4 result;\n"
"    result.x = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.y = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.z = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    result.w = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2_11 =
"ivec4 _viv_textureGather_int_2D_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultG = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultB = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    resultA = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = ivec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = ivec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = ivec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
gctSTRING gcLibTextureGather_Func_2_12 =
"ivec4 _viv_textureGather_int_2DArray_NoComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    ivec4 result;\n"
"    result.x = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.y = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.z = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    result.w = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2_13 =
"ivec4 _viv_textureGather_int_2DArray_WithComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultG = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultB = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    resultA = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = ivec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = ivec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = ivec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
gctSTRING gcLibTextureGather_Func_2_14 =
"ivec4 _viv_textureGather_int_Cube_NoComp(isamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    ivec4 result;\n"
"    vec2 orgST, orgUV;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    result.x = texture(sampler, _viv_recomputeCoord(i0j1, face, size))[0];\n"
"    result.y = texture(sampler, _viv_recomputeCoord(i1j1, face, size))[0];\n"
"    result.z = texture(sampler, _viv_recomputeCoord(i1j0, face, size))[0];\n"
"    result.w = texture(sampler, _viv_recomputeCoord(i0j0, face, size))[0];\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2_15 =
"ivec4 _viv_textureGather_int_Cube_WithComp(isamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    vec2 orgST, orgUV;\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    resultR = texture(sampler, _viv_recomputeCoord(i0j1, face, size));\n"
"    resultG = texture(sampler, _viv_recomputeCoord(i1j1, face, size));\n"
"    resultB = texture(sampler, _viv_recomputeCoord(i1j0, face, size));\n"
"    resultA = texture(sampler, _viv_recomputeCoord(i0j0, face, size));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = ivec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = ivec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = ivec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* 2D sampler. */
gctSTRING gcLibTextureGather_Func_2_16 =
"uvec4 _viv_textureGather_uint_2D_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    uvec4 result;\n"
"    result.x = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.y = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.z = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    result.w = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2_17 =
"uvec4 _viv_textureGather_uint_2D_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultG = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultB = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    resultA = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = uvec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = uvec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = uvec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
gctSTRING gcLibTextureGather_Func_2_18 =
"uvec4 _viv_textureGather_uint_2DArray_NoComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    uvec4 result;\n"
"    result.x = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.y = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.z = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    result.w = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2_19 =
"uvec4 _viv_textureGather_uint_2DArray_WithComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultG = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultB = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    resultA = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = uvec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = uvec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = uvec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
gctSTRING gcLibTextureGather_Func_2_20 =
"uvec4 _viv_textureGather_uint_Cube_NoComp(usamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    uvec4 result;\n"
"    vec2 orgST, orgUV;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    result.x = texture(sampler, _viv_recomputeCoord(i0j1, face, size))[0];\n"
"    result.y = texture(sampler, _viv_recomputeCoord(i1j1, face, size))[0];\n"
"    result.z = texture(sampler, _viv_recomputeCoord(i1j0, face, size))[0];\n"
"    result.w = texture(sampler, _viv_recomputeCoord(i0j0, face, size))[0];\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGather_Func_2_21 =
"uvec4 _viv_textureGather_uint_Cube_WithComp(usamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    vec2 orgST, orgUV;\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    resultR = texture(sampler, _viv_recomputeCoord(i0j1, face, size));\n"
"    resultG = texture(sampler, _viv_recomputeCoord(i1j1, face, size));\n"
"    resultB = texture(sampler, _viv_recomputeCoord(i1j0, face, size));\n"
"    resultA = texture(sampler, _viv_recomputeCoord(i0j0, face, size));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = uvec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = uvec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = uvec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/***********************textureGatherOffset implementation***********************/
gctSTRING gcLibTextureGatherOffset_Func_1 =
"vec4 _viv_textureGatherOffset_float_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_float_2D_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_2 =
"vec4 _viv_textureGatherOffset_float_2DArray_NoComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_float_2DArray_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_3 =
"vec4 _viv_textureGatherOffset_float_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset, int comp)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_float_2D_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_4 =
"vec4 _viv_textureGatherOffset_float_2DArray_WithComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset, int comp)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_float_2DArray_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_5 =
"vec4 _viv_textureGatherOffset_float_2DShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ, ivec2 offset)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_2DShadow(sampler, levelBaseSize, newCoord, refZ);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_6 =
"vec4 _viv_textureGatherOffset_float_2DArrayShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ, ivec2 offset)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_2DArrayShadow(sampler, levelBaseSize, newCoord, refZ);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_7 =
"ivec4 _viv_textureGatherOffset_int_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_int_2D_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_8 =
"ivec4 _viv_textureGatherOffset_int_2DArray_NoComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_int_2DArray_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_9 =
"ivec4 _viv_textureGatherOffset_int_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset, int comp)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_int_2D_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_10 =
"ivec4 _viv_textureGatherOffset_int_2DArray_WithComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset, int comp)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_int_2DArray_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_11 =
"uvec4 _viv_textureGatherOffset_uint_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_uint_2D_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_12 =
"uvec4 _viv_textureGatherOffset_uint_2DArray_NoComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_uint_2DArray_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_13 =
"uvec4 _viv_textureGatherOffset_uint_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset, int comp)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_uint_2D_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_14 =
"uvec4 _viv_textureGatherOffset_uint_2DArray_WithComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset, int comp)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_uint_2DArray_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_15 =
"vec4 _viv_textureGatherOffset_float_2DRect_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffset_float_NoComp(sampler, levelBaseSize, p, offset);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_16 =
"vec4 _viv_textureGatherOffset_float_2DRect_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset, int comp)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffset_float_WithComp(sampler, levelBaseSize, p, offset, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_17 =
"ivec4 _viv_textureGatherOffset_int_2DRect_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffset_int_NoComp(sampler, levelBaseSize, p, offset);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_18 =
"ivec4 _viv_textureGatherOffset_int_2DRect_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset, int comp)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffset_int_WithComp(sampler, levelBaseSize, p, offset, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_19 =
"uvec4 _viv_textureGatherOffset_uint_2DRect_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffset_uint_NoComp(sampler, levelBaseSize, p, offset);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_20 =
"uvec4 _viv_textureGatherOffset_uint_2DRect_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset, int comp)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffset_uint_WithComp(sampler, levelBaseSize, p, offset, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffset_Func_21 =
"vec4 _viv_textureGatherOffset_float_2DRectShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ, ivec2 offset)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffset_float_2DShadow(sampler, levelBaseSize, p, refZ, offset);\n"
"}\n";

/***********************textureGatherOffsets implementation***********************/
gctSTRING gcLibTextureGatherOffsets_Func_1 =
"vec4 _viv_textureGatherOffsets_float_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4])\n"
"{\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_2 =
"vec4 _viv_textureGatherOffsets_float_2DArray_NoComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4])\n"
"{\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_3 =
"vec4 _viv_textureGatherOffsets_float_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = vec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = vec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = vec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_4 =
"vec4 _viv_textureGatherOffsets_float_2DArray_WithComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = vec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = vec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = vec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_5 =
"vec4 _viv_textureGatherOffsets_float_2DShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ, ivec2 offsets[4])\n"
"{\n"
"    vec4 result;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    result.x = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    result.y = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    result.z = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    result.w = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), refZ));\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_6 =
"vec4 _viv_textureGatherOffsets_float_2DArrayShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ, ivec2 offsets[4])\n"
"{\n"
"    vec4 result;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    result.x = texture(sampler, vec4(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z, refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    result.y = texture(sampler, vec4(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z, refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    result.z = texture(sampler, vec4(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z, refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    result.w = texture(sampler, vec4(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z, refZ));\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_7 =
"ivec4 _viv_textureGatherOffsets_int_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4])\n"
"{\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_8 =
"ivec4 _viv_textureGatherOffsets_int_2DArray_NoComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4])\n"
"{\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_9 =
"ivec4 _viv_textureGatherOffsets_int_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = ivec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = ivec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = ivec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_10 =
"ivec4 _viv_textureGatherOffsets_int_2DArray_WithComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = ivec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = ivec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = ivec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_11 =
"uvec4 _viv_textureGatherOffsets_uint_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4])\n"
"{\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_12 =
"uvec4 _viv_textureGatherOffsets_uint_2DArray_NoComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4])\n"
"{\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_13 =
"uvec4 _viv_textureGatherOffsets_uint_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = uvec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = uvec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = uvec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_14 =
"uvec4 _viv_textureGatherOffsets_uint_2DArray_WithComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = uvec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = uvec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = uvec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_15 =
"vec4 _viv_textureGatherOffsets_float_2DRect_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4])\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffsets_float_NoComp(sampler, levelBaseSize, p, offsets);\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_16 =
"vec4 _viv_textureGatherOffsets_float_2DRect_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffsets_float_WithComp(sampler, levelBaseSize, p, offsets, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_17 =
"ivec4 _viv_textureGatherOffsets_int_2DRect_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4])\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffsets_int_NoComp(sampler, levelBaseSize, p, offsets);\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_18 =
"ivec4 _viv_textureGatherOffsets_int_2DRect_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffsets_int_WithComp(sampler, levelBaseSize, p, offsets, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_19 =
"uvec4 _viv_textureGatherOffsets_uint_2DRect_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4])\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffsets_uint_NoComp(sampler, levelBaseSize, p, offsets);\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_20 =
"uvec4 _viv_textureGatherOffsets_uint_2DRect_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffsets_uint_WithComp(sampler, levelBaseSize, p, offsets, comp);\n"
"}\n";

gctSTRING gcLibTextureGatherOffsets_Func_21 =
"vec4 _viv_textureGatherOffsets_float_2DRectShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ, ivec2 offsets[4])\n"
"{\n"
"    p = p / vec2(levelBaseSize.xy);\n"
"    return _viv_textureGatherOffsets_float_2DShadow(sampler, levelBaseSize, p, refZ, offsets);\n"
"}\n";

/***********************texelFetch for MSAA implementation that HW can directly support***********************/
gctSTRING gcLibTexelFetchForMSAA_Func_1 =
"vec4 _viv_texelFetch_float(sampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetchForMSAA_Func_2 =
"ivec4 _viv_texelFetch_int(isampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetchForMSAA_Func_3 =
"uvec4 _viv_texelFetch_uint(usampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetchForMSAA_Func_4 =
"vec4 _viv_texelFetch_float_array(sampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetchForMSAA_Func_5 =
"ivec4 _viv_texelFetch_int_array(isampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetchForMSAA_Func_6 =
"uvec4 _viv_texelFetch_uint_array(usampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/***********************texelFetch for MSAA implementation that HW can't directly support***********************/
gctSTRING gcLibTexelFetchForMSAA_Func_2_1 =
"vec4 _viv_texelFetch_float(sampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    vec4 result;\n"
"    vec2 newCoord = vec2(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetchForMSAA_Func_2_2 =
"ivec4 _viv_texelFetch_int(isampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    ivec4 result;\n"
"    vec2 newCoord = vec2(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetchForMSAA_Func_2_3 =
"uvec4 _viv_texelFetch_uint(usampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    uvec4 result;\n"
"    vec2 newCoord = vec2(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetchForMSAA_Func_2_4 =
"vec4 _viv_texelFetch_float_array(sampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    vec4 result;\n"
"    vec3 newCoord = vec3(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord.xy += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord.xy /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetchForMSAA_Func_2_5 =
"ivec4 _viv_texelFetch_int_array(isampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    ivec4 result;\n"
"    vec3 newCoord = vec3(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord.xy += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord.xy /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetchForMSAA_Func_2_6 =
"uvec4 _viv_texelFetch_uint_array(usampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    uvec4 result;\n"
"    vec3 newCoord = vec3(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord.xy += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord.xy /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

/******************** image instructions implementation ********************/

/* The image size function needs to be patched at the end of linkLibFunction.
   Based on the uniform's name and generate the size uniform to replace
   the img_desc. Thus the result will have the uniform's size */

/* This image size is for inner use. The size uniform's w channel stores the
   slice size. */
gctSTRING gcLibImageSize =
"highp uvec4 _viv_image_size(highp uvec4 img_desc)\n"
"{\n"
"    uvec4 result = img_desc;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_halti4 =
"highp uvec4 _viv_image_size(highp uvec4 img_desc)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    return uvec4(size);\n"
"}\n";

gctSTRING gcLibImageSize_2D_float =
"highp uvec2 _viv_image_size_1(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result;\n"
"    result = img_desc.xy;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_3D_float =
"highp uvec3 _viv_image_size_2(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result ;\n"
"    result = img_desc.xyz;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_CUBE_float =
"highp uvec2 _viv_image_size_3(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result;\n"
"    result = img_desc.xy;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_2DArray_float =
"highp uvec3 _viv_image_size_4(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result ;\n"
"    result = img_desc.xyz;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_2D_int =
"highp uvec2 _viv_image_size_5(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result;\n"
"    result = img_desc.xy;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_3D_int =
"highp uvec3 _viv_image_size_6(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result;\n"
"    result = img_desc.xyz;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_CUBE_int =
"highp uvec2 _viv_image_size_7(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result;\n"
"    result = img_desc.xy;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_2DArray_int =
"highp uvec3 _viv_image_size_8(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result;\n"
"    result = img_desc.xyz;\n"
"    return result;\n"
"}\n";


gctSTRING gcLibImageSize_2D_uint =
"highp uvec2 _viv_image_size_9(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result =  img_desc.xy;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_3D_uint  =
"highp uvec3 _viv_image_size_10(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result =  img_desc.xyz;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_CUBE_uint  =
"highp uvec2 _viv_image_size_11(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result =  img_desc.xy;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_2DArray_uint  =
"highp uvec3 _viv_image_size_12(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result =  img_desc.xyz;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_CubeArray_float  =
"highp uvec3 _viv_image_size_13(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result =  img_desc.xyz;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_CubeArray_int  =
"highp uvec3 _viv_image_size_14(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result =  img_desc.xyz;\n"
"    return result;\n"
"}\n";


gctSTRING gcLibImageSize_CubeArray_uint  =
"highp uvec3 _viv_image_size_15(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result =  img_desc.xyz;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_Buffer_float  =
"highp uint _viv_image_size_16(highp uvec4 img_desc)\n"
"{\n"
"    uint result =  img_desc.x;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_Buffer_int  =
"highp uint _viv_image_size_17(highp uvec4 img_desc)\n"
"{\n"
"    uint result =  img_desc.x;\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageSize_Buffer_uint  =
"highp uint _viv_image_size_18(highp uvec4 img_desc)\n"
"{\n"
"    uint result =  img_desc.x;\n"
"    return result;\n"
"}\n";

/******************************************************************/
/* gc3000/5000 image instruction implmentation */
/******************************************************************/
/* _viv_image_computeImgAddr function compute the img address.
    The return is a uvec2 (x is inBorder, y is address) */
gctSTRING gcLibImageAddr =
"highp uvec2 _viv_image_computeImgAddr3D(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   uint base = uint(p.z);\n"
"   uint stride = img_desc.y;\n"
"   uint shift  = _viv_bitfieldExtract_uint_const(img_desc.w, 0, 3);\n"
"   uint mul  = _viv_bitfieldExtract_uint_const(img_desc.w, 3, 1);\n"
"   uint tiling  = _viv_bitfieldExtract_uint_const(img_desc.w, 10, 2);\n"
"   uint addressing = _viv_bitfieldExtract_uint_const(img_desc.w, 4, 2);\n"
"   if (addressing == IMAGE_ADDRESSING_NONE) { addressing = IMAGE_ADDRESSING_BORDER0; } \n"
"   uint xCoord = uint(p.x);\n"
"   uint yCoord = uint(p.y);\n"
"   int width = int(_viv_bitfieldExtract_uint_const(img_desc.z, 0, 16));\n"
"   int height = int(_viv_bitfieldExtract_uint_const(img_desc.z, 16, 16));\n"
"   if (addressing == IMAGE_ADDRESSING_CLAMP)\n"
"   {\n"
"       if (p.x < 0)\n"
"           xCoord = 0u;\n"
"       else if (p.x >= width)\n"
"           xCoord = uint(width - 1);\n"
"       if (p.y < 0)\n"
"           yCoord = 0u;\n"
"       else if (p.y >= height)\n"
"           yCoord = uint(height - 1);\n"
"   }\n"
"   else if ((p.x < 0) || (p.y < 0) || (p.x >= width) || (p.y >= height)) { return uvec2(addressing, 0u); } \n"
"   uint x = 0u, y = 0u;\n"
"   if (tiling == 0u) { x = xCoord; y = yCoord; }\n"
"   /* driver always set to super tile, thus not consider the tile case */\n"
"   if (tiling == 2u) {\n"
"       y = yCoord;\n"
"       x = _viv_bitfieldExtract_uint_const(xCoord, 0, 2) | (_viv_bitfieldExtract_uint_const(y, 0, 2) << 2u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 2, 1) << 4u) | (_viv_bitfieldExtract_uint_const(y, 2, 1) << 5u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 3, 1) << 6u) | (_viv_bitfieldExtract_uint_const(y, 3, 1) << 7u)|\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 4, 1) << 8u) | (_viv_bitfieldExtract_uint_const(y, 4, 1) << 9u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 5, 1) << 10u) | (_viv_bitfieldExtract_uint_const(y, 5, 1) << 11u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 6, 26) << 12u);\n"
"       y =  _viv_bitfieldInsert_uint_const(y, 0u, 0, 6);\n"
"   }\n"
"   uint xOffset;\n"
"   if (mul == 1u) { xOffset = (x * 3u ) << shift ; } \n"
"   else { xOffset = x << shift ; } \n"
"   uint yOffset = y * stride;\n"
"   uint address = base + xOffset + yOffset;\n"
"   return uvec2(0u, address);\n"
"}\n"
"highp uvec2 _viv_image_computeImgAddr2D(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uint addressing = _viv_bitfieldExtract_uint_const(img_desc.w, 4, 2);\n"
"   if (addressing == IMAGE_ADDRESSING_NONE) { addressing = IMAGE_ADDRESSING_BORDER0; } \n"
"   uint xCoord = uint(p.x);\n"
"   uint yCoord = uint(p.y);\n"
"   int width = int(_viv_bitfieldExtract_uint_const(img_desc.z, 0, 16));\n"
"   int height = int(_viv_bitfieldExtract_uint_const(img_desc.z, 16, 16));\n"
"   if (addressing == IMAGE_ADDRESSING_CLAMP)\n"
"   {\n"
"       if (p.x < 0)\n"
"           xCoord = 0u;\n"
"       else if (p.x >= width)\n"
"           xCoord = uint(width - 1);\n"
"       if (p.y < 0)\n"
"           yCoord = 0u;\n"
"       else if (p.y >= height)\n"
"           yCoord = uint(height - 1);\n"
"   }\n"
"   else if ((p.x < 0) || (p.y < 0) || (p.x >= width) || (p.y >= height)) { return uvec2(addressing, 0u); } \n"
"   uint x = 0u, y = 0u;\n"
"   uint tiling  = _viv_bitfieldExtract_uint_const(img_desc.w, 10, 2);\n"
"   if (tiling == 0u) { x = xCoord; y = yCoord; }\n"
"   /* driver always set to super tile, thus not consider the tile case */\n"
"   if (tiling == 2u) {\n"
"       y = yCoord;\n"
"       x = _viv_bitfieldExtract_uint_const(xCoord, 0, 2) | (_viv_bitfieldExtract_uint_const(y, 0, 2) << 2u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 2, 1) << 4u) | (_viv_bitfieldExtract_uint_const(y, 2, 1) << 5u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 3, 1) << 6u) | (_viv_bitfieldExtract_uint_const(y, 3, 1) << 7u)|\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 4, 1) << 8u) | (_viv_bitfieldExtract_uint_const(y, 4, 1) << 9u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 5, 1) << 10u) | (_viv_bitfieldExtract_uint_const(y, 5, 1) << 11u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 6, 26) << 12u);\n"
"       y =  _viv_bitfieldInsert_uint_const(y, 0u, 0, 6);\n"
"   }\n"
"   uint xOffset;\n"
"   uint shift  = _viv_bitfieldExtract_uint_const(img_desc.w, 0, 3);\n"
"   uint mul  = _viv_bitfieldExtract_uint_const(img_desc.w, 3, 1);\n"
"   if (mul == 1u) { xOffset = (x * 3u ) << shift ; } \n"
"   else { xOffset = x << shift ; } \n"
"   uint yOffset = y * img_desc.y;\n"
"   uint address = img_desc.x + xOffset + yOffset;\n"
"   return uvec2(0u, address);\n"
"}\n";

gctSTRING gcLibImageAddr_halti4 =
"bool _viv_image_checkBorder(highp uvec4 img_desc, uint addressing, ivec2 p)\n"
"{\n"
"   int width = int(_viv_bitfieldExtract_uint_const(img_desc.z, 0, 16));\n"
"   int height = int(_viv_bitfieldExtract_uint_const(img_desc.z, 16, 16));\n"
"   if ((addressing != IMAGE_ADDRESSING_CLAMP) && ((p.x < 0) || (p.y < 0) || (p.x >= width) || (p.y >= height)))\n"
"   { return true; } \n"
"   return false;\n"
"}\n"
"highp uvec2 _viv_image_computeImgAddr3D(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   uint addressing = _viv_bitfieldExtract_uint_const(img_desc.w, 4, 2);\n"
"   if (addressing == IMAGE_ADDRESSING_NONE) { addressing = IMAGE_ADDRESSING_BORDER0; } \n"
"   if (_viv_image_checkBorder(img_desc, addressing, p.xy))\n"
"   { return uvec2(addressing, 0u); } \n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p);\n"
"   return uvec2(0u, address);\n"
"}\n"
"highp uvec2 _viv_image_computeImgAddr2D(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uint addressing = _viv_bitfieldExtract_uint_const(img_desc.w, 4, 2);\n"
"   if (addressing == IMAGE_ADDRESSING_NONE) { addressing = IMAGE_ADDRESSING_BORDER0; } \n"
"   if (_viv_image_checkBorder(img_desc, addressing, p.xy))\n"
"   { return uvec2(addressing, 0u); } \n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   return uvec2(0u, address);\n"
"}\n";

gctSTRING gcLibImageAddr_intrinsic =
"highp uint _viv_image_addr_image_1d(highp uvec4 img_desc, int p, int selectSample)\n"
"{\n"
"   return _viv_image_computeImgAddr2D(img_desc, ivec2(p, 0)).y;\n"
"}\n"
"highp uint _viv_image_addr_image_1d_array(highp uvec4 img_desc, ivec2 p, int selectSample)\n"
"{\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = ivec3(p.x, 0, p.y);\n"
"   p1.z = int(img_desc.x) + p.y * int(is.w);\n"
"   return _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"}\n"
"highp uint _viv_image_addr_image_2d(highp uvec4 img_desc, ivec2 p, int selectSample)\n"
"{\n"
"   return _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"}\n"
"highp uint _viv_image_addr_image_2d_array(highp uvec4 img_desc, ivec3 p, int selectSample)\n"
"{\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   p.z = int(img_desc.x) + p.z * int(is.w);\n"
"   return _viv_image_computeImgAddr3D(img_desc, p).y;\n"
"}\n"
"highp uint _viv_image_addr_image_3d(highp uvec4 img_desc, ivec3 p, int selectSample)\n"
"{\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   p.z = int(img_desc.x) + p.z * int(is.w);\n"
"   return _viv_image_computeImgAddr3D(img_desc, p).y;\n"
"}\n";

gctSTRING gcLibImageSwizzle =
"highp vec4 _viv_image_swizzle(highp uvec4 img_desc, highp vec4 raw)\n"
"{\n"
"   vec4 result;\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.x = raw.y; break;\n"
"       case 2u: result.x = raw.z; break;\n"
"       case 3u: result.x = raw.w; break;\n"
"       case 4u: result.x = 0.0; break;\n"
"       case 5u: result.x = 1.0; break; \n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.y = raw.x; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.y = raw.z; break;\n"
"       case 3u: result.y = raw.w; break;\n"
"       case 4u: result.y = 0.0; break;\n"
"       case 5u: result.y = 1.0; break; \n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.z = raw.x; break;\n"
"       case 1u: result.z = raw.y; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.z = raw.w; break;\n"
"       case 4u: result.z = 0.0; break;\n"
"       case 5u: result.z = 1.0; break; \n"
"   }\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.w = raw.x; break;\n"
"       case 1u: result.w = raw.y; break;\n"
"       case 2u: result.w = raw.z; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"       case 4u: result.w = 0.0; break;\n"
"       case 5u: result.w = 1.0; break; \n"
"   }\n"
"   return result;\n"
"}\n"
"highp ivec4 _viv_image_swizzle_int(highp uvec4 img_desc, highp ivec4 raw)\n"
"{\n"
"   ivec4 result;\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.x = raw.y; break;\n"
"       case 2u: result.x = raw.z; break;\n"
"       case 3u: result.x = raw.w; break;\n"
"       case 4u: result.x = 0; break;\n"
"       case 5u: result.x = 1; break; \n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.y = raw.x; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.y = raw.z; break;\n"
"       case 3u: result.y = raw.w; break;\n"
"       case 4u: result.y = 0; break;\n"
"       case 5u: result.y = 1; break; \n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.z = raw.x; break;\n"
"       case 1u: result.z = raw.y; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.z = raw.w; break;\n"
"       case 4u: result.z = 0; break;\n"
"       case 5u: result.z = 1; break; \n"
"   }\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.w = raw.x; break;\n"
"       case 1u: result.w = raw.y; break;\n"
"       case 2u: result.w = raw.z; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"       case 4u: result.w = 0; break;\n"
"       case 5u: result.w = 1; break; \n"
"   }\n"
"   return result;\n"
"}\n"
"highp uvec4 _viv_image_swizzle_uint(highp uvec4 img_desc, highp uvec4 raw)\n"
"{\n"
"   uvec4 result;\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.x = raw.y; break;\n"
"       case 2u: result.x = raw.z; break;\n"
"       case 3u: result.x = raw.w; break;\n"
"       case 4u: result.x = 0u; break;\n"
"       case 5u: result.x = 1u; break; \n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.y = raw.x; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.y = raw.z; break;\n"
"       case 3u: result.y = raw.w; break;\n"
"       case 4u: result.y = 0u; break;\n"
"       case 5u: result.y = 1u; break; \n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.z = raw.x; break;\n"
"       case 1u: result.z = raw.y; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.z = raw.w; break;\n"
"       case 4u: result.z = 0u; break;\n"
"       case 5u: result.z = 1u; break; \n"
"   }\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.w = raw.x; break;\n"
"       case 1u: result.w = raw.y; break;\n"
"       case 2u: result.w = raw.z; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"       case 4u: result.w = 0u; break;\n"
"       case 5u: result.w = 1u; break; \n"
"   }\n"
"   return result;\n"
"}\n";

/* this is currently used in rgba8.
   Driver maps rgba8 to bgra8. We use this swizzle function
   to get the correct data to write. */
gctSTRING gcLibImageStoreSwizzle =
"highp vec4 _viv_image_store_swizzle(highp uvec4 img_desc, highp vec4 raw)\n"
"{\n"
"   vec4 result = raw;\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.x = raw.w; break;\n"
"       case 1u: result.y = raw.w; break;\n"
"       case 2u: result.z = raw.w; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.x = raw.z; break;\n"
"       case 1u: result.y = raw.z; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.w = raw.z; break;\n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.x = raw.y; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.z = raw.y; break;\n"
"       case 3u: result.w = raw.y; break;\n"
"   }\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.y = raw.x; break;\n"
"       case 2u: result.z = raw.x; break;\n"
"       case 3u: result.w = raw.x; break;\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_store_swizzle_int(highp uvec4 img_desc, highp ivec4 raw)\n"
"{\n"
"   ivec4 result = raw;\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.x = raw.w; break;\n"
"       case 1u: result.y = raw.w; break;\n"
"       case 2u: result.z = raw.w; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.x = raw.z; break;\n"
"       case 1u: result.y = raw.z; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.w = raw.z; break;\n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.x = raw.y; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.z = raw.y; break;\n"
"       case 3u: result.w = raw.y; break;\n"
"   }\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.y = raw.x; break;\n"
"       case 2u: result.z = raw.x; break;\n"
"       case 3u: result.w = raw.x; break;\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp uvec4 _viv_image_store_swizzle_uint(highp uvec4 img_desc, highp uvec4 raw)\n"
"{\n"
"   uvec4 result = raw;\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.x = raw.w; break;\n"
"       case 1u: result.y = raw.w; break;\n"
"       case 2u: result.z = raw.w; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.x = raw.z; break;\n"
"       case 1u: result.y = raw.z; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.w = raw.z; break;\n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.x = raw.y; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.z = raw.y; break;\n"
"       case 3u: result.w = raw.y; break;\n"
"   }\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.y = raw.x; break;\n"
"       case 2u: result.z = raw.x; break;\n"
"       case 3u: result.w = raw.x; break;\n"
"   }\n"
"   return result;\n"
"}\n";

/****************************imageLoad for a 2D image****************************/
gctSTRING gcLibImageLoad_2D_float =
"highp vec4 _viv_image_load_image_2d(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:FLOAT16>, address, 0);\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_rgba8 =
"highp vec4 _viv_image_load_image_2d_rgba8(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 raw = _viv_image_load_uimage_2d_rgba8ui(img_desc, p);\n"
"   return vec4(min(raw, 255u)) / 255.0;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_rgba8_snorm =
"highp vec4 _viv_image_load_image_2d_rgba8_snorm(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 raw = _viv_image_load_iimage_2d_rgba8i(img_desc, p);\n"
"   return vec4(clamp(raw, -127, 127)) / 127.0;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_rg8 =
"highp vec4 _viv_image_load_image_2d_rg8(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 raw = _viv_image_load_uimage_2d_rg8ui(img_desc, p);\n"
"   return vec4(min(raw, 255u)) / 255.0;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_rg8_snorm =
"highp vec4 _viv_image_load_image_2d_rg8_snorm(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 raw = _viv_image_load_iimage_2d_rg8i(img_desc, p);\n"
"   return vec4(clamp(raw, -127, 127)) / 127.0;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_r8 =
"highp vec4 _viv_image_load_image_2d_r8(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 raw = _viv_image_load_uimage_2d_r8ui(img_desc, p);\n"
"   return vec4(min(raw, 255u)) / 255.0;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_r8_snorm =
"highp vec4 _viv_image_load_image_2d_r8_snorm(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 raw = _viv_image_load_iimage_2d_r8i(img_desc, p);\n"
"   return vec4(clamp(raw, -127, 127)) / 127.0;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_rgba32f =
"highp vec4 _viv_image_load_image_2d_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp vec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:FLOAT>, address, 0);\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp vec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:FLOAT>, address, 0);\n"
"       result.zw = _viv_image_swizzle(img_desc_1, raw).xy;\n"
"   }\n"
"   return result;\n"
"}\n";

/* don't use raw.zw = vec2(0.0, 1.0),
   recompilation has issue with const vector*/
gctSTRING gcLibImageLoad_2D_float_rg16f =
"highp vec4 _viv_image_load_image_2d_rg16f(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       highp vec2 temp;\n"
"       _viv_asm(LOAD, temp!<f:FLOAT16>, address, 0);\n"
"       raw.xy = temp;\n"
"       raw.z = 0.0;\n"
"       raw.w = 1.0;\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_r16f =
"highp vec4 _viv_image_load_image_2d_r16f(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       highp float temp;\n"
"       _viv_asm(LOAD, temp!<f:FLOAT16>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0.0;\n"
"       raw.z = 0.0;\n"
"       raw.w = 1.0;\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_rg32f =
"highp vec4 _viv_image_load_image_2d_rg32f(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       highp vec2 temp;\n"
"       _viv_asm(LOAD, temp!<f:FLOAT>, address, 0);\n"
"       raw.xy = temp;\n"
"       raw.z = 0.0;\n"
"       raw.w = 1.0;\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

/* don't use raw = vec4(0.0, 0.0, 0.0, 1.0),
   recompilation has issue with const vector*/
gctSTRING gcLibImageLoad_2D_float_r32f =
"highp vec4 _viv_image_load_image_2d_r32f(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       highp float temp;\n"
"       _viv_asm(LOAD, temp!<f:FLOAT>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0.0;\n"
"       raw.z = 0.0;\n"
"       raw.w = 1.0;\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_r5g6b5_unorm_pack16 =
"highp vec4 _viv_image_load_image_2d_r5g6b5_unorm_pack16(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT16>, address, 0);\n"
"       result.x = float((raw.x >> 11) & uint(0x1F)) / 31.0;\n"
"       result.y = float((raw.x >> 5)  & uint(0x3F)) / 63.0;\n"
"       result.z = float((raw.x) & uint(0x1F)) / 31.0;\n"
"       result.w = 1.0;\n"
"       result = _viv_image_swizzle(img_desc, result);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_abgr8_unorm_pack32 =
"highp vec4 _viv_image_load_image_2d_abgr8_unorm_pack32(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"   else {\n"
"       highp uint raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result.x = float((raw) & uint(0xFF)) / 255.0;\n"
"       result.y = float((raw >> 8) & uint(0xFF)) / 255.0;\n"
"       result.z = float((raw >> 16) & uint(0xFF)) / 255.0;\n"
"       result.w = float((raw >> 24) & uint(0xFF)) / 255.0;\n"
"       result = _viv_image_swizzle(img_desc, result);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_a2r10g10b10_unorm_pack32 =
"highp vec4 _viv_image_load_image_2d_a2r10g10b10_unorm_pack32(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"   else {\n"
"       highp uint raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result.x = float((raw) & uint(0x3FF)) / 1023.0;\n"
"       result.y = float((raw >> 10) & uint(0x3FF)) / 1023.0;\n"
"       result.z = float((raw >> 20) & uint(0x3FF)) / 1023.0;\n"
"       result.w = float((raw >> 30) & uint(0x3)) / 3.0;\n"
"       result = _viv_image_swizzle(img_desc, result);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_abgr8ui_pack32 =
"highp uvec4 _viv_image_load_uimage_2d_abgr8ui_pack32(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uint raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result.x = (raw) & uint(0xFF);\n"
"       result.y = (raw >> 8) & uint(0xFF);\n"
"       result.z = (raw >> 16) & uint(0xFF);\n"
"       result.w = (raw >> 24) & uint(0xFF);\n"
"       result = _viv_image_swizzle_uint(img_desc, result);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_abgr8i_pack32 =
"highp ivec4 _viv_image_load_iimage_2d_abgr8i_pack32(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp int raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result.x = (raw) & (0xFF);\n"
"       result.y = (raw >> 8) & (0xFF);\n"
"       result.z = (raw >> 16) & (0xFF);\n"
"       result.w = (raw >> 24) & (0xFF);\n"
"       result.x = ((result.x << 24) >> 24);\n"
"       result.y = ((result.y << 24) >> 24);\n"
"       result.z = ((result.z << 24) >> 24);\n"
"       result.w = ((result.w << 24) >> 24);\n"
"       result = _viv_image_swizzle_int(img_desc, result);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int =
"highp ivec4 _viv_image_load_iimage_2d(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT16>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_rgba8i =
"highp ivec4 _viv_image_load_iimage_2d_rgba8i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_rg8i =
"highp ivec4 _viv_image_load_iimage_2d_rg8i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec2 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result.xy = raw;\n"
"       result.z = 0;\n"
"       result.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, result);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_r8i =
"highp ivec4 _viv_image_load_iimage_2d_r8i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp int raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result.x = raw;\n"
"       result.y = 0;\n"
"       result.z = 0;\n"
"       result.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, result);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_rgba32i =
"highp ivec4 _viv_image_load_iimage_2d_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result.zw = _viv_image_swizzle_int(img_desc_1, raw).xy;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_rg32i =
"highp ivec4 _viv_image_load_iimage_2d_rg32i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       highp ivec2 temp;\n"
"       _viv_asm(LOAD, temp!<f:INT32>, address, 0);\n"
"       raw.xy = temp.xy;\n"
"       raw.z = 0;\n"
"       raw.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_r32i =
"highp ivec4 _viv_image_load_iimage_2d_r32i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       highp int temp;\n"
"       _viv_asm(LOAD, temp!<f:INT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0;\n"
"       raw.z = 0;\n"
"       raw.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_rg16i =
"highp ivec4 _viv_image_load_iimage_2d_rg16i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       highp ivec2 temp;\n"
"       _viv_asm(LOAD, temp!<f:INT16>, address, 0);\n"
"       raw.xy = temp.xy;\n"
"       raw.z = 0;\n"
"       raw.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_r16i =
"highp ivec4 _viv_image_load_iimage_2d_r16i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       highp int temp;\n"
"       _viv_asm(LOAD, temp!<f:INT16>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0;\n"
"       raw.z = 0;\n"
"       raw.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint =
"highp uvec4 _viv_image_load_uimage_2d(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT16>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_rgba8ui =
"highp uvec4 _viv_image_load_uimage_2d_rgba8ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_rg8ui =
"highp uvec4 _viv_image_load_uimage_2d_rg8ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec2 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result.xy = raw;\n"
"       result.z = 0u;\n"
"       result.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, result);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_r8ui =
"highp uvec4 _viv_image_load_uimage_2d_r8ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uint raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result.x = raw;\n"
"       result.y = 0u;\n"
"       result.z = 0u;\n"
"       result.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, result);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_rgba32ui =
"highp uvec4 _viv_image_load_uimage_2d_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result.zw = _viv_image_swizzle_uint(img_desc_1, raw).xy;\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_r32ui =
"highp uvec4 _viv_image_load_uimage_2d_r32ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       highp uint temp;\n"
"       _viv_asm(LOAD, temp!<f:UINT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0u;\n"
"       raw.z = 0u;\n"
"       raw.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_rg32ui =
"highp uvec4 _viv_image_load_uimage_2d_rg32ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       highp uvec2 temp;\n"
"       _viv_asm(LOAD, temp!<f:UINT32>, address, 0);\n"
"       raw.xy = temp;\n"
"       raw.z = 0u;\n"
"       raw.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_rg16ui =
"highp uvec4 _viv_image_load_uimage_2d_rg16ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       highp uvec2 temp;\n"
"       _viv_asm(LOAD, temp!<f:UINT16>, address, 0);\n"
"       raw.xy = temp.xy;\n"
"       raw.z = 0u;\n"
"       raw.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_r16ui =
"highp uvec4 _viv_image_load_uimage_2d_r16ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       highp uint temp;\n"
"       _viv_asm(LOAD, temp!<f:UINT16>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0u;\n"
"       raw.z = 0u;\n"
"       raw.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

/****************************imageLoad for a 3D/cube/2DArray image****************************/
gctSTRING gcLibImageLoad_3Dcommon =
"highp uvec4 _viv_image_load_3Dcommon_uint_rgba8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_3Dcommon_uint_rg8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec2 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, uvec4(raw, 0u, 0u));\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_3Dcommon_uint_r8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uint raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, uvec4(raw, 0u, 0u, 0u));\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3Dcommon_int_rgba8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3Dcommon_int_rg8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec2 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, ivec4(raw, 0, 0));\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3Dcommon_int_r8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp int raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, ivec4(raw, 0, 0, 0));\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3Dcommon_float(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    vec4 result = vec4(0.0);\n"
"    uint is = _viv_image_size(img_desc).w;\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"    uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"    uint inBorder = addrRet.x;\n"
"    uint address = addrRet.y;\n"
"    if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"    else {\n"
"        highp vec4 raw;\n"
"        _viv_asm(LOAD, raw!<f:FLOAT16>, address, 0);\n"
"        result = _viv_image_swizzle(img_desc, raw);\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3Dcommon_float_rgba8(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec4 raw = _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, p);\n"
"   result = vec4(raw) / 255.0;\n"
"   if (raw.x == 255u)\n"
"       result.x = 1.0;\n"
"   if (raw.y == 255u)\n"
"       result.y = 1.0;\n"
"   if (raw.z == 255u)\n"
"       result.z = 1.0;\n"
"   if (raw.w == 255u)\n"
"       result.w = 1.0;\n"
"   return result;\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3Dcommon_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec4 raw = _viv_image_load_3Dcommon_int_rgba8i(img_desc, p);\n"
"   result = vec4(raw) / 127.0;\n"
"   if (abs(raw.x) == 127)\n"
"       result.x = sign(result.x);\n"
"   if (abs(raw.y) == 127)\n"
"       result.y = sign(result.y);\n"
"   if (abs(raw.z) == 127)\n"
"       result.z = sign(result.z);\n"
"   if (abs(raw.w) == 127)\n"
"       result.w = sign(result.w);\n"
"   return result;\n"
"}\n"
"highp vec4 _viv_image_load_3Dcommon_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    vec4 result = vec4(0.0);\n"
"    uint is = _viv_image_size(img_desc).w;\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"    uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"    uint inBorder = addrRet.x;\n"
"    uint address = addrRet.y;\n"
"    if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"    else {\n"
"        highp vec4 raw;\n"
"        _viv_asm(LOAD, raw!<f:FLOAT>, address, 0);\n"
"        result = _viv_image_swizzle(img_desc, raw);\n"
"    }\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is) ;\n"
"    addrRet = _viv_image_computeImgAddr3D(img_desc_1, p1);\n"
"    inBorder = addrRet.x;\n"
"    address = addrRet.y;\n"
"    if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"    else {\n"
"        highp vec4 raw;\n"
"        _viv_asm(LOAD, raw!<f:FLOAT>, address, 0);\n"
"        result.zw = _viv_image_swizzle(img_desc_1, raw).xy;\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3Dcommon_float_r32f(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       highp float temp;\n"
"       _viv_asm(LOAD, temp!<f:FLOAT>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0.0;\n"
"       raw.z = 0.0;\n"
"       raw.w = 1.0;\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3Dcommon_int(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT16>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3Dcommon_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   p1 = p;\n"
"   p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"   addrRet = _viv_image_computeImgAddr3D(img_desc_1, p1);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result.zw = _viv_image_swizzle_int(img_desc_1, raw).xy;\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3Dcommon_int_r32i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       highp int temp;\n"
"       _viv_asm(LOAD, temp!<f:INT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0;\n"
"       raw.z = 0;\n"
"       raw.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"highp uvec4 _viv_image_load_3Dcommon_uint(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT16>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_3Dcommon_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   p1 = p;\n"
"   p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"   addrRet = _viv_image_computeImgAddr3D(img_desc_1, p1);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result.zw = _viv_image_swizzle_uint(img_desc_1, raw).xy;\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_3Dcommon_uint_r32ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       highp uint temp;\n"
"       _viv_asm(LOAD, temp!<f:UINT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0u;\n"
"       raw.z = 0u;\n"
"       raw.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";


gctSTRING gcLibImageLoad_3D =
"highp uvec4 _viv_image_load_uimage_3d_rgba8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_3d_rgba8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba8i(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_3d(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_3d_rgba8(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_3d_rgba8_snorm(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8_snorm(img_desc, p);\n"
"}\n"
"highp vec4 _viv_image_load_image_3d_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float_rgba32f(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_3d_r32f(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_r32f(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_3d(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_3d_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba32i(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_3d_r32i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_r32i(img_desc, p);\n"
"}\n"
"highp uvec4 _viv_image_load_uimage_3d(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint(img_desc, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_uimage_3d_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_uimage_3d_r32ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_r32ui(img_desc, p);\n"
"}\n";

/* cube */
gctSTRING gcLibImageLoad_cube =
"highp uvec4 _viv_image_load_uimage_cube_rgba8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_cube_rgba8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba8i(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_cube(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_cube_rgba8(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_cube_rgba8_snorm(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8_snorm(img_desc, p);\n"
"}\n"
"highp vec4 _viv_image_load_image_cube_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float_rgba32f(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_cube_r32f(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_r32f(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_cube(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_cube_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba32i(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_cube_r32i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_r32i(img_desc, p);\n"
"}\n"
"highp uvec4 _viv_image_load_uimage_cube(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint(img_desc, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_uimage_cube_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_uimage_cube_r32ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_r32ui(img_desc, p);\n"
"}\n";

/* 1DArray */
gctSTRING gcLibImageLoad_1DArray =
"highp uvec4 _viv_image_load_uimage_1d_array_rgba8ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, ivec3(p.x, 0, p.y));\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_1d_array_rgba8i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba8i(img_desc, ivec3(p.x, 0, p.y));\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_1d_array(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float(img_desc, ivec3(p.x, 0, p.y));\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_1d_array_rgba8(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8(img_desc, ivec3(p.x, 0, p.y));\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_1d_array_rgba8_snorm(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8_snorm(img_desc, ivec3(p.x, 0, p.y));\n"
"}\n"
"highp vec4 _viv_image_load_image_1d_array_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float_rgba32f(img_desc, img_desc_1, ivec3(p.x, 0, p.y));\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_1d_array_r32f(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_r32f(img_desc, ivec3(p.x, 0, p.y));\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_1d_array(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int(img_desc, ivec3(p.x, 0, p.y));\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_1d_array_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba32i(img_desc, img_desc_1, ivec3(p.x, 0, p.y));\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_1d_array_r32i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_r32i(img_desc, ivec3(p.x, 0, p.y));\n"
"}\n"
"highp uvec4 _viv_image_load_uimage_1d_array(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint(img_desc, ivec3(p.x, 0, p.y));\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_uimage_1d_array_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, ivec3(p.x, 0, p.y));\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_uimage_1d_array_r32ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_r32ui(img_desc, ivec3(p.x, 0, p.y));\n"
"}\n";

/* 2DArray */
gctSTRING gcLibImageLoad_2DArray =
"highp uvec4 _viv_image_load_uimage_2d_array_rgba8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_2d_array_rgba8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba8i(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_2d_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_2d_array_rgba8(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_2d_array_rgba8_snorm(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8_snorm(img_desc, p);\n"
"}\n"
"highp vec4 _viv_image_load_image_2d_array_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float_rgba32f(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_2d_array_r32f(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_r32f(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_2d_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_2d_array_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba32i(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_2d_array_r32i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_r32i(img_desc, p);\n"
"}\n"
"highp uvec4 _viv_image_load_uimage_2d_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint(img_desc, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_uimage_2d_array_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_uimage_2d_array_r32ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_r32ui(img_desc, p);\n"
"}\n";

/****************************imageLoad for a 1D image****************************/
gctSTRING gcLibImageLoad_1D_float =
"highp vec4 _viv_image_load_image_1d(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_image_2d(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_rgba8 =
"highp vec4 _viv_image_load_image_1d_rgba8(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_image_2d_rgba8(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_rg8 =
"highp vec4 _viv_image_load_image_1d_rg8(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_image_2d_rg8(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_r8 =
"highp vec4 _viv_image_load_image_1d_r8(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_image_2d_r8(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_rgba8_snorm =
"highp vec4 _viv_image_load_image_1d_rgba8_snorm(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_image_2d_rgba8_snorm(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_rg8_snorm =
"highp vec4 _viv_image_load_image_1d_rg8_snorm(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_image_2d_rg8_snorm(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_r8_snorm =
"highp vec4 _viv_image_load_image_1d_r8_snorm(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_image_2d_r8_snorm(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_rgba32f =
"highp vec4 _viv_image_load_image_1d_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, int p)\n"
"{\n"
"   return _viv_image_load_image_2d_rgba32f(img_desc, img_desc_1, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_r32f =
"highp vec4 _viv_image_load_image_1d_r32f(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_image_2d_r32f(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_r32i =
"highp ivec4 _viv_image_load_image_1d_r32i(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_iimage_2d_r32i(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_r32ui =
"highp uvec4 _viv_image_load_image_1d_r32ui(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_uimage_2d_r32ui(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_int =
"highp ivec4 _viv_image_load_iimage_1d(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_iimage_2d(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_int_rgba8i =
"highp ivec4 _viv_image_load_iimage_1d_rgba8i(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_iimage_2d_rgba8i(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_int_rgba32i =
"highp ivec4 _viv_image_load_iimage_1d_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, int p)\n"
"{\n"
"   return _viv_image_load_iimage_2d_rgba32i(img_desc, img_desc_1, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_int_r32i =
"highp ivec4 _viv_image_load_iimage_1d_r32i(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_iimage_2d_r32i(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_uint =
"highp uvec4 _viv_image_load_uimage_1d(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_uimage_2d(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_uint_rgba8ui =
"highp uvec4 _viv_image_load_uimage_1d_rgba8ui(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_uimage_2d_rgba8ui(img_desc, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_uint_rgba32ui =
"highp uvec4 _viv_image_load_uimage_1d_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, int p)\n"
"{\n"
"   return _viv_image_load_uimage_2d_rgba32ui(img_desc, img_desc_1, ivec2(p, 0));\n"
"}\n";

gctSTRING gcLibImageLoad_1D_uint_r32ui =
"highp uvec4 _viv_image_load_uimage_1d_r32ui(highp uvec4 img_desc, int p)\n"
"{\n"
"   return _viv_image_load_uimage_2d_r32ui(img_desc, ivec2(p, 0));\n"
"}\n";

/* CubeArray */
gctSTRING gcLibImageLoad_CubeArray =
"highp uvec4 _viv_image_load_uimage_cube_array_rgba8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_cube_array_rgba8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba8i(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_cube_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_cube_array_rgba8(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_cube_array_rgba8_snorm(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8_snorm(img_desc, p);\n"
"}\n"
"highp vec4 _viv_image_load_image_cube_array_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba32f(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_image_cube_array_r32f(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_r32f(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_cube_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_cube_array_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba32i(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_iimage_cube_array_r32i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_r32i(img_desc, p);\n"
"}\n"
"highp uvec4 _viv_image_load_uimage_cube_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint(img_desc, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_uimage_cube_array_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_uimage_cube_array_r32ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_r32ui(img_desc, p);\n"
"}\n";

/****************************imageLoad for a buffer image****************************/
gctSTRING gcLibImageLoad_Buffer_float =
"highp vec4 _viv_image_load_imageBuffer(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:FLOAT16>, address, 0);\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_float_rgba8 =
"highp vec4 _viv_image_load_imageBuffer_rgba8(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec4 raw = _viv_image_load_uimageBuffer_rgba8ui(img_desc, coord);\n"
"   result = vec4(raw) / 255.0;\n"
"   if (raw.x == 255u)\n"
"       result.x = 1.0;\n"
"   if (raw.y == 255u)\n"
"       result.y = 1.0;\n"
"   if (raw.z == 255u)\n"
"       result.z = 1.0;\n"
"   if (raw.w == 255u)\n"
"       result.w = 1.0;\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_float_rg8 =
"highp vec4 _viv_image_load_imageBuffer_rg8(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec4 raw = _viv_image_load_uimageBuffer_rg8ui(img_desc, coord);\n"
"   result = vec4(raw) / 255.0;\n"
"   if (raw.x == 255u)\n"
"       result.x = 1.0;\n"
"   if (raw.y == 255u)\n"
"       result.y = 1.0;\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_float_r8 =
"highp vec4 _viv_image_load_imageBuffer_r8(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec4 raw = _viv_image_load_uimageBuffer_r8ui(img_desc, coord);\n"
"   result = vec4(raw) / 255.0;\n"
"   if (raw.x == 255u)\n"
"       result.x = 1.0;\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_float_rgba8_snorm =
"highp vec4 _viv_image_load_imageBuffer_rgba8_snorm(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec4 raw = _viv_image_load_iimageBuffer_rgba8i(img_desc, coord);\n"
"   result = vec4(raw) / 127.0;\n"
"   if (abs(raw.x) == 127)\n"
"       result.x = sign(result.x);\n"
"   if (abs(raw.y) == 127)\n"
"       result.y = sign(result.y);\n"
"   if (abs(raw.z) == 127)\n"
"       result.z = sign(result.z);\n"
"   if (abs(raw.w) == 127)\n"
"       result.w = sign(result.w);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_float_rg8_snorm =
"highp vec4 _viv_image_load_imageBuffer_rg8_snorm(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec4 raw = _viv_image_load_iimageBuffer_rg8i(img_desc, coord);\n"
"   result = vec4(raw) / 127.0;\n"
"   if (abs(raw.x) == 127)\n"
"       result.x = sign(result.x);\n"
"   if (abs(raw.y) == 127)\n"
"       result.y = sign(result.y);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_float_r8_snorm =
"highp vec4 _viv_image_load_imageBuffer_r8_snorm(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec4 raw = _viv_image_load_iimageBuffer_r8i(img_desc, coord);\n"
"   result = vec4(raw) / 127.0;\n"
"   if (abs(raw.x) == 127)\n"
"       result.x = sign(result.x);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_float_rgba32f =
"highp vec4 _viv_image_load_imageBuffer_rgba32f(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp vec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:FLOAT>, address, 0);\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_float_r32f =
"highp vec4 _viv_image_load_imageBuffer_r32f(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       highp float temp;\n"
"       _viv_asm(LOAD, temp!<f:FLOAT>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0.0;\n"
"       raw.z = 0.0;\n"
"       raw.w = 1.0;\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_int =
"highp ivec4 _viv_image_load_iimageBuffer(highp uvec4 img_desc, int coord)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT16>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_int_rgba8i =
"highp ivec4 _viv_image_load_iimageBuffer_rgba8i(highp uvec4 img_desc, int coord)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_int_rg8i =
"highp ivec4 _viv_image_load_iimageBuffer_rg8i(highp uvec4 img_desc, int coord)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec2 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, ivec4(raw, 0, 0));\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_int_r8i =
"highp ivec4 _viv_image_load_iimageBuffer_r8i(highp uvec4 img_desc, int coord)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp int raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, ivec4(raw, 0, 0, 0));\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_int_rgba32i =
"highp ivec4 _viv_image_load_iimageBuffer_rgba32i(highp uvec4 img_desc, int coord)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_int_r32i =
"highp ivec4 _viv_image_load_iimageBuffer_r32i(highp uvec4 img_desc, int coord)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       highp int temp;\n"
"       _viv_asm(LOAD, temp!<f:INT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0;\n"
"       raw.z = 0;\n"
"       raw.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_uint =
"highp uvec4 _viv_image_load_uimageBuffer(highp uvec4 img_desc, int coord)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT16>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_uint_rgba8ui =
"highp uvec4 _viv_image_load_uimageBuffer_rgba8ui(highp uvec4 img_desc, int coord)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_uint_rg8ui =
"highp uvec4 _viv_image_load_uimageBuffer_rg8ui(highp uvec4 img_desc, int coord)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec2 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, uvec4(raw, 0, 0));\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_uint_r8ui =
"highp uvec4 _viv_image_load_uimageBuffer_r8ui(highp uvec4 img_desc, int coord)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uint raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, uvec4(raw, 0u, 0u, 0u));\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_uint_rgba32ui =
"highp uvec4 _viv_image_load_uimageBuffer_rgba32ui(highp uvec4 img_desc, int coord)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_uint_r32ui =
"highp uvec4 _viv_image_load_uimageBuffer_r32ui(highp uvec4 img_desc, int coord)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       highp uint temp;\n"
"       _viv_asm(LOAD, temp!<f:UINT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0u;\n"
"       raw.z = 0u;\n"
"       raw.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

/* gc7000 image instruction implmentation, in which HW support image instruction */
/* imageLoad for image1D. */
gctSTRING gcLibImageLoad_1D_float_hati4 =
"highp vec4 _viv_image_load_image_1d(highp uvec4 img_desc, int p)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    _viv_asm(IMAGE_RD, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_1D_float_1_hati4 =
"highp vec4 _viv_image_load_image_1d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, int p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    _viv_asm(IMAGE_RD, result1, img_desc, p1);\n"
"    _viv_asm(IMAGE_RD, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_1D_int_hati4 =
"highp ivec4 _viv_image_load_iimage_1d(highp uvec4 img_desc, int p)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    _viv_asm(IMAGE_RD, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_1D_int_1_hati4 =
"highp ivec4 _viv_image_load_iimage_1d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, int p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    _viv_asm(IMAGE_RD, result1, img_desc, p1);\n"
"    _viv_asm(IMAGE_RD, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_1D_uint_hati4 =
"highp uvec4 _viv_image_load_uimage_1d(highp uvec4 img_desc, int p)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    _viv_asm(IMAGE_RD, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_1D_uint_1_hati4 =
"highp uvec4 _viv_image_load_uimage_1d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, int p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    _viv_asm(IMAGE_RD, result1, img_desc, p1);\n"
"    _viv_asm(IMAGE_RD, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

/* imageLoad for image1DArray. */
gctSTRING gcLibImageLoad_1D_array_float_hati4 =
"highp vec4 _viv_image_load_image_1d_array(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_1D_array_float_1_hati4 =
"highp vec4 _viv_image_load_image_1d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w ;\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1.z = int(img_desc_1.x) + p.y * is.w ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_1D_array_int_hati4 =
"highp ivec4 _viv_image_load_iimage_1d_array(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_1D_array_int_1_hati4 =
"highp ivec4 _viv_image_load_iimage_1d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w ;\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1.z = int(img_desc_1.x) + p.y * is.w ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_1D_array_uint_hati4 =
"highp uvec4 _viv_image_load_uimage_1d_array(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_1D_array_uint_1_hati4 =
"highp uvec4 _viv_image_load_uimage_1d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w ;\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1.z = int(img_desc_1.x) + p.y * is.w ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

/* imageLoad for image2D. */
gctSTRING gcLibImageLoad_2D_float_hati4 =
"highp vec4 _viv_image_load_image_2d(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"    highp vec4 result;\n"
"    _viv_asm(IMAGE_RD, result, img_desc, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_float_1_hati4 =
"highp vec4 _viv_image_load_image_2d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    _viv_asm(IMAGE_RD, result1, img_desc, p);\n"
"    _viv_asm(IMAGE_RD, result2, img_desc_1, p);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_hati4 =
"highp ivec4 _viv_image_load_iimage_2d(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    _viv_asm(IMAGE_RD, result, img_desc, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_int_1_hati4 =
"highp ivec4 _viv_image_load_iimage_2d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    _viv_asm(IMAGE_RD, result1, img_desc, p);\n"
"    _viv_asm(IMAGE_RD, result2, img_desc_1, p);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_hati4 =
"highp uvec4 _viv_image_load_uimage_2d(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    _viv_asm(IMAGE_RD, result, img_desc, p);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2D_uint_1_hati4 =
"highp uvec4 _viv_image_load_uimage_2d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    _viv_asm(IMAGE_RD, result1, img_desc, p);\n"
"    _viv_asm(IMAGE_RD, result2, img_desc_1, p);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

/* imageLoad for image3D. */
gctSTRING gcLibImageLoad_3D_float_hati4 =
"highp vec4 _viv_image_load_image_3d(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_3D_float_1_hati4 =
"highp vec4 _viv_image_load_image_3d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_3D_int_hati4 =
"highp ivec4 _viv_image_load_iimage_3d(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_3D_int_1_hati4 =
"highp ivec4 _viv_image_load_iimage_3d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_3D_uint_hati4 =
"highp uvec4 _viv_image_load_uimage_3d(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_3D_uint_1_hati4 =
"highp uvec4 _viv_image_load_uimage_3d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

/* imageLoad for imageCube. */
gctSTRING gcLibImageLoad_cube_float_hati4 =
"highp vec4 _viv_image_load_image_cube(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_cube_float_1_hati4 =
"highp vec4 _viv_image_load_image_cube_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_cube_int_hati4 =
"highp ivec4 _viv_image_load_iimage_cube(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_cube_int_1_hati4 =
"highp ivec4 _viv_image_load_iimage_cube_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_cube_uint_hati4 =
"highp uvec4 _viv_image_load_uimage_cube(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_cube_uint_1_hati4 =
"highp uvec4 _viv_image_load_uimage_cube_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

/* imageLoad for image2DArray. */
gctSTRING gcLibImageLoad_2DArray_float_hati4 =
"highp vec4 _viv_image_load_image_2d_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2DArray_float_1_hati4 =
"highp vec4 _viv_image_load_image_2d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_2DArray_int_hati4 =
"highp ivec4 _viv_image_load_iimage_2d_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2DArray_int_1_hati4 =
"highp ivec4 _viv_image_load_iimage_2d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_2DArray_uint_hati4 =
"highp uvec4 _viv_image_load_uimage_2d_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_2DArray_uint_1_hati4 =
"highp uvec4 _viv_image_load_uimage_2d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

/* imageLoad for imageCubeArray. */
gctSTRING gcLibImageLoad_CubeArray_float_img_access =
"highp vec4 _viv_image_load_image_cube_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_CubeArray_float_1_img_access =
"highp vec4 _viv_image_load_image_cube_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_CubeArray_int_img_access =
"highp ivec4 _viv_image_load_iimage_cube_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_CubeArray_int_1_img_access =
"highp ivec4 _viv_image_load_iimage_cube_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

gctSTRING gcLibImageLoad_CubeArray_uint_img_access =
"highp uvec4 _viv_image_load_uimage_cube_array(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_CubeArray_uint_1_img_access =
"highp uvec4 _viv_image_load_uimage_cube_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

/* imageLoad for imageBuffer. */
gctSTRING gcLibImageLoad_Buffer_float_img_access =
"highp vec4 _viv_image_load_imageBuffer(highp uvec4 img_desc, int p)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_RD, result, img_desc, newCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_int_img_access =
"highp ivec4 _viv_image_load_iimageBuffer(highp uvec4 img_desc, int p)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_RD, result, img_desc, newCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibImageLoad_Buffer_uint_img_access =
"highp uvec4 _viv_image_load_uimageBuffer(highp uvec4 img_desc, int p)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_RD, result, img_desc, newCoord);\n"
"    return result;\n"
"}\n";

/* texelFetch for sampler2D. */
gctSTRING gcLibTexelFetch_Sampler2D =
"highp vec4 _viv_image_fetch_for_sampler_sampler2D(sampler2D sampler, ivec2 p, int lod)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    vec2 fCoord = vec2(vec2(p) / vec2(size.xy));\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler2D(isampler2D sampler, ivec2 p, int lod)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    vec2 fCoord = vec2(vec2(p) / vec2(size.xy));\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler2D(usampler2D sampler, ivec2 p, int lod)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    vec2 fCoord = vec2(vec2(p) / vec2(size.xy));\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp vec4 _viv_image_fetch_for_sampler_sampler2D_offset(sampler2D sampler, ivec2 p, int lod, ivec2 offset)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    vec2 fCoord = vec2(vec2(p + offset) / vec2(size.xy));\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler2D_offset(isampler2D sampler, ivec2 p, int lod, ivec2 offset)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    vec2 fCoord = vec2(vec2(p + offset) / vec2(size.xy));\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler2D_offset(usampler2D sampler, ivec2 p, int lod, ivec2 offset)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    vec2 fCoord = vec2(vec2(p + offset) / vec2(size.xy));\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetch_Sampler2D_halti4 =
"highp vec4 _viv_image_fetch_for_sampler_sampler2D(sampler2D sampler, ivec2 p, int lod)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler2D(isampler2D sampler, ivec2 p, int lod)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler2D(usampler2D sampler, ivec2 p, int lod)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp vec4 _viv_image_fetch_for_sampler_sampler2D_offset(sampler2D sampler, ivec2 p, int lod, ivec2 offset)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec2 newP = p + offset;\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, newP);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler2D_offset(isampler2D sampler, ivec2 p, int lod, ivec2 offset)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec2 newP = p + offset;\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, newP);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler2D_offset(usampler2D sampler, ivec2 p, int lod, ivec2 offset)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec2 newP = p + offset;\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, newP);\n"
"    return result;\n"
"}\n";

/* texelFetch for sampler2DArray. */
gctSTRING gcLibTexelFetch_Sampler2DArray =
"highp vec4 _viv_image_fetch_for_sampler_sampler_2d_array(sampler2DArray sampler, ivec3 p, int lod)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    float arrayLayer = float(p.z);\n"
"    arrayLayer = max(0.0, floor(arrayLayer + 0.5));\n"
"    vec3 fCoord = vec3(vec2(p.xy) / vec2(size.xy), arrayLayer);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler_2d_array(isampler2DArray sampler, ivec3 p, int lod)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    float arrayLayer = float(p.z);\n"
"    arrayLayer = max(0.0, floor(arrayLayer + 0.5));\n"
"    vec3 fCoord = vec3(vec2(p.xy) / vec2(size.x), arrayLayer);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler_2d_array(usampler2DArray sampler, ivec3 p, int lod)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    float arrayLayer = float(p.z);\n"
"    arrayLayer = max(0.0, floor(arrayLayer + 0.5));\n"
"    vec3 fCoord = vec3(vec2(p.xy) / vec2(size.xy), arrayLayer);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp vec4 _viv_image_fetch_for_sampler_sampler_2d_array_offset(sampler2DArray sampler, ivec3 p, int lod, ivec2 offset)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    float arrayLayer = float(p.z);\n"
"    arrayLayer = max(0.0, floor(arrayLayer + 0.5));\n"
"    vec3 fCoord = vec3(vec2(p.xy + offset) / vec2(size.xy), arrayLayer);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler_2d_array_offset(isampler2DArray sampler, ivec3 p, int lod, ivec2 offset)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    float arrayLayer = float(p.z);\n"
"    arrayLayer = max(0.0, floor(arrayLayer + 0.5));\n"
"    vec3 fCoord = vec3(vec2(p.xy + offset) / vec2(size.xy), arrayLayer);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler_2d_array_offset(usampler2DArray sampler, ivec3 p, int lod, ivec2 offset)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xy = size.xy >> newLod;\n"
"    float arrayLayer = float(p.z);\n"
"    arrayLayer = max(0.0, floor(arrayLayer + 0.5));\n"
"    vec3 fCoord = vec3(vec2(p.xy + offset) / vec2(size.xy), arrayLayer);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetch_Sampler2DArray_halti4 =
"highp vec4 _viv_image_fetch_for_sampler_sampler_2d_array(sampler2DArray sampler, ivec3 p, int lod)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    _viv_asm(MAX, p.z, p.z, 0);\n"
"    float fNewLod = float(newLod);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler_2d_array(isampler2DArray sampler, ivec3 p, int lod)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    _viv_asm(MAX, p.z, p.z, 0);\n"
"    float fNewLod = float(newLod);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler_2d_array(usampler2DArray sampler, ivec3 p, int lod)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    _viv_asm(MAX, p.z, p.z, 0);\n"
"    float fNewLod = float(newLod);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp vec4 _viv_image_fetch_for_sampler_sampler_2d_array_offset(sampler2DArray sampler, ivec3 p, int lod, ivec2 offset)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    _viv_asm(MAX, p.z, p.z, 0);\n"
"    float fNewLod = float(newLod);\n"
"    ivec3 newP = p;\n"
"    newP.xy += offset;\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, newP);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler_2d_array_offset(isampler2DArray sampler, ivec3 p, int lod, ivec2 offset)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    _viv_asm(MAX, p.z, p.z, 0);\n"
"    float fNewLod = float(newLod);\n"
"    ivec3 newP = p;\n"
"    newP.xy += offset;\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, newP);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler_2d_array_offset(usampler2DArray sampler, ivec3 p, int lod, ivec2 offset)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    _viv_asm(MAX, p.z, p.z, 0);\n"
"    float fNewLod = float(newLod);\n"
"    ivec3 newP = p;\n"
"    newP.xy += offset;\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, newP);\n"
"    return result;\n"
"}\n";

/* texelFetch for sampler2DMS. */
gctSTRING gcLibTexelFetch_Sampler2DMS_halti4 =
"highp vec4 _viv_image_fetch_for_sampler_sampler_2d_ms(sampler2DMS sampler, ivec2 p, int sampleIndex)\n"
"{\n"
"    highp vec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler_2d_ms(isampler2DMS sampler, ivec2 p, int sampleIndex)\n"
"{\n"
"    highp ivec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler_2d_ms(usampler2DMS sampler, ivec2 p, int sampleIndex)\n"
"{\n"
"    highp uvec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* texelFetch for sampler2DMSArray. */
gctSTRING gcLibTexelFetch_Sampler2DMSArray_halti4 =
"highp vec4 _viv_image_fetch_for_sampler_sampler_2d_ms_array(sampler2DMSArray sampler, ivec3 p, int sampleIndex)\n"
"{\n"
"    highp vec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler_2d_ms_array(isampler2DMSArray sampler, ivec3 p, int sampleIndex)\n"
"{\n"
"    highp ivec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler_2d_ms_array(usampler2DMSArray sampler, ivec3 p, int sampleIndex)\n"
"{\n"
"    highp uvec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* texelFetch for sampler3D. */
gctSTRING gcLibTexelFetch_Sampler3D =
"highp vec4 _viv_image_fetch_for_sampler_sampler3D(sampler3D sampler, ivec3 p, int lod)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xyz = size.xyz >> newLod;\n"
"    vec3 fCoord = vec3(p) / vec3(size);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler3D(isampler3D sampler, ivec3 p, int lod)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xyz = size.xyz >> newLod;\n"
"    vec3 fCoord = vec3(p) / vec3(size);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler3D(usampler3D sampler, ivec3 p, int lod)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xyz = size.xyz >> newLod;\n"
"    vec3 fCoord = vec3(p) / vec3(size);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp vec4 _viv_image_fetch_for_sampler_sampler3D_offset(sampler3D sampler, ivec3 p, int lod, ivec3 offset)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xyz = size.xyz >> newLod;\n"
"    vec3 fCoord = vec3(p + offset) / vec3(size);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler3D_offset(isampler3D sampler, ivec3 p, int lod, ivec3 offset)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xyz = size.xyz >> newLod;\n"
"    vec3 fCoord = vec3(p + offset) / vec3(size);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler3D_offset(usampler3D sampler, ivec3 p, int lod, ivec3 offset)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    size = max(size, 1);\n"
"    size.xyz = size.xyz >> newLod;\n"
"    vec3 fCoord = vec3(p + offset) / vec3(size);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetch_Sampler3D_halti4 =
"highp vec4 _viv_image_fetch_for_sampler_sampler3D(sampler3D sampler, ivec3 p, int lod)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler3D(isampler3D sampler, ivec3 p, int lod)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler3D(usampler3D sampler, ivec3 p, int lod)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, p);\n"
"    return result;\n"
"}\n"
"highp vec4 _viv_image_fetch_for_sampler_sampler3D_offset(sampler3D sampler, ivec3 p, int lod, ivec3 offset)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec3 newP = p + offset;\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, newP);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isampler3D_offset(isampler3D sampler, ivec3 p, int lod, ivec3 offset)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec3 newP = p + offset;\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, newP);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usampler3D_offset(usampler3D sampler, ivec3 p, int lod, ivec3 offset)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec4 lmm;\n"
"    int newLod;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(MAX, newLod, lod, lmm.x);\n"
"    _viv_asm(MIN, newLod, newLod, lmm.y);\n"
"    float fNewLod = float(newLod);\n"
"    ivec3 newP = p + offset;\n"
"    _viv_asm(TEXLOD, result, sampler, fNewLod);\n"
"    _viv_asm(TEXLD_U, result, sampler, newP);\n"
"    return result;\n"
"}\n";

/* texelFetch for samplerBuffer. */
gctSTRING gcLibTexelFetch_SamplerBuffer =
"highp vec4 _viv_image_fetch_for_sampler_samplerBuffer(samplerBuffer sampler, int p)\n"
"{\n"
"    highp vec4 result;\n"
"    mediump ivec4 size;\n"
"    ivec2 newCoord;\n"
"    vec2 fCoord;\n"
"    int height;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    if (size.x > MAX_TEXTURE_BUFFER_SIZE)\n"
"    {\n"
"       height = int(ceil(float(size.x)/float(MAX_TEXTURE_BUFFER_SIZE)));\n"
"       newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"       fCoord = vec2(float(newCoord.x)/float(MAX_TEXTURE_BUFFER_SIZE), float(newCoord.y)/float(height));\n"
"    }\n"
"    else\n"
"    {\n"
"       newCoord = ivec2(p%size.x, p/size.x);\n"
"       fCoord = vec2(float(newCoord.x)/float(size.x), float(newCoord.y)/float(size.y));\n"
"    }\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isamplerBuffer(isamplerBuffer sampler, int p)\n"
"{\n"
"    highp ivec4 result;\n"
"    mediump ivec4 size;\n"
"    ivec2 newCoord;\n"
"    vec2 fCoord;\n"
"    int height;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    if (size.x > MAX_TEXTURE_BUFFER_SIZE)\n"
"    {\n"
"       height = int(ceil(float(size.x)/float(MAX_TEXTURE_BUFFER_SIZE)));\n"
"       newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"       fCoord = vec2(float(newCoord.x)/float(MAX_TEXTURE_BUFFER_SIZE), float(newCoord.y)/float(height));\n"
"    }\n"
"    else\n"
"    {\n"
"       newCoord = ivec2(p%size.x, p/size.x);\n"
"       fCoord = vec2(float(newCoord.x)/float(size.x), float(newCoord.y)/float(size.y));\n"
"    }\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usamplerBuffer(usamplerBuffer sampler, int p)\n"
"{\n"
"    highp uvec4 result;\n"
"    mediump ivec4 size;\n"
"    ivec2 newCoord;\n"
"    vec2 fCoord;\n"
"    int height;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    if (size.x > MAX_TEXTURE_BUFFER_SIZE)\n"
"    {\n"
"       height = int(ceil(float(size.x)/float(MAX_TEXTURE_BUFFER_SIZE)));\n"
"       newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"       fCoord = vec2(float(newCoord.x)/float(MAX_TEXTURE_BUFFER_SIZE), float(newCoord.y)/float(height));\n"
"    }\n"
"    else\n"
"    {\n"
"       newCoord = ivec2(p%size.x, p/size.x);\n"
"       fCoord = vec2(float(newCoord.x)/float(size.x), float(newCoord.y)/float(size.y));\n"
"    }\n"
"    _viv_asm(TEXLD, result, sampler, fCoord);\n"
"    return result;\n"
"}\n";

gctSTRING gcLibTexelFetch_SamplerBuffer_halti4 =
"highp vec4 _viv_image_fetch_for_sampler_samplerBuffer(samplerBuffer sampler, int p)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(TEXLD_U, result, sampler, newCoord);\n"
"    return result;\n"
"}\n"
"highp ivec4 _viv_image_fetch_for_sampler_isamplerBuffer(isamplerBuffer sampler, int p)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(TEXLD_U, result, sampler, newCoord);\n"
"    return result;\n"
"}\n"
"highp uvec4 _viv_image_fetch_for_sampler_usamplerBuffer(usamplerBuffer sampler, int p)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(TEXLD_U, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

/* getLod. */
gctSTRING gcLibGetLod =
"highp vec2 _viv_calculate_lod(ivec4 size, ivec4 lmm, vec3 coord)\n"
"{\n"
"    float lambda_prime, clampResult;\n"
"    vec3 temp1, temp2, temp3;\n"
"    temp1 = dFdx(coord);\n"
"    temp2 = dFdy(coord);\n"
"    temp3 = vec3(size.xyz);\n"
"    temp1 = temp1 * temp3;\n"
"    temp2 = temp2 * temp3;\n"
"    temp1.x = length(temp1);\n"
"    temp2.x = length(temp2);\n"
"    lambda_prime = max(log2(temp1.x), log2(temp2.x));\n"
"    {\n"
"       clampResult = max(lambda_prime, float(lmm.x));\n"
"       clampResult = min(clampResult, float(lmm.y));\n"
"       clampResult = max(clampResult, 0.0);\n"
"       clampResult = ceil(clampResult + 0.5) - 1.0;\n"
"    }\n"
"    return vec2(clampResult, lambda_prime);\n"
"}\n"
"highp vec2 _viv_image_query_lod_1d(sampler2D sampler, float coord)\n"
"{\n"
"    ivec4 size;\n"
"    ivec4 lmm;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    return _viv_calculate_lod(size, lmm, vec3(coord, 0.0, 0.0));\n"
"}\n"
"highp vec2 _viv_image_query_lod_2d(sampler2D sampler, vec2 coord)\n"
"{\n"
"    ivec4 size;\n"
"    ivec4 lmm;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    return _viv_calculate_lod(size, lmm, vec3(coord, 0.0));\n"
"}\n"
"highp vec2 _viv_image_query_lod_3d(sampler3D sampler, vec3 coord)\n"
"{\n"
"    ivec4 size;\n"
"    ivec4 lmm;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    return _viv_calculate_lod(size, lmm, coord);\n"
"}\n"
"highp vec2 _viv_image_query_lod_cube(sampler2D sampler, vec3 coord)\n"
"{\n"
"    ivec4 size;\n"
"    ivec4 lmm;\n"
"    _viv_asm(GET_SAMPLER_LMM, lmm, sampler);\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    float maxCoord;\n"
"    int face;\n"
"    vec3 absCoord = abs(coord);\n"
"    vec2 orgST, orgUV;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (coord.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(coord.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (coord.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(coord.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (coord.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(coord.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (coord.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(coord.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, 1.0);\n"
"    return _viv_calculate_lod(size, lmm, vec3(orgUV, 0.0));\n"
"}\n";

/* imageStore gc3000/5000 implementation where HW does not support image_wr */
/* imageStore for image2D. */
gctSTRING gcLibImageStore_2D_float_rgba32f =
"void _viv_image_store_image_2d_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, vec4 data)\n"
"{\n"
"   vec2 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.xy);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.zw);\n"
"   }\n"
"}\n";

/* format rgba16f */
gctSTRING gcLibImageStore_2D_float =
"void _viv_image_store_image_2d(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT16>, address, data);\n"
"   }\n"
"}\n";

/* format rg32f */
gctSTRING gcLibImageStore_2D_float_rg32f =
"void _viv_image_store_image_2d_rg32f(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   vec2 result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.xy);\n"
"       data.z = 0.0;\n"
"       data.w = 1.0;\n"
"   }\n"
"}\n";

/* format rg16f */
gctSTRING gcLibImageStore_2D_float_rg16f =
"void _viv_image_store_image_2d_rg16f(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   vec2 result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT16>, address, data.xy);\n"
"       data.z = 0.0;\n"
"       data.w = 1.0;\n"
"   }\n"
"}\n";

/* format r16f */
gctSTRING gcLibImageStore_2D_float_r16f =
"void _viv_image_store_image_2d_r16f(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT16>, address, data.x);\n"
"   }\n"
"}\n";

/* format r32f */
gctSTRING gcLibImageStore_2D_float_r32f =
"void _viv_image_store_image_2d_r32f(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.x);\n"
"   }\n"
"}\n";

/* format r5g6b5 */
gctSTRING gcLibImageStore_2D_float_r5g6b5_unorm_pack16 =
"void _viv_image_store_image_2d_r5g6b5_unorm_pack16(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 temp = uvec4(0u);\n"
"       temp.x = uint(data.x * 31.0);\n"
"       temp.y = uint(data.y * 63.0);\n"
"       temp.z = uint(data.z * 31.0);\n"
"       temp.w = (temp.x << 11) | (temp.y << 5) | temp.z;\n"
"       _viv_asm(STORE1, result!<f:UINT16>, address, temp.w);\n"
"   }\n"
"}\n";

/* format abgr8 */
gctSTRING gcLibImageStore_2D_float_abgr8_unorm_pack32 =
"void _viv_image_store_image_2d_abgr8_unorm_pack32(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 temp = uvec4(0u);\n"
"       temp.x = uint(data.x * 255.0);\n"
"       temp.y = uint(data.y * 255.0);\n"
"       temp.z = uint(data.z * 255.0);\n"
"       temp.w = uint(data.w * 255.0);\n"
"       temp.x = (temp.x) | (temp.y << 8) | (temp.z << 16) | (temp.w << 24);\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, temp.x);\n"
"   }\n"
"}\n";

/* format abgr8 */
gctSTRING gcLibImageStore_2D_float_a2r10g10b10_unorm_pack32 =
"void _viv_image_store_image_2d_a2r10g10b10_unorm_pack32(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 temp = uvec4(0u);\n"
"       temp.x = uint(data.x * 1023.0);\n"
"       temp.y = uint(data.y * 1023.0);\n"
"       temp.z = uint(data.z * 1023.0);\n"
"       temp.w = uint(data.w * 3.0);\n"
"       temp.x = (temp.x) | (temp.y << 10) | (temp.z << 20) | (temp.w << 30);\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, temp.x);\n"
"   }\n"
"}\n";

/* format abgr8_ui */
gctSTRING gcLibImageStore_2D_uint_abgr8ui_pack32 =
"void _viv_image_store_uimage_2d_abgr8ui_pack32(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uint result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uint temp = 0u;\n"
"       temp = (data.x) | (data.y << 8) | (data.z << 16) | (data.w << 24);\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, temp);\n"
"   }\n"
"}\n";

/* format abgr8_i */
gctSTRING gcLibImageStore_2D_int_abgr8i_pack32 =
"void _viv_image_store_iimage_2d_abgr8i_pack32(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   int result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       int temp = 0;\n"
"       temp = (data.x) | (data.y << 8) | (data.z << 16) | (data.w << 24);\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, temp);\n"
"   }\n"
"}\n";

/* format rgba8
   since driver treats rgba8 as bgra8, we need _viv_image_store_swizzle to
   get the correct data to write */
gctSTRING gcLibImageStore_2D_float_rgba8 =
"void _viv_image_store_image_2d_rgba8(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 data1 = uvec4(clamp(data, 0.0, 1.0) * 255.5);\n"
"       uvec4 data2 = _viv_image_store_swizzle_uint(img_desc, data1);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data2);\n"
"   }\n"
"}\n";

gctSTRING gcLibImageStore_2D_float_rg8 =
"void _viv_image_store_image_2d_rg8(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   vec2 result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 data1 = uvec4(clamp(data, 0.0, 1.0) * 255.5);\n"
"       uvec4 data2 = _viv_image_store_swizzle_uint(img_desc, data1);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data2.xy);\n"
"   }\n"
"}\n";

gctSTRING gcLibImageStore_2D_float_r8 =
"void _viv_image_store_image_2d_r8(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 data1 = uvec4(clamp(data, 0.0, 1.0) * 255.5);\n"
"       uvec4 data2 = _viv_image_store_swizzle_uint(img_desc, data1);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data2.x);\n"
"   }\n"
"}\n";

/* format rgba8_snorm */
gctSTRING gcLibImageStore_2D_float_rgba8_snorm =
"void _viv_image_store_image_2d_rgba8_snorm(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 data1 = ivec4(clamp(data, -1.0, 1.0) * 127.5);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data1);\n"
"   }\n"
"}\n";

/* format rg8_snorm */
gctSTRING gcLibImageStore_2D_float_rg8_snorm =
"void _viv_image_store_image_2d_rg8_snorm(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   vec2 result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 data1 = ivec4(clamp(data, -1.0, 1.0) * 127.5);\n"
"       ivec4 data2 = _viv_image_store_swizzle_int(img_desc, data1);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data2.xy);\n"
"   }\n"
"}\n";

/* format r8_snorm */
gctSTRING gcLibImageStore_2D_float_r8_snorm =
"void _viv_image_store_image_2d_r8_snorm(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 data1 = ivec4(clamp(data, -1.0, 1.0) * 127.5);\n"
"       ivec4 data2 = _viv_image_store_swizzle_int(img_desc, data1);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data2.x);\n"
"   }\n"
"}\n";

/* format rgba32i */
gctSTRING gcLibImageStore_2D_int_rgba32i =
"void _viv_image_store_iimage_2d_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, ivec4 data)\n"
"{\n"
"   ivec2 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.xy);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.zw);\n"
"   }\n"
"}\n";

/* format rg16i */
gctSTRING gcLibImageStore_2D_int_rg16i =
"void _viv_image_store_iimage_2d_rg16i(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   ivec2 result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT16>, address, data.xy);\n"
"   }\n"
"}\n";

/* format r16i */
gctSTRING gcLibImageStore_2D_int_r16i =
"void _viv_image_store_iimage_2d_r16i(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   int result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT16>, address, data.x);\n"
"   }\n"
"}\n";

/* format rgba16i */
gctSTRING gcLibImageStore_2D_int =
"void _viv_image_store_iimage_2d(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT16>, address, data);\n"
"   }\n"
"}\n";

/* format rgba8i */
gctSTRING gcLibImageStore_2D_int_rgba8i =
"void _viv_image_store_iimage_2d_rgba8i(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 val = _viv_image_store_swizzle_int(img_desc_u, data);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, val);\n"
"   }\n"
"}\n";

/* format rg8i */
gctSTRING gcLibImageStore_2D_int_rg8i =
"void _viv_image_store_iimage_2d_rg8i(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   ivec2 result;\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 val = _viv_image_store_swizzle_int(img_desc_u, data);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, val.xy);\n"
"   }\n"
"}\n";

/* format r8i */
gctSTRING gcLibImageStore_2D_int_r8i =
"void _viv_image_store_iimage_2d_r8i(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 val = _viv_image_store_swizzle_int(img_desc_u, data);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, val.x);\n"
"   }\n"
"}\n";

/* format r32i */
gctSTRING gcLibImageStore_2D_int_r32i =
"void _viv_image_store_iimage_2d_r32i(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   int result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.x);\n"
"   }\n"
"}\n";

/* format rg32i */
gctSTRING gcLibImageStore_2D_int_rg32i =
"void _viv_image_store_iimage_2d_rg32i(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   int result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.xy);\n"
"   }\n"
"}\n";

/* format rgba32ui */
gctSTRING gcLibImageStore_2D_uint_rgba32ui =
"void _viv_image_store_uimage_2d_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, uvec4 data)\n"
"{\n"
"   uvec2 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.xy);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.zw);\n"
"   }\n"
"}\n";

/* format rgba16ui */
gctSTRING gcLibImageStore_2D_uint =
"void _viv_image_store_uimage_2d(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT16>, address, data);\n"
"   }\n"
"}\n";

/* format rgba8ui */
gctSTRING gcLibImageStore_2D_uint_rgba8ui =
"void _viv_image_store_uimage_2d_rgba8ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 val = _viv_image_store_swizzle_uint(img_desc, data);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, val);\n"
"   }\n"
"}\n";

/* format rg8ui */
gctSTRING gcLibImageStore_2D_uint_rg8ui =
"void _viv_image_store_uimage_2d_rg8ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uvec2 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 val = _viv_image_store_swizzle_uint(img_desc, data);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, val.xy);\n"
"   }\n"
"}\n";

/* format r8ui */
gctSTRING gcLibImageStore_2D_uint_r8ui =
"void _viv_image_store_uimage_2d_r8ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 val = _viv_image_store_swizzle_uint(img_desc, data);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, val.x);\n"
"   }\n"
"}\n";

/* format rg16ui */
gctSTRING gcLibImageStore_2D_uint_rg16ui =
"void _viv_image_store_uimage_2d_rg16ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uvec2 result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT16>, address, data.xy);\n"
"   }\n"
"}\n";

/* format r16ui */
gctSTRING gcLibImageStore_2D_uint_r16ui =
"void _viv_image_store_uimage_2d_r16ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uint result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT16>, address, data.x);\n"
"   }\n"
"}\n";

/* format rg32ui */
gctSTRING gcLibImageStore_2D_uint_rg32ui =
"void _viv_image_store_uimage_2d_rg32ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uvec2 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.xy);\n"
"   }\n"
"}\n";

/* format r32ui */
gctSTRING gcLibImageStore_2D_uint_r32ui =
"void _viv_image_store_uimage_2d_r32ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uint result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.x);\n"
"   }\n"
"}\n";

/* imageStore for image1D. */
gctSTRING gcLibImageStore_1D_float_rgba32f =
"void _viv_image_store_image_1d_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, int p, vec4 data)\n"
"{\n"
"   _viv_image_store_image_2d_rgba32f(img_desc, img_desc_1, ivec2(p, 0), data);\n"
"}\n";

/* format rgba16f */
gctSTRING gcLibImageStore_1D_float =
"void _viv_image_store_image_1d(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"   _viv_image_store_image_2d(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format r32f */
gctSTRING gcLibImageStore_1D_float_r32f =
"void _viv_image_store_image_1d_r32f(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"   _viv_image_store_image_2d_r32f(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format r32i */
gctSTRING gcLibImageStore_1D_float_r32i =
"void _viv_image_store_image_1d_r32i(highp uvec4 img_desc, int p, ivec4 data)\n"
"{\n"
"   _viv_image_store_iimage_2d_r32i(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format r32ui */
gctSTRING gcLibImageStore_1D_float_r32ui =
"void _viv_image_store_image_1d_r32ui(highp uvec4 img_desc, int p, uvec4 data)\n"
"{\n"
"   _viv_image_store_uimage_2d_r32ui(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format rgba8
   since driver treats rgba8 as bgra8, we need _viv_image_store_swizzle to
   get the correct data to write */
gctSTRING gcLibImageStore_1D_float_rgba8 =
"void _viv_image_store_image_1d_rgba8(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"   _viv_image_store_image_2d_rgba8(img_desc, ivec2(p, 0), data);\n"
"}\n";

gctSTRING gcLibImageStore_1D_float_rg8 =
"void _viv_image_store_image_1d_rg8(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"   _viv_image_store_image_2d_rg8(img_desc, ivec2(p, 0), data);\n"
"}\n";

gctSTRING gcLibImageStore_1D_float_r8 =
"void _viv_image_store_image_1d_r8(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"   _viv_image_store_image_2d_r8(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format rgba8_snorm */
gctSTRING gcLibImageStore_1D_float_rgba8_snorm =
"void _viv_image_store_image_1d_rgba8_snorm(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"   _viv_image_store_image_2d_rgba8_snorm(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format rg8_snorm */
gctSTRING gcLibImageStore_1D_float_rg8_snorm =
"void _viv_image_store_image_1d_rg8_snorm(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"   _viv_image_store_image_2d_rg8_snorm(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format r8_snorm */
gctSTRING gcLibImageStore_1D_float_r8_snorm =
"void _viv_image_store_image_1d_r8_snorm(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"   _viv_image_store_image_2d_r8_snorm(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format rgba32i */
gctSTRING gcLibImageStore_1D_int_rgba32i =
"void _viv_image_store_iimage_1d_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, int p, ivec4 data)\n"
"{\n"
"   _viv_image_store_iimage_2d_rgba32i(img_desc, img_desc_1, ivec2(p, 0), data);\n"
"}\n";

/* format rgba16i */
gctSTRING gcLibImageStore_1D_int =
"void _viv_image_store_iimage_1d(highp uvec4 img_desc, int p, ivec4 data)\n"
"{\n"
"   _viv_image_store_iimage_2d(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format rgba8i */
gctSTRING gcLibImageStore_1D_int_rgba8i =
"void _viv_image_store_iimage_1d_rgba8i(highp uvec4 img_desc, int p, ivec4 data)\n"
"{\n"
"   _viv_image_store_iimage_2d_rgba8i(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format r32i */
gctSTRING gcLibImageStore_1D_int_r32i =
"void _viv_image_store_iimage_1d_r32i(highp uvec4 img_desc, int p, ivec4 data)\n"
"{\n"
"   _viv_image_store_iimage_2d_r32i(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format rgba32ui */
gctSTRING gcLibImageStore_1D_uint_rgba32ui =
"void _viv_image_store_uimage_1d_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, int p, uvec4 data)\n"
"{\n"
"   _viv_image_store_uimage_2d_rgba32ui(img_desc, img_desc_1, ivec2(p, 0), data);\n"
"}\n";

/* format rgba16ui */
gctSTRING gcLibImageStore_1D_uint =
"void _viv_image_store_uimage_1d(highp uvec4 img_desc, int p, uvec4 data)\n"
"{\n"
"   _viv_image_store_uimage_2d(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format rgba8ui */
gctSTRING gcLibImageStore_1D_uint_rgba8ui =
"void _viv_image_store_uimage_1d_rgba8ui(highp uvec4 img_desc, int p, uvec4 data)\n"
"{\n"
"   _viv_image_store_uimage_2d_rgba8ui(img_desc, ivec2(p, 0), data);\n"
"}\n";

/* format r32ui */
gctSTRING gcLibImageStore_1D_uint_r32ui =
"void _viv_image_store_uimage_1d_r32ui(highp uvec4 img_desc, int p, uvec4 data)\n"
"{\n"
"   _viv_image_store_uimage_2d_r32ui(img_desc, ivec2(p, 0), data);\n"
"}\n";


/* 3D/cube/2DArray image store */
gctSTRING gcLibImageStore_3Dcommon =
"void _viv_image_store_3Dcommon_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"   vec2 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.xy);\n"
"   }\n"
"   p1 = p;\n"
"   p1.z = int(img_desc_1.x) + p.z * int(is) ;\n"
"   addrRet = _viv_image_computeImgAddr3D(img_desc_1, p1);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.zw);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_float(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT16>, address, data);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_float_r32f(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   float result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc_u, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.x);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_float_rgba8(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc_u, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 data1 = uvec4(clamp(data, 0.0, 1.0) * 255.5);\n"
"       uvec4 data2 = _viv_image_store_swizzle_uint(img_desc_u, data1);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data2);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 data1 = ivec4(clamp(data, -1.0, 1.0) * 127.5);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data1);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"   ivec2 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.xy);\n"
"   }\n"
"   p1 = p;\n"
"   p1.z = int(img_desc_1.x) + p.z * int(is) ;\n"
"   addrRet = _viv_image_computeImgAddr3D(img_desc_1, p1);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.zw);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_int(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT16>, address, data);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_int_rgba8i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc_u, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 val = _viv_image_store_swizzle_int(img_desc_u, data);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, val);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_int_r32i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   int result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.x);\n"
"   }\n"
"}\n"
"void _viv_image_store_3Dcommon_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"   uvec2 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.xy);\n"
"   }\n"
"   p1 = p;\n"
"   p1.z = int(img_desc_1.x) + p.z * int(is);\n"
"   addrRet = _viv_image_computeImgAddr3D(img_desc_1, p1);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.zw);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_uint(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT16>, address, data);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_uint_rgba8ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 val = _viv_image_store_swizzle_uint(img_desc, data);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, val);\n"
"   }\n"
"}\n"
"void _viv_image_store_3Dcommon_uint_r32ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   uint result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr3D(img_desc, p1);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.x);\n"
"   }\n"
"}\n";

gctSTRING gcLibImageStore_3D =
"void _viv_image_store_image_3d_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba32f(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_3d(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_3d_r32f(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_r32f(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_3d_rgba8(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_3d_rgba8_snorm(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8_snorm(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_3d_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba32i(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_3d(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_3d_rgba8i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba8i(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_3d_r32i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_r32i(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_uimage_3d_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_uimage_3d(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_uimage_3d_rgba8ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba8ui(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_uimage_3d_r32ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_r32ui(img_desc, p, data);\n"
"}\n";

/* cube */
gctSTRING gcLibImageStore_cube =
"void _viv_image_store_image_cube_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba32f(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_cube(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_cube_r32f(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_r32f(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_cube_rgba8(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_cube_rgba8_snorm(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8_snorm(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_cube_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba32i(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_cube(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_cube_rgba8i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba8i(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_cube_r32i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_r32i(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_uimage_cube_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_uimage_cube(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_uimage_cube_rgba8ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba8ui(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_uimage_cube_r32ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_r32ui(img_desc, p, data);\n"
"}\n";

/* 1DArray */
gctSTRING gcLibImageStore_1DArray =
"void _viv_image_store_image_1d_array_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba32f(img_desc, img_desc_1, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"\n"
"void _viv_image_store_image_1d_array(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float(img_desc, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"\n"
"void _viv_image_store_image_1d_array_r32f(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_r32f(img_desc, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"\n"
"void _viv_image_store_image_1d_array_rgba8(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8(img_desc, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"\n"
"void _viv_image_store_image_1d_array_rgba8_snorm(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8_snorm(img_desc, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_1d_array_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba32i(img_desc, img_desc_1, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_1d_array(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int(img_desc, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_1d_array_rgba8i(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba8i(img_desc, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_1d_array_r32i(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_r32i(img_desc, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"void _viv_image_store_uimage_1d_array_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"\n"
"void _viv_image_store_uimage_1d_array(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint(img_desc, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"\n"
"void _viv_image_store_uimage_1d_array_rgba8ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba8ui(img_desc, ivec3(p.x, 0, p.y), data);\n"
"}\n"
"void _viv_image_store_uimage_1d_array_r32ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_r32ui(img_desc, ivec3(p.x, 0, p.y), data);\n"
"}\n";

/* 2DArray */
gctSTRING gcLibImageStore_2DArray =
"void _viv_image_store_image_2d_array_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba32f(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_2d_array(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_2d_array_r32f(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_r32f(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_2d_array_rgba8(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_2d_array_rgba8_snorm(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8_snorm(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_2d_array_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba32i(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_2d_array(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_2d_array_rgba8i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba8i(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_2d_array_r32i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_r32i(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_uimage_2d_array_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_uimage_2d_array(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_uimage_2d_array_rgba8ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba8ui(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_uimage_2d_array_r32ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_r32ui(img_desc, p, data);\n"
"}\n";

gctSTRING gcLibImageStore_CubeArray =
"void _viv_image_store_image_cube_array_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba32f(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_cube_array(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_cube_array_r32f(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_r32f(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_cube_array_rgba8(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_image_cube_array_rgba8_snorm(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8_snorm(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_cube_array_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba32i(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_cube_array(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_cube_array_rgba8i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba8i(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_iimage_cube_array_r32i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_r32i(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_uimage_cube_array_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_uimage_cube_array(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_uimage_cube_array_rgba8ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba8ui(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_uimage_cube_array_r32ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_r32ui(img_desc, p, data);\n"
"}\n";

gctSTRING gcLibImageStore_Buffer_float_rgba32f =
"void _viv_image_store_imageBuffer_rgba32f(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data);\n"
"   }\n"
"}\n";

/* format rgba16f */
gctSTRING gcLibImageStore_Buffer_float =
"void _viv_image_store_imageBuffer(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT16>, address, data);\n"
"   }\n"
"}\n";

/* format r32f */
gctSTRING gcLibImageStore_Buffer_float_r32f =
"void _viv_image_store_imageBuffer_r32f(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.x);\n"
"   }\n"
"}\n";

/* format rgba8
   since driver treats rgba8 as bgra8, we need _viv_image_store_swizzle to
   get the correct data to write */
gctSTRING gcLibImageStore_Buffer_float_rgba8 =
"void _viv_image_store_imageBuffer_rgba8(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 data1 = uvec4(clamp(data, 0.0, 1.0) * 255.5);\n"
"       uvec4 data2 = _viv_image_store_swizzle_uint(img_desc_u, data1);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data2);\n"
"   }\n"
"}\n";

gctSTRING gcLibImageStore_Buffer_float_rg8 =
"void _viv_image_store_imageBuffer_rg8(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   vec2 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 data1 = uvec4(clamp(data, 0.0, 1.0) * 255.5);\n"
"       uvec4 data2 = _viv_image_store_swizzle_uint(img_desc, data1);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data2.xy);\n"
"   }\n"
"}\n";

gctSTRING gcLibImageStore_Buffer_float_r8 =
"void _viv_image_store_imageBuffer_r8(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 data1 = uvec4(clamp(data, 0.0, 1.0) * 255.5);\n"
"       uvec4 data2 = _viv_image_store_swizzle_uint(img_desc, data1);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data2.x);\n"
"   }\n"
"}\n";

/* format rgba8_snorm */
gctSTRING gcLibImageStore_Buffer_float_rgba8_snorm =
"void _viv_image_store_imageBuffer_rgba8_snorm(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 data1 = ivec4(clamp(data, -1.0, 1.0) * 127.5);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data1);\n"
"   }\n"
"}\n";

/* format rg8_snorm */
gctSTRING gcLibImageStore_Buffer_float_rg8_snorm =
"void _viv_image_store_imageBuffer_rg8_snorm(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   vec2 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 data1 = ivec4(clamp(data, -1.0, 1.0) * 127.5);\n"
"       ivec4 data2 = _viv_image_store_swizzle_int(img_desc, data1);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data2.xy);\n"
"   }\n"
"}\n";

/* format r8_snorm */
gctSTRING gcLibImageStore_Buffer_float_r8_snorm =
"void _viv_image_store_imageBuffer_r8_snorm(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 data1 = ivec4(clamp(data, -1.0, 1.0) * 127.5);\n"
"       ivec4 data2 = _viv_image_store_swizzle_int(img_desc, data1);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data2.xy);\n"
"   }\n"
"}\n";

/* format rgba32i */
gctSTRING gcLibImageStore_Buffer_int_rgba32i =
"void _viv_image_store_iimageBuffer_rgba32i(highp uvec4 img_desc, int coord, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data);\n"
"   }\n"
"}\n";

/* format rgba16i */
gctSTRING gcLibImageStore_Buffer_int =
"void _viv_image_store_iimageBuffer(highp uvec4 img_desc, int coord, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT16>, address, data);\n"
"   }\n"
"}\n";

/* format rgba8i */
gctSTRING gcLibImageStore_Buffer_int_rgba8i =
"void _viv_image_store_iimageBuffer_rgba8i(highp uvec4 img_desc, int coord, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data);\n"
"   }\n"
"}\n";

/* format r32i */
gctSTRING gcLibImageStore_Buffer_int_r32i =
"void _viv_image_store_iimageBuffer_r32i(highp uvec4 img_desc, int coord, ivec4 data)\n"
"{\n"
"   int result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.x);\n"
"   }\n"
"}\n";

/* format rgba32ui */
gctSTRING gcLibImageStore_Buffer_uint_rgba32ui =
"void _viv_image_store_uimageBuffer_rgba32ui(highp uvec4 img_desc, int coord, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data);\n"
"   }\n"
"}\n";

/* format rgba16ui */
gctSTRING gcLibImageStore_Buffer_uint =
"void _viv_image_store_uimageBuffer(highp uvec4 img_desc, int coord, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT16>, address, data);\n"
"   }\n"
"}\n";

/* format rgba8ui */
gctSTRING gcLibImageStore_Buffer_uint_rgba8ui =
"void _viv_image_store_uimageBuffer_rgba8ui(highp uvec4 img_desc, int coord, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data);\n"
"   }\n"
"}\n";

/* format r32ui */
gctSTRING gcLibImageStore_Buffer_uint_r32ui =
"void _viv_image_store_uimageBuffer_r32ui(highp uvec4 img_desc, int coord, uvec4 data)\n"
"{\n"
"   uint result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.x);\n"
"   }\n"
"}\n";

/* imageStore for image1D */
gctSTRING gcLibImageStore_1D_float_hati4 =
"void _viv_image_store_image_1d(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_1D_float_1_hati4 =
"void _viv_image_store_image_1d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, int p, vec4 data)\n"
"{\n"
"    vec2 result = data.xy;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p1);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_1D_int_hati4 =
"void _viv_image_store_iimage_1d(highp uvec4 img_desc, int p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_1D_int_1_hati4 =
"void _viv_image_store_iimage_1d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, int p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p1);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_1D_uint_hati4 =
"void _viv_image_store_uimage_1d(highp uvec4 img_desc, int p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_1D_uint_1_hati4 =
"void _viv_image_store_uimage_1d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, int p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    ivec2 p1 = ivec2(p, 0);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p1);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR, result, img_desc_1, p1);\n"
"}\n";

/* imageStore for image1DArray. */
gctSTRING gcLibImageStore_1D_array_float_hati4 =
"void _viv_image_store_image_1d_array(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_1D_array_float_1_hati4 =
"void _viv_image_store_image_1d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, vec4 data)\n"
"{\n"
"    vec2 result = data.xy;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1.z = int(img_desc_1.x) + p.y * is.w ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_1D_array_int_hati4 =
"void _viv_image_store_iimage_1d_array(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_1D_array_int_1_hati4 =
"void _viv_image_store_iimage_1d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w;\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1.z = int(img_desc_1.x) + p.y * is.w ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_1D_array_uint_hati4 =
"void _viv_image_store_uimage_1d_array(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_1D_array_uint_1_hati4 =
"void _viv_image_store_uimage_1d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    ivec4 is = ivec4(_viv_image_size(img_desc));\n"
"    ivec3 p1;\n"
"    p1.x = p.x;\n"
"    p1.y = 0;\n"
"    p1.z = int(img_desc.x) + p.y * is.w;\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1.z = int(img_desc_1.x) + p.y * is.w ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

/* imageStore for image2D. */
gctSTRING gcLibImageStore_2D_float_hati4 =
"void _viv_image_store_image_2d(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"}\n";

gctSTRING gcLibImageStore_2D_float_1_hati4 =
"void _viv_image_store_image_2d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, vec4 data)\n"
"{\n"
"    vec2 result = data.xy;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR, result, img_desc_1, p);\n"
"}\n";

gctSTRING gcLibImageStore_2D_int_hati4 =
"void _viv_image_store_iimage_2d(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"}\n";

gctSTRING gcLibImageStore_2D_int_1_hati4 =
"void _viv_image_store_iimage_2d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR, result, img_desc_1, p);\n"
"}\n";

gctSTRING gcLibImageStore_2D_uint_hati4 =
"void _viv_image_store_uimage_2d(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"}\n";

gctSTRING gcLibImageStore_2D_uint_1_hati4 =
"void _viv_image_store_uimage_2d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR, result, img_desc_1, p);\n"
"}\n";

/* imageStore for image3D. */
gctSTRING gcLibImageStore_3D_float_hati4 =
"void _viv_image_store_image_3d(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_3D_float_1_hati4 =
"void _viv_image_store_image_3d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"    vec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_3D_int_hati4 =
"void _viv_image_store_iimage_3d(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_3D_int_1_hati4 =
"void _viv_image_store_iimage_3d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_3D_uint_hati4 =
"void _viv_image_store_uimage_3d(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_3D_uint_1_hati4 =
"void _viv_image_store_uimage_3d_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

/* imageStore for imageCube. */
gctSTRING gcLibImageStore_cube_float_hati4 =
"void _viv_image_store_image_cube(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_cube_float_1_hati4 =
"void _viv_image_store_image_cube_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"    vec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_cube_int_hati4 =
"void _viv_image_store_iimage_cube(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_cube_int_1_hati4 =
"void _viv_image_store_iimage_cube_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_cube_uint_hati4 =
"void _viv_image_store_uimage_cube(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_cube_uint_1_hati4 =
"void _viv_image_store_uimage_cube_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

/* imageStore for image2DArray. */
gctSTRING gcLibImageStore_2DArray_float_hati4 =
"void _viv_image_store_image_2d_array(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_2DArray_float_1_hati4 =
"void _viv_image_store_image_2d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"    vec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_2DArray_int_hati4 =
"void _viv_image_store_iimage_2d_array(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_2DArray_int_1_hati4 =
"void _viv_image_store_iimage_2d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_2DArray_uint_hati4 =
"void _viv_image_store_uimage_2d_array(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_2DArray_uint_1_hati4 =
"void _viv_image_store_uimage_2d_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

/* imageStore for imageCubeArray. */
gctSTRING gcLibImageStore_CubeArray_float_img_access =
"void _viv_image_store_image_cube_array(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_CubeArray_float_1_img_access =
"void _viv_image_store_image_cube_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"    vec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_CubeArray_int_img_access =
"void _viv_image_store_iimage_cube_array(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_CubeArray_int_1_img_access =
"void _viv_image_store_iimage_cube_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

gctSTRING gcLibImageStore_CubeArray_uint_img_access =
"void _viv_image_store_uimage_cube_array(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

gctSTRING gcLibImageStore_CubeArray_uint_1_img_access =
"void _viv_image_store_uimage_cube_array_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

/* imageStore for imageBuffer. */
gctSTRING gcLibImageStore_Buffer_float_img_access =
"void _viv_image_store_imageBuffer(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    result = data;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_WR, result, img_desc, newCoord);\n"
"}\n";

gctSTRING gcLibImageStore_Buffer_int_img_access =
"void _viv_image_store_iimageBuffer(highp uvec4 img_desc, int p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    result = data;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_WR, result, img_desc, newCoord);\n"
"}\n";

gctSTRING gcLibImageStore_Buffer_uint_img_access =
"void _viv_image_store_uimageBuffer(highp uvec4 img_desc, int p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    result = data;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_WR, result, img_desc, newCoord);\n"
"}\n";

/* image atomic functions */
gctSTRING gcLibImageAtomicAdd_2D_int =
"int _viv_image_atomic_add_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_2D_uint =
"uint _viv_image_atomic_add_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_3D_int =
"int _viv_image_atomic_add_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_3D_uint =
"uint _viv_image_atomic_add_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_CUBE_int =
"int _viv_image_atomic_add_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_CUBE_uint =
"uint _viv_image_atomic_add_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_2DARRAY_int =
"int _viv_image_atomic_add_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_2DARRAY_uint =
"uint _viv_image_atomic_add_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_buffer_int =
"int _viv_image_atomic_add_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_buffer_uint =
"uint _viv_image_atomic_add_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_2D_int =
"int _viv_image_atomic_min_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_2D_uint =
"uint _viv_image_atomic_min_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_3D_int =
"int _viv_image_atomic_min_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_3D_uint =
"uint _viv_image_atomic_min_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_CUBE_int =
"int _viv_image_atomic_min_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_CUBE_uint =
"uint _viv_image_atomic_min_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_2DARRAY_int =
"int _viv_image_atomic_min_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_2DARRAY_uint =
"uint _viv_image_atomic_min_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_buffer_int =
"int _viv_image_atomic_min_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_buffer_uint =
"uint _viv_image_atomic_min_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_2D_int =
"int _viv_image_atomic_max_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_2D_uint =
"uint _viv_image_atomic_max_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_3D_int =
"int _viv_image_atomic_max_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_3D_uint =
"uint _viv_image_atomic_max_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_CUBE_int =
"int _viv_image_atomic_max_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_CUBE_uint =
"uint _viv_image_atomic_max_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_2DARRAY_int =
"int _viv_image_atomic_max_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_2DARRAY_uint =
"uint _viv_image_atomic_max_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_buffer_int =
"int _viv_image_atomic_max_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_buffer_uint =
"uint _viv_image_atomic_max_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_2D_int =
"int _viv_image_atomic_and_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_2D_uint =
"uint _viv_image_atomic_and_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_3D_int =
"int _viv_image_atomic_and_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_3D_uint =
"uint _viv_image_atomic_and_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_CUBE_int =
"int _viv_image_atomic_and_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_CUBE_uint =
"uint _viv_image_atomic_and_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_2DARRAY_int =
"int _viv_image_atomic_and_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_2DARRAY_uint =
"uint _viv_image_atomic_and_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_buffer_int =
"int _viv_image_atomic_and_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_buffer_uint =
"uint _viv_image_atomic_and_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_2D_int =
"int _viv_image_atomic_or_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_2D_uint =
"uint _viv_image_atomic_or_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_3D_int =
"int _viv_image_atomic_or_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_3D_uint =
"uint _viv_image_atomic_or_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_CUBE_int =
"int _viv_image_atomic_or_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_CUBE_uint =
"uint _viv_image_atomic_or_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_2DARRAY_int =
"int _viv_image_atomic_or_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_2DARRAY_uint =
"uint _viv_image_atomic_or_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_buffer_int =
"int _viv_image_atomic_or_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_buffer_uint =
"uint _viv_image_atomic_or_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_2D_int =
"int _viv_image_atomic_xor_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_2D_uint =
"uint _viv_image_atomic_xor_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_3D_int =
"int _viv_image_atomic_xor_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_3D_uint =
"uint _viv_image_atomic_xor_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_CUBE_int =
"int _viv_image_atomic_xor_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_CUBE_uint =
"uint _viv_image_atomic_xor_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_2DARRAY_int =
"int _viv_image_atomic_xor_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_2DARRAY_uint =
"uint _viv_image_atomic_xor_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_buffer_int =
"int _viv_image_atomic_xor_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_buffer_uint =
"uint _viv_image_atomic_xor_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2D_int =
"int _viv_image_atomic_xchg_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2D_uint =
"uint _viv_image_atomic_xchg_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2D_float =
"float _viv_image_atomic_xchg_2D_float(highp uvec4 img_desc, ivec2 p, float data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_3D_int =
"int _viv_image_atomic_xchg_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_3D_uint =
"uint _viv_image_atomic_xchg_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_3D_float =
"float _viv_image_atomic_xchg_3D_float(highp uvec4 img_desc, ivec3 p, float data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_CUBE_int =
"int _viv_image_atomic_xchg_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_CUBE_uint =
"uint _viv_image_atomic_xchg_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_CUBE_float =
"float _viv_image_atomic_xchg_CUBE_float(highp uvec4 img_desc, ivec3 p, float data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2DARRAY_int =
"int _viv_image_atomic_xchg_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2DARRAY_uint =
"uint _viv_image_atomic_xchg_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2DARRAY_float =
"float _viv_image_atomic_xchg_2DARRAY_float(highp uvec4 img_desc, ivec3 p, float data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_buffer_int =
"int _viv_image_atomic_xchg_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_buffer_uint =
"uint _viv_image_atomic_xchg_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_buffer_float =
"float _viv_image_atomic_xchg_buffer_float(highp uvec4 img_desc, int p, float data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_2D_int =
"int _viv_image_atomic_cmpxchg_2D_int(highp uvec4 img_desc, ivec2 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   ivec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_2D_uint =
"uint _viv_image_atomic_cmpxchg_2D_uint(highp uvec4 img_desc, ivec2 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   uvec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_3D_int =
"int _viv_image_atomic_cmpxchg_3D_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   ivec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_3D_uint =
"uint _viv_image_atomic_cmpxchg_3D_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   uvec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_CUBE_int =
"int _viv_image_atomic_cmpxchg_CUBE_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   ivec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_CUBE_uint =
"uint _viv_image_atomic_cmpxchg_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   uvec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_2DARRAY_int =
"int _viv_image_atomic_cmpxchg_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(uvec4(img_desc), p1).y;\n"
"   ivec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_2DARRAY_uint =
"uint _viv_image_atomic_cmpxchg_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr3D(img_desc, p1).y;\n"
"   uvec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_buffer_int =
"int _viv_image_atomic_cmpxchg_buffer_int(highp uvec4 img_desc, int p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   ivec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_buffer_uint =
"uint _viv_image_atomic_cmpxchg_buffer_uint(highp uvec4 img_desc, int p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   uvec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_2D_int_hati4 =
"int _viv_image_atomic_add_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_2D_uint_hati4 =
"uint _viv_image_atomic_add_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_3D_int_hati4 =
"int _viv_image_atomic_add_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_3D_uint_hati4 =
"uint _viv_image_atomic_add_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_CUBE_int_hati4 =
"int _viv_image_atomic_add_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_CUBE_uint_hati4 =
"uint _viv_image_atomic_add_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_2DARRAY_int_hati4 =
"int _viv_image_atomic_add_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_add_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_buffer_int_img_access =
"int _viv_image_atomic_add_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAdd_buffer_uint_img_access =
"uint _viv_image_atomic_add_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_2D_int_hati4 =
"int _viv_image_atomic_min_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_2D_uint_hati4 =
"uint _viv_image_atomic_min_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_3D_int_hati4 =
"int _viv_image_atomic_min_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_3D_uint_hati4 =
"uint _viv_image_atomic_min_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_CUBE_int_hati4 =
"int _viv_image_atomic_min_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_CUBE_uint_hati4 =
"uint _viv_image_atomic_min_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_2DARRAY_int_hati4 =
"int _viv_image_atomic_min_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_min_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_buffer_int_img_access =
"int _viv_image_atomic_min_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMin_buffer_uint_img_access =
"uint _viv_image_atomic_min_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_2D_int_hati4 =
"int _viv_image_atomic_max_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_2D_uint_hati4 =
"uint _viv_image_atomic_max_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_3D_int_hati4 =
"int _viv_image_atomic_max_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_3D_uint_hati4 =
"uint _viv_image_atomic_max_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_CUBE_int_hati4 =
"int _viv_image_atomic_max_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_CUBE_uint_hati4 =
"uint _viv_image_atomic_max_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_2DARRAY_int_hati4 =
"int _viv_image_atomic_max_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_max_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_buffer_int_img_access =
"int _viv_image_atomic_max_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicMax_buffer_uint_img_access =
"uint _viv_image_atomic_max_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_2D_int_hati4 =
"int _viv_image_atomic_and_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_2D_uint_hati4 =
"uint _viv_image_atomic_and_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_3D_int_hati4 =
"int _viv_image_atomic_and_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_3D_uint_hati4 =
"uint _viv_image_atomic_and_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_CUBE_int_hati4 =
"int _viv_image_atomic_and_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_CUBE_uint_hati4 =
"uint _viv_image_atomic_and_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_2DARRAY_int_hati4 =
"int _viv_image_atomic_and_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_and_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_buffer_int_img_access =
"int _viv_image_atomic_and_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicAnd_buffer_uint_img_access =
"uint _viv_image_atomic_and_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_2D_int_hati4 =
"int _viv_image_atomic_or_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_2D_uint_hati4 =
"uint _viv_image_atomic_or_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_3D_int_hati4 =
"int _viv_image_atomic_or_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_3D_uint_hati4 =
"uint _viv_image_atomic_or_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_CUBE_int_hati4 =
"int _viv_image_atomic_or_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_CUBE_uint_hati4 =
"uint _viv_image_atomic_or_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_2DARRAY_int_hati4 =
"int _viv_image_atomic_or_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_or_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_buffer_int_img_access =
"int _viv_image_atomic_or_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicOr_buffer_uint_img_access =
"uint _viv_image_atomic_or_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_2D_int_hati4 =
"int _viv_image_atomic_xor_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_2D_uint_hati4 =
"uint _viv_image_atomic_xor_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_3D_int_hati4 =
"int _viv_image_atomic_xor_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_3D_uint_hati4 =
"uint _viv_image_atomic_xor_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_CUBE_int_hati4 =
"int _viv_image_atomic_xor_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_CUBE_uint_hati4 =
"uint _viv_image_atomic_xor_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_2DARRAY_int_hati4 =
"int _viv_image_atomic_xor_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_xor_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_buffer_int_img_access =
"int _viv_image_atomic_xor_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXor_buffer_uint_img_access =
"uint _viv_image_atomic_xor_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2D_int_hati4 =
"int _viv_image_atomic_xchg_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2D_uint_hati4 =
"uint _viv_image_atomic_xchg_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2D_float_hati4 =
"float _viv_image_atomic_xchg_2D_float(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_3D_int_hati4 =
"int _viv_image_atomic_xchg_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_3D_uint_hati4 =
"uint _viv_image_atomic_xchg_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_3D_float_hati4 =
"float _viv_image_atomic_xchg_3D_float(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_CUBE_int_hati4 =
"int _viv_image_atomic_xchg_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_CUBE_uint_hati4 =
"uint _viv_image_atomic_xchg_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_CUBE_float_hati4 =
"float _viv_image_atomic_xchg_CUBE_float(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2DARRAY_int_hati4 =
"int _viv_image_atomic_xchg_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_xchg_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_2DARRAY_float_hati4 =
"float _viv_image_atomic_xchg_2DARRAY_float(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_buffer_int_img_access =
"int _viv_image_atomic_xchg_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_buffer_uint_img_access =
"uint _viv_image_atomic_xchg_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicXchg_buffer_float_img_access =
"float _viv_image_atomic_xchg_buffer_float(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_2D_int_hati4 =
"int _viv_image_atomic_cmpxchg_2D_int(highp uvec4 img_desc, ivec2 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   ivec2 temp;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_2D_uint_hati4 =
"uint _viv_image_atomic_cmpxchg_2D_uint(highp uvec4 img_desc, ivec2 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uvec2 temp;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_3D_int_hati4 =
"int _viv_image_atomic_cmpxchg_3D_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   ivec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_3D_uint_hati4 =
"uint _viv_image_atomic_cmpxchg_3D_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uvec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_CUBE_int_hati4 =
"int _viv_image_atomic_cmpxchg_CUBE_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   ivec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_CUBE_uint_hati4 =
"uint _viv_image_atomic_cmpxchg_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uvec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_2DARRAY_int_hati4 =
"int _viv_image_atomic_cmpxchg_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   ivec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_cmpxchg_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uvec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_buffer_int_img_access =
"int _viv_image_atomic_cmpxchg_buffer_int(highp uvec4 img_desc, int p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   ivec2 temp;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

gctSTRING gcLibImageAtomicCmpXchg_buffer_uint_img_access =
"uint _viv_image_atomic_cmpxchg_buffer_uint(highp uvec4 img_desc, int p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uvec2 temp;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

/* image query functions for halti4. */
gctSTRING gcLibImageQuery_halti4 =
"#define CUBE_FACES_NUM        6\n"
"int _viv_image_query_size_1d(highp uvec4 img_desc)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    return size.x;\n"
"}\n"
"ivec2 _viv_image_query_size_1d_array(highp uvec4 img_desc)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    return size.xz;\n"
"}\n"
"ivec2 _viv_image_query_size_2d(highp uvec4 img_desc)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    return size.xy;\n"
"}\n"
"ivec2 _viv_image_query_size_for_sampler_sampler_2d_ms(sampler2DMS sampler)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    return size.xy;\n"
"}\n"
"ivec2 _viv_image_query_size_for_sampler_isampler_2d_ms(isampler2DMS sampler)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    return size.xy;\n"
"}\n"
"ivec2 _viv_image_query_size_for_sampler_usampler_2d_ms(usampler2DMS sampler)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, sampler);\n"
"    return size.xy;\n"
"}\n"
"ivec3 _viv_image_query_size_2d_array(highp uvec4 img_desc)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    return size.xyz;\n"
"}\n"
"ivec2 _viv_image_query_size_cube(highp uvec4 img_desc)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    return size.xy;\n"
"}\n"
"ivec3 _viv_image_query_size_cube_array(highp uvec4 img_desc)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.z /= CUBE_FACES_NUM;\n"
"    return size.xyz;\n"
"}\n"
"ivec3 _viv_image_query_size_3d(highp uvec4 img_desc)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    return size.xyz;\n"
"}\n"
"ivec4 _viv_image_query_size_3d_array(highp uvec4 img_desc)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    return size;\n"
"}\n"
"int _viv_image_query_size_samplerBuffer(highp uvec4 img_desc)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    return size.z;\n"
"}\n"
/* Size for mipmap level for LOD */
"ivec4 _viv_image_query_size_lod(highp uvec4 img_desc, float lod)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.xyz = size.xyz >> int(lod);\n"
"    size.xyz = max(size.xyz, 1);\n"
"    return size;\n"
"}\n"
"int _viv_image_query_size_lod_1d(highp uvec4 img_desc, int lod)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.x = size.x >> lod;\n"
"    size.x = max(size.x, 1);\n"
"    return size.x;\n"
"}\n"
"ivec2 _viv_image_query_size_lod_1d_array(highp uvec4 img_desc, int lod)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.x = size.x >> lod;\n"
"    size.x = max(size.x, 1);\n"
"    return size.xz;\n"
"}\n"
"ivec2 _viv_image_query_size_lod_2d(highp uvec4 img_desc, int lod)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.xy = size.xy >> lod;\n"
"    size.xy = max(size.xy, 1);\n"
"    return size.xy;\n"
"}\n"
"ivec3 _viv_image_query_size_lod_2d_array(highp uvec4 img_desc, int lod)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.xy = size.xy >> lod;\n"
"    size.xy = max(size.xy, 1);\n"
"    return size.xyz;\n"
"}\n"
"ivec2 _viv_image_query_size_lod_cube(highp uvec4 img_desc, int lod)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.xy = size.xy >> lod;\n"
"    size.xy = max(size.xy, 1);\n"
"    return size.xy;\n"
"}\n"
"ivec3 _viv_image_query_size_lod_cube_array(highp uvec4 img_desc, int lod)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.z /= CUBE_FACES_NUM;\n"
"    size.xy = size.xy >> lod;\n"
"    size.xy = max(size.xy, 1);\n"
"    return size.xyz;\n"
"}\n"
"ivec3 _viv_image_query_size_lod_3d(highp uvec4 img_desc, int lod)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.xyz = size.xyz >> lod;\n"
"    size.xyz = max(size.xyz, 1);\n"
"    return size.xyz;\n"
"}\n"
"ivec4 _viv_image_query_size_lod_3d_array(highp uvec4 img_desc, int lod)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.xyz = size.xyz >> lod;\n"
"    size.xyz = max(size.xyz, 1);\n"
"    return size;\n"
"}\n"
"ivec2 _viv_image_query_size_lod_samplerBuffer(highp uvec4 img_desc, int lod)\n"
"{\n"
"    ivec4 size;\n"
"    _viv_asm(GET_SAMPLER_LBS, size, img_desc);\n"
"    size.xy = max(size.xy, 1);\n"
"    return size.xy;\n"
"}\n";

/******************** advanced blend equation implementation ********************/
/* gc3000/5000 blend equation implementation */
gctSTRING gcLibBlendEquation_Multiply =
"vec4 _blend_equation_advanced_multiply(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_MULTIPLY) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Screen =
"vec4 _blend_equation_advanced_screen(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SCREEN) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = src.xyz + dst.xyz - src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Overlay =
"vec4 _blend_equation_advanced_overlay(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_OVERLAY) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            vec3 temp = (vec3(2) * dst.xyz) == vec3(dst.w) ? vec3(0.5) : dst.xyz/vec3(dst.w);\n"
"            dst.xyz = mix(temp, vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f1 = vec3(2.0) * src.xyz * dst.xyz;\n"
"            vec3 f2 = vec3(1.0) - vec3(2.0) * (vec3(1.0) - src.xyz) * (vec3(1.0) - dst.xyz);\n"
"            bvec3 sel = lessThanEqual(dst.xyz, vec3(0.5));\n"
"            vec3 f = mix(f2, f1, sel);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Darken =
"vec4 _blend_equation_advanced_darken(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DARKEN) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = min(src.xyz, dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Lighten =
"vec4 _blend_equation_advanced_lighten(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_LIGHTEN) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = max(src.xyz, dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Hardlight =
"vec4 _blend_equation_advanced_hardlight(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HARDLIGHT) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            vec3 temp = (vec3(2) * src.xyz) == vec3(src.w) ? vec3(0.5) : src.xyz/vec3(src.w);\n"
"            src.xyz = mix(temp, vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f1 = vec3(2.0) * src.xyz * dst.xyz;\n"
"            vec3 f2 = vec3(1.0) - vec3(2.0) * (vec3(1.0) - src.xyz) * (vec3(1.0) - dst.xyz);\n"
"            bvec3 sel = lessThanEqual(src.xyz, vec3(0.5));\n"
"            vec3 f = mix(f2, f1, sel);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Difference =
"vec4 _blend_equation_advanced_difference(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DIFFERENCE) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = abs(src.xyz - dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Exclusion =
"vec4 _blend_equation_advanced_exclusion(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_EXCLUSION) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = src.xyz + dst.xyz - vec3(2.0) * src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Colordodge =
"vec4 _blend_equation_advanced_colordodge(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            vec3 temp = src.xyz == vec3(src.w) ? vec3(1.0) : src.xyz/vec3(src.w);\n"
"            src.xyz = mix(temp, vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            temp = dst.xyz == vec3(dst.w) ? vec3(1.0) : dst.xyz/vec3(dst.w);\n"
"            dst.xyz = mix(temp, vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = vec3(1.0);\n"
"            sel1 = lessThanEqual(dst.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            bvec3 sel2 = lessThan(src.xyz, vec3(1.0));\n"
"            f = mix(f, min(vec3(1.0), dst.xyz/(vec3(1.0) - src.xyz)), sel2);\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Colorburn =
"vec4 _blend_equation_advanced_colorburn(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            vec3 temp = dst.xyz == vec3(dst.w) ? vec3(1.0) : dst.xyz/vec3(dst.w);\n"
"            dst.xyz = mix(temp, vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = vec3(0.0);\n"
"            sel1 = greaterThanEqual(dst.xyz, vec3(1.0));\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            bvec3 sel2 = greaterThan(src.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(1.0) - min(vec3(1.0), (vec3(1.0) - dst.xyz)/src.xyz), sel2);\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Softlight =
"vec4 _blend_equation_advanced_softlight(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            vec3 temp = (vec3(2) * src.xyz) == vec3(src.w) ? vec3(0.5) : src.xyz/vec3(src.w);\n"
"            src.xyz = mix(temp, vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            temp = (vec3(4) *dst.xyz) == vec3(dst.w) ? vec3(0.25) : dst.xyz/vec3(dst.w);\n"
"            dst.xyz = mix(temp, vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f1 = dst.xyz - (vec3(1.0) - vec3(2.0) * src.xyz)* dst.xyz * (vec3(1.0) - dst.xyz);\n"
"            vec3 f2 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0))* dst.xyz * ((vec3(16.0) * dst.xyz - vec3(12.0))* dst.xyz+vec3(3.0));\n"
"            vec3 f3 = dst.xyz + (vec3(2.0) * src.xyz-vec3(1.0)) *(sqrt(dst.xyz)-dst.xyz);\n"
"            vec3 f = f3;\n"
"            sel1 = lessThanEqual(src.xyz, vec3(0.5));\n"
"            f = mix(f, f1, sel1);\n"
"            bvec3 sel2 = lessThanEqual(dst.xyz, vec3(0.25));\n"
"            f = mix(f, f2, sel2);\n"
"            f = mix(f, f1, sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_HSL_HUE =
"vec4 _blend_equation_advanced_hsl_hue(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            float minbase = min(min(src.x, src.y), src.z);\n"
"            float maxbase = max(max(src.x, src.y), src.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(dst.x, dst.y), dst.z);\n"
"            float maxsat = max(max(dst.x, dst.y), dst.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (src.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_HSL_SATURATION =
"vec4 _blend_equation_advanced_hsl_saturation(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            float minbase = min(min(dst.x, dst.y), dst.z);\n"
"            float maxbase = max(max(dst.x, dst.y), dst.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(src.x, src.y), src.z);\n"
"            float maxsat = max(max(src.x, src.y), src.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (dst.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_HSL_COLOR =
"vec4 _blend_equation_advanced_hsl_color(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float lbase = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;\n"
"            float llum = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = src.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_HSL_LUMINOSITY =
"vec4 _blend_equation_advanced_hsl_luminosity(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float lbase = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float llum = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = dst.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_ALL =
"vec4 _blend_equation_advanced_all(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            vec3 temp = src.xyz == vec3(src.w) ? vec3(1.0) : src.xyz/vec3(src.w);\n"
"            src.xyz = mix(temp, vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            temp = dst.xyz == vec3(dst.w) ? vec3(1.0) : dst.xyz/vec3(dst.w);\n"
"            dst.xyz = mix(temp, vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            bvec3 sel2;\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_MULTIPLY) {\n"
"            vec3 f = src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SCREEN) {\n"
"            vec3 f = src.xyz + dst.xyz - src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_OVERLAY) {\n"
"            vec3 f1 = vec3(2.0) * src.xyz * dst.xyz;\n"
"            vec3 f2 = vec3(1.0) - vec3(2.0) * (vec3(1.0) - src.xyz) * (vec3(1.0) - dst.xyz);\n"
"            bvec3 sel = lessThanEqual(dst.xyz, vec3(0.5));\n"
"            vec3 f = mix(f2, f1, sel);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DARKEN) {\n"
"            vec3 f = min(src.xyz, dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_LIGHTEN) {\n"
"            vec3 f = max(src.xyz, dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HARDLIGHT) {\n"
"            vec3 f1 = vec3(2.0) * src.xyz * dst.xyz;\n"
"            vec3 f2 = vec3(1.0) - vec3(2.0) * (vec3(1.0) - src.xyz) * (vec3(1.0) - dst.xyz);\n"
"            bvec3 sel = lessThanEqual(src.xyz, vec3(0.5));\n"
"            vec3 f = mix(f2, f1, sel);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DIFFERENCE) {\n"
"            vec3 f = abs(src.xyz - dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_EXCLUSION) {\n"
"            vec3 f = src.xyz + dst.xyz - vec3(2.0) * src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE) {\n"
"            vec3 f = vec3(1.0); \n"
"            sel1 = lessThanEqual(dst.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            sel2 = lessThan(src.xyz, vec3(1.0));\n"
"            f = mix(f, min(vec3(1.0), dst.xyz/(vec3(1.0) - src.xyz)), sel2);\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN) {\n"
"            vec3 f = vec3(0.0);\n"
"            sel1 = greaterThanEqual(dst.xyz, vec3(1.0));\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            sel2 = greaterThan(src.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(1.0) - min(vec3(1.0), (vec3(1.0) - dst.xyz)/src.xyz), sel2);\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT) {\n"
"            vec3 f1 = dst.xyz - (vec3(1.0) - vec3(2.0) * src.xyz)* dst.xyz * (vec3(1.0) - dst.xyz);\n"
"            vec3 f2 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0))* dst.xyz * ((vec3(16.0) * dst.xyz - vec3(12.0))* dst.xyz+vec3(3.0));\n"
"            vec3 f3 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0)) *(sqrt(dst.xyz)-dst.xyz);\n"
"            vec3 f = f3;\n"
"            sel1 = lessThanEqual(src.xyz, vec3(0.5));\n"
"            f = mix(f, f1, sel1);\n"
"            sel2 = lessThanEqual(dst.xyz, vec3(0.25));\n"
"            f = mix(f, f2, sel2);\n"
"            f = mix(f, f1, sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE) {\n"
"            float minbase = min(min(src.x, src.y), src.z);\n"
"            float maxbase = max(max(src.x, src.y), src.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(dst.x, dst.y), dst.z);\n"
"            float maxsat = max(max(dst.x, dst.y), dst.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (src.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION) {\n"
"            float minbase = min(min(dst.x, dst.y), dst.z);\n"
"            float maxbase = max(max(dst.x, dst.y), dst.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(src.x, src.y), src.z);\n"
"            float maxsat = max(max(src.x, src.y), src.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (dst.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR) {\n"
"            float lbase = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;\n"
"            float llum = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = src.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY) {\n"
"            float lbase = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float llum = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = dst.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

/* gc7000 blend equation implementation */
gctSTRING gcLibBlendEquation_Colordodge_hati4 =
"vec4 _blend_equation_advanced_colordodge(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE) {\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = vec3(1.0);\n"
"            sel1 = lessThanEqual(dst.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            bvec3 sel2 = lessThan(src.xyz, vec3(1.0));\n"
"            f = mix(f, min(vec3(1.0), dst.xyz/(vec3(1.0) - src.xyz)), sel2);\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Colorburn_hati4 =
"vec4 _blend_equation_advanced_colorburn(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN) {\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = vec3(0.0);\n"
"            sel1 = greaterThanEqual(dst.xyz, vec3(1.0));\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            bvec3 sel2 = greaterThan(src.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(1.0) - min(vec3(1.0), (vec3(1.0) - dst.xyz)/src.xyz), sel2);\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_Softlight_hati4 =
"vec4 _blend_equation_advanced_softlight(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT) {\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f1 = dst.xyz - (vec3(1.0) - vec3(2.0) * src.xyz)* dst.xyz * (vec3(1.0) - dst.xyz);\n"
"            vec3 f2 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0))* dst.xyz * ((vec3(16.0) * dst.xyz - vec3(12.0))* dst.xyz+vec3(3.0));\n"
"            vec3 f3 = dst.xyz + (vec3(2.0) * src.xyz-vec3(1.0)) *(sqrt(dst.xyz)-dst.xyz);\n"
"            vec3 f = f3;\n"
"            sel1 = lessThanEqual(src.xyz, vec3(0.5));\n"
"            f = mix(f, f1, sel1);\n"
"            bvec3 sel2 = lessThanEqual(dst.xyz, vec3(0.25));\n"
"            f = mix(f, f2, sel2);\n"
"            f = mix(f, f1, sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_HSL_HUE_hati4 =
"vec4 _blend_equation_advanced_hsl_hue(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE) {\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            float minbase = min(min(src.x, src.y), src.z);\n"
"            float maxbase = max(max(src.x, src.y), src.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(dst.x, dst.y), dst.z);\n"
"            float maxsat = max(max(dst.x, dst.y), dst.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (src.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_HSL_SATURATION_hati4 =
"vec4 _blend_equation_advanced_hsl_saturation(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION) {\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            float minbase = min(min(dst.x, dst.y), dst.z);\n"
"            float maxbase = max(max(dst.x, dst.y), dst.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(src.x, src.y), src.z);\n"
"            float maxsat = max(max(src.x, src.y), src.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (dst.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_HSL_COLOR_hati4 =
"vec4 _blend_equation_advanced_hsl_color(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR) {\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float lbase = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;\n"
"            float llum = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = src.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";


gctSTRING gcLibBlendEquation_HSL_LUMINOSITY_hati4 =
"vec4 _blend_equation_advanced_hsl_luminosity(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY) {\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float lbase = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float llum = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = dst.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLibBlendEquation_ALL_hati4 =
"vec4 _blend_equation_advanced_all(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f;\n"
"            bvec3 sel2;\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE) {\n"
"            f = vec3(1.0); \n"
"            sel1 = lessThanEqual(dst.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            sel2 = lessThan(src.xyz, vec3(1.0));\n"
"            f = mix(f, min(vec3(1.0), dst.xyz/(vec3(1.0) - src.xyz)), sel2);\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN) {\n"
"            f = vec3(0.0);\n"
"            sel1 = greaterThanEqual(dst.xyz, vec3(1.0));\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            sel2 = greaterThan(src.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(1.0) - min(vec3(1.0), (vec3(1.0) - dst.xyz)/src.xyz), sel2);\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT) {\n"
"            vec3 f1 = dst.xyz - (vec3(1.0) - vec3(2.0) * src.xyz)* dst.xyz * (vec3(1.0) - dst.xyz);\n"
"            vec3 f2 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0))* dst.xyz * ((vec3(16.0) * dst.xyz - vec3(12.0))* dst.xyz+vec3(3.0));\n"
"            vec3 f3 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0)) *(sqrt(dst.xyz)-dst.xyz);\n"
"            f = f3;\n"
"            sel1 = lessThanEqual(src.xyz, vec3(0.5));\n"
"            f = mix(f, f1, sel1);\n"
"            sel2 = lessThanEqual(dst.xyz, vec3(0.25));\n"
"            f = mix(f, f2, sel2);\n"
"            f = mix(f, f1, sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE) {\n"
"            float minbase = min(min(src.x, src.y), src.z);\n"
"            float maxbase = max(max(src.x, src.y), src.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(dst.x, dst.y), dst.z);\n"
"            float maxsat = max(max(dst.x, dst.y), dst.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (src.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION) {\n"
"            float minbase = min(min(dst.x, dst.y), dst.z);\n"
"            float maxbase = max(max(dst.x, dst.y), dst.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(src.x, src.y), src.z);\n"
"            float maxsat = max(max(src.x, src.y), src.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (dst.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR) {\n"
"            float lbase = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;\n"
"            float llum = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = src.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY) {\n"
"            float lbase = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float llum = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = dst.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

gctSTRING gcLib_3instMixFunc =
NL
NL "float _viv_mix_float(float x, float y, float a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec2 _viv_mix_vec2(vec2 x, vec2 y, float a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec3 _viv_mix_vec3(vec3 x, vec3 y, float a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec4 _viv_mix_vec4(vec4 x, vec4 y, float a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec2 _viv_mix_vec2_vec2(vec2 x, vec2 y, vec2 a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec3 _viv_mix_vec3_vec3(vec3 x, vec3 y, vec3 a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec4 _viv_mix_vec4_vec4(vec4 x, vec4 y, vec4 a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL ;

gctSTRING gcLib_2instMixFunc =
NL
NL "float _viv_mix_float(float x, float y, float a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec2 _viv_mix_vec2(vec2 x, vec2 y, float a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec3 _viv_mix_vec3(vec3 x, vec3 y, float a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec4 _viv_mix_vec4(vec4 x, vec4 y, float a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec2 _viv_mix_vec2_vec2(vec2 x, vec2 y, vec2 a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec3 _viv_mix_vec3_vec3(vec3 x, vec3 y, vec3 a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec4 _viv_mix_vec4_vec4(vec4 x, vec4 y, vec4 a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL ;

gctSTRING gcLibCommon_Func =
NL "float _viv_round_float(float x)"
NL "{"
NL "    /* sign(x) * floor((abs(x) + 0.5)) */"
NL "    float sgn = sign(x);"
NL "    float tmp0, tmp1, tmp2;"
NL "    _viv_asm(ABS, tmp0, x);"
NL "    _viv_asm(ADD!<rnd:RTZ>, tmp1, tmp0, 0.5);"
NL "    _viv_asm(FLOOR, tmp2, tmp1);"
NL "    return sgn * tmp2;"
NL "}"
NL
NL "vec2 _viv_round_vec2(vec2 x)"
NL "{"
NL "    /* sign(x) * floor((abs(x) + 0.5)) */"
NL "    vec2 sgn = sign(x);"
NL "    vec2 tmp0, tmp1, tmp2;"
NL "    _viv_asm(ABS, tmp0, x);"
NL "    _viv_asm(ADD!<rnd:RTZ>, tmp1, tmp0, 0.5);"
NL "    _viv_asm(FLOOR, tmp2, tmp1);"
NL "    return sgn * tmp2;"
NL "}"
NL
NL "vec3 _viv_round_vec3(vec3 x)"
NL "{"
NL "    /* sign(x) * floor((abs(x) + 0.5)) */"
NL "    vec3 sgn = sign(x);"
NL "    vec3 tmp0, tmp1, tmp2;"
NL "    _viv_asm(ABS, tmp0, x);"
NL "    _viv_asm(ADD!<rnd:RTZ>, tmp1, tmp0, 0.5);"
NL "    _viv_asm(FLOOR, tmp2, tmp1);"
NL "    return sgn * tmp2;"
NL "}"
NL
NL "vec4 _viv_round_vec4(vec4 x)"
NL "{"
NL "    /* sign(x) * floor((abs(x) + 0.5)) */"
NL "    vec4 sgn = sign(x);"
NL "    vec4 tmp0, tmp1, tmp2;"
NL "    _viv_asm(ABS, tmp0, x);"
NL "    _viv_asm(ADD!<rnd:RTZ>, tmp1, tmp0, 0.5);"
NL "    _viv_asm(FLOOR, tmp2, tmp1);"
NL "    return sgn * tmp2;"
NL "}"
NL
NL "float _viv_roundEven_float(float x)"
NL "{"
NL "    const float epsilon = 0.0000001;"
NL "    float fraction;"
NL "    float integerPart;"
NL "    highp float absVal = abs(x);"
NL "    fraction = _viv_modf_float(absVal, integerPart);"
NL "    if (fraction == 0.5)"
NL "    {"
NL "        /* half way */;"
NL "        float sgn = sign(x);"
NL "        if (mod(integerPart, 2.0) < epsilon)"
NL "        {"
NL "            return sgn*integerPart;"
NL "        }"
NL "        else {"
NL "            return sgn*(integerPart + 1.0);"
NL "        }"
NL "    }"
NL "    else {"
NL "        return _viv_round_float(x);"
NL "    }"
NL "}"
NL
NL "vec2 _viv_roundEven_vec2(vec2 x)"
NL "{"
NL "    vec2 tmp0;"
NL "    tmp0.x = _viv_roundEven_float(x.x);"
NL "    tmp0.y = _viv_roundEven_float(x.y);"
NL "    return tmp0;"
NL "}"
NL
NL "vec3 _viv_roundEven_vec3(vec3 x)"
NL "{"
NL "    vec3 tmp0;"
NL "    tmp0.x = _viv_roundEven_float(x.x);"
NL "    tmp0.y = _viv_roundEven_float(x.y);"
NL "    tmp0.z = _viv_roundEven_float(x.z);"
NL "    return tmp0;"
NL "}"
NL
NL "vec4 _viv_roundEven_vec4(vec4 x)"
NL "{"
NL "    vec4 tmp0;"
NL "    tmp0.x = _viv_roundEven_float(x.x);"
NL "    tmp0.y = _viv_roundEven_float(x.y);"
NL "    tmp0.z = _viv_roundEven_float(x.z);"
NL "    tmp0.w = _viv_roundEven_float(x.w);"
NL "    return tmp0;"
NL "}"
NL "float _viv_determinant_vec2(vec2 a, vec2 b)"
NL "{"
NL "    vec2 temp = a * b.yx;"
NL "    return (temp.x - temp.y);"
NL "}"
NL "float _viv_determinant_vec3(vec3 a, vec3 b, vec3 c)"
NL "{"
NL "    vec3 temp;"
NL "    temp.x = _viv_determinant_vec2(b.yz, c.yz);"
NL "    temp.y = _viv_determinant_vec2(b.zx, c.zx);"
NL "    temp.z = _viv_determinant_vec2(b.xy, c.xy);"
NL "    float result = dot(a.xyz, temp.xyz);"
NL "    return result;"
NL "}"
NL "float _viv_determinant_vec4(vec4 a, vec4 b, vec4 c, vec4 d)"
NL "{"
NL "    vec4 temp;"
NL "    temp.x = _viv_determinant_vec3(b.yzw, c.yzw, d.yzw);"
NL "    temp.y = _viv_determinant_vec3(b.wzx, c.wzx, d.wzx);"
NL "    temp.z = _viv_determinant_vec3(b.xyw, c.xyw, d.xyw);"
NL "    temp.w = _viv_determinant_vec3(b.zyx, c.zyx, d.zyx);"
NL "    float result = dot(a.xyzw, temp.xyzw);"
NL "    return result;"
NL "}"
NL "mat2 _viv_matrixinverse_vec2(vec2 a, vec2 b)"
NL "{"
NL "    float f = 1.0f / (a.x * b.y - b.x * a.y);"
NL "    mat2 result;"
NL "    result[0].x =  b.y * f;"
NL "    result[0].y =  -a.y * f;"
NL "    result[1].x =  -b.x * f;"
NL "    result[1].y =  a.x * f;"
NL "    return result;"
NL "}"
NL "mat3 _viv_matrixinverse_vec3(vec3 a, vec3 b, vec3 c)"
NL "{"
NL "    float f = 1.0f / _viv_determinant_vec3(a, b, c);"
NL "    mat3 result;"
NL "    result[0].x =  _viv_determinant_vec2(b.yz, c.yz) * f;"
NL "    result[1].x = -_viv_determinant_vec2(b.xz, c.xz) * f;"
NL "    result[2].x =  _viv_determinant_vec2(b.xy, c.xy) * f;"
NL "    result[0].y = -_viv_determinant_vec2(a.yz, c.yz) * f;"
NL "    result[1].y =  _viv_determinant_vec2(a.xz, c.xz) * f;"
NL "    result[2].y = -_viv_determinant_vec2(a.xy, c.xy) * f;"
NL "    result[0].z =  _viv_determinant_vec2(a.yz, b.yz) * f;"
NL "    result[1].z = -_viv_determinant_vec2(a.xz, b.xz) * f;"
NL "    result[2].z =  _viv_determinant_vec2(a.xy, b.xy) * f;"
NL "    return result;"
NL "}"
NL "mat4 _viv_matrixinverse_vec4(vec4 a, vec4 b, vec4 c, vec4 d)"
NL "{"
NL "    float f = 1.0f / _viv_determinant_vec4(a, b, c, d);"
NL "    mat4 result;"
NL "    result[0].x =  _viv_determinant_vec3(b.yzw, c.yzw, d.yzw) * f;"
NL "    result[1].x = -_viv_determinant_vec3(b.xzw, c.xzw, d.xzw) * f;"
NL "    result[2].x =  _viv_determinant_vec3(b.xyw, c.xyw, d.xyw) * f;"
NL "    result[3].x = -_viv_determinant_vec3(b.xyz, c.xyz, d.xyz) * f;"
NL "    result[0].y = -_viv_determinant_vec3(a.yzw, c.yzw, d.yzw) * f;"
NL "    result[1].y =  _viv_determinant_vec3(a.xzw, c.xzw, d.xzw) * f;"
NL "    result[2].y = -_viv_determinant_vec3(a.xyw, c.xyw, d.xyw) * f;"
NL "    result[3].y =  _viv_determinant_vec3(a.xyz, c.xyz, d.xyz) * f;"
NL "    result[0].z =  _viv_determinant_vec3(a.yzw, b.yzw, d.yzw) * f;"
NL "    result[1].z = -_viv_determinant_vec3(a.xzw, b.xzw, d.xzw) * f;"
NL "    result[2].z =  _viv_determinant_vec3(a.xyw, b.xyw, d.xyw) * f;"
NL "    result[3].z = -_viv_determinant_vec3(a.xyz, b.xyz, d.xyz) * f;"
NL "    result[0].w = -_viv_determinant_vec3(a.yzw, b.yzw, c.yzw) * f;"
NL "    result[1].w =  _viv_determinant_vec3(a.xzw, b.xzw, c.xzw) * f;"
NL "    result[2].w = -_viv_determinant_vec3(a.xyw, b.xyw, c.xyw) * f;"
NL "    result[3].w =  _viv_determinant_vec3(a.xyz, b.xyz, c.xyz) * f;"
NL "    return result;"
NL "}"
NL ;

gctSTRING gcLibInterpolateCommon =
NL "#define INTERPOLATE_AT_CENTROID                            0"
NL "#define INTERPOLATE_AT_SAMPLE                              1"
NL "#define INTERPOLATE_AT_CENTER                              2"
NL "bool _viv_calculate_sample_mask(uint sampleMaskIn, vec4 sampleLocation[4], out vec4 newLocation)"
NL "{"
NL "    newLocation = vec4(0.0);"
NL "    ivec4 mask = ivec4(0);"
NL "    int count = 0;"
NL "    if ((sampleMaskIn & 0x1u) != 0u) mask.x = 1;"
NL "    if ((sampleMaskIn & 0x2u) != 0u) mask.y = 1;"
NL "    if ((sampleMaskIn & 0x4u) != 0u) mask.z = 1;"
NL "    if ((sampleMaskIn & 0x8u) != 0u) mask.w = 1;"
NL "    if (mask.x + mask.y + mask.z + mask.w >= 3)"
NL "        return false;"
NL "    for (int i = 0; i < 4; i++)"
NL "    {"
NL "        if (mask[i] == 1)"
NL "        {"
NL "            newLocation += sampleLocation[i];"
NL "            count++;"
NL "        }"
NL "    }"
NL "    if (count == 0)"
NL "        return false;"
NL "    newLocation = newLocation / float(count);"
NL "    return true;"
NL "}"
NL
NL "vec4 _viv_GetVaryingValueAtCenter(vec4 interpolant, int interpolateType, vec4 position,"
NL "                                  bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    vec4 newInterpolant = interpolant;"
NL "    vec4 newInterpolant1 = newInterpolant * position.w;"
NL "    vec4 dsx_v = dFdx(newInterpolant1);"
NL "    vec4 dsy_v = dFdy(newInterpolant1);"
NL "    if (!multiSampleBuffer) return newInterpolant;"
NL "    if (underSampleShading || interpolateType == INTERPOLATE_AT_SAMPLE)"
NL "    {"
NL "        vec4 newSampleLocation = sampleLocation[sampleId];"
NL "        newInterpolant1 += dsx_v * (0.5 - newSampleLocation.x) + dsy_v * (0.5 - newSampleLocation.y);"
NL "        newInterpolant = newInterpolant1 / position.w;"
NL "    }"
NL "    return newInterpolant;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtCentroid_float =
NL "float _viv_interpolateAtCentroid_float(float interpolant,"
NL "                                       int interpolateType, vec4 position,"
NL "                                       bool multiSampleBuffer, bool underSampleShading, int sampleId, int sampleMaskIn, vec4 sampleLocation[4])"
NL "{"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).x;"
NL "    uint maskin = uint(sampleMaskIn);"
NL "    vec4 newSampleLocation = vec4(0.0);"
NL "    float newInterpolant = interpolant;"
NL "    float newInterpolant1 = newInterpolant * position.w;"
NL "    float dsx_v = dFdx(newInterpolant1);"
NL "    float dsy_v = dFdy(newInterpolant1);"
NL "    if (_viv_calculate_sample_mask(maskin, sampleLocation, newSampleLocation))"
NL "    {"
NL "        newInterpolant1 += dsx_v * (newSampleLocation.x - 0.5) + dsy_v * (newSampleLocation.y - 0.5);"
NL "        newInterpolant = newInterpolant1 / position.w;"
NL "    }"
NL "    return newInterpolant;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtCentroid_vec2 =
NL "vec2 _viv_interpolateAtCentroid_vec2(vec2 interpolant,"
NL "                                     int interpolateType, vec4 position,"
NL "                                     bool multiSampleBuffer, bool underSampleShading, int sampleId, int sampleMaskIn, vec4 sampleLocation[4])"
NL "{"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    uint maskin = uint(sampleMaskIn);"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xy;"
NL "    vec4 newSampleLocation = vec4(0.0);"
NL "    vec2 newInterpolant = interpolant;"
NL "    vec2 newInterpolant1 = newInterpolant * position.w;"
NL "    vec2 dsx_v = dFdx(newInterpolant1);"
NL "    vec2 dsy_v = dFdy(newInterpolant1);"
NL "    if (_viv_calculate_sample_mask(maskin, sampleLocation, newSampleLocation))"
NL "    {"
NL "        newInterpolant1 += dsx_v * (newSampleLocation.x - 0.5) + dsy_v * (newSampleLocation.y - 0.5);"
NL "        newInterpolant = newInterpolant1 / position.w;"
NL "    }"
NL "    return newInterpolant;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtCentroid_vec3 =
NL "vec3 _viv_interpolateAtCentroid_vec3(vec3 interpolant,"
NL "                                     int interpolateType, vec4 position,"
NL "                                     bool multiSampleBuffer, bool underSampleShading, int sampleId, int sampleMaskIn, vec4 sampleLocation[4])"
NL "{"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xyz;"
NL "    uint maskin = uint(sampleMaskIn);"
NL "    vec4 newSampleLocation = vec4(0.0);"
NL "    vec3 newInterpolant = interpolant;"
NL "    vec3 newInterpolant1 = newInterpolant * position.w;"
NL "    vec3 dsx_v = dFdx(newInterpolant1);"
NL "    vec3 dsy_v = dFdy(newInterpolant1);"
NL "    if (_viv_calculate_sample_mask(maskin, sampleLocation, newSampleLocation))"
NL "    {"
NL "        newInterpolant1 += dsx_v * (newSampleLocation.x - 0.5) + dsy_v * (newSampleLocation.y - 0.5);"
NL "        newInterpolant = newInterpolant1 / position.w;"
NL "    }"
NL "    return newInterpolant;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtCentroid_vec4 =
NL "vec4 _viv_interpolateAtCentroid_vec4(vec4 interpolant,"
NL "                                     int interpolateType, vec4 position,"
NL "                                     bool multiSampleBuffer, bool underSampleShading, int sampleId, int sampleMaskIn, vec4 sampleLocation[4])"
NL "{"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(interpolant, interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation);"
NL "    uint maskin = uint(sampleMaskIn);"
NL "    vec4 newSampleLocation = vec4(0.0);"
NL "    vec4 newInterpolant = interpolant;"
NL "    vec4 newInterpolant1 = newInterpolant * position.w;"
NL "    vec4 dsx_v = dFdx(newInterpolant1);"
NL "    vec4 dsy_v = dFdy(newInterpolant1);"
NL "    if (_viv_calculate_sample_mask(maskin, sampleLocation, newSampleLocation))"
NL "    {"
NL "        newInterpolant1 += dsx_v * (newSampleLocation.x - 0.5) + dsy_v * (newSampleLocation.y - 0.5);"
NL "        newInterpolant = newInterpolant1 / position.w;"
NL "    }"
NL "    return newInterpolant;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtSample_float =
NL "float _viv_interpolateAtSample_float(float interpolant, int sampleIndex,"
NL "                                     int interpolateType,"
NL "                                     vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    if (sampleIndex > 3) return interpolant;"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).x;"
NL "    vec4 newSampleLocation = sampleLocation[sampleIndex];"
NL "    float newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * (newSampleLocation.x - 0.5) + dFdy(newInterpolant) * (newSampleLocation.y - 0.5);"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtSample_vec2 =
NL "vec2 _viv_interpolateAtSample_vec2(vec2 interpolant, int sampleIndex,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    if (sampleIndex > 3) return interpolant;"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xy;"
NL "    vec4 newSampleLocation = sampleLocation[sampleIndex];"
NL "    vec2 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * (newSampleLocation.x - 0.5) + dFdy(newInterpolant) * (newSampleLocation.y - 0.5);"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtSample_vec3 =
NL "vec3 _viv_interpolateAtSample_vec3(vec3 interpolant, int sampleIndex,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"

NL "    if (sampleIndex > 3) return interpolant;"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xyz;"
NL "    vec4 newSampleLocation = sampleLocation[sampleIndex];"
NL "    vec3 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * (newSampleLocation.x - 0.5) + dFdy(newInterpolant) * (newSampleLocation.y - 0.5);"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtSample_vec4 =
NL "vec4 _viv_interpolateAtSample_vec4(vec4 interpolant, int sampleIndex,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    if (sampleIndex > 3) return interpolant;"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(interpolant, interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation);"
NL "    vec4 newSampleLocation = sampleLocation[sampleIndex];"
NL "    vec4 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * (newSampleLocation.x - 0.5) + dFdy(newInterpolant) * (newSampleLocation.y - 0.5);"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtOffset_float =
NL "float _viv_interpolateAtOffset_float(float interpolant, vec2 offset,"
NL "                                     int interpolateType,"
NL "                                     vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).x;"
NL "    float newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * offset.x + dFdy(newInterpolant) * offset.y;"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtOffset_vec2 =
NL "vec2 _viv_interpolateAtOffset_vec2(vec2 interpolant, vec2 offset,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xy;"
NL "    vec2 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * offset.x + dFdy(newInterpolant) * offset.y;"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtOffset_vec3 =
NL "vec3 _viv_interpolateAtOffset_vec3(vec3 interpolant, vec2 offset,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xyz;"
NL "    vec3 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * offset.x + dFdy(newInterpolant) * offset.y;"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

gctSTRING gcLibInterpolateAtOffset_vec4 =
NL "vec4 _viv_interpolateAtOffset_vec4(vec4 interpolant,vec2 offset,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    interpolant = _viv_GetVaryingValueAtCenter(interpolant, interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation);"
NL "    vec4 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * offset.x + dFdy(newInterpolant) * offset.y;"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

/* texld for sampler1DArray */
gctSTRING gcLibTexLd_sampler_1d_array =
NL "vec4 _viv_texld_sampler_1d_array(sampler2DArray sampler, vec2 coord)"
NL "{"
NL "    vec4 result;"
NL "    vec3 newCoord = vec3(coord.x, 0.0, coord.y);"
NL "    newCoord.z = max(0.0, floor(newCoord.z + 0.5));"
NL "    _viv_asm(TEXLD, result, sampler, newCoord);"
NL "    return result;"
NL "}"
NL ;
gctSTRING gcLibTexLd_sampler_1d_array_lod =
NL "vec4 _viv_texld_sampler_1d_array_lod(sampler2DArray sampler, vec2 coord, float lod)"
NL "{"
NL "    vec4 result;"
NL "    vec3 newCoord = vec3(coord.x, 0.0, coord.y);"
NL "    newCoord.z = max(0.0, floor(newCoord.z + 0.5));"
NL "    _viv_asm(TEXLOD, result, sampler, lod);"
NL "    _viv_asm(TEXLD, result, sampler, newCoord);"
NL "    return result;"
NL "}"
NL ;
gctSTRING gcLibTexLd_sampler_1d_array_bias =
NL "vec4 _viv_texld_sampler_1d_array_bias(sampler2DArray sampler, vec2 coord, float bias)"
NL "{"
NL "    vec4 result;"
NL "    vec3 newCoord = vec3(coord.x, 0.0, coord.y);"
NL "    newCoord.z = max(0.0, floor(newCoord.z + 0.5));"
NL "    _viv_asm(TEXBIAS, result, sampler, bias);"
NL "    _viv_asm(TEXLD, result, sampler, newCoord);"
NL "    return result;"
NL "}"
NL ;
/* texld for sampler2DArray */
gctSTRING gcLibTexLd_sampler_2d_array =
NL "vec4 _viv_texld_sampler_2d_array(sampler2DArray sampler, vec3 coord)"
NL "{"
NL "    vec4 result;"
NL "    vec3 newCoord = vec3(coord);"
NL "    newCoord.z = max(0.0, floor(newCoord.z + 0.5));"
NL "    _viv_asm(TEXLD, result, sampler, newCoord);"
NL "    return result;"
NL "}"
NL ;
gctSTRING gcLibTexLd_sampler_2d_array_lod =
NL "vec4 _viv_texld_sampler_2d_array_lod(sampler2DArray sampler, vec3 coord, float lod)"
NL "{"
NL "    vec4 result;"
NL "    vec3 newCoord = vec3(coord);"
NL "    newCoord.z = max(0.0, floor(newCoord.z + 0.5));"
NL "    _viv_asm(TEXLOD, result, sampler, lod);"
NL "    _viv_asm(TEXLD, result, sampler, newCoord);"
NL "    return result;"
NL "}"
NL ;
gctSTRING gcLibTexLd_sampler_2d_array_bias =
NL "vec4 _viv_texld_sampler_2d_array_bias(sampler2DArray sampler, vec3 coord, float bias)"
NL "{"
NL "    vec4 result;"
NL "    vec3 newCoord = vec3(coord);"
NL "    newCoord.z = max(0.0, floor(newCoord.z + 0.5));"
NL "    _viv_asm(TEXBIAS, result, sampler, bias);"
NL "    _viv_asm(TEXLD, result, sampler, newCoord);"
NL "    return result;"
NL "}"
NL ;

/* opengl version to getLocalID
 * input variable "glLocalinvocationIndex" will be replaced by
 *  Compute local invocation index :
 *          Z * I * J + Y * I + X
 *          where local Id = (X, Y, Z) and
 *                work group size = (I, J, K)
 * like builtin input "gl_LocalInvocationIndex", see VirShader_GenInvocationIndex
 */
gctSTRING gcGLLibGetLocalID =
NL "in int glLocalinvocationIndex;"
NL "int _viv_getLocalID()"
NL "{"
NL "    return glLocalinvocationIndex;"
NL "}"
NL ;

/* atomicpatch lib function, Atomcmpxchg patch functions are put in another string
 * because the second argument is different between opencl and opengl versions
 */
gctSTRING gcGLLib_AtomcmpxchgPatch_Func_core1_Str =
"int _atomcmpxchg_int_uint_ivec2_core1(uint a, ivec2 val)"
NL "{"
NL "    int tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0x3;"
NL "    int result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL "uint _atomcmpxchg_uint_uint_uvec2_core1(uint a, uvec2 val)"
NL "{"
NL "    int tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0x3;"
NL "    uint result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL "float _atomcmpxchg_float_uint_vec2_core1(uint a, vec2 val)"
NL "{"
NL "    int tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0x3;"
NL "    float result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL;

gctSTRING gcGLLib_AtomcmpxchgPatch_Func_core2_Str =
"int _atomcmpxchg_int_uint_ivec2_core2(uint a, ivec2 val)"
NL "{"
NL "    int tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0x7;"
NL "    int result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 4:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 5:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 6:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 7:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL "uint _atomcmpxchg_uint_uint_uvec2_core2(uint a, uvec2 val)"
NL "{"
NL "    int tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0x7;"
NL "    uint result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 4:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 5:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 6:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 7:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL "float _atomcmpxchg_float_uint_vec2_core2(uint a, vec2 val)"
NL "{"
NL "    int tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0x7;"
NL "    float result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 4:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 5:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 6:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 7:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL;

gctSTRING gcGLLib_AtomcmpxchgPatch_Func_core4_Str =
"int _atomcmpxchg_int_uint_ivec2_core4(uint a, ivec2 val)"
NL "{"
NL "    int  tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0xf;"
NL "    int result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 4:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 5:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 6:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 7:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 8:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 9:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 10:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 11:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 12:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 13:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 14:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 15:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL "uint _atomcmpxchg_uint_uint_uvec2_core4(uint a, uvec2 val)"
NL "{"
NL "    int  tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0xf;"
NL "    uint result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 4:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 5:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 6:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 7:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 8:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 9:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 10:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 11:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 12:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 13:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 14:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 15:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL "float _atomcmpxchg_float_uint_vec2_core4(uint a, vec2 val)"
NL "{"
NL "    int  tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0xf;"
NL "    float result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 4:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 5:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 6:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 7:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 8:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 9:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 10:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 11:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 12:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 13:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 14:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 15:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL;

gctSTRING gcGLLib_AtomcmpxchgPatch_Func_core8_Str =
"int _atomcmpxchg_int_uint_ivec2_core8(uint a, ivec2 val)"
NL "{"
NL "    int  tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0x1f;"
NL "    int result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 4:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 5:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 6:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 7:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 8:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 9:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 10:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 11:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 12:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 13:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 14:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 15:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 16:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 17:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 18:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 19:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 20:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 21:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 22:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 23:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 24:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 25:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 26:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 27:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 28:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 29:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 30:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 31:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL "uint _atomcmpxchg_uint_uint_uvec2_core8(uint a, uvec2 val)"
NL "{"
NL "    int  tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0x1f;"
NL "    uint result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 4:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 5:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 6:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 7:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 8:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 9:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 10:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 11:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 12:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 13:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 14:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 15:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 16:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 17:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 18:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 19:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 20:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 21:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 22:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 23:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 24:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 25:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 26:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 27:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 28:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 29:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 30:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 31:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL "float _atomcmpxchg_float_uint_vec2_core8(uint a, vec2 val)"
NL "{"
NL "    int  tid = _viv_getLocalID();"
NL "    int id_in_a_sh_group = tid & 0x1f;"
NL "    float result;"
NL "    switch(id_in_a_sh_group)"
NL "    {"
NL "        case 0:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 1:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 2:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 3:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 4:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 5:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 6:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 7:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 8:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 9:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 10:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 11:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 12:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 13:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 14:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 15:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 16:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 17:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 18:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 19:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 20:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 21:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 22:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 23:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 24:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 25:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 26:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 27:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 28:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 29:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 30:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "        case 31:"
NL "             _viv_asm(ATOMCMPXCHG, result, a, val);"
NL "             break;"
NL "    }"
NL "    return result;"
NL "}"
NL;

gctSTRING gcGLLibNoise_Funcs_Str =
/* A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm. */
NL "uint _viv_noise_hash(uint x )"
NL "{"
NL "    x += (x << 10u );"
NL "    x ^= (x >>  6u );"
NL "    x += (x <<  3u );"
NL "    x ^= (x >> 11u );"
NL "    x += (x << 15u );"
NL "    return x;"
NL "}"
/* Compound versions of the hashing algorithm */
NL "uint _viv_noise_hash_uvec2(uvec2 v )"
NL "{"
NL "    return _viv_noise_hash(v.x ^ _viv_noise_hash(v.y) );"
NL "}"
NL "uint _viv_noise_hash_uvec3(uvec3 v )"
NL "{"
NL "    return _viv_noise_hash(v.x ^ _viv_noise_hash(v.y) ^ _viv_noise_hash(v.z) );"
NL "}"
NL "uint _viv_noise_hash_uvec4(uvec4 v )"
NL "{"
NL "    return _viv_noise_hash(v.x ^ _viv_noise_hash(v.y) ^ _viv_noise_hash(v.z) ^ _viv_noise_hash(v.w) );"
NL "}"
/* Construct a float with half-open range [0:1] using low 23 bits.
   All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0. */
NL "float _viv_noise_randomFloat(uint m )"
NL "{"
NL "    const uint ieeeMantissa = 0x007FFFFFu;" /* binary32 mantissa bitmask */
NL "    const uint ieeeOne      = 0x3F800000u;" /* 1.0 in IEEE binary32 */
NL "    float tmp;"
NL "    m &= ieeeMantissa;"                     /* Keep only mantissa bits (fractional part) */
NL "    m |= ieeeOne;"                          /* Add fractional part to 1.0 */
NL "    _viv_asm(MOV, tmp, m);"                   /* Range [1:2] */
NL "    return tmp - 1.0;"                        /* Range [0:1] */
NL "}"
/* Pseudo-random value in half-open range [0:1].*/
NL "float _viv_noise1_float(float x )"
NL "{"
NL "    uint tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "     return _viv_noise_randomFloat(_viv_noise_hash(tmp));"
NL "}"
NL "float _viv_noise1_vec2(vec2 x )"
NL "{"
NL "    uvec2 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "     return _viv_noise_randomFloat(_viv_noise_hash_uvec2(tmp));"
NL "}"
NL "float _viv_noise1_vec3(vec3 x )"
NL "{"
NL "    uvec3 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "     return _viv_noise_randomFloat(_viv_noise_hash_uvec3(tmp));"
NL "}"
NL "float _viv_noise1_vec4(vec4 x )"
NL "{"
NL "    uvec4 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "     return _viv_noise_randomFloat(_viv_noise_hash_uvec4(tmp));"
NL "}"
NL "vec2 _viv_noise2_float(float x )"
NL "{"
NL "    uint tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec2(_viv_noise_randomFloat(_viv_noise_hash(tmp)));"
NL "}"
NL "vec2 _viv_noise2_vec2(vec2 x )"
NL "{"
NL "    uvec2 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec2(_viv_noise_randomFloat(_viv_noise_hash_uvec2(tmp)));"
NL "}"
NL "vec2 _viv_noise2_vec3(vec3 x )"
NL "{"
NL "    uvec3 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec2(_viv_noise_randomFloat(_viv_noise_hash_uvec3(tmp)));"
NL "}"
NL "vec2 _viv_noise2_vec4(vec4 x )"
NL "{"
NL "    uvec4 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec2(_viv_noise_randomFloat(_viv_noise_hash_uvec4(tmp)));"
NL "}"
NL "vec3 _viv_noise3_float(float x )"
NL "{"
NL "    uint tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec3(_viv_noise_randomFloat(_viv_noise_hash(tmp)));"
NL "}"
NL "vec3 _viv_noise3_vec2(vec2 x )"
NL "{"
NL "    uvec2 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec3(_viv_noise_randomFloat(_viv_noise_hash_uvec2(tmp)));"
NL "}"
NL "vec3 _viv_noise3_vec3(vec3 x )"
NL "{"
NL "    uvec3 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec3(_viv_noise_randomFloat(_viv_noise_hash_uvec3(tmp)));"
NL "}"
NL "vec3 _viv_noise3_vec4(vec4 x )"
NL "{"
NL "    uvec4 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec3(_viv_noise_randomFloat(_viv_noise_hash_uvec4(tmp)));"
NL "}"
NL "vec4 _viv_noise4_float(float x )"
NL "{"
NL "    uint tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec4(_viv_noise_randomFloat(_viv_noise_hash(tmp)));"
NL "}"
NL "vec4 _viv_noise4_vec2(vec2 x )"
NL "{"
NL "    uvec2 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec4(_viv_noise_randomFloat(_viv_noise_hash_uvec2(tmp)));"
NL "}"
NL "vec4 _viv_noise4_vec3(vec3 x )"
NL "{"
NL "    uvec3 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec4(_viv_noise_randomFloat(_viv_noise_hash_uvec3(tmp)));"
NL "}"
NL "vec4 _viv_noise4_vec4(vec4 x )"
NL "{"
NL "    uvec4 tmp;"
NL "    _viv_asm(MOV, tmp, x);"
NL "    return vec4(_viv_noise_randomFloat(_viv_noise_hash_uvec4(tmp)));"
NL "}"
NL;
#undef NL

