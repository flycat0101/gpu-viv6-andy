/****************************************************************************
*
*    Copyright (c) 2005 - 2016 by Vivante Corp.  All rights reserved.
*
*    The material in this file is confidential and contains trade secrets
*    of Vivante Corporation. This is proprietary information owned by
*    Vivante Corporation. No part of this work may be disclosed,
*    reproduced, copied, transmitted, or used in any way for any purpose,
*    without the express written permission of Vivante Corporation.
*
*****************************************************************************/


#ifndef __gc_vsc_gl_builtin_lib_h_
#define __gc_vsc_gl_builtin_lib_h_

#define __BUILTIN_SHADER_LENGTH__ (65535 * 8)
#define NL "\n"

static gctSTRING gcLibFunc_Extension =
"#version 310 es\n"
"#extension GL_VIV_asm: enable\n"
;

static gctSTRING gcLibFunc_Extension_For_TexMS2DArray =
"#extension GL_OES_texture_storage_multisample_2d_array:    enable\n"
;

static gctSTRING gcLibFunc_Extension_For_CubeMapArray =
"#extension GL_EXT_texture_cube_map_array :                 require\n"
;

static gctSTRING gcLibFunc_Extension_For_TextureBuffer =
"#extension GL_EXT_texture_buffer :                         require\n"
;

static gctSTRING gcLibFunc_Extension_For_MSShading     =
"#extension GL_OES_shader_multisample_interpolation :       require\n"
"#extension GL_OES_sample_variables :                       require\n"
;

static gctSTRING gcLibFunc_BuiltinHeader =
"#define MIN_PROGRAM_TEXTURE_GATHER_OFFSET                  -8 \n"
"#define MAX_PROGRAM_TEXTURE_GATHER_OFFSET                  7 \n"
"#define MAX_TEXTURE_BUFFER_SIZE                            16384 \n"
"out vec4 fragColor;\n"
"void main(void)\n"
"{\n"
"    fragColor = vec4(0.0);\n"
"}\n"
"\n";

static gctSTRING gcLibFunc_BlendEquationHeader =
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_MULTIPLY         0x1 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_OVERLAY          0x2 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DARKEN           0x4 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_LIGHTEN          0x8 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE       0x10 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN        0x20 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HARDLIGHT        0x40 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT        0x80 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DIFFERENCE       0x100 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_EXCLUSION        0x200 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE          0x400 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION   0x800 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR        0x1000 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY   0x2000 \n"
"#define gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SCREEN           0x4000 \n"
"precision highp float;\n"
"precision highp sampler2D;\n"
"precision highp sampler3D;\n"
"precision highp isampler2D;\n"
"precision highp isampler3D;\n"
"precision highp usampler2D;\n"
"precision highp usampler3D;\n"
"out vec4 fragColor;\n"
"void main(void)\n"
"{\n"
"    fragColor = vec4(0.0);\n"
"}\n"
"\n";

/* To meet the dQEP asin/acos/acosh/atan/atan2 accuracy, we have to use the following builtint function */
static gctSTRING gcLibASIN_ACOS_Funcs_Common =
"float _viv_asin_base_1(float a)\n"
"{\n"
"   float temp  = a * a;\n"
"   float result = a * (1.0004488056969831f+ temp*(0.15295127520390661f + temp* 0.13409603620943705f));\n"
"   return result;\n"
"}\n"
"vec2 _viv_asin_base_2(vec2 a)\n"
"{\n"
"   vec2 temp  = a * a;\n"
"   vec2 result = a * (vec2(1.0004488056969831f) + temp*(vec2(0.15295127520390661f) + temp* vec2(0.13409603620943705f)));\n"
"   return result;\n"
"}\n"
"vec3 _viv_asin_base_3(vec3 a)\n"
"{\n"
"   vec3 temp  = a * a;\n"
"   vec3 result = a * (vec3(1.0004488056969831f)+ temp*(vec3(0.15295127520390661f) + temp* vec3(0.13409603620943705f)));\n"
"   return result;\n"
"}\n"
"vec4 _viv_asin_base_4(vec4 a)\n"
"{\n"
"   vec4 temp  = a * a;\n"
"   vec4 result = a * (vec4(1.0004488056969831f) + temp*(vec4(0.15295127520390661f) + temp* vec4(0.13409603620943705f)));\n"
"   return result;\n"
"}\n"
"float _viv_asin_1(float a)\n"
"{\n"
"   float result;\n"
"   if (abs(a) < 0.7072f)\n"
"   {\n"
"       result = _viv_asin_base_1(a);\n"
"   } else {\n"
"       result = (3.14159265358979323846f/2.0f - _viv_asin_base_1(sqrt(1.0f - a * a))) * sign(a);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibASIN_Funcs_halti0 =
"vec2 _viv_asin_2(vec2 a)\n"
"{\n"
"   vec2 result, result1;\n"
"   bvec2 sel = lessThan(abs(a), vec2(0.7072f));\n"
"   result1 = (vec2(3.14159265358979323846f/2.0f) - _viv_asin_base_2(sqrt(vec2(1.0f) - a * a))) * sign(a);\n"
"   result = mix(result1, _viv_asin_base_2(a), sel);\n"
"   return result;\n"
"}\n"
"vec3 _viv_asin_3(vec3 a)\n"
"{\n"
"   vec3 result, result1;\n"
"   bvec3 sel = lessThan(abs(a), vec3(0.7072f));\n"
"   result1 = (vec3(3.14159265358979323846f/2.0f) - _viv_asin_base_3(sqrt(vec3(1.0f) - a * a))) * sign(a);\n"
"   result = mix(result1, _viv_asin_base_3(a), sel);\n"
"   return result;\n"
"}\n"
"vec4 _viv_asin_4(vec4 a)\n"
"{\n"
"   vec4 result, result1;\n"
"   bvec4 sel = lessThan(abs(a), vec4(0.7072f));\n"
"   result1 = (vec4(3.14159265358979323846f/2.0f) - _viv_asin_base_4(sqrt(vec4(1.0f) - a * a))) * sign(a);\n"
"   result = mix(result1, _viv_asin_base_4(a), sel);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibASIN_Funcs =
"vec2 _viv_asin_2(vec2 a)\n"
"{\n"
"   vec2 result, result1;\n"
"   result = (vec2(3.14159265358979323846f/2.0f) - _viv_asin_base_2(sqrt(vec2(1.0f) - a * a))) * sign(a);\n"
"   result1 = _viv_asin_base_2(a);\n"
"   if (abs(a.x) < 0.7072f)\n"
"       result.x = result1.x;\n"
"   if (abs(a.y) < 0.7072f)\n"
"       result.y = result1.y;\n"
"   return result;\n"
"}\n"
"vec3 _viv_asin_3(vec3 a)\n"
"{\n"
"   vec3 result, result1;\n"
"   result = (vec3(3.14159265358979323846f/2.0f) - _viv_asin_base_3(sqrt(vec3(1.0f) - a * a))) * sign(a);\n"
"   result1 = _viv_asin_base_3(a);\n"
"   if (abs(a.x) < 0.7072f)\n"
"       result.x = result1.x;\n"
"   if (abs(a.y) < 0.7072f)\n"
"       result.y = result1.y;\n"
"   if (abs(a.z) < 0.7072f)\n"
"       result.z = result1.z;\n"
"   return result;\n"
"}\n"
"vec4 _viv_asin_4(vec4 a)\n"
"{\n"
"   vec4 result, result1;\n"
"   result = (vec4(3.14159265358979323846f/2.0f) - _viv_asin_base_4(sqrt(vec4(1.0f) - a * a))) * sign(a);\n"
"   result1 = _viv_asin_base_4(a);\n"
"   if (abs(a.x) < 0.7072f)\n"
"       result.x = result1.x;\n"
"   if (abs(a.y) < 0.7072f)\n"
"       result.y = result1.y;\n"
"   if (abs(a.z) < 0.7072f)\n"
"       result.z = result1.z;\n"
"   if (abs(a.w) < 0.7072f)\n"
"       result.w = result1.w;\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibACOS_Funcs =
"float _viv_acos_1(float a)\n"
"{\n"
"   float result = 3.14159265358979323846f/2.0f - _viv_asin_1(a);\n"
"   return result;\n"
"}\n"
"vec2 _viv_acos_2(vec2 a)\n"
"{\n"
"   vec2 result = vec2(3.14159265358979323846f/2.0f) -  _viv_asin_2(a);\n"
"   return result;\n"
"}\n"
"vec3 _viv_acos_3(vec3 a)\n"
"{\n"
"   vec3 result = vec3(3.14159265358979323846f/2.0f) -  _viv_asin_3(a);\n"
"   return result;\n"
"}\n"
"vec4 _viv_acos_4(vec4 a)\n"
"{\n"
"   vec4 result = vec4(3.14159265358979323846f/2.0f) -  _viv_asin_4(a);\n"
"   return result;\n"
"}\n";
static gctSTRING gcLibATAN_Funcs =
"float _viv_atan_1(float a)\n"
"{\n"
"   float result;\n"
"   _viv_asm(ATAN, result, a);\n"
"   return result;\n"
"}\n"
"vec2 _viv_atan_2(vec2 a)\n"
"{\n"
"   vec2 result;\n"
"   _viv_asm(ATAN, result, a);\n"
"   return result;\n"
"}\n"
"vec3 _viv_atan_3(vec3 a)\n"
"{\n"
"   vec3 result;\n"
"   _viv_asm(ATAN, result, a);\n"
"   return result;\n"
"}\n"
"vec4 _viv_atan_4(vec4 a)\n"
"{\n"
"   vec4 result;\n"
"   _viv_asm(ATAN, result, a);\n"
"   return result;\n"
"}\n"
;

static gctSTRING gcLibATAN2_Funcs =
"float _viv_atan2_1(float y, float x)\n"
"{\n"
"    float result;\n"
"    _viv_asm(ATAN, result, y / x);\n"
"    if(sign(x) < 0.0)\n"
"    {\n"
"        if(result <= 0.0)\n"
"        {\n"
"            result = result + 3.14159265358979323846f;\n"
"        }\n"
"        else if(result >= -0.0)\n"
"        {\n"
"            result = result - 3.14159265358979323846f;\n"
"        }\n"
"    }\n"
"   return result;\n"
"}\n"
"vec2 _viv_atan2_2(vec2 y, vec2 x)\n"
"{\n"
"    vec2 result;\n"
"    _viv_asm(ATAN, result, y / x);\n"
"    bvec2 sel = lessThanEqual(result, vec2(0.0));\n"
"    vec2 result2 = mix(result - vec2(3.14159265358979323846f), result + vec2(3.14159265358979323846f), sel);\n"
"    sel = lessThan(sign(x), vec2(0.0));\n"
"    result = mix(result, result2, sel);\n"
"    return result;\n"
"}\n"
"vec3 _viv_atan2_3(vec3 y, vec3 x)\n"
"{\n"
"    vec3 result;\n"
"    _viv_asm(ATAN, result, y / x);\n"
"    bvec3 sel = lessThanEqual(result, vec3(0.0));\n"
"    vec3 result2 = mix(result - vec3(3.14159265358979323846f), result + vec3(3.14159265358979323846f), sel);\n"
"    sel = lessThan(sign(x), vec3(0.0));\n"
"    result = mix(result, result2, sel);\n"
"    return result;\n"
"}\n"
"vec4 _viv_atan2_4(vec4 y, vec4 x)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(ATAN, result, y / x);\n"
"    bvec4 sel = lessThanEqual(result, vec4(0.0));\n"
"    vec4 result2 = mix(result - vec4(3.14159265358979323846f), result + vec4(3.14159265358979323846f), sel);\n"
"    sel = lessThan(sign(x), vec4(0.0));\n"
"    result = mix(result, result2, sel);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibASIN_ACOS_Funcs_halti2 =
"float _viv_asin_1(float a)\n"
"{\n"
"   float result = 0.0f;\n"
"   float s = sqrt(1.0 - a * a);\n"
"   float t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * a;\n"
"   return result;\n"
"}\n"
"vec2 _viv_asin_2(vec2 a)\n"
"{\n"
"   vec2 result = vec2(0.0f);\n"
"   vec2 s = sqrt(1.0 - a * a);\n"
"   vec2 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * a;\n"
"   return result;\n"
"}\n"
"vec3 _viv_asin_3(vec3 a)\n"
"{\n"
"   vec3 result = vec3(0.0f);\n"
"   vec3 s = sqrt(1.0 - a * a);\n"
"   vec3 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * a;\n"
"   return result;\n"
"}\n"
"vec4 _viv_asin_4(vec4 a)\n"
"{\n"
"   vec4 result = vec4(0.0f);\n"
"   vec4 s = sqrt(1.0 - a * a);\n"
"   vec4 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * a;\n"
"   return result;\n"
"}\n"
"float _viv_acos_1(float a)\n"
"{\n"
"   float result = 0.0f;\n"
"   float s = sqrt((1.0 - a) * (1.0 + a));\n"
"   float t = abs(a) - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s;\n"
"   if(a < 0.0)\n"
"   {\n"
"       result = 3.14159265358979323846f - result;\n"
"   }\n"
"   return result;\n"
"}\n"
"vec2 _viv_acos_2(vec2 a)\n"
"{\n"
"   vec2 result = vec2(0.0f);\n"
"   vec2 s = sqrt((1.0 - a) * (1.0 + a));\n"
"   vec2 t = abs(a) - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s;\n"
"   bvec2 sel = lessThan(a, vec2(0.0));\n"
"   result = mix(result, 3.14159265358979323846f - result, sel);\n"
"   return result;\n"
"}\n"
"vec3 _viv_acos_3(vec3 a)\n"
"{\n"
"   vec3 result = vec3(0.0f);\n"
"   vec3 s = sqrt((1.0 - a) * (1.0 + a));\n"
"   vec3 t = abs(a) - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s;\n"
"   bvec3 sel = lessThan(a, vec3(0.0));\n"
"   result = mix(result, 3.14159265358979323846f - result, sel);\n"
"   return result;\n"
"}\n"
"vec4 _viv_acos_4(vec4 a)\n"
"{\n"
"   vec4 result = vec4(0.0f);\n"
"   vec4 s = sqrt((1.0 - a) * (1.0 + a));\n"
"   vec4 t = abs(a) - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s;\n"
"   bvec4 sel = lessThan(a, vec4(0.0));\n"
"   result = mix(result, 3.14159265358979323846f - result, sel);\n"
"   return result;\n"
"}\n"
;

static gctSTRING gcLibACOSH_Funcs =
"float _viv_acosh_1(float a)\n"
"{\n"
"   return log(a + sqrt((a + 1.0) * (a - 1.0)));\n"
"}\n"
"vec2 _viv_acosh_2(vec2 a)\n"
"{\n"
"   return log(a + sqrt((a + 1.0) * (a - 1.0)));\n"
"}\n"
"vec3 _viv_acosh_3(vec3 a)\n"
"{\n"
"   return log(a + sqrt((a + 1.0) * (a - 1.0)));\n"
"}\n"
"vec4 _viv_acosh_4(vec4 a)\n"
"{\n"
"   return log(a + sqrt((a + 1.0) * (a - 1.0)));\n"
"}\n"
;

static gctSTRING gcLibATAN_Funcs_halti2 =
"float _viv_atan_1(float a)\n"
"{\n"
"   highp float hp_a = a;\n"
"   float result = 0.0f;\n"
"   float s;\n"
"   if(abs(hp_a) > 1152921504606846976.0f)\n"
"   {\n"
"       return 3.14159265358979323846f / 2.0 * sign(hp_a);\n"
"   }\n"
"   else\n"
"   {\n"
"       s = inversesqrt(1.0 + hp_a * hp_a);\n"
"   }\n"
"   float t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s * hp_a;\n"
"   return result;\n"
"}\n"
"vec2 _viv_atan_2(vec2 a)\n"
"{\n"
"   highp vec2 hp_a = a;\n"
"   vec2 result = vec2(0.0f);\n"
"   vec2 s = inversesqrt(1.0 + hp_a * hp_a);\n"
"   vec2 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s * hp_a;\n"
"   bvec2 sel = greaterThan(abs(hp_a), vec2(1152921504606846976.0f));\n"
"   result = mix(result, 3.14159265358979323846f / 2.0 * sign(hp_a), sel);\n"
"   return result;\n"
"}\n"
"vec3 _viv_atan_3(vec3 a)\n"
"{\n"
"   highp vec3 hp_a = a;\n"
"   vec3 result = vec3(0.0f);\n"
"   vec3 s = inversesqrt(1.0 + hp_a * hp_a);\n"
"   vec3 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s * hp_a;\n"
"   bvec3 sel = greaterThan(abs(hp_a), vec3(1152921504606846976.0f));\n"
"   result = mix(result, 3.14159265358979323846f / 2.0 * sign(hp_a), sel);\n"
"   return result;\n"
"}\n"
"vec4 _viv_atan_4(vec4 a)\n"
"{\n"
"   highp vec4 hp_a = a;\n"
"   vec4 result = vec4(0.0f);\n"
"   vec4 s = inversesqrt(1.0 + hp_a * hp_a);\n"
"   vec4 t = s - 0.5;\n"
"   result = t * result + -0.011785832233726978000000f;\n"
"   result = t * result + 0.017653759568929672000000f;\n"
"   result = t * result + -0.020724477246403694000000f;\n"
"   result = t * result + 0.033923693001270294000000f;\n"
"   result = t * result + -0.056853778660297394000000f;\n"
"   result = t * result + 0.093872688710689545000000f;\n"
"   result = t * result + -0.158690780401229860000000f;\n"
"   result = t * result + 0.278930336236953740000000f;\n"
"   result = t * result + -0.527200400829315190000000f;\n"
"   result = t * result + 1.209199547767639200000000f;\n"
"   result = result * s * hp_a;\n"
"   bvec4 sel = greaterThan(abs(hp_a), vec4(1152921504606846976.0f));\n"
"   result = mix(result, 3.14159265358979323846f / 2.0 * sign(hp_a), sel);\n"
"   return result;\n"
"}\n"
;

static gctSTRING gcLibATAN2_Funcs_halti2 =
"float _viv_sign_1(float a)\n"
"{\n"
"    uint t = floatBitsToUint(a);\n"
"    t &= 0x80000000u;\n"
"    t |= 0x3f800000u;\n"
"    float result = uintBitsToFloat(t);\n"
"    return result;\n"
"}\n"
"vec2 _viv_sign_2(vec2 a)\n"
"{\n"
"    uvec2 t = floatBitsToUint(a);\n"
"    t &= 0x80000000u;\n"
"    t |= 0x3f800000u;\n"
"    vec2 result = uintBitsToFloat(t);\n"
"    return result;\n"
"}\n"
"vec3 _viv_sign_3(vec3 a)\n"
"{\n"
"    uvec3 t = floatBitsToUint(a);\n"
"    t &= 0x80000000u;\n"
"    t |= 0x3f800000u;\n"
"    vec3 result = uintBitsToFloat(t);\n"
"    return result;\n"
"}\n"
"vec4 _viv_sign_4(vec4 a)\n"
"{\n"
"    uvec4 t = floatBitsToUint(a);\n"
"    t &= 0x80000000u;\n"
"    t |= 0x3f800000u;\n"
"    vec4 result = uintBitsToFloat(t);\n"
"    return result;\n"
"}\n"
"float _viv_atan2_1(float y, float x)\n"
"{\n"
"    highp float tiny    = 1.0e-30;\n"
"    highp float zero    = 0.0;\n"
"    highp float pi_o_4  = 7.8539818525e-01; /* 0x3f490fdb */\n"
"    highp float pi_o_2  = 1.5707963705e+00; /* 0x3fc90fdb */\n"
"    highp float pi      = 3.1415927410e+00; /* 0x40490fdb */\n"
"    highp float pi_lo   = -8.7422776573e-08; /* 0xb3bbbd2e */\n"
"    highp float z;\n"
"    highp int k,m,hx,hy,ix,iy;\n"
"    if(floatBitsToUint(y) == 0x80000000u)\n"
"    {\n"
"        y = 0.0;\n"
"    }\n"
"    hx = floatBitsToInt(x);\n"
"    ix = floatBitsToInt(abs(x));\n"
"    hy = floatBitsToInt(y);\n"
"    iy = floatBitsToInt(abs(y));\n"
"    if ((ix>0x7f800000)||\n"
"        (iy>0x7f800000)) /* x or y is NaN */\n"
"        return x+y;\n"
"    if (hx==0x3f800000) return _viv_atan_1(y);   /* x=1.0 */\n"
"    m = ((hy>>31)&1)|((hx>>30)&2);  /* 2*sign(x)+sign(y) */\n"
"    /* when y = 0 */\n"
"    if (iy==0) {\n"
"        switch (m) {\n"
"        case 0:\n"
"        case 1: return y;   /* atan(+-0,+anything)=+-0 */\n"
"        case 2: return  pi+tiny;/* atan(+0,-anything) = pi */\n"
"        case 3: return -pi-tiny;/* atan(-0,-anything) =-pi */\n"
"        }\n"
"    }\n"
"    /* when x = 0 */\n"
"    if (ix==0) return (hy<0)?  -pi_o_2-tiny: pi_o_2+tiny;\n"
"    /* when x is INF */\n"
"    if (ix==0x7f800000) {\n"
"        if (iy==0x7f800000) {\n"
"            switch (m) {\n"
"            case 0: return  pi_o_4+tiny;/* atan(+INF,+INF) */\n"
"            case 1: return -pi_o_4-tiny;/* atan(-INF,+INF) */\n"
"            case 2: return  3.0*pi_o_4+tiny;/*atan(+INF,-INF)*/\n"
"            case 3: return -3.0*pi_o_4-tiny;/*atan(-INF,-INF)*/\n"
"            }\n"
"        } else {\n"
"            switch(m) {\n"
"            case 0: return  zero  ; /* atan(+...,+INF) */\n"
"            case 1: return -zero  ; /* atan(-...,+INF) */\n"
"            case 2: return  pi+tiny  ;  /* atan(+...,-INF) */\n"
"            case 3: return -pi-tiny  ;  /* atan(-...,-INF) */\n"
"            }\n"
"        }\n"
"    }\n"
"    /* when y is INF */\n"
"    if (iy==0x7f800000) return (hy<0)? -pi_o_2-tiny: pi_o_2+tiny;\n"
"    /* compute y/x */\n"
"    k = (iy-ix)>>23;\n"
"    if (k > 26) {            /* |y/x| >  2**26 */\n"
"        z=pi_o_2+0.5*pi_lo;\n"
"        m&=1;\n"
"    }\n"
"    else if (k<-26&&hx<0) z=0.0;     /* 0 > |y|/x > -2**-26 */\n"
"    else z=_viv_atan_1(abs(y/x));   /* safe to do y/x */\n"
"    switch (m) {\n"
"        case 0: return       z  ;   /* atan(+,+) */\n"
"        case 1: return      -z  ;   /* atan(-,+) */\n"
"        case 2: return  pi-(z-pi_lo);/* atan(+,-) */\n"
"        default: /* case 3 */\n"
"                return  (z-pi_lo)-pi;/* atan(-,-) */\n"
"    }\n"
"}\n"
"vec2 _viv_atan2_2(vec2 y, vec2 x)\n"
"{\n"
"    return vec2(_viv_atan2_1(y.x, x.x), \n"
"                _viv_atan2_1(y.y, x.y));\n"
"}\n"
"vec3 _viv_atan2_3(vec3 y, vec3 x)\n"
"{\n"
"    return vec3(_viv_atan2_1(y.x, x.x), \n"
"                _viv_atan2_1(y.y, x.y), \n"
"                _viv_atan2_1(y.z, x.z));\n"
"}\n"
"vec4 _viv_atan2_4(vec4 y, vec4 x)\n"
"{\n"
"    return vec4(_viv_atan2_1(y.x, x.x), \n"
"                _viv_atan2_1(y.y, x.y), \n"
"                _viv_atan2_1(y.z, x.z), \n"
"                _viv_atan2_1(y.w, x.w));\n"
"}\n"
;

static gctSTRING gcLibASIN_ACOS_Funcs_halti5_fmaSupported =
"float _viv_fma_1(float a, float b, float c);\n"
"float _viv_asin_1(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, result;\n"
"    floatTemp0 = _viv_fma_1(a, -a, 1.0);\n"
"    floatTemp0 = sqrt(floatTemp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, floatTemp0, floatTemp0);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    result = a * vec2Temp0.x;\n"
"    return result;\n"
"}\n"
"vec2 _viv_fma_2(vec2 a, vec2 b, vec2 c);\n"
"vec2 _viv_asin_2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, result;\n"
"    vec2Temp2 = _viv_fma_2(a, -a, vec2(1.0));\n"
"    vec2Temp2 = sqrt(vec2Temp2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec2Temp2.x, vec2Temp2.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec2Temp2.y, vec2Temp2.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    result = a * vec2(vec2Temp0.x, vec2Temp1.x);\n"
"    return result;\n"
"}\n"
"vec3 _viv_fma_3(vec3 a, vec3 b, vec3 c);\n"
"vec3 _viv_asin_3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, result;\n"
"    vec3Temp0 = _viv_fma_3(a, -a, vec3(1.0));\n"
"    vec3Temp0 = sqrt(vec3Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec3Temp0.x, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec3Temp0.y, vec3Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec3Temp0.z, vec3Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x1);\n"
"    result = a * vec3(vec2Temp0.x, vec2Temp1.x, vec2Temp2.x);\n"
"    return result;\n"
"}\n"
"vec4 _viv_fma_4(vec4 a, vec4 b, vec4 c);\n"
"vec4 _viv_asin_4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, result;\n"
"    vec4Temp0 = _viv_fma_4(a, -a, vec4(1.0));\n"
"    vec4Temp0 = sqrt(vec4Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec4Temp0.x, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec4Temp0.y, vec4Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec4Temp0.z, vec4Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, vec4Temp0.w, vec4Temp0.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x1);\n"
"    result = a * vec4(vec2Temp0.x, vec2Temp1.x, vec2Temp2.x, vec2Temp3.x);\n"
"    return result;\n"
"}\n"
"float _viv_fma_1(float a, float b, float c);\n"
"float _viv_acos_1(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, result;\n"
"    floatTemp0 = _viv_fma_1(a, -a, 1.0);\n"
"    floatTemp0 = sqrt(floatTemp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a, floatTemp0);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    result = _viv_fma_1(floatTemp0, vec2Temp0.x, vec2Temp0.y);\n"
"    return result;\n"
"}\n"
"vec2 _viv_fma_2(vec2 a, vec2 b, vec2 c);\n"
"vec2 _viv_acos_2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, result;\n"
"    vec2Temp2 = _viv_fma_2(a, -a, vec2(1.0));\n"
"    vec2Temp2 = sqrt(vec2Temp2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec2Temp2.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec2Temp2.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    result.x = _viv_fma_1(vec2Temp2.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_1(vec2Temp2.y, vec2Temp1.x, vec2Temp1.y);\n"
"    return result;\n"
"}\n"
"vec3 _viv_fma_3(vec3 a, vec3 b, vec3 c);\n"
"vec3 _viv_acos_3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, result;\n"
"    vec3Temp0 = _viv_fma_3(a, -a, vec3(1.0));\n"
"    vec3Temp0 = sqrt(vec3Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec3Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, a.z, vec3Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x0);\n"
"    result.x = _viv_fma_1(vec3Temp0.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_1(vec3Temp0.y, vec2Temp1.x, vec2Temp1.y);\n"
"    result.z = _viv_fma_1(vec3Temp0.z, vec2Temp2.x, vec2Temp2.y);\n"
"    return result;\n"
"}\n"
"vec4 _viv_fma_4(vec4 a, vec4 b, vec4 c);\n"
"vec4 _viv_acos_4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, result;\n"
"    vec4Temp0 = _viv_fma_4(a, -a, vec4(1.0));\n"
"    vec4Temp0 = sqrt(vec4Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec4Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, a.z, vec4Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, a.w, vec4Temp0.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x0);\n"
"    result.x = _viv_fma_1(vec4Temp0.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_1(vec4Temp0.y, vec2Temp1.x, vec2Temp1.y);\n"
"    result.z = _viv_fma_1(vec4Temp0.z, vec2Temp2.x, vec2Temp2.y);\n"
"    result.w = _viv_fma_1(vec4Temp0.w, vec2Temp3.x, vec2Temp3.y);\n"
"    return result;\n"
"}\n"
;

static gctSTRING gcLibASIN_ACOS_Funcs_halti5 =
"float _viv_asin_1(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, result;\n"
"    floatTemp0 = 1.0 - a * a;\n"
"    floatTemp0 = sqrt(floatTemp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, floatTemp0, floatTemp0);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    result = a * vec2Temp0.x;\n"
"    return result;\n"
"}\n"
"vec2 _viv_asin_2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, result;\n"
"    vec2Temp2 = vec2(1.0) - a * a;\n"
"    vec2Temp2 = sqrt(vec2Temp2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec2Temp2.x, vec2Temp2.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec2Temp2.y, vec2Temp2.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    result = a * vec2(vec2Temp0.x, vec2Temp1.x);\n"
"    return result;\n"
"}\n"
"vec3 _viv_asin_3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, result;\n"
"    vec3Temp0 = vec3(1.0) - a * a;\n"
"    vec3Temp0 = sqrt(vec3Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec3Temp0.x, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec3Temp0.y, vec3Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec3Temp0.z, vec3Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x1);\n"
"    result = a * vec3(vec2Temp0.x, vec2Temp1.x, vec2Temp2.x);\n"
"    return result;\n"
"}\n"
"vec4 _viv_asin_4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, result;\n"
"    vec4Temp0 = vec4(1.0) - a * a;\n"
"    vec4Temp0 = sqrt(vec4Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec4Temp0.x, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec4Temp0.y, vec4Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec4Temp0.z, vec4Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x1);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, vec4Temp0.w, vec4Temp0.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x1);\n"
"    result = a * vec4(vec2Temp0.x, vec2Temp1.x, vec2Temp2.x, vec2Temp3.x);\n"
"    return result;\n"
"}\n"
"float _viv_acos_1(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, floatTemp1, result;\n"
"    floatTemp0 = 1.0 + a;\n"
"    floatTemp1 = 1.0 - a;\n"
"    floatTemp0 = floatTemp0 * floatTemp1;\n"
"    floatTemp0 = sqrt(floatTemp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a, floatTemp0);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    result = floatTemp0 * vec2Temp0.x + vec2Temp0.y;\n"
"    return result;\n"
"}\n"
"vec2 _viv_acos_2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, result;\n"
"    vec2Temp0 = vec2(1.0) + a;\n"
"    vec2Temp1 = vec2(1.0) - a;\n"
"    vec2Temp2 = vec2Temp0 * vec2Temp1;\n"
"    vec2Temp2 = sqrt(vec2Temp2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec2Temp2.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec2Temp2.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    result.x = vec2Temp2.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec2Temp2.y * vec2Temp1.x + vec2Temp1.y;\n"
"    return result;\n"
"}\n"
"vec3 _viv_acos_3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, vec3Temp1, result;\n"
"    vec3Temp0 = vec3(1.0) + a;\n"
"    vec3Temp1 = vec3(1.0) - a;\n"
"    vec3Temp0 = vec3Temp0 * vec3Temp1;\n"
"    vec3Temp0 = sqrt(vec3Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec3Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, a.z, vec3Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x0);\n"
"    result.x = vec3Temp0.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec3Temp0.y * vec2Temp1.x + vec2Temp1.y;\n"
"    result.z = vec3Temp0.z * vec2Temp2.x + vec2Temp2.y;\n"
"    return result;\n"
"}\n"
"vec4 _viv_acos_4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, vec4Temp1, result;\n"
"    vec4Temp0 = vec4(1.0) + a;\n"
"    vec4Temp1 = vec4(1.0) - a;\n"
"    vec4Temp0 = vec4Temp0 * vec4Temp1;\n"
"    vec4Temp0 = sqrt(vec4Temp0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, a.x, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, a.y, vec4Temp0.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, a.z, vec4Temp0.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x0);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, a.w, vec4Temp0.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x0);\n"
"    result.x = vec4Temp0.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec4Temp0.y * vec2Temp1.x + vec2Temp1.y;\n"
"    result.z = vec4Temp0.z * vec2Temp2.x + vec2Temp2.y;\n"
"    result.w = vec4Temp0.w * vec2Temp3.x + vec2Temp3.y;\n"
"    return result;\n"
"}\n"
;

static gctSTRING gcLibATAN_Funcs_halti5_fmaSupported =
"float _viv_fma_1(float a, float b, float c);\n"
"float _viv_atan_1(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, floatTemp1, result;\n"
"    floatTemp0 = _viv_fma_1(a, a, 1.0);\n"
"    floatTemp0 = inversesqrt(floatTemp0);\n"
"    _viv_asm(MUL_Z, floatTemp1, floatTemp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, floatTemp0, floatTemp1);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    result = _viv_fma_1(floatTemp1, vec2Temp0.x, vec2Temp0.y);\n"
"    return result;\n"
"}\n"
"vec2 _viv_fma_2(vec2 a, vec2 b, vec2 c);\n"
"vec2 _viv_atan_2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, vec2Temp3, result;\n"
"    vec2Temp2 = _viv_fma_2(a, a, vec2(1.0));\n"
"    vec2Temp2 = inversesqrt(vec2Temp2);\n"
"    _viv_asm(MUL_Z, vec2Temp3, vec2Temp2, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec2Temp2.x, vec2Temp3.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec2Temp2.y, vec2Temp3.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    result.x = _viv_fma_1(vec2Temp3.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_1(vec2Temp3.y, vec2Temp1.x, vec2Temp1.y);\n"
"    return result;\n"
"}\n"
"vec3 _viv_fma_3(vec3 a, vec3 b, vec3 c);\n"
"vec3 _viv_atan_3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, vec3Temp1, result;\n"
"    vec3Temp0 = _viv_fma_3(a, a, vec3(1.0));\n"
"    vec3Temp0 = inversesqrt(vec3Temp0);\n"
"    _viv_asm(MUL_Z, vec3Temp1, vec3Temp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec3Temp0.x, vec3Temp1.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec3Temp0.y, vec3Temp1.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec3Temp0.z, vec3Temp1.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x2);\n"
"    result.x = _viv_fma_1(vec3Temp1.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_1(vec3Temp1.y, vec2Temp1.x, vec2Temp1.y);\n"
"    result.z = _viv_fma_1(vec3Temp1.z, vec2Temp2.x, vec2Temp2.y);\n"
"    return result;\n"
"}\n"
"vec4 _viv_fma_4(vec4 a, vec4 b, vec4 c);\n"
"vec4 _viv_atan_4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, vec4Temp1, result;\n"
"    vec4Temp0 = _viv_fma_4(a, a, vec4(1.0));\n"
"    vec4Temp0 = inversesqrt(vec4Temp0);\n"
"    _viv_asm(MUL_Z, vec4Temp1, vec4Temp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec4Temp0.x, vec4Temp1.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec4Temp0.y, vec4Temp1.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec4Temp0.z, vec4Temp1.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, vec4Temp0.w, vec4Temp1.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x2);\n"
"    result.x = _viv_fma_1(vec4Temp1.x, vec2Temp0.x, vec2Temp0.y);\n"
"    result.y = _viv_fma_1(vec4Temp1.y, vec2Temp1.x, vec2Temp1.y);\n"
"    result.z = _viv_fma_1(vec4Temp1.z, vec2Temp2.x, vec2Temp2.y);\n"
"    result.w = _viv_fma_1(vec4Temp1.w, vec2Temp3.x, vec2Temp3.y);\n"
"    return result;\n"
"}\n"
;

static gctSTRING gcLibATAN_Funcs_halti5 =
"float _viv_atan_1(float a)\n"
"{\n"
"    vec2 vec2Temp0;\n"
"    float floatTemp0, floatTemp1, result;\n"
"    floatTemp0 = a * a + 1.0;\n"
"    floatTemp0 = inversesqrt(floatTemp0);\n"
"    _viv_asm(MUL_Z, floatTemp1, floatTemp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, floatTemp0, floatTemp1);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    result = floatTemp1 * vec2Temp0.x + vec2Temp0.y;\n"
"    return result;\n"
"}\n"
"vec2 _viv_atan_2(vec2 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1;\n"
"    vec2 vec2Temp2, vec2Temp3, result;\n"
"    vec2Temp2 = a * a + vec2(1.0);\n"
"    vec2Temp2 = inversesqrt(vec2Temp2);\n"
"    _viv_asm(MUL_Z, vec2Temp3, vec2Temp2, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec2Temp2.x, vec2Temp3.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec2Temp2.y, vec2Temp3.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    result.x = vec2Temp3.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec2Temp3.y * vec2Temp1.x + vec2Temp1.y;\n"
"    return result;\n"
"}\n"
"vec3 _viv_atan_3(vec3 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2;\n"
"    vec3 vec3Temp0, vec3Temp1, result;\n"
"    vec3Temp0 = a * a + vec3(1.0);\n"
"    vec3Temp0 = inversesqrt(vec3Temp0);\n"
"    _viv_asm(MUL_Z, vec3Temp1, vec3Temp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec3Temp0.x, vec3Temp1.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec3Temp0.y, vec3Temp1.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec3Temp0.z, vec3Temp1.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x2);\n"
"    result.x = vec3Temp1.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec3Temp1.y * vec2Temp1.x + vec2Temp1.y;\n"
"    result.z = vec3Temp1.z * vec2Temp2.x + vec2Temp2.y;\n"
"    return result;\n"
"}\n"
"vec4 _viv_atan_4(vec4 a)\n"
"{\n"
"    vec2 vec2Temp0, vec2Temp1, vec2Temp2, vec2Temp3;\n"
"    vec4 vec4Temp0, vec4Temp1, result;\n"
"    vec4Temp0 = a * a + vec4(1.0);\n"
"    vec4Temp0 = inversesqrt(vec4Temp0);\n"
"    _viv_asm(MUL_Z, vec4Temp1, vec4Temp0, a);\n"
"    _viv_asm(ARCTRIG0, vec2Temp0, vec4Temp0.x, vec4Temp1.x);\n"
"    _viv_asm(ARCTRIG1, vec2Temp0, vec2Temp0, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp1, vec4Temp0.y, vec4Temp1.y);\n"
"    _viv_asm(ARCTRIG1, vec2Temp1, vec2Temp1, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp2, vec4Temp0.z, vec4Temp1.z);\n"
"    _viv_asm(ARCTRIG1, vec2Temp2, vec2Temp2, 0x2);\n"
"    _viv_asm(ARCTRIG0, vec2Temp3, vec4Temp0.w, vec4Temp1.w);\n"
"    _viv_asm(ARCTRIG1, vec2Temp3, vec2Temp3, 0x2);\n"
"    result.x = vec4Temp1.x * vec2Temp0.x + vec2Temp0.y;\n"
"    result.y = vec4Temp1.y * vec2Temp1.x + vec2Temp1.y;\n"
"    result.z = vec4Temp1.z * vec2Temp2.x + vec2Temp2.y;\n"
"    result.w = vec4Temp1.w * vec2Temp3.x + vec2Temp3.y;\n"
"    return result;\n"
"}\n"
;

static gctSTRING gcLibATAN2_Funcs_halti5_fmaSupported =
"float _viv_fma_1(float a, float b, float c);\n"
"float _viv_atan2_1(float y, float x)\n"
"{\n"
"    vec2 arctrig0, vec2Temp0;\n"
"    float dot0, rsq0, result;\n"
"    if(floatBitsToUint(y) == 0x80000000u)\n"
"    {\n"
"        y = 0.0;\n"
"    }\n"
"    _viv_asm(ARCTRIG0, arctrig0, y, x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    dot0 = dot(arctrig0, arctrig0);\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec2Temp0 = arctrig0 * rsq0;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec2Temp0.y, vec2Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    result = _viv_fma_1(arctrig0.x, vec2Temp0.x, arctrig0.y);\n"
"    return result;\n"
"}\n"
"vec2 _viv_fma_2(vec2 a, vec2 b, vec2 c);\n"
"vec2 _viv_atan2_2(vec2 y, vec2 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, vec2Temp0, vec2Temp1;\n"
"    vec2 dot0, rsq0, result;\n"
"    bvec2 sel = equal(floatBitsToUint(y), uvec2(0x80000000u));\n"
"    y = mix(y, vec2(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    dot0.x = dot(arctrig0, arctrig0);\n"
"    dot0.y = dot(arctrig1, arctrig1);\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec2Temp0 = arctrig0 * rsq0.x;\n"
"    vec2Temp1 = arctrig1 * rsq0.y;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec2Temp0.y, vec2Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec2Temp1.y, vec2Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    result.x = _viv_fma_1(arctrig0.x, vec2Temp0.x, arctrig0.y);\n"
"    result.y = _viv_fma_1(arctrig1.x, vec2Temp1.x, arctrig1.y);\n"
"    return result;\n"
"}\n"
"vec3 _viv_fma_3(vec3 a, vec3 b, vec3 c);\n"
"vec3 _viv_atan2_3(vec3 y, vec3 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, arctrig2, vec3Temp0, vec3Temp1, vec3Temp2;\n"
"    vec3 dot0, rsq0, result;\n"
"    bvec3 sel = equal(floatBitsToUint(y), uvec3(0x80000000u));\n"
"    y = mix(y, vec3(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig2, y.z, x.z);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x83);\n"
"    dot0.x = dot(arctrig0, arctrig0);\n"
"    dot0.y = dot(arctrig1, arctrig1);\n"
"    dot0.z = dot(arctrig2, arctrig2);\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec3Temp0 = arctrig0 * rsq0.x;\n"
"    vec3Temp1 = arctrig1 * rsq0.y;\n"
"    vec3Temp2 = arctrig2 * rsq0.z;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec3Temp0.y, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec3Temp1.y, vec3Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig2, vec3Temp2.y, vec3Temp2.x);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x3);\n"
"    result.x = _viv_fma_1(arctrig0.x, vec3Temp0.x, arctrig0.y);\n"
"    result.y = _viv_fma_1(arctrig1.x, vec3Temp1.x, arctrig1.y);\n"
"    result.z = _viv_fma_1(arctrig2.x, vec3Temp2.x, arctrig2.y);\n"
"    return result;\n"
"}\n"
"vec4 _viv_fma_4(vec4 a, vec4 b, vec4 c);\n"
"vec4 _viv_atan2_4(vec4 y, vec4 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, arctrig2, arctrig3, vec4Temp0, vec4Temp1, vec4Temp2, vec4Temp3;\n"
"    vec4 dot0, rsq0, result;\n"
"    bvec4 sel = equal(floatBitsToUint(y), uvec4(0x80000000u));\n"
"    y = mix(y, vec4(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig2, y.z, x.z);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig3, y.w, x.w);\n"
"    _viv_asm(ARCTRIG1, arctrig3, arctrig3, 0x83);\n"
"    dot0.x = dot(arctrig0, arctrig0);\n"
"    dot0.y = dot(arctrig1, arctrig1);\n"
"    dot0.z = dot(arctrig2, arctrig2);\n"
"    dot0.w = dot(arctrig3, arctrig3);\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec4Temp0 = arctrig0 * rsq0.x;\n"
"    vec4Temp1 = arctrig1 * rsq0.y;\n"
"    vec4Temp2 = arctrig2 * rsq0.z;\n"
"    vec4Temp3 = arctrig3 * rsq0.w;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec4Temp0.y, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec4Temp1.y, vec4Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig2, vec4Temp2.y, vec4Temp2.x);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig3, vec4Temp3.y, vec4Temp3.x);\n"
"    _viv_asm(ARCTRIG1, arctrig3, arctrig3, 0x3);\n"
"    result.x = _viv_fma_1(arctrig0.x, vec4Temp0.x, arctrig0.y);\n"
"    result.y = _viv_fma_1(arctrig1.x, vec4Temp1.x, arctrig1.y);\n"
"    result.z = _viv_fma_1(arctrig2.x, vec4Temp2.x, arctrig2.y);\n"
"    result.w = _viv_fma_1(arctrig3.x, vec4Temp3.x, arctrig3.y);\n"
"    return result;\n"
"}\n"
;

static gctSTRING gcLibATAN2_Funcs_halti5 =
"float _viv_atan2_1(float y, float x)\n"
"{\n"
"    vec2 arctrig0, vec2Temp0;\n"
"    float dot0, rsq0, result;\n"
"    if(floatBitsToUint(y) == 0x80000000u)\n"
"    {\n"
"        y = 0.0;\n"
"    }\n"
"    _viv_asm(ARCTRIG0, arctrig0, y, x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    dot0 = arctrig0.x * arctrig0.x + arctrig0.y * arctrig0.y;\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec2Temp0 = arctrig0 * rsq0;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec2Temp0.y, vec2Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    result = arctrig0.x * vec2Temp0.x + arctrig0.y;\n"
"    return result;\n"
"}\n"
"vec2 _viv_atan2_2(vec2 y, vec2 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, vec2Temp0, vec2Temp1;\n"
"    vec2 dot0, rsq0, result;\n"
"    bvec2 sel = equal(floatBitsToUint(y), uvec2(0x80000000u));\n"
"    y = mix(y, vec2(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    dot0.x = arctrig0.x * arctrig0.x + arctrig0.y * arctrig0.y;\n"
"    dot0.y = arctrig1.x * arctrig1.x + arctrig1.y * arctrig1.y;\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec2Temp0 = arctrig0 * rsq0.x;\n"
"    vec2Temp1 = arctrig1 * rsq0.y;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec2Temp0.y, vec2Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec2Temp1.y, vec2Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    result.x = arctrig0.x * vec2Temp0.x + arctrig0.y;\n"
"    result.y = arctrig1.x * vec2Temp1.x + arctrig1.y;\n"
"    return result;\n"
"}\n"
"vec3 _viv_atan2_3(vec3 y, vec3 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, arctrig2, vec3Temp0, vec3Temp1, vec3Temp2;\n"
"    vec3 dot0, rsq0, result;\n"
"    bvec3 sel = equal(floatBitsToUint(y), uvec3(0x80000000u));\n"
"    y = mix(y, vec3(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig2, y.z, x.z);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x83);\n"
"    dot0.x = arctrig0.x * arctrig0.x + arctrig0.y * arctrig0.y;\n"
"    dot0.y = arctrig1.x * arctrig1.x + arctrig1.y * arctrig1.y;\n"
"    dot0.z = arctrig2.x * arctrig2.x + arctrig2.y * arctrig2.y;\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec3Temp0 = arctrig0 * rsq0.x;\n"
"    vec3Temp1 = arctrig1 * rsq0.y;\n"
"    vec3Temp2 = arctrig2 * rsq0.z;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec3Temp0.y, vec3Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec3Temp1.y, vec3Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig2, vec3Temp2.y, vec3Temp2.x);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x3);\n"
"    result.x = arctrig0.x * vec3Temp0.x + arctrig0.y;\n"
"    result.y = arctrig1.x * vec3Temp1.x + arctrig1.y;\n"
"    result.z = arctrig2.x * vec3Temp2.x + arctrig2.y;\n"
"    return result;\n"
"}\n"
"vec4 _viv_atan2_4(vec4 y, vec4 x)\n"
"{\n"
"    vec2 arctrig0, arctrig1, arctrig2, arctrig3, vec4Temp0, vec4Temp1, vec4Temp2, vec4Temp3;\n"
"    vec4 dot0, rsq0, result;\n"
"    bvec4 sel = equal(floatBitsToUint(y), uvec4(0x80000000u));\n"
"    y = mix(y, vec4(0.0), sel);\n"
"    _viv_asm(ARCTRIG0, arctrig0, y.x, x.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig1, y.y, x.y);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig2, y.z, x.z);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x83);\n"
"    _viv_asm(ARCTRIG0, arctrig3, y.w, x.w);\n"
"    _viv_asm(ARCTRIG1, arctrig3, arctrig3, 0x83);\n"
"    dot0.x = arctrig0.x * arctrig0.x + arctrig0.y * arctrig0.y;\n"
"    dot0.y = arctrig1.x * arctrig1.x + arctrig1.y * arctrig1.y;\n"
"    dot0.z = arctrig2.x * arctrig2.x + arctrig2.y * arctrig2.y;\n"
"    dot0.w = arctrig3.x * arctrig3.x + arctrig3.y * arctrig3.y;\n"
"    rsq0 = inversesqrt(dot0);\n"
"    vec4Temp0 = arctrig0 * rsq0.x;\n"
"    vec4Temp1 = arctrig1 * rsq0.y;\n"
"    vec4Temp2 = arctrig2 * rsq0.z;\n"
"    vec4Temp3 = arctrig3 * rsq0.w;\n"
"    _viv_asm(ARCTRIG0, arctrig0, vec4Temp0.y, vec4Temp0.x);\n"
"    _viv_asm(ARCTRIG1, arctrig0, arctrig0, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig1, vec4Temp1.y, vec4Temp1.x);\n"
"    _viv_asm(ARCTRIG1, arctrig1, arctrig1, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig2, vec4Temp2.y, vec4Temp2.x);\n"
"    _viv_asm(ARCTRIG1, arctrig2, arctrig2, 0x3);\n"
"    _viv_asm(ARCTRIG0, arctrig3, vec4Temp3.y, vec4Temp3.x);\n"
"    _viv_asm(ARCTRIG1, arctrig3, arctrig3, 0x3);\n"
"    result.x = arctrig0.x * vec4Temp0.x + arctrig0.y;\n"
"    result.y = arctrig1.x * vec4Temp1.x + arctrig1.y;\n"
"    result.z = arctrig2.x * vec4Temp2.x + arctrig2.y;\n"
"    result.w = arctrig3.x * vec4Temp3.x + arctrig3.y;\n"
"    return result;\n"
"}\n"
;

/* findLSB gc3000/5000 implementation */
static gctSTRING gcLibFindLSB_Func_1 =
"lowp int _viv_findLSB_1(int a)\n"
"{\n"
"   lowp int result = -1;\n"
"   lowp int i;\n"
"   highp int mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a & mask)  != 0) { result = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_2 =
"lowp ivec2 _viv_findLSB_2(ivec2 a)\n"
"{\n"
"   lowp ivec2 result = ivec2(-1, -1);\n"
"   lowp int i;\n"
"   highp int mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_3 =
"lowp ivec3 _viv_findLSB_3(ivec3 a)\n"
"{\n"
"   lowp ivec3 result = ivec3(-1, -1, -1);\n"
"   lowp int i;\n"
"   highp int mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.z & mask)  != 0) { result.z = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_4 =
"lowp ivec4 _viv_findLSB_4(ivec4 a)\n"
"{\n"
"   lowp ivec4 result = ivec4(-1, -1, -1, -1);\n"
"   lowp int i;\n"
"   highp int mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.z & mask)  != 0) { result.z = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.w & mask)  != 0) { result.w = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibFindLSB_Func_5 =
"lowp int _viv_findLSB_5(uint a)\n"
"{\n"
"   lowp int result = -1;\n"
"   lowp int i;\n"
"   highp uint mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a & mask)  != 0u) { result = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_6 =
"lowp ivec2 _viv_findLSB_6(uvec2 a)\n"
"{\n"
"   lowp ivec2 result = ivec2(-1,-1);\n"
"   lowp int i;\n"
"   highp uint mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0u) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0u) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_7 =
"lowp ivec3 _viv_findLSB_7(uvec3 a)\n"
"{\n"
"   lowp ivec3 result = ivec3(-1, -1, -1);\n"
"   lowp int i;\n"
"   highp uint mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0u) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0u) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.z & mask)  != 0u) { result.z = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_8 =
"lowp ivec4 _viv_findLSB_8(uvec4 a)\n"
"{\n"
"   lowp ivec4 result = ivec4(-1, -1, -1, -1);\n"
"   lowp int i;\n"
"   highp uint mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.x & mask)  != 0u) { result.x = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.y & mask)  != 0u) { result.y = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.z & mask)  != 0u) { result.z = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   mask = 1u;\n"
"   for (i = 0; i < 32; i++)\n"
"   {\n"
"       if ((a.w & mask)  != 0u) { result.w = i; break; } \n"
"       mask = mask << 1;\n"
"   }\n"
"   return result;\n"
"}\n";

/* findLSB gc7000 implementation */
static gctSTRING gcLibFindLSB_Func_1_hati4 =
"lowp int _viv_findLSB_1(int a)\n"
"{\n"
"   lowp int result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_2_hati4 =
"lowp ivec2 _viv_findLSB_2(ivec2 a)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_3_hati4 =
"lowp ivec3 _viv_findLSB_3(ivec3 a)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_4_hati4 =
"lowp ivec4 _viv_findLSB_4(ivec4 a)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_5_hati4 =
"lowp int _viv_findLSB_5(uint a)\n"
"{\n"
"   int result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_6_hati4 =
"lowp ivec2 _viv_findLSB_6(uvec2 a)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_7_hati4 =
"lowp ivec3 _viv_findLSB_7(uvec3 a)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindLSB_Func_8_hati4 =
"lowp ivec4 _viv_findLSB_8(uvec4 a)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(FINDLSB, result, a);\n"
"   return result;\n"
"}\n";

/* findMSB gc3000/5000 implementation */
static gctSTRING gcLibFindMSB_Func_1 =
"lowp int _viv_findMSB_1(highp int a)\n"
"{\n"
"   lowp int result = -1;\n"
"   lowp int i;\n"
"   highp int mask = 1 << 30;\n"
"   if (a < 0) { a = ~a; } \n"
"   for (i = 30; i >= 0 ; i--)\n"
"   {\n"
"       if ((a & mask)  != 0) { result = i; break; } \n"
"       mask = mask >> 1;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindMSB_Func_2 =
"lowp ivec2 _viv_findMSB_2(highp ivec2 a)\n"
"{\n"
"   lowp ivec2 result;\n"
"   if (a.x != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.x < 0) { a.x = ~a.x; } \n"
"       for (result.x = 30; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.y < 0) { a.y = ~a.y; } \n"
"       for (result.y = 30; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibFindMSB_Func_3 =
"lowp ivec3 _viv_findMSB_3(highp ivec3 a)\n"
"{\n"
"   lowp ivec3 result;\n"
"   if (a.x != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.x < 0) { a.x = ~a.x; } \n"
"       for (result.x = 30; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.y < 0) { a.y = ~a.y; } \n"
"       for (result.y = 30; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   if (a.z != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.z < 0) { a.z = ~a.z; } \n"
"       for (result.z = 30; result.z >= 0 ; result.z--)\n"
"       {\n"
"           if ((a.z & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.z = -1;\n"
"   }\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibFindMSB_Func_4 =
"lowp ivec4 _viv_findMSB_4(highp ivec4 a)\n"
"{\n"
"   lowp ivec4 result;\n"
"   if (a.x != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.x < 0) { a.x = ~a.x; } \n"
"       for (result.x = 30; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.y < 0) { a.y = ~a.y; } \n"
"       for (result.y = 30; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   if (a.z != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.z < 0) { a.z = ~a.z; } \n"
"       for (result.z = 30; result.z >= 0 ; result.z--)\n"
"       {\n"
"           if ((a.z & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.z = -1;\n"
"   }\n"
"   if (a.w != 0 ) { \n"
"       highp int mask = 1 << 30;\n"
"       if (a.w < 0) { a.w = ~a.w; } \n"
"       for (result.w = 30; result.w >= 0 ; result.w--)\n"
"       {\n"
"           if ((a.w & mask)  != 0) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.w = -1;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindMSB_Func_5 =
"lowp int _viv_findMSB_5(highp uint a)\n"
"{\n"
"   lowp int result = -1;\n"
"   lowp int i;\n"
"   highp uint mask = 1u << 31;\n"
"   for (i = 31; i >= 0 ; i--)\n"
"   {\n"
"       if ((a & mask)  != 0u) { result = i; break; } \n"
"       mask = mask >> 1;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindMSB_Func_6 =
"lowp ivec2 _viv_findMSB_6(highp uvec2 a)\n"
"{\n"
"   lowp ivec2 result;\n"
"   highp uint mask;\n"
"   if (a.x != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.x = 31; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.y = 31; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibFindMSB_Func_7 =
"lowp ivec3 _viv_findMSB_7(highp uvec3 a)\n"
"{\n"
"   lowp ivec3 result;\n"
"   highp uint mask;\n"
"   if (a.x != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.x = 31; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.y = 31; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   if (a.z != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.z = 31; result.z >= 0 ; result.z--)\n"
"       {\n"
"           if ((a.z & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.z = -1;\n"
"   }\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibFindMSB_Func_8 =
"lowp ivec4 _viv_findMSB_8(highp uvec4 a)\n"
"{\n"
"   lowp ivec4 result;\n"
"   highp uint mask;\n"
"   if (a.x != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.x = 31; result.x >= 0 ; result.x--)\n"
"       {\n"
"           if ((a.x & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.x = -1;\n"
"   }\n"
"   if (a.y != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.y = 31; result.y >= 0 ; result.y--)\n"
"       {\n"
"           if ((a.y & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.y = -1;\n"
"   }\n"
"   if (a.z != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.z = 31; result.z >= 0 ; result.z--)\n"
"       {\n"
"           if ((a.z & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.z = -1;\n"
"   }\n"
"   if (a.w != 0u ) { \n"
"       mask = 1u << 31;\n"
"       for (result.w = 31; result.w >= 0 ; result.w--)\n"
"       {\n"
"           if ((a.w & mask)  != 0u) { break; } \n"
"           mask = mask >> 1;\n"
"       }\n"
"   } else { \n"
"       result.w = -1;\n"
"   }\n"
"   return result;\n"
"}\n";


/* findMSB gc7000 implementation */
static gctSTRING gcLibFindMSB_Func_1_hati4 =
"lowp int _viv_findMSB_1(highp int a)\n"
"{\n"
"   lowp int result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindMSB_Func_2_hati4 =
"lowp ivec2 _viv_findMSB_2(highp ivec2 a)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindMSB_Func_3_hati4 =
"lowp ivec3 _viv_findMSB_3(highp ivec3 a)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindMSB_Func_4_hati4 =
"lowp ivec4 _viv_findMSB_4(highp ivec4 a)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindMSB_Func_5_hati4 =
"lowp int _viv_findMSB_5(highp uint a)\n"
"{\n"
"   int result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindMSB_Func_6_hati4 =
"lowp ivec2 _viv_findMSB_6(highp uvec2 a)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindMSB_Func_7_hati4 =
"lowp ivec3 _viv_findMSB_7(highp uvec3 a)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFindMSB_Func_8_hati4 =
"lowp ivec4 _viv_findMSB_8(highp uvec4 a)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(FINDMSB, result, a);\n"
"   return result;\n"
"}\n";

/* bitfieldReverse gc3000/5000 implementation */
static gctSTRING gcLibBitfieldReverse_Func_1 =
"highp int _viv_bitfieldReverse_1(highp int a)\n"
"{\n"
"   highp uint temp = uint(a);\n"
"   highp uint result = ((temp >> 1) & 0x55555555u) | ((temp & 0x55555555u) << 1);\n"
"   result  = ((result >> 2) & 0x33333333u) | ((result & 0x33333333u) << 2);\n"
"   result = ((result >> 4) & 0x0F0F0F0Fu) | ((result & 0x0F0F0F0Fu) << 4);\n"
"   result = ((result >> 8) & 0x00FF00FFu) | ((result & 0x00FF00FFu) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return int(result);\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_2 =
"highp ivec2 _viv_bitfieldReverse_2(highp ivec2 a)\n"
"{\n"
"   highp uvec2 temp = uvec2(a);\n"
"   highp uvec2 result = ((temp >> 1) & uvec2(0x55555555u)) | ((temp & uvec2(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec2(0x33333333u)) | ((result & uvec2(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec2(0x0F0F0F0Fu)) | ((result & uvec2(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec2(0x00FF00FFu)) | ((result & uvec2(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return ivec2(result);\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_3 =
"highp ivec3 _viv_bitfieldReverse_3(highp ivec3 a)\n"
"{\n"
"   highp uvec3 temp = uvec3(a);\n"
"   highp uvec3 result = ((temp >> 1) & uvec3(0x55555555u)) | ((temp & uvec3(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec3(0x33333333u)) | ((result & uvec3(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec3(0x0F0F0F0Fu)) | ((result & uvec3(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec3(0x00FF00FFu)) | ((result & uvec3(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return ivec3(result);\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_4 =
"highp ivec4 _viv_bitfieldReverse_4(highp ivec4 a)\n"
"{\n"
"   highp uvec4 temp = uvec4(a);\n"
"   highp uvec4 result = ((temp >> 1) & uvec4(0x55555555u)) | ((temp & uvec4(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec4(0x33333333u)) | ((result & uvec4(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec4(0x0F0F0F0Fu)) | ((result & uvec4(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec4(0x00FF00FFu)) | ((result & uvec4(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return ivec4(result);\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_5 =
"highp uint _viv_bitfieldReverse_5(highp uint a)\n"
"{\n"
"   highp uint result = ((a >> 1) & 0x55555555u) | ((a & 0x55555555u) << 1);\n"
"   result  = ((result >> 2) & 0x33333333u) | ((result & 0x33333333u) << 2);\n"
"   result = ((result >> 4) & 0x0F0F0F0Fu) | ((result & 0x0F0F0F0Fu) << 4);\n"
"   result = ((result >> 8) & 0x00FF00FFu) | ((result & 0x00FF00FFu) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_6 =
"highp uvec2 _viv_bitfieldReverse_6(highp uvec2 a)\n"
"{\n"
"   highp uvec2 result = ((a >> 1) & uvec2(0x55555555u)) | ((a & uvec2(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec2(0x33333333u)) | ((result & uvec2(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec2(0x0F0F0F0Fu)) | ((result & uvec2(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec2(0x00FF00FFu)) | ((result & uvec2(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_7 =
"highp uvec3 _viv_bitfieldReverse_7(highp uvec3 a)\n"
"{\n"
"   highp uvec3 result = ((a >> 1) & uvec3(0x55555555u)) | ((a & uvec3(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec3(0x33333333u)) | ((result & uvec3(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec3(0x0F0F0F0Fu)) | ((result & uvec3(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec3(0x00FF00FFu)) | ((result & uvec3(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_8 =
"highp uvec4 _viv_bitfieldReverse_8(highp uvec4 a)\n"
"{\n"
"   highp uvec4 result = ((a >> 1) & uvec4(0x55555555u)) | ((a & uvec4(0x55555555u)) << 1);\n"
"   result  = ((result >> 2) & uvec4(0x33333333u)) | ((result & uvec4(0x33333333u)) << 2);\n"
"   result = ((result >> 4) & uvec4(0x0F0F0F0Fu)) | ((result & uvec4(0x0F0F0F0Fu)) << 4);\n"
"   result = ((result >> 8) & uvec4(0x00FF00FFu)) | ((result & uvec4(0x00FF00FFu)) << 8);\n"
"   result = (result >> 16 ) | (result << 16);\n"
"   return result;\n"
"}\n";

/* bitfieldReverse gc7000 implementation */
static gctSTRING gcLibBitfieldReverse_Func_1_hati4 =
"highp int _viv_bitfieldReverse_1(highp int a)\n"
"{\n"
"   highp int result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_2_hati4 =
"highp ivec2 _viv_bitfieldReverse_2(highp ivec2 a)\n"
"{\n"
"   highp ivec2 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_3_hati4 =
"highp ivec3 _viv_bitfieldReverse_3(highp ivec3 a)\n"
"{\n"
"   highp ivec3 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibBitfieldReverse_Func_4_hati4 =
"highp ivec4 _viv_bitfieldReverse_4(highp ivec4 a)\n"
"{\n"
"   highp ivec4 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_5_hati4 =
"highp uint _viv_bitfieldReverse_5(highp uint a)\n"
"{\n"
"   highp uint result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_6_hati4 =
"highp uvec2 _viv_bitfieldReverse_6(highp uvec2 a)\n"
"{\n"
"   highp uvec2 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibBitfieldReverse_Func_7_hati4 =
"highp uvec3 _viv_bitfieldReverse_7(highp uvec3 a)\n"
"{\n"
"   highp uvec3 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldReverse_Func_8_hati4 =
"highp uvec4 _viv_bitfieldReverse_8(highp uvec4 a)\n"
"{\n"
"   highp uvec4 result;\n"
"   _viv_asm(BIT_REVERSAL, result, a);\n"
"   return result;\n"
"}\n";

/* bitfieldExtract gc3000/5000 implementation */
static gctSTRING gcLibBitfieldExtract_Func_1 =
"int _viv_bitfieldExtract_int(int a, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   if (offset >= 32) { result = 0u; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uint mask = (~0u >> (32 - bits));\n"
"           highp uint aa = uint(a);\n"
"           result = (aa >> offset) & mask;\n"
"           if (((result >> (bits -1)) & 0x1u) != 0u) {\n"
"               /* sign extension */\n"
"               mask = (~0u << (bits -1));\n"
"               result = result | mask;\n"
"           }\n"
"       } else { \n"
"           result = 0u;\n"
"       }\n"
"   }\n"
"   return int(result);\n"
"}\n"
"int _viv_bitfieldExtract_int_const(int a, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   highp uint mask = (~0u >> (32 - bits));\n"
"   result = (uint(a) >> offset) & mask;\n"
"   if (((result >> (bits -1)) & 0x1u) != 0u) {\n"
"       /* sign extension */\n"
"       mask = (~0u << (bits -1));\n"
"       result = result | mask;\n"
"   }\n"
"   return int(result);\n"
"}\n";

static gctSTRING gcLibBitfieldExtract_Func_2 =
"ivec2 _viv_bitfieldExtract_ivec2(ivec2 a, int offset, int bits)\n"
"{\n"
"   highp uvec2 result;\n"
"   if (offset >= 32) { result = uvec2(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec2 mask = (uvec2(~0u) >> (32 - bits));\n"
"           highp uvec2 aa = uvec2(a);\n"
"           result = (aa >> offset) & mask;\n"
"           bvec2 sel = notEqual(((result >> (bits -1)) & uvec2(0x1u)), uvec2(0u));\n"
"           mask = (uvec2(~0u) << (bits - 1));\n"
"           result = mix(result, (result | mask), sel);\n"
"       } else { \n"
"           result = uvec2(0u);\n"
"       }\n"
"   }\n"
"   return ivec2(result);\n"
"}\n";

static gctSTRING gcLibBitfieldExtract_Func_3 =
"ivec3 _viv_bitfieldExtract_ivec3(ivec3 a, int offset, int bits)\n"
"{\n"
"   highp uvec3 result;\n"
"   if (offset >= 32) { result = uvec3(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec3 mask = (uvec3(~0u) >> (32 - bits));\n"
"           highp uvec3 aa = uvec3(a);\n"
"           result = (aa >> offset) & mask;\n"
"           bvec3 sel = notEqual(((result >> (bits -1)) & uvec3(0x1u)), uvec3(0u));\n"
"           mask = (uvec3(~0u) << (bits-1));\n"
"           result = mix(result, (result | mask), sel);\n"
"       } else { \n"
"           result = uvec3(0u);\n"
"       }\n"
"   }\n"
"   return ivec3(result);\n"
"}\n";

static gctSTRING gcLibBitfieldExtract_Func_4 =
"ivec4 _viv_bitfieldExtract_ivec4(ivec4 a, int offset, int bits)\n"
"{\n"
"   highp uvec4 result;\n"
"   if (offset >= 32) { result = uvec4(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec4 mask = (uvec4(~0u) >> (32 - bits));\n"
"           highp uvec4 aa = uvec4(a);\n"
"           result = (aa >> offset) & mask;\n"
"           bvec4 sel = notEqual(((result >> (bits -1)) & uvec4(0x1u)), uvec4(0u));\n"
"           mask = (uvec4(~0u) << (bits-1));\n"
"           result = mix(result, (result | mask), sel);\n"
"       } else { \n"
"           result = uvec4(0u);\n"
"       }\n"
"   }\n"
"   return ivec4(result);\n"
"}\n";

static gctSTRING gcLibBitfieldExtract_Func_5 =
"uint _viv_bitfieldExtract_uint(uint a, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   if (offset >= 32) { result = 0u; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uint mask = (~0u >> (32 - bits));\n"
"           result = (a >> offset) & mask;\n"
"       } else { \n"
"           result = 0u;\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n"
"highp uint _viv_bitfieldExtract_uint_const(highp uint a, int offset, int bits)\n"
"{\n"
"   highp uint mask = (~0u >> (32 - bits));\n"
"   highp uint result = (a >> offset) & mask;\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldExtract_Func_6 =
"uvec2 _viv_bitfieldExtract_uvec2(uvec2 a, int offset, int bits)\n"
"{\n"
"   highp uvec2 result;\n"
"   if (offset >= 32) { result = uvec2(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec2 mask = (uvec2(~0u) >> (32 - bits));\n"
"           result = (a >> offset) & mask;\n"
"       } else { \n"
"           result = uvec2(0u);\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldExtract_Func_7 =
"uvec3 _viv_bitfieldExtract_uvec3(uvec3 a, int offset, int bits)\n"
"{\n"
"   highp uvec3 result;\n"
"   if (offset >= 32) { result = uvec3(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec3 mask = (uvec3(~0u) >> (32 - bits));\n"
"           result = (a >> offset) & mask;\n"
"       } else { \n"
"           result = uvec3(0u);\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldExtract_Func_8 =
"uvec4 _viv_bitfieldExtract_uvec4(uvec4 a, int offset, int bits)\n"
"{\n"
"   highp uvec4 result;\n"
"   if (offset >= 32) { result = uvec4(0u); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           highp uvec4 mask = (uvec4(~0u) >> (32 - bits));\n"
"           result = (a >> offset) & mask;\n"
"       } else { \n"
"           result = uvec4(0u);\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n";

/* bitfieldExtract gc7000 implementation */
static gctSTRING gcLibBitfieldExtract_Func_1_hati4 =
"int _viv_bitfieldExtract_int(int a, int offset, int bits)\n"
"{\n"
"   int result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"int _viv_bitfieldExtract_int_const(int a, int offset, int bits)\n"
"{\n"
"   int result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldExtract_Func_2_hati4 =
"ivec2 _viv_bitfieldExtract_ivec2(ivec2 a, int offset, int bits)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldExtract_Func_3_hati4 =
"ivec3 _viv_bitfieldExtract_ivec3(ivec3 a, int offset, int bits)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibBitfieldExtract_Func_4_hati4 =
"ivec4 _viv_bitfieldExtract_ivec4(ivec4 a, int offset, int bits)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibBitfieldExtract_Func_5_hati4 =
"uint _viv_bitfieldExtract_uint(uint a, int offset, int bits)\n"
"{\n"
"   uint result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n"
"highp uint _viv_bitfieldExtract_uint_const(highp uint a, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibBitfieldExtract_Func_6_hati4 =
"uvec2 _viv_bitfieldExtract_uvec2(uvec2 a, int offset, int bits)\n"
"{\n"
"   uvec2 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibBitfieldExtract_Func_7_hati4 =
"uvec3 _viv_bitfieldExtract_uvec3(uvec3 a, int offset, int bits)\n"
"{\n"
"   uvec3 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibBitfieldExtract_Func_8_hati4 =
"uvec4 _viv_bitfieldExtract_uvec4(uvec4 a, int offset, int bits)\n"
"{\n"
"   uvec4 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITEXTRACT, result, a);\n"
"   return result;\n"
"}\n";

/* bitfieldInsert gc3000/5000 implementation */
static gctSTRING gcLibBitfieldInsert_Func_1 =
"int _viv_bitfieldInsert_int(int a, int b, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   if (offset >= 32) { result = uint(a); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = uint(a);\n"
"           highp uint mask = (~0u >> (32 - bits)) << offset;\n"
"           result = result & ~mask;\n"
"           result = result | ((uint(b) << offset) & mask);\n"
"       } else { \n"
"           result = uint(a);\n"
"       }\n"
"   }\n"
"   return int(result);\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_2 =
"ivec2 _viv_bitfieldInsert_ivec2(ivec2 a, ivec2 b, int offset, int bits)\n"
"{\n"
"   highp uvec2 result;\n"
"   if (offset >= 32) { result = uvec2(a); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = uvec2(a);\n"
"           highp uvec2 mask = (uvec2(~0u) >> (32 - bits)) << offset;\n"
"           result = result & ~mask;\n"
"           result = result | ((uvec2(b) << offset) & mask);\n"
"       } else { \n"
"           result = uvec2(a);\n"
"       }\n"
"   }\n"
"   return ivec2(result);\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_3 =
"ivec3 _viv_bitfieldInsert_ivec3(ivec3 a, ivec3 b, int offset, int bits)\n"
"{\n"
"   highp uvec3 result;\n"
"   if (offset >= 32) { result = uvec3(a); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = uvec3(a);\n"
"           highp uvec3 mask = (uvec3(~0u) >> (32 - bits)) << offset;\n"
"           result = result & ~mask;\n"
"           result = result | ((uvec3(b) << offset) & mask);\n"
"       } else { \n"
"           result = uvec3(a);\n"
"       }\n"
"   }\n"
"   return ivec3(result);\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_4 =
"ivec4 _viv_bitfieldInsert_ivec4(ivec4 a, ivec4 b, int offset, int bits)\n"
"{\n"
"   highp uvec4 result;\n"
"   if (offset >= 32) { result = uvec4(a); \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = uvec4(a);\n"
"           highp uvec4 mask = (uvec4(~0u) >> (32 - bits)) << offset;\n"
"           result = result & ~mask;\n"
"           result = result | ((uvec4(b) << offset) & mask);\n"
"       } else { \n"
"           result = uvec4(a);\n"
"       }\n"
"   }\n"
"   return ivec4(result);\n"
"}\n";


static gctSTRING gcLibBitfieldInsert_Func_5 =
"uint _viv_bitfieldInsert_uint(uint a, uint b, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   if (offset >= 32) { result = a; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = a;\n"
"           highp uint aa = ~0u >> (32 - bits); \n"
"           highp uint mask = aa << offset;\n"
"           result = result & ~mask;\n"
"           highp uint bb = b << offset; \n"
"           result = result | (bb & mask);\n"
"       } else { \n"
"           result = a;\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n"
"highp uint _viv_bitfieldInsert_uint_const(highp uint a, highp uint b, int offset, int bits)\n"
"{\n"
"   highp uint result = a;\n"
"   highp uint mask = (~0u >> (32 - bits)) << offset;\n"
"   result = result & ~mask;\n"
"   result = result | ((b << offset) & mask);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_6 =
"uvec2 _viv_bitfieldInsert_uvec2(uvec2 a, uvec2 b, int offset, int bits)\n"
"{\n"
"   highp uvec2 result;\n"
"   if (offset >= 32) { result = a; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = a;\n"
"           highp uvec2 aa = uvec2(~0u) >> (32 - bits); \n"
"           highp uvec2 mask = aa << offset;\n"
"           result = result & ~mask;\n"
"           highp uvec2 bb = b << offset; \n"
"           result = result | (bb & mask);\n"
"       } else { \n"
"           result = a;\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_7 =
"uvec3 _viv_bitfieldInsert_uvec3(uvec3 a, uvec3 b, int offset, int bits)\n"
"{\n"
"   highp uvec3 result;\n"
"   if (offset >= 32) { result = a; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = a;\n"
"           highp uvec3 aa = uvec3(~0u) >> (32 - bits); \n"
"           highp uvec3 mask = aa << offset;\n"
"           result = result & ~mask;\n"
"           highp uvec3 bb = b << offset; \n"
"           result = result | (bb & mask);\n"
"       } else { \n"
"           result = a;\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_8 =
"uvec4 _viv_bitfieldInsert_uvec4(uvec4 a, uvec4 b, int offset, int bits)\n"
"{\n"
"   highp uvec4 result;\n"
"   if (offset >= 32) { result = a; \n"
"   } else { \n"
"       if (bits > 32) bits = 32;\n"
"       if (bits > 0) { \n"
"           result = a;\n"
"           highp uvec4 aa = uvec4(~0u) >> (32 - bits); \n"
"           highp uvec4 mask = aa << offset;\n"
"           result = result & ~mask;\n"
"           highp uvec4 bb = b << offset; \n"
"           result = result | (bb & mask);\n"
"       } else { \n"
"           result = a;\n"
"       }\n"
"   }\n"
"   return result;\n"
"}\n";

/* bitfieldInsert gc7000 implementation */
static gctSTRING gcLibBitfieldInsert_Func_1_hati4 =
"int _viv_bitfieldInsert_int(int a, int b, int offset, int bits)\n"
"{\n"
"   int result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_2_hati4 =
"ivec2 _viv_bitfieldInsert_ivec2(ivec2 a, ivec2 b, int offset, int bits)\n"
"{\n"
"   ivec2 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_3_hati4 =
"ivec3 _viv_bitfieldInsert_ivec3(ivec3 a, ivec3 b, int offset, int bits)\n"
"{\n"
"   ivec3 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_4_hati4 =
"ivec4 _viv_bitfieldInsert_ivec4(ivec4 a, ivec4 b, int offset, int bits)\n"
"{\n"
"   ivec4 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_5_hati4 =
"uint _viv_bitfieldInsert_uint(uint a, uint b, int offset, int bits)\n"
"{\n"
"   uint result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n"
"highp uint _viv_bitfieldInsert_uint_const(highp uint a, highp uint b, int offset, int bits)\n"
"{\n"
"   highp uint result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_6_hati4 =
"uvec2 _viv_bitfieldInsert_uvec2(uvec2 a, uvec2 b, int offset, int bits)\n"
"{\n"
"   uvec2 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibBitfieldInsert_Func_7_hati4 =
"uvec3 _viv_bitfieldInsert_uvec3(uvec3 a, uvec3 b, int offset, int bits)\n"
"{\n"
"   uvec3 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibBitfieldInsert_Func_8_hati4 =
"uvec4 _viv_bitfieldInsert_uvec4(uvec4 a, uvec4 b, int offset, int bits)\n"
"{\n"
"   uvec4 result;\n"
"   _viv_asm(BITRANGE, result, offset, bits);\n"
"   _viv_asm(BITINSERT, result, a, b);\n"
"   return result;\n"
"}\n";

/* uaddCarry gc3000/gc5000 implementation */
static gctSTRING gcLibUaddCarry_Func_1 =
"highp uint _viv_uaddCarry_1(highp uint a, highp uint b, out lowp uint c)\n"
"{\n"
"   highp uint result = a + b;\n"
"   highp uint temp = min(a, b);\n"
"   c = result < temp ? 1u : 0u;\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibUaddCarry_Func_2 =
"highp uvec2 _viv_uaddCarry_2(highp uvec2 a, highp uvec2 b, out lowp uvec2 c)\n"
"{\n"
"   highp uvec2 result = a + b;\n"
"   highp uvec2 temp = min(a, b);\n"
"   bvec2 sel = lessThan(result, temp);\n"
"   c = mix(uvec2(0u), uvec2(1u), sel);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function uaddCarry */
static gctSTRING gcLibUaddCarry_Func_3 =
"highp uvec3 _viv_uaddCarry_3(highp uvec3 a, highp uvec3 b, out lowp uvec3 c)\n"
"{\n"
"   highp uvec3 result = a + b;\n"
"   highp uvec3 temp = min(a, b);\n"
"   bvec3 sel = lessThan(result, temp);\n"
"   c = mix(uvec3(0u), uvec3(1u), sel);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function uaddCarry */
static gctSTRING gcLibUaddCarry_Func_4 =
"highp uvec4 _viv_uaddCarry_4(highp uvec4 a, highp uvec4 b, out lowp uvec4 c)\n"
"{\n"
"   highp uvec4 result = a + b;\n"
"   highp uvec4 temp = min(a, b);\n"
"   bvec4 sel = lessThan(result, temp);\n"
"   c = mix(uvec4(0u), uvec4(1u), sel);\n"
"   return result;\n"
"}\n";

/* uaddCarry gc7000 implementation */
static gctSTRING gcLibUaddCarry_Func_1_hati4 =
"highp uint _viv_uaddCarry_1(highp uint a, highp uint b, out lowp uint c)\n"
"{\n"
"   highp uint result = a + b;\n"
"   _viv_asm(UCARRY, c, a, b);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibUaddCarry_Func_2_hati4 =
"highp uvec2 _viv_uaddCarry_2(highp uvec2 a, highp uvec2 b, out lowp uvec2 c)\n"
"{\n"
"   highp uvec2 result = a + b;\n"
"   _viv_asm(UCARRY, c, a, b);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function uaddCarry */
static gctSTRING gcLibUaddCarry_Func_3_hati4 =
"highp uvec3 _viv_uaddCarry_3(highp uvec3 a, highp uvec3 b, out lowp uvec3 c)\n"
"{\n"
"   highp uvec3 result = a + b;\n"
"   _viv_asm(UCARRY, c, a, b);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function uaddCarry */
static gctSTRING gcLibUaddCarry_Func_4_hati4 =
"highp uvec4 _viv_uaddCarry_4(highp uvec4 a, highp uvec4 b, out lowp uvec4 c)\n"
"{\n"
"   highp uvec4 result = a + b;\n"
"   _viv_asm(UCARRY, c, a, b);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function ldexp */
/* The function ldexp() builds a single-precision floatingpoint
    number from each significand component in x and
    the corresponding integral exponent of two in exp,
    returning:
       x = significand* 2 ^ exponent

    If exponent is greater than +128, the value returned is
    undefined. If exponent is less than -126, the value
    returned may be flushed to zero. Additionally, splitting
    the value into a significand and exponent using frexp()
    and then reconstructing a floating-point value using
    ldexp() should yield the original input for zero and all
    finite non-subnormal values.
    If the input x is a vector, this operation is performed in a
    component-wise manner; the value passed in exp and
    returned by the function are vectors with the same
    number of components as x.
*/
static gctSTRING gcLibLDEXP_Func_1 =
"highp float _viv_ldexp_1(highp float a, highp int b)\n"
"{\n"
"   highp int temp, exp0, exp;\n"
"   highp float result;\n"
"   highp uint bits = floatBitsToUint(a);\n"
"   exp0 = int(_viv_bitfieldExtract_uint_const(bits, 23, 8));\n"
"   exp = exp0 + b;\n"
"   if (a == 0.0) {\n"
"       result = ((bits & 0x80000000u) != 0U) ? -0.0 : 0.0; /* denorm flushed to 0.0 */\n"
"   }\n"
"   else if (isnan(a) || isinf(a) || b == 0) result = a;\n"
"   else if (exp <= 0) result = 0.0;\n"
"   else if (exp >= 255) {\n"
"       /* +/- inf */\n"
"       result = (a>0.0) ? uintBitsToFloat(0x7F800000u) : uintBitsToFloat(0xFF800000u);\n"
"   }\n"
"   else {\n"
    "   temp = _viv_bitfieldInsert_int(floatBitsToInt(a), exp, 23, 8);\n"
    "   result = intBitsToFloat(temp);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibLDEXP_Func_2 =
"highp vec2 _viv_ldexp_2(highp vec2 a, highp ivec2 b)\n"
"{\n"
"   highp vec2 result;\n"
"   result.x = _viv_ldexp_1(a.x, b.x);\n"
"   result.y = _viv_ldexp_1(a.y, b.y);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibLDEXP_Func_3 =
"highp vec3 _viv_ldexp_3(highp vec3 a, highp ivec3 b)\n"
"{\n"
"   highp vec3 result;\n"
"   result.x = _viv_ldexp_1(a.x, b.x);\n"
"   result.y = _viv_ldexp_1(a.y, b.y);\n"
"   result.z = _viv_ldexp_1(a.z, b.z);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibLDEXP_Func_4 =
"highp vec4 _viv_ldexp_4(highp vec4 a, highp ivec4 b)\n"
"{\n"
"   highp vec4 result;\n"
"   result.x = _viv_ldexp_1(a.x, b.x);\n"
"   result.y = _viv_ldexp_1(a.y, b.y);\n"
"   result.z = _viv_ldexp_1(a.z, b.z);\n"
"   result.w = _viv_ldexp_1(a.w, b.w);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function frexp */
static gctSTRING gcLibFREXP_Func_1 =
"highp float _viv_frexp_1(highp float a, out highp int b)\n"
"{\n"
"   highp uint exp = _viv_bitfieldExtract_uint_const(floatBitsToUint(a), 23, 8);\n"
"   b = int(exp) - 126;\n"
"   b = (a == 0.0)? 0 : b;\n"
"   highp int temp = _viv_bitfieldInsert_int(floatBitsToInt(a), 126, 23, 8);\n"
"   highp float result = intBitsToFloat(temp);\n"
"   result = (a == 0.0)? a : result;\n"
"   return result;\n"
"}\n";

/* TO-DO: can be optimized to one select instruction for component-wise compare */
static gctSTRING gcLibFREXP_Func_2 =
"highp vec2 _viv_frexp_2(highp vec2 a, out highp ivec2 b)\n"
"{\n"
"   highp uvec2 exp = _viv_bitfieldExtract_uvec2(floatBitsToUint(a), 23, 8);\n"
"   b = ivec2(exp) - ivec2(126);\n"
"   bvec2 sel = notEqual(a, vec2(0.0));\n"
"   b = mix(ivec2(0), b, sel);\n"
"   highp ivec2 temp = _viv_bitfieldInsert_ivec2(floatBitsToInt(a), ivec2(126), 23, 8);\n"
"   highp vec2 result = intBitsToFloat(temp);\n"
"   result = mix(a, result, sel);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibFREXP_Func_3 =
"highp vec3 _viv_frexp_3(highp vec3 a, out highp ivec3 b)\n"
"{\n"
"   highp uvec3 exp = _viv_bitfieldExtract_uvec3(floatBitsToUint(a), 23, 8);\n"
"   b = ivec3(exp) - ivec3(126);\n"
"   bvec3 sel = notEqual(a, vec3(0.0));\n"
"   b = mix(ivec3(0), b, sel);\n"
"   highp ivec3 temp = _viv_bitfieldInsert_ivec3(floatBitsToInt(a), ivec3(126), 23, 8);\n"
"   highp vec3 result = intBitsToFloat(temp);\n"
"   result = mix(a, result, sel);\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibFREXP_Func_4 =
"highp vec4 _viv_frexp_4(highp vec4 a, out highp ivec4 b)\n"
"{\n"
"   highp uvec4 exp = _viv_bitfieldExtract_uvec4(floatBitsToUint(a), 23, 8);\n"
"   b = ivec4(exp) - ivec4(126);\n"
"   bvec4 sel = notEqual(a, vec4(0.0));\n"
"   b = mix(ivec4(0), b, sel);\n"
"   highp ivec4 temp = _viv_bitfieldInsert_ivec4(floatBitsToInt(a), ivec4(126), 23, 8);\n"
"   highp vec4 result = intBitsToFloat(temp);\n"
"   result = mix(a, result, sel);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function usubBorrow */
static gctSTRING gcLibUsubBorrow_Func_1 =
"highp uint _viv_usubBorrow_1(highp uint a, highp uint b, out lowp uint c)\n"
"{\n"
"   highp uint result = a - b;\n"
"   c = a >= b ? 0u : 1u;\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibUsubBorrow_Func_2 =
"highp uvec2 _viv_usubBorrow_2(highp uvec2 a, highp uvec2 b, out lowp uvec2 c)\n"
"{\n"
"   highp uvec2 result = a - b;\n"
"   bvec2 sel = greaterThanEqual(a, b);\n"
"   c = mix (uvec2(1u), uvec2(0u), sel);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibUsubBorrow_Func_3 =
"highp uvec3 _viv_usubBorrow_3(highp uvec3 a, highp uvec3 b, out lowp uvec3 c)\n"
"{\n"
"   highp uvec3 result = a - b;\n"
"   bvec3 sel = greaterThanEqual(a, b);\n"
"   c = mix (uvec3(1u), uvec3(0u), sel);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibUsubBorrow_Func_4 =
"highp uvec4 _viv_usubBorrow_4(highp uvec4 a, highp uvec4 b, out lowp uvec4 c)\n"
"{\n"
"   highp uvec4 result = a - b;\n"
"   bvec4 sel = greaterThanEqual(a, b);\n"
"   c = mix (uvec4(1u), uvec4(0u), sel);\n"
"   return result;\n"
"}\n";

/* high level function for Pack/Unpack */
static gctSTRING gcLibPack_Func =
"highp uint _viv_packUnorm4x8(mediump vec4 a)\n"
"{\n"
"   vec4 temp;\n"
"   temp = _viv_round_vec4(clamp(a, vec4(0.0), vec4(1.0)) * vec4(255.0));\n"
"   highp uint result = uint(temp.x) & 0xFFu;\n"
"   result = result | ((uint(temp.y) & 0xFFu) << 8 );\n"
"   result = result | ((uint(temp.z) & 0xFFu) << 16 );\n"
"   result = result | ((uint(temp.w) & 0xFFu) << 24 );\n"
"   return result;\n"
"}\n"
"highp uint _viv_packUnorm2x16(vec2 a)\n"
"{\n"
"   vec2 temp;\n"
"   temp = _viv_round_vec2(clamp(a, vec2(0.0), vec2(1.0)) * vec2(65535.0));\n"
"   highp uint result = uint(temp.x) & 0xFFFFu;\n"
"   result = result | ((uint(temp.y) & 0xFFFFu) << 16 );\n"
"   return result;\n"
"}\n"
"highp uint _viv_packSnorm4x8(mediump vec4 a)\n"
"{\n"
"   vec4 temp;\n"
"   temp = _viv_round_vec4(clamp(a, vec4(-1.0), vec4(1.0)) * vec4(127.0));\n"
"   highp int result = int(temp.x) & 0xFF;\n"
"   result = result | ((int(temp.y) & 0xFF) << 8 );\n"
"   result = result | ((int(temp.z) & 0xFF) << 16 );\n"
"   result = result | ((int(temp.w) & 0xFF) << 24 );\n"
"   return uint(result);\n"
"}\n"
"highp uint _viv_packSnorm2x16(vec2 a)\n"
"{\n"
"   vec2 temp;\n"
"   temp = _viv_round_vec2(clamp(a, vec2(-1.0), vec2(1.0)) * vec2(32767.0));\n"
"   highp int result = int(temp.x) & 0xFFFF;\n"
"   result = result | ((int(temp.y) & 0xFFFF) << 16 );\n"
"   return uint(result);\n"
"}\n"
"highp uint _viv_packHalf2x16(mediump vec2 a)\n"
"{\n"
"   mediump vec2 temp;\n"
/* conv source1 is the source data type, here it is float*/
"   _viv_asm(CONV, temp!<f:FLOAT16>, a, 0);\n"
"   highp uint result = (floatBitsToUint(temp.x) & 0xFFFFu);\n"
"   result = result | ((floatBitsToUint(temp.y) & 0xFFFFu) << 16);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibUnpack_Func =
"mediump vec4 _viv_unpackUnorm4x8(highp uint a)\n"
"{\n"
"   highp uint temp = _viv_bitfieldExtract_uint_const(a, 0, 8);\n"
"   vec4 result;\n"
"   result.x = float(temp) / 255.0;\n"
"   temp = _viv_bitfieldExtract_uint_const(a, 8, 8);\n"
"   result.y = float(temp) / 255.0;\n"
"   temp = _viv_bitfieldExtract_uint_const(a, 16, 8);\n"
"   result.z = float(temp) / 255.0;\n"
"   temp = _viv_bitfieldExtract_uint_const(a, 24, 8);\n"
"   result.w = float(temp) / 255.0;\n"
"   return result;\n"
"}\n"
"highp vec2 _viv_unpackUnorm2x16(highp uint a)\n"
"{\n"
"   highp uint temp = _viv_bitfieldExtract_uint_const(a, 0, 16);\n"
"   highp vec2 result;\n"
"   result.x = float(temp) / 65535.0;\n"
"   temp = _viv_bitfieldExtract_uint_const(a, 16, 16);\n"
"   result.y = float(temp) / 65535.0;\n"
"   return result;\n"
"}\n"
"mediump vec4 _viv_unpackSnorm4x8(highp uint a)\n"
"{\n"
"   highp int temp = _viv_bitfieldExtract_int_const(int(a), 0, 8);\n"
"   vec4 result;\n"
"   result.x = clamp(float(temp) / 127.0, -1.0, 1.0);\n"
"   temp = _viv_bitfieldExtract_int_const(int(a), 8, 8);\n"
"   result.y = clamp(float(temp) / 127.0, -1.0, 1.0);\n"
"   temp = _viv_bitfieldExtract_int_const(int(a), 16, 8);\n"
"   result.z = clamp(float(temp) / 127.0, -1.0, 1.0);\n"
"   temp = _viv_bitfieldExtract_int_const(int(a), 24, 8);\n"
"   result.w = clamp(float(temp) / 127.0, -1.0, 1.0);\n"
"   return result;\n"
"}\n"
"highp vec2 _viv_unpackSnorm2x16(highp uint a)\n"
"{\n"
"   highp int temp = _viv_bitfieldExtract_int_const(int(a), 0, 16);\n"
"   highp vec2 result;\n"
"   result.x = clamp(float(temp) / 32767.0, -1.0, 1.0);\n"
"   temp = _viv_bitfieldExtract_int_const(int(a), 16, 16);\n"
"   result.y = clamp(float(temp) / 32767.0, -1.0, 1.0);\n"
"   return result;\n"
"}\n"
"mediump vec2 _viv_unpackHalf2x16(highp uint a)\n"
"{\n"
"   highp vec2 result;\n"
"   highp uint temp = a & 0xFFFFu;\n"
"   highp float tempx, tempy;\n"
/* conv source1 is the source data type, here it is float16*/
"   _viv_asm(CONV, tempx, uintBitsToFloat(temp)!<f:FLOAT16>, 12);\n"
"   temp = a >> 16;\n"
"   _viv_asm(CONV, tempy, uintBitsToFloat(temp)!<f:FLOAT16>, 12);\n"
"   result.x = tempx;\n"
"   result.y = tempy;\n"
"   return result;\n"
"}\n";

/* use inline assembly to write these functions */
static gctSTRING gcLibUmulExtended_Func_1 =
"void _viv_umulExtended_1(highp uint a, highp uint b, out highp uint msb, out highp uint lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

static gctSTRING gcLibUmulExtended_Func_2 =
"void _viv_umulExtended_2(highp uvec2 a, highp uvec2 b, out highp uvec2 msb, out highp uvec2 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

static gctSTRING gcLibUmulExtended_Func_3 =
"void _viv_umulExtended_3(highp uvec3 a, highp uvec3 b, out highp uvec3 msb, out highp uvec3 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

static gctSTRING gcLibUmulExtended_Func_4 =
"void _viv_umulExtended_4(highp uvec4 a, highp uvec4 b, out highp uvec4 msb, out highp uvec4 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";


static gctSTRING gcLibImulExtended_Func_1 =
"void _viv_imulExtended_1(highp int a, highp int b, out highp int msb, out highp int lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

static gctSTRING gcLibImulExtended_Func_2 =
"void _viv_imulExtended_2(highp ivec2 a, highp ivec2 b, out highp ivec2 msb, out highp ivec2 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

static gctSTRING gcLibImulExtended_Func_3 =
"void _viv_imulExtended_3(highp ivec3 a, highp ivec3 b, out highp ivec3 msb, out highp ivec3 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

static gctSTRING gcLibImulExtended_Func_4 =
"void _viv_imulExtended_4(highp ivec4 a, highp ivec4 b, out highp ivec4 msb, out highp ivec4 lsb)\n"
"{\n"
"   _viv_asm(MULHI, msb, a, b);\n"
"   _viv_asm(MUL, lsb, a, b);\n"
"}\n";

/* high level source for buitin function modf */
static gctSTRING gcLibMODF_Func_1 =
"float _viv_modf_1(float a, out float b)\n"
"{\n"
"   uint temp_u = floatBitsToUint(a) & 0x7fffffffu;\n"
"   float a_abs = abs(a);\n"
"   float a_sign = sign(a);\n"
"   float a_floor = floor(a_abs);\n"
"   float temp_f;\n"
"   if(temp_u == 0x7f800000u)\n"
"   {\n"
"       temp_f = 0.0;\n"
"   }\n"
"   else\n"
"   {\n"
"       temp_f = a_abs - a_floor;\n"
"   }\n"
"   b = a_floor * a_sign;\n"
"   return temp_f * a_sign;\n"
"}\n";
static gctSTRING gcLibMODF_Func_2 =
"vec2 _viv_modf_2(vec2 a, out vec2 b)\n"
"{\n"
"   uvec2 temp_u = floatBitsToUint(a) & 0x7fffffffu;\n"
"   vec2 a_abs = abs(a);\n"
"   vec2 a_sign = sign(a);\n"
"   vec2 a_floor = floor(a_abs);\n"
"   vec2 temp_f;\n"
"   bvec2 sel = equal(temp_u, uvec2(0x7f800000u));\n"
"   temp_f = mix(a_abs - a_floor, vec2(0.0), sel);\n"
"   b = a_floor * a_sign;\n"
"   return temp_f * a_sign;\n"
"}\n";
static gctSTRING gcLibMODF_Func_3 =
"vec3 _viv_modf_3(vec3 a, out vec3 b)\n"
"{\n"
"   uvec3 temp_u = floatBitsToUint(a) & 0x7fffffffu;\n"
"   vec3 a_abs = abs(a);\n"
"   vec3 a_sign = sign(a);\n"
"   vec3 a_floor = floor(a_abs);\n"
"   vec3 temp_f;\n"
"   bvec3 sel = equal(temp_u, uvec3(0x7f800000u));\n"
"   temp_f = mix(a_abs - a_floor, vec3(0.0), sel);\n"
"   b = a_floor * a_sign;\n"
"   return temp_f * a_sign;\n"
"}\n";
static gctSTRING gcLibMODF_Func_4 =
"vec4 _viv_modf_4(vec4 a, out vec4 b)\n"
"{\n"
"   uvec4 temp_u = floatBitsToUint(a) & 0x7fffffffu;\n"
"   vec4 a_abs = abs(a);\n"
"   vec4 a_sign = sign(a);\n"
"   vec4 a_floor = floor(a_abs);\n"
"   vec4 temp_f;\n"
"   bvec4 sel = equal(temp_u, uvec4(0x7f800000u));\n"
"   temp_f = mix(a_abs - a_floor, vec4(0.0), sel);\n"
"   b = a_floor * a_sign;\n"
"   return temp_f * a_sign;\n"
"}\n";

/* high level source for buitin function fma */
static gctSTRING gcLibFMA_Func_1 =
"float _viv_fma_1(float a, float b, float c)\n"
"{\n"
"   float temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n";
static gctSTRING gcLibFMA_Func_2 =
"vec2 _viv_fma_2(vec2 a, vec2 b, vec2 c)\n"
"{\n"
"   vec2 temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n";
static gctSTRING gcLibFMA_Func_3 =
"vec3 _viv_fma_3(vec3 a, vec3 b, vec3 c)\n"
"{\n"
"   vec3 temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n";
static gctSTRING gcLibFMA_Func_4 =
"vec4 _viv_fma_4(vec4 a, vec4 b, vec4 c)\n"
"{\n"
"   vec4 temp, result;\n"
"   _viv_asm(FMA_MUL, temp, a, b);\n"
"   _viv_asm(FMA_ADD, result, temp, c);\n"
"   return result;\n"
"}\n";

/* high level source for buitin function reflect */
static gctSTRING gcLibREFLECT_Func_1 =
"float _viv_reflect_1(float I, float N)\n"
"{\n"
"   float temp0 = N * dot(N, I);\n"
"   return -2.0 * temp0 + I;\n"
"}\n";
static gctSTRING gcLibREFLECT_Func_2 =
"vec2 _viv_reflect_2(vec2 I, vec2 N)\n"
"{\n"
"   vec2 temp0 = N * dot(N, I);\n"
"   return -2.0 * temp0 + I;\n"
"}\n";
static gctSTRING gcLibREFLECT_Func_3 =
"vec3 _viv_reflect_3(vec3 I, vec3 N)\n"
"{\n"
"   vec3 temp0 = N * dot(N, I);\n"
"   return -2.0 * temp0 + I;\n"
"}\n";
static gctSTRING gcLibREFLECT_Func_4 =
"vec4 _viv_reflect_4(vec4 I, vec4 N)\n"
"{\n"
"   vec4 temp0 = N * dot(N, I);\n"
"   return -2.0 * temp0 + I;\n"
"}\n";
static gctSTRING gcLibREFLECT_Func_1_fmaSupported =
"float _viv_reflect_1(float I, float N)\n"
"{\n"
"   float temp0 = N * dot(N, I);\n"
"   return _viv_fma_1(-2.0, temp0, I);\n"
"}\n";
static gctSTRING gcLibREFLECT_Func_2_fmaSupported =
"vec2 _viv_reflect_2(vec2 I, vec2 N)\n"
"{\n"
"   vec2 temp0 = N * dot(N, I);\n"
"   return _viv_fma_2(vec2(-2.0), temp0, I);\n"
"}\n";
static gctSTRING gcLibREFLECT_Func_3_fmaSupported =
"vec3 _viv_reflect_3(vec3 I, vec3 N)\n"
"{\n"
"   vec3 temp0 = N * dot(N, I);\n"
"   return _viv_fma_3(vec3(-2.0), temp0, I);\n"
"}\n";
static gctSTRING gcLibREFLECT_Func_4_fmaSupported =
"vec4 _viv_reflect_4(vec4 I, vec4 N)\n"
"{\n"
"   vec4 temp0 = N * dot(N, I);\n"
"   return _viv_fma_4(vec4(-2.0), temp0, I);\n"
"}\n";

/*********************************texture size implementation*********************************/
/* For the 2D sampler. */
static gctSTRING gcLibTextureSize_Func_1 =
"ivec2 _viv_textureSize_float_2D(sampler2D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the cube sampler. */
static gctSTRING gcLibTextureSize_Func_2 =
"ivec2 _viv_textureSize_float_Cube(samplerCube sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D shadow sampler. */
static gctSTRING gcLibTextureSize_Func_3 =
"ivec2 _viv_textureSize_float_2DShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the cube shadow sampler. */
static gctSTRING gcLibTextureSize_Func_4 =
"ivec2 _viv_textureSize_float_CubeShadow(samplerCubeShadow sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 3D sampler. */
static gctSTRING gcLibTextureSize_Func_5 =
"ivec3 _viv_textureSize_float_3D(sampler3D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D array sampler. */
static gctSTRING gcLibTextureSize_Func_6 =
"ivec3 _viv_textureSize_float_Array(sampler2DArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D array shadow sampler. */
static gctSTRING gcLibTextureSize_Func_7 =
"ivec3 _viv_textureSize_float_ArrayShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D sampler. */
static gctSTRING gcLibTextureSize_Func_8 =
"ivec2 _viv_textureSize_int_2D(isampler2D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the cube sampler. */
static gctSTRING gcLibTextureSize_Func_9 =
"ivec2 _viv_textureSize_int_Cube(isamplerCube sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 3D sampler. */
static gctSTRING gcLibTextureSize_Func_10 =
"ivec3 _viv_textureSize_int_3D(isampler3D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D array sampler. */
static gctSTRING gcLibTextureSize_Func_11 =
"ivec3 _viv_textureSize_int_Array(isampler2DArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D sampler. */
static gctSTRING gcLibTextureSize_Func_12 =
"ivec2 _viv_textureSize_uint_2D(usampler2D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the cube sampler. */
static gctSTRING gcLibTextureSize_Func_13 =
"ivec2 _viv_textureSize_uint_Cube(usamplerCube sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec2 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 3D sampler. */
static gctSTRING gcLibTextureSize_Func_14 =
"ivec3 _viv_textureSize_uint_3D(usampler3D sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result = levelBaseSize >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D array sampler. */
static gctSTRING gcLibTextureSize_Func_15 =
"ivec3 _viv_textureSize_uint_Array(usampler2DArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D MS sampler. */
static gctSTRING gcLibTextureSize_Func_16 =
"ivec2 _viv_textureSize_float_MS(sampler2DMS sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec2 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_17 =
"ivec2 _viv_textureSize_int_MS(isampler2DMS sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec2 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_18 =
"ivec2 _viv_textureSize_uint_MS(usampler2DMS sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec2 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    return max(result, 1);\n"
"}\n";

/* For the 2D MS array sampler. */
static gctSTRING gcLibTextureSize_Func_19 =
"ivec3 _viv_textureSize_float_MSArray(sampler2DMSArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec3 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_20 =
"ivec3 _viv_textureSize_int_MSArray(isampler2DMSArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec3 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_21 =
"ivec3 _viv_textureSize_uint_MSArray(usampler2DMSArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    ivec3 result;\n"
"    int lod = 0;\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_22 =
"ivec3 _viv_textureSize_float_CubeArray(samplerCubeArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_23 =
"ivec3 _viv_textureSize_float_CubeArrayShadow(samplerCubeArrayShadow sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_24 =
"ivec3 _viv_textureSize_int_CubeArray(isamplerCubeArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_25 =
"ivec3 _viv_textureSize_uint_CubeArray(usamplerCubeArray sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax, int lod)\n"
"{\n"
"    ivec3 result;\n"
"    lod = clamp(lod, lodMinAndMax.x, lodMinAndMax.y);\n"
"    result.xy = levelBaseSize.xy >> lod;\n"
"    result.z = levelBaseSize.z;\n"
"    return max(result, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_26 =
"int _viv_textureSize_float_buffer(samplerBuffer sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    return max(levelBaseSize.x, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_27 =
"int _viv_textureSize_int_buffer(isamplerBuffer sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    return max(levelBaseSize.x, 1);\n"
"}\n";

static gctSTRING gcLibTextureSize_Func_28 =
"int _viv_textureSize_uint_buffer(usamplerBuffer sampler, mediump ivec3 levelBaseSize, mediump ivec2 lodMinAndMax)\n"
"{\n"
"    return max(levelBaseSize.x, 1);\n"
"}\n";

/***********************textureGather* implementation that HW can directly support***********************/
static gctSTRING gcLibTextureGatherCommon_Func_1 =
"vec2 _viv_textureGatherCommon_ComputeOffset(mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    vec2 offset1 = vec2(clamp(offset, MIN_PROGRAM_TEXTURE_GATHER_OFFSET, MAX_PROGRAM_TEXTURE_GATHER_OFFSET));\n"
"    vec2 size = vec2(max(levelBaseSize.xy, 1));\n"
"    return (p + offset1 / size);\n"
"}\n";

/***********************textureGather implementation***********************/
/* 2D sampler. */
static gctSTRING gcLibTextureGather_Func_1 =
"vec4 _viv_textureGather_float_2D_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2 =
"vec4 _viv_textureGather_float_2D_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
static gctSTRING gcLibTextureGather_Func_3 =
"vec4 _viv_textureGather_float_2DArray_NoComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_4 =
"vec4 _viv_textureGather_float_2DArray_WithComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
static gctSTRING gcLibTextureGather_Func_5 =
"vec4 _viv_textureGather_float_Cube_NoComp(samplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_6 =
"vec4 _viv_textureGather_float_Cube_WithComp(samplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2D shadow sampler. */
static gctSTRING gcLibTextureGather_Func_7 =
"vec4 _viv_textureGather_2DShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, refZ);\n"
"    _viv_asm(TEXLDPCF, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2D array shadow sampler. */
static gctSTRING gcLibTextureGather_Func_8 =
"vec4 _viv_textureGather_2DArrayShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, refZ);\n"
"    _viv_asm(TEXLDPCF, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* Cube shadow sampler. */
static gctSTRING gcLibTextureGather_Func_9 =
"vec4 _viv_textureGather_CubeShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, refZ);\n"
"    _viv_asm(TEXLDPCF, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2D sampler. */
static gctSTRING gcLibTextureGather_Func_10 =
"ivec4 _viv_textureGather_int_2D_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_11 =
"ivec4 _viv_textureGather_int_2D_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
static gctSTRING gcLibTextureGather_Func_12 =
"ivec4 _viv_textureGather_int_2DArray_NoComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_13 =
"ivec4 _viv_textureGather_int_2DArray_WithComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
static gctSTRING gcLibTextureGather_Func_14 =
"ivec4 _viv_textureGather_int_Cube_NoComp(isamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_15 =
"ivec4 _viv_textureGather_int_Cube_WithComp(isamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2D sampler. */
static gctSTRING gcLibTextureGather_Func_16 =
"uvec4 _viv_textureGather_uint_2D_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_17 =
"uvec4 _viv_textureGather_uint_2D_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
static gctSTRING gcLibTextureGather_Func_18 =
"uvec4 _viv_textureGather_uint_2DArray_NoComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_19 =
"uvec4 _viv_textureGather_uint_2DArray_WithComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
static gctSTRING gcLibTextureGather_Func_20 =
"uvec4 _viv_textureGather_uint_Cube_NoComp(usamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_21 =
"uvec4 _viv_textureGather_uint_Cube_WithComp(usamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/* CubeArray sampler. */
static gctSTRING gcLibTextureGather_Func_22 =
"vec4 _viv_textureGather_foat_CubeArray_NoComp(samplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_23 =
"vec4 _viv_textureGather_float_CubeArray_WithComp(samplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p, int comp)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_24 =
"ivec4 _viv_textureGather_int_CubeArray_NoComp(isamplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_25 =
"ivec4 _viv_textureGather_int_CubeArray_WithComp(isamplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p, int comp)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_26 =
"uvec4 _viv_textureGather_uint_CubeArray_NoComp(usamplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_27 =
"uvec4 _viv_textureGather_uint_CubeArray_WithComp(usamplerCubeArray sampler, mediump ivec3 levelBaseSize, vec4 p, int comp)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXGATHER, result, comp, 0.0);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_28 =
"vec4 _viv_textureGather_float_CubeArrayShadow(samplerCubeArrayShadow sampler, mediump ivec3 levelBaseSize, vec4 p, float refZ)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXGATHER, result, 0, refZ);\n"
"    _viv_asm(TEXLDPCF, result, sampler, p);\n"
"    return result;\n"
"}\n";

/***********************textureGather implementation that HW can't directly support***********************/
/* 2D sampler. */
static gctSTRING gcLibTextureGather_Func_2_0 =
"bool _viv_inBounds(int x, int a)\n"
"{\n"
"    return (x >= 0) && x < a;\n"
"}\n"
"ivec3 _viv_remapCubeCoord(int face, ivec2 coords, int size)\n"
"{\n"
"    bool uInBounds = _viv_inBounds(coords.x, size);\n"
"    bool vInBounds = _viv_inBounds(coords.y, size);\n"
"    if (uInBounds && vInBounds)\n"
"        return ivec3(face, coords);\n"
"    ivec3 canonizedCoords;\n"
"    switch (face)\n"
"    {\n"
"        case 0:  canonizedCoords = ivec3(size-1, size-1-coords.y, size-1-coords.x); break;\n"
"        case 1:  canonizedCoords = ivec3(0, size-1-coords.y, coords.x); break;\n"
"        case 2:  canonizedCoords = ivec3(coords.x, size-1, coords.y); break;\n"
"        case 3:  canonizedCoords = ivec3(coords.x, 0, size-1-coords.y); break;\n"
"        case 4:  canonizedCoords = ivec3(coords.x, size-1-coords.y, size-1); break;\n"
"        default: canonizedCoords = ivec3(size-1-coords.x, size-1-coords.y, 0); break;\n"
"    }\n"
"    if (canonizedCoords.x == -1)\n"
"        return ivec3(1, ivec2(canonizedCoords.z, size-1-canonizedCoords.y));\n"
"    if (canonizedCoords.x == size)\n"
"        return ivec3(0, ivec2(size-1-canonizedCoords.z, size-1-canonizedCoords.y));\n"
"    if (canonizedCoords.y == -1)\n"
"        return ivec3(3, ivec2(canonizedCoords.x, size-1-canonizedCoords.z));\n"
"    if (canonizedCoords.y == size)\n"
"        return ivec3(2, ivec2(canonizedCoords.x, canonizedCoords.z));\n"
"    if (canonizedCoords.z == -1)\n"
"        return ivec3(5, ivec2(size-1-canonizedCoords.x, size-1-canonizedCoords.y));\n"
"    if (canonizedCoords.z == size)\n"
"        return ivec3(4, ivec2(canonizedCoords.x, size-1-canonizedCoords.y));\n"
"}\n"
"vec3 _viv_recomputeCoord(ivec2 UV, int face, float size)\n"
"{\n"
"    vec3 newCoord;\n"
"    ivec3 canonizedCoords = _viv_remapCubeCoord(face, UV, int(size));\n"
"    float offset = 0.5/size;\n"
"    float s = float(canonizedCoords.y) + offset;\n"
"    float t = float(canonizedCoords.z) + offset;\n"
"    float temp = offset - 1.0;\n"
"    s = (2.0 * s) / size - 1.0;\n"
"    t = (2.0 * t) / size - 1.0;\n"
     /* If s/t is 0, it may change face, so we need to add a small offset. */
"    switch (canonizedCoords.x)\n"
"    {\n"
"        case 0:\n"
"            if (canonizedCoords.y == 0)\n"
"                s = temp;\n"
"            if (canonizedCoords.z == 0)\n"
"                t = temp;\n"
"            newCoord = vec3(1.0, -t, -s); break;\n"
"        case 1:\n"
"            if (canonizedCoords.y == 0)\n"
"                s = temp;\n"
"            if (canonizedCoords.z == 0)\n"
"                t = temp;\n"
"            newCoord = vec3(-1.0, -t, s); break;\n"
"        case 2:\n"
"            if (canonizedCoords.z == 0)\n"
"                t = temp;\n"
"            newCoord = vec3(s, 1.0, t); break;\n"
"        case 3:\n"
"            if (canonizedCoords.z == 0)\n"
"                t = temp;\n"
"            newCoord = vec3(s, -1.0, -t); break;\n"
"        case 4: newCoord = vec3(s, -t, 1.0); break;\n"
"        default: newCoord = vec3(-s, -t, -1.0); break;\n"
"    }\n"
"    return newCoord;\n"
"}\n"
"vec2 _viv_evaluate_UV(int face, float maxCoord, vec2 coord, float size)\n"
"{\n"
"    float s, t;\n"
"    float x = coord.x, y = coord.y;\n"
"    switch(face)\n"
"    {\n"
"        case 0:\n"
"            s = -y;\n"
"            t = -x;\n"
"            break;\n"
"        case 1:\n"
"            s = y;\n"
"            t = -x;\n"
"            break;\n"
"        case 2:\n"
"            s = x;\n"
"            t = y;\n"
"            break;\n"
"        case 3:\n"
"            s = x;\n"
"            t = -y;\n"
"            break;\n"
"        case 4:\n"
"            s = x;\n"
"            t = -y;\n"
"            break;\n"
"        default:\n"
"            s = -x;\n"
"            t = -y;\n"
"            break;\n"
"    }\n"
"    vec2 temp = vec2(s, t);\n"
"    temp = (temp/maxCoord + 1.0) / 2.0 * size;\n"
"    return temp;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2_1 =
"vec4 _viv_textureGather_float_2D_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result;\n"
"    result.x = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.y = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.z = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    result.w = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2_2 =
"vec4 _viv_textureGather_float_2D_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultG = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultB = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    resultA = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = vec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = vec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = vec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
static gctSTRING gcLibTextureGather_Func_2_3 =
"vec4 _viv_textureGather_float_2DArray_NoComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result;\n"
"    result.x = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.y = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.z = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    result.w = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2_4 =
"vec4 _viv_textureGather_float_2DArray_WithComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultG = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultB = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    resultA = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = vec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = vec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = vec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
static gctSTRING gcLibTextureGather_Func_2_5 =
"vec4 _viv_textureGather_float_Cube_NoComp(samplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    vec4 result;\n"
"    vec2 orgST, orgUV;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    result.x = texture(sampler, _viv_recomputeCoord(i0j1, face, size))[0];\n"
"    result.y = texture(sampler, _viv_recomputeCoord(i1j1, face, size))[0];\n"
"    result.z = texture(sampler, _viv_recomputeCoord(i1j0, face, size))[0];\n"
"    result.w = texture(sampler, _viv_recomputeCoord(i0j0, face, size))[0];\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2_6 =
"vec4 _viv_textureGather_float_Cube_WithComp(samplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    vec2 orgST, orgUV;\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    resultR = texture(sampler, _viv_recomputeCoord(i0j1, face, size));\n"
"    resultG = texture(sampler, _viv_recomputeCoord(i1j1, face, size));\n"
"    resultB = texture(sampler, _viv_recomputeCoord(i1j0, face, size));\n"
"    resultA = texture(sampler, _viv_recomputeCoord(i0j0, face, size));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = vec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = vec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = vec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* 2D shadow sampler. */
static gctSTRING gcLibTextureGather_Func_2_7 =
"vec4 _viv_textureGather_2DShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result;\n"
"    result.x = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), refZ));\n"
"    result.y = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), refZ));\n"
"    result.z = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), refZ));\n"
"    result.w = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), refZ));\n"
"    return result;\n"
"}\n";

/* 2D array shadow sampler. */
static gctSTRING gcLibTextureGather_Func_2_8 =
"vec4 _viv_textureGather_2DArrayShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    vec4 result;\n"
"    result.x = texture(sampler, vec4(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z, refZ));\n"
"    result.y = texture(sampler, vec4(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z, refZ));\n"
"    result.z = texture(sampler, vec4(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z, refZ));\n"
"    result.w = texture(sampler, vec4(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z, refZ));\n"
"    return result;\n"
"}\n";

/* Cube shadow sampler. */
static gctSTRING gcLibTextureGather_Func_2_9 =
"vec4 _viv_textureGather_CubeShadow(samplerCubeShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    vec4 result;\n"
"    vec2 orgST, orgUV;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    result.x = texture(sampler, vec4(_viv_recomputeCoord(i0j1, face, size), refZ));\n"
"    result.y = texture(sampler, vec4(_viv_recomputeCoord(i1j1, face, size), refZ));\n"
"    result.z = texture(sampler, vec4(_viv_recomputeCoord(i1j0, face, size), refZ));\n"
"    result.w = texture(sampler, vec4(_viv_recomputeCoord(i0j0, face, size), refZ));\n"
"    return result;\n"
"}\n";

/* 2D sampler. */
static gctSTRING gcLibTextureGather_Func_2_10 =
"ivec4 _viv_textureGather_int_2D_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    ivec4 result;\n"
"    result.x = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.y = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.z = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    result.w = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2_11 =
"ivec4 _viv_textureGather_int_2D_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultG = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultB = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    resultA = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = ivec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = ivec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = ivec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
static gctSTRING gcLibTextureGather_Func_2_12 =
"ivec4 _viv_textureGather_int_2DArray_NoComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    ivec4 result;\n"
"    result.x = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.y = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.z = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    result.w = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2_13 =
"ivec4 _viv_textureGather_int_2DArray_WithComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultG = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultB = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    resultA = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = ivec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = ivec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = ivec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
static gctSTRING gcLibTextureGather_Func_2_14 =
"ivec4 _viv_textureGather_int_Cube_NoComp(isamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    ivec4 result;\n"
"    vec2 orgST, orgUV;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    result.x = texture(sampler, _viv_recomputeCoord(i0j1, face, size))[0];\n"
"    result.y = texture(sampler, _viv_recomputeCoord(i1j1, face, size))[0];\n"
"    result.z = texture(sampler, _viv_recomputeCoord(i1j0, face, size))[0];\n"
"    result.w = texture(sampler, _viv_recomputeCoord(i0j0, face, size))[0];\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2_15 =
"ivec4 _viv_textureGather_int_Cube_WithComp(isamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    vec2 orgST, orgUV;\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    resultR = texture(sampler, _viv_recomputeCoord(i0j1, face, size));\n"
"    resultG = texture(sampler, _viv_recomputeCoord(i1j1, face, size));\n"
"    resultB = texture(sampler, _viv_recomputeCoord(i1j0, face, size));\n"
"    resultA = texture(sampler, _viv_recomputeCoord(i0j0, face, size));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = ivec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = ivec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = ivec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* 2D sampler. */
static gctSTRING gcLibTextureGather_Func_2_16 =
"uvec4 _viv_textureGather_uint_2D_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    uvec4 result;\n"
"    result.x = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.y = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)))[0];\n"
"    result.z = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    result.w = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)))[0];\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2_17 =
"uvec4 _viv_textureGather_uint_2D_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec2(p.x - (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultG = texture(sampler, vec2(p.x + (0.5 / size.x), p.y + (0.5 / size.y)));\n"
"    resultB = texture(sampler, vec2(p.x + (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    resultA = texture(sampler, vec2(p.x - (0.5 / size.x), p.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = uvec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = uvec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = uvec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* 2DArray sampler. */
static gctSTRING gcLibTextureGather_Func_2_18 =
"uvec4 _viv_textureGather_uint_2DArray_NoComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    uvec4 result;\n"
"    result.x = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.y = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z))[0];\n"
"    result.z = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    result.w = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z))[0];\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2_19 =
"uvec4 _viv_textureGather_uint_2DArray_WithComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    resultR = texture(sampler, vec3(p.x - (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultG = texture(sampler, vec3(p.x + (0.5 / size.x), p.y + (0.5 / size.y), p.z));\n"
"    resultB = texture(sampler, vec3(p.x + (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    resultA = texture(sampler, vec3(p.x - (0.5 / size.x), p.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = uvec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = uvec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = uvec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/* Cube sampler. */
static gctSTRING gcLibTextureGather_Func_2_20 =
"uvec4 _viv_textureGather_uint_Cube_NoComp(usamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    uvec4 result;\n"
"    vec2 orgST, orgUV;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    result.x = texture(sampler, _viv_recomputeCoord(i0j1, face, size))[0];\n"
"    result.y = texture(sampler, _viv_recomputeCoord(i1j1, face, size))[0];\n"
"    result.z = texture(sampler, _viv_recomputeCoord(i1j0, face, size))[0];\n"
"    result.w = texture(sampler, _viv_recomputeCoord(i0j0, face, size))[0];\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGather_Func_2_21 =
"uvec4 _viv_textureGather_uint_Cube_WithComp(usamplerCube sampler, mediump ivec3 levelBaseSize, vec3 p, int comp)\n"
"{\n"
"    float maxCoord, offset;\n"
"    float size = float(levelBaseSize.x);\n"
"    int face;\n"
"    vec3 absCoord = abs(p);\n"
"    vec2 orgST, orgUV;\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    if (absCoord.x > absCoord.y)\n"
"    {\n"
"        if (absCoord.x > absCoord.z)\n"
"        {\n"
"            maxCoord = absCoord.x;\n"
"            if (p.x > 0.0)\n"
"                face = 0;\n"
"            else\n"
"                face = 1;\n"
"            orgST = vec2(p.yz);\n"
"        }\n"
"        else\n"
"        {\n"
"            maxCoord = absCoord.z;\n"
"            if (p.z > 0.0)\n"
"                face = 4;\n"
"            else\n"
"                face = 5;\n"
"            orgST = vec2(p.xy);\n"
"        }\n"
"    }\n"
"    else if (absCoord.y > absCoord.z)\n"
"    {\n"
"        maxCoord = absCoord.y;\n"
"        if (p.y > 0.0)\n"
"            face = 2;\n"
"        else\n"
"            face = 3;\n"
"            orgST = vec2(p.xz);\n"
"    }\n"
"    else\n"
"    {\n"
"        maxCoord = absCoord.z;\n"
"        if (p.z > 0.0)\n"
"            face = 4;\n"
"        else\n"
"            face = 5;\n"
"            orgST = vec2(p.xy);\n"
"    }\n"
"    orgUV = _viv_evaluate_UV(face, maxCoord, orgST, size);\n"
"    int x0 = int(floor(orgUV.x-0.5));\n"
"    int x1 = x0+1;\n"
"    int y0 = int(floor(orgUV.y-0.5));\n"
"    int y1 = y0+1;\n"
"    ivec2 i0j0 = ivec2(x0, y0);\n"
"    ivec2 i1j0 = ivec2(x1, y0);\n"
"    ivec2 i0j1 = ivec2(x0, y1);\n"
"    ivec2 i1j1 = ivec2(x1, y1);\n"
"    resultR = texture(sampler, _viv_recomputeCoord(i0j1, face, size));\n"
"    resultG = texture(sampler, _viv_recomputeCoord(i1j1, face, size));\n"
"    resultB = texture(sampler, _viv_recomputeCoord(i1j0, face, size));\n"
"    resultA = texture(sampler, _viv_recomputeCoord(i0j0, face, size));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = uvec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = uvec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = uvec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/***********************textureGatherOffset implementation***********************/
static gctSTRING gcLibTextureGatherOffset_Func_1 =
"vec4 _viv_textureGatherOffset_float_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_float_2D_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_2 =
"vec4 _viv_textureGatherOffset_float_2DArray_NoComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_float_2DArray_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_3 =
"vec4 _viv_textureGatherOffset_float_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset, int comp)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_float_2D_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_4 =
"vec4 _viv_textureGatherOffset_float_2DArray_WithComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset, int comp)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_float_2DArray_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_5 =
"vec4 _viv_textureGatherOffset_float_2DShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ, ivec2 offset)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_2DShadow(sampler, levelBaseSize, newCoord, refZ);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_6 =
"vec4 _viv_textureGatherOffset_float_2DArrayShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ, ivec2 offset)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_2DArrayShadow(sampler, levelBaseSize, newCoord, refZ);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_7 =
"ivec4 _viv_textureGatherOffset_int_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_int_2D_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_8 =
"ivec4 _viv_textureGatherOffset_int_2DArray_NoComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_int_2DArray_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_9 =
"ivec4 _viv_textureGatherOffset_int_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset, int comp)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_int_2D_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_10 =
"ivec4 _viv_textureGatherOffset_int_2DArray_WithComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset, int comp)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_int_2DArray_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_11 =
"uvec4 _viv_textureGatherOffset_uint_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_uint_2D_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_12 =
"uvec4 _viv_textureGatherOffset_uint_2DArray_NoComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_uint_2DArray_NoComp(sampler, levelBaseSize, newCoord);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_13 =
"uvec4 _viv_textureGatherOffset_uint_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offset, int comp)\n"
"{\n"
"    vec2 newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offset);\n"
"    return _viv_textureGather_uint_2D_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

static gctSTRING gcLibTextureGatherOffset_Func_14 =
"uvec4 _viv_textureGatherOffset_uint_2DArray_WithComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offset, int comp)\n"
"{\n"
"    vec3 newCoord = vec3(_viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offset), p.z);\n"
"    return _viv_textureGather_uint_2DArray_WithComp(sampler, levelBaseSize, newCoord, comp);\n"
"}\n";

/***********************textureGatherOffsets implementation***********************/
static gctSTRING gcLibTextureGatherOffsets_Func_1 =
"vec4 _viv_textureGatherOffsets_float_NoComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4])\n"
"{\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_2 =
"vec4 _viv_textureGatherOffsets_float_2DArray_NoComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4])\n"
"{\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_3 =
"vec4 _viv_textureGatherOffsets_float_WithComp(sampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = vec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = vec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = vec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_4 =
"vec4 _viv_textureGatherOffsets_float_2DArray_WithComp(sampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    vec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = vec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = vec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = vec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = vec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_5 =
"vec4 _viv_textureGatherOffsets_float_2DShadow(sampler2DShadow sampler, mediump ivec3 levelBaseSize, vec2 p, float refZ, ivec2 offsets[4])\n"
"{\n"
"    vec4 result;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    result.x = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    result.y = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    result.z = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    result.w = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), refZ));\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_6 =
"vec4 _viv_textureGatherOffsets_float_2DArrayShadow(sampler2DArrayShadow sampler, mediump ivec3 levelBaseSize, vec3 p, float refZ, ivec2 offsets[4])\n"
"{\n"
"    vec4 result;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    result.x = texture(sampler, vec4(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z, refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    result.y = texture(sampler, vec4(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z, refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    result.z = texture(sampler, vec4(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z, refZ));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    result.w = texture(sampler, vec4(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z, refZ));\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_7 =
"ivec4 _viv_textureGatherOffsets_int_NoComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4])\n"
"{\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_8 =
"ivec4 _viv_textureGatherOffsets_int_2DArray_NoComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4])\n"
"{\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_9 =
"ivec4 _viv_textureGatherOffsets_int_WithComp(isampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = ivec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = ivec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = ivec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_10 =
"ivec4 _viv_textureGatherOffsets_int_2DArray_WithComp(isampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    ivec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = ivec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = ivec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = ivec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = ivec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_11 =
"uvec4 _viv_textureGatherOffsets_uint_NoComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4])\n"
"{\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_12 =
"uvec4 _viv_textureGatherOffsets_uint_2DArray_NoComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4])\n"
"{\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_13 =
"uvec4 _viv_textureGatherOffsets_uint_WithComp(usampler2D sampler, mediump ivec3 levelBaseSize, vec2 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[0]);\n"
"    resultR = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[1]);\n"
"    resultG = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[2]);\n"
"    resultB = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p, offsets[3]);\n"
"    resultA = texture(sampler, vec2(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y)));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = uvec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = uvec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = uvec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTextureGatherOffsets_Func_14 =
"uvec4 _viv_textureGatherOffsets_uint_2DArray_WithComp(usampler2DArray sampler, mediump ivec3 levelBaseSize, vec3 p, ivec2 offsets[4], int comp)\n"
"{\n"
"    uvec4 result, resultR, resultG, resultB, resultA;\n"
"    vec2 newCoord;\n"
"    vec2 size = vec2(levelBaseSize.xy);\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[0]);\n"
"    resultR = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[1]);\n"
"    resultG = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[2]);\n"
"    resultB = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    newCoord = _viv_textureGatherCommon_ComputeOffset(levelBaseSize, p.xy, offsets[3]);\n"
"    resultA = texture(sampler, vec3(newCoord.x - (0.5 / size.x), newCoord.y - (0.5 / size.y), p.z));\n"
"    if (comp == 0)\n"
"    {\n"
"        result = uvec4(resultR.x, resultG.x, resultB.x, resultA.x);\n"
"    }\n"
"    else if (comp == 1)\n"
"    {\n"
"        result = uvec4(resultR.y, resultG.y, resultB.y, resultA.y);\n"
"    }\n"
"    else if (comp == 2)\n"
"    {\n"
"        result = uvec4(resultR.z, resultG.z, resultB.z, resultA.z);\n"
"    }\n"
"    else\n"
"    {\n"
"        result = uvec4(resultR.w, resultG.w, resultB.w, resultA.w);\n"
"    }\n"
"    return result;\n"
"}\n";

/***********************texelFetch for MSAA implementation that HW can directly support***********************/
static gctSTRING gcLibTexelFetchForMSAA_Func_1 =
"vec4 _viv_texelFetch_float(sampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTexelFetchForMSAA_Func_2 =
"ivec4 _viv_texelFetch_int(isampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTexelFetchForMSAA_Func_3 =
"uvec4 _viv_texelFetch_uint(usampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTexelFetchForMSAA_Func_4 =
"vec4 _viv_texelFetch_float_array(sampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    vec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTexelFetchForMSAA_Func_5 =
"ivec4 _viv_texelFetch_int_array(isampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    ivec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTexelFetchForMSAA_Func_6 =
"uvec4 _viv_texelFetch_uint_array(usampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    uvec4 result;\n"
"    _viv_asm(TEXFETCH_MS, result, sampler, sampleIndex);\n"
"    _viv_asm(TEXLD, result, sampler, p);\n"
"    return result;\n"
"}\n";

/***********************texelFetch for MSAA implementation that HW can't directly support***********************/
static gctSTRING gcLibTexelFetchForMSAA_Func_2_1 =
"vec4 _viv_texelFetch_float(sampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    vec4 result;\n"
"    vec2 newCoord = vec2(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTexelFetchForMSAA_Func_2_2 =
"ivec4 _viv_texelFetch_int(isampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    ivec4 result;\n"
"    vec2 newCoord = vec2(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTexelFetchForMSAA_Func_2_3 =
"uvec4 _viv_texelFetch_uint(usampler2DMS sampler, mediump ivec3 levelBaseSize, ivec2 p, int sampleIndex)\n"
"{\n"
"    uvec4 result;\n"
"    vec2 newCoord = vec2(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTexelFetchForMSAA_Func_2_4 =
"vec4 _viv_texelFetch_float_array(sampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    vec4 result;\n"
"    vec3 newCoord = vec3(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord.xy += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord.xy /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTexelFetchForMSAA_Func_2_5 =
"ivec4 _viv_texelFetch_int_array(isampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    ivec4 result;\n"
"    vec3 newCoord = vec3(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord.xy += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord.xy /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibTexelFetchForMSAA_Func_2_6 =
"uvec4 _viv_texelFetch_uint_array(usampler2DMSArray sampler, mediump ivec3 levelBaseSize, ivec3 p, int sampleIndex)\n"
"{\n"
"    uvec4 result;\n"
"    vec3 newCoord = vec3(p);\n"
"    switch(sampleIndex)\n"
"    {\n"
"        case 0:\n"
"            break;\n"
"        case 1:\n"
"            newCoord.x += 0.5;\n"
"            break;\n"
"        case 2:\n"
"            newCoord.y += 0.5;\n"
"            break;\n"
"        default:\n"
"            newCoord.xy += 0.5;\n"
"            break;\n"
"    }\n"
"    newCoord.xy /= vec2(levelBaseSize.xy);\n"
"    _viv_asm(TEXLD, result, sampler, newCoord);\n"
"    return result;\n"
"}\n";

/******************** image instructions implementation ********************/

/* The image size function needs to be patched at the end of linkLibFunction.
   Based on the uniform's name and generate the size uniform to replace
   the img_desc. Thus the result will have the uniform's size */

/* This image size is for inner use. The size uniform's w channel stores the
   slice size. */
static gctSTRING gcLibImageSize =
"highp uvec4 _viv_image_size(highp uvec4 img_desc)\n"
"{\n"
"    uvec4 result = img_desc;\n"
"    return result;\n"
"}\n";

/* TO-DO: have T_GEN_IMAGE to combine functions */
static gctSTRING gcLibImageSize_2D_float =
"highp uvec2 _viv_image_size_1(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result;\n"
"    result = img_desc.xy;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_3D_float =
"highp uvec3 _viv_image_size_2(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result ;\n"
"    result = img_desc.xyz;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_CUBE_float =
"highp uvec2 _viv_image_size_3(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result;\n"
"    result = img_desc.xy;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_2DArray_float =
"highp uvec3 _viv_image_size_4(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result ;\n"
"    result = img_desc.xyz;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_2D_int =
"highp uvec2 _viv_image_size_5(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result;\n"
"    result = img_desc.xy;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_3D_int =
"highp uvec3 _viv_image_size_6(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result;\n"
"    result = img_desc.xyz;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_CUBE_int =
"highp uvec2 _viv_image_size_7(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result;\n"
"    result = img_desc.xy;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_2DArray_int =
"highp uvec3 _viv_image_size_8(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result;\n"
"    result = img_desc.xyz;\n"
"    return result;\n"
"}\n";


static gctSTRING gcLibImageSize_2D_uint =
"highp uvec2 _viv_image_size_9(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result =  img_desc.xy;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_3D_uint  =
"highp uvec3 _viv_image_size_10(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result =  img_desc.xyz;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_CUBE_uint  =
"highp uvec2 _viv_image_size_11(highp uvec4 img_desc)\n"
"{\n"
"    uvec2 result =  img_desc.xy;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_2DArray_uint  =
"highp uvec3 _viv_image_size_12(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result =  img_desc.xyz;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_CubeArray_float  =
"highp uvec3 _viv_image_size_13(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result =  img_desc.xyz;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_CubeArray_int  =
"highp uvec3 _viv_image_size_14(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result =  img_desc.xyz;\n"
"    return result;\n"
"}\n";


static gctSTRING gcLibImageSize_CubeArray_uint  =
"highp uvec3 _viv_image_size_15(highp uvec4 img_desc)\n"
"{\n"
"    uvec3 result =  img_desc.xyz;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_Buffer_float  =
"highp uint _viv_image_size_16(highp uvec4 img_desc)\n"
"{\n"
"    uint result =  img_desc.x;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_Buffer_int  =
"highp uint _viv_image_size_17(highp uvec4 img_desc)\n"
"{\n"
"    uint result =  img_desc.x;\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageSize_Buffer_uint  =
"highp uint _viv_image_size_18(highp uvec4 img_desc)\n"
"{\n"
"    uint result =  img_desc.x;\n"
"    return result;\n"
"}\n";


/******************************************************************/
/* gc3000/5000 image instruction implmentation */
/******************************************************************/
/* _viv_image_computeImgAddr function compute the img address.
    The return is a uvec2 (x is inBorder, y is address) */
static gctSTRING gcLibImageAddr =
"highp uvec2 _viv_image_computeImgAddr(highp uvec4 img_desc, ivec3 p, bool img3D)\n"
"{\n"
"   uint base = img3D ? uint(p.z) : img_desc.x;\n"
"   uint stride = img_desc.y;\n"
"   uint shift  = _viv_bitfieldExtract_uint_const(img_desc.w, 0, 3);\n"
"   uint mul  = _viv_bitfieldExtract_uint_const(img_desc.w, 3, 1);\n"
"   uint tiling  = _viv_bitfieldExtract_uint_const(img_desc.w, 10, 2);\n"
"   uint addressing = _viv_bitfieldExtract_uint_const(img_desc.w, 4, 2);\n"
"   if (addressing == 0u) { addressing = 1u; } \n"
"   uint xCoord = uint(p.x);\n"
"   uint yCoord = uint(p.y);\n"
"   uint width = _viv_bitfieldExtract_uint_const(img_desc.z, 0, 16);\n"
"   uint height = _viv_bitfieldExtract_uint_const(img_desc.z, 16, 16);\n"
"   if ((xCoord >= width) || (yCoord >= height)) { return uvec2(addressing, 0u); } \n"
"   uint x = 0u, y = 0u;\n"
"   if (tiling == 0u) { x = xCoord; y = yCoord; }\n"
"   /* driver always set to super tile, thus not consider the tile case */\n"
"   if (tiling == 2u) {\n"
"       y = yCoord;\n"
"       x = _viv_bitfieldExtract_uint_const(xCoord, 0, 2) | (_viv_bitfieldExtract_uint_const(y, 0, 2) << 2u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 2, 1) << 4u) | (_viv_bitfieldExtract_uint_const(y, 2, 1) << 5u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 3, 1) << 6u) | (_viv_bitfieldExtract_uint_const(y, 3, 1) << 7u)|\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 4, 1) << 8u) | (_viv_bitfieldExtract_uint_const(y, 4, 1) << 9u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 5, 1) << 10u) | (_viv_bitfieldExtract_uint_const(y, 5, 1) << 11u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 6, 26) << 12u);\n"
"       y =  _viv_bitfieldInsert_uint_const(y, 0u, 0, 6);\n"
"   }\n"
"   uint xOffset;\n"
"   if (mul == 1u) { xOffset = (x * 3u ) << shift ; } \n"
"   else { xOffset = x << shift ; } \n"
"   uint yOffset = y * stride;\n"
"   uint address = base + xOffset + yOffset;\n"
"   return uvec2(0u, address);\n"
"}\n"
"highp uvec2 _viv_image_computeImgAddr2D(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uint xCoord = uint(p.x);\n"
"   uint yCoord = uint(p.y);\n"
"   uint width = _viv_bitfieldExtract_uint_const(img_desc.z, 0, 16);\n"
"   uint height = _viv_bitfieldExtract_uint_const(img_desc.z, 16, 16);\n"
"   if ((xCoord >= width) || (yCoord >= height)) { return uvec2(1u, 0u); } \n"
"   uint x = 0u, y = 0u;\n"
"   uint tiling  = _viv_bitfieldExtract_uint_const(img_desc.w, 10, 2);\n"
"   if (tiling == 0u) { x = xCoord; y = yCoord; }\n"
"   /* driver always set to super tile, thus not consider the tile case */\n"
"   if (tiling == 2u) {\n"
"       y = yCoord;\n"
"       x = _viv_bitfieldExtract_uint_const(xCoord, 0, 2) | (_viv_bitfieldExtract_uint_const(y, 0, 2) << 2u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 2, 1) << 4u) | (_viv_bitfieldExtract_uint_const(y, 2, 1) << 5u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 3, 1) << 6u) | (_viv_bitfieldExtract_uint_const(y, 3, 1) << 7u)|\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 4, 1) << 8u) | (_viv_bitfieldExtract_uint_const(y, 4, 1) << 9u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 5, 1) << 10u) | (_viv_bitfieldExtract_uint_const(y, 5, 1) << 11u) |\n"
"           (_viv_bitfieldExtract_uint_const(xCoord, 6, 26) << 12u);\n"
"       y =  _viv_bitfieldInsert_uint_const(y, 0u, 0, 6);\n"
"   }\n"
"   uint xOffset;\n"
"   uint shift  = _viv_bitfieldExtract_uint_const(img_desc.w, 0, 3);\n"
"   uint mul  = _viv_bitfieldExtract_uint_const(img_desc.w, 3, 1);\n"
"   if (mul == 1u) { xOffset = (x * 3u ) << shift ; } \n"
"   else { xOffset = x << shift ; } \n"
"   uint yOffset = y * img_desc.y;\n"
"   uint address = img_desc.x + xOffset + yOffset;\n"
"   return uvec2(0u, address);\n"
"}\n";

static gctSTRING gcLibImageAddr_halti4 =
"highp uvec2 _viv_image_computeImgAddr(highp uvec4 img_desc, ivec3 p, bool img3D)\n"
"{\n"
"   uint addressing = _viv_bitfieldExtract_uint_const(img_desc.w, 4, 2);\n"
"   if (addressing == 0u) { addressing = 1u; } \n"
"   uint xCoord = uint(p.x);\n"
"   uint yCoord = uint(p.y);\n"
"   uint width = _viv_bitfieldExtract_uint_const(img_desc.z, 0, 16);\n"
"   uint height = _viv_bitfieldExtract_uint_const(img_desc.z, 16, 16);\n"
"   if ((xCoord >= width) || (yCoord >= height)) { return uvec2(addressing, 0u); } \n"
"   uint address;\n"
"   if (img3D) \n"
"   {\n"
"       _viv_asm(IMAGE_ADDR_3D, address, img_desc, p);\n"
"   }\n"
"   else \n"
"   {\n"
"       _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   }\n"
"   return uvec2(0u, address);\n"
"}\n"
"highp uvec2 _viv_image_computeImgAddr2D(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uint xCoord = uint(p.x);\n"
"   uint yCoord = uint(p.y);\n"
"   uint width = _viv_bitfieldExtract_uint_const(img_desc.z, 0, 16);\n"
"   uint height = _viv_bitfieldExtract_uint_const(img_desc.z, 16, 16);\n"
"   if ((xCoord >= width) || (yCoord >= height)) { return uvec2(1u, 0u); } \n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   return uvec2(0u, address);\n"
"}\n";

static gctSTRING gcLibImageSwizzle =
"highp vec4 _viv_image_swizzle(highp uvec4 img_desc, highp vec4 raw)\n"
"{\n"
"   vec4 result;\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.x = raw.y; break;\n"
"       case 2u: result.x = raw.z; break;\n"
"       case 3u: result.x = raw.w; break;\n"
"       case 4u: result.x = 0.0; break;\n"
"       case 5u: result.x = 1.0; break; \n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.y = raw.x; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.y = raw.z; break;\n"
"       case 3u: result.y = raw.w; break;\n"
"       case 4u: result.y = 0.0; break;\n"
"       case 5u: result.y = 1.0; break; \n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.z = raw.x; break;\n"
"       case 1u: result.z = raw.y; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.z = raw.w; break;\n"
"       case 4u: result.z = 0.0; break;\n"
"       case 5u: result.z = 1.0; break; \n"
"   }\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.w = raw.x; break;\n"
"       case 1u: result.w = raw.y; break;\n"
"       case 2u: result.w = raw.z; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"       case 4u: result.w = 0.0; break;\n"
"       case 5u: result.w = 1.0; break; \n"
"   }\n"
"   return result;\n"
"}\n"
"highp ivec4 _viv_image_swizzle_int(highp uvec4 img_desc, highp ivec4 raw)\n"
"{\n"
"   ivec4 result;\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.x = raw.y; break;\n"
"       case 2u: result.x = raw.z; break;\n"
"       case 3u: result.x = raw.w; break;\n"
"       case 4u: result.x = 0; break;\n"
"       case 5u: result.x = 1; break; \n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.y = raw.x; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.y = raw.z; break;\n"
"       case 3u: result.y = raw.w; break;\n"
"       case 4u: result.y = 0; break;\n"
"       case 5u: result.y = 1; break; \n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.z = raw.x; break;\n"
"       case 1u: result.z = raw.y; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.z = raw.w; break;\n"
"       case 4u: result.z = 0; break;\n"
"       case 5u: result.z = 1; break; \n"
"   }\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.w = raw.x; break;\n"
"       case 1u: result.w = raw.y; break;\n"
"       case 2u: result.w = raw.z; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"       case 4u: result.w = 0; break;\n"
"       case 5u: result.w = 1; break; \n"
"   }\n"
"   return result;\n"
"}\n"
"highp uvec4 _viv_image_swizzle_uint(highp uvec4 img_desc, highp uvec4 raw)\n"
"{\n"
"   uvec4 result;\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.x = raw.y; break;\n"
"       case 2u: result.x = raw.z; break;\n"
"       case 3u: result.x = raw.w; break;\n"
"       case 4u: result.x = 0u; break;\n"
"       case 5u: result.x = 1u; break; \n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.y = raw.x; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.y = raw.z; break;\n"
"       case 3u: result.y = raw.w; break;\n"
"       case 4u: result.y = 0u; break;\n"
"       case 5u: result.y = 1u; break; \n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.z = raw.x; break;\n"
"       case 1u: result.z = raw.y; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.z = raw.w; break;\n"
"       case 4u: result.z = 0u; break;\n"
"       case 5u: result.z = 1u; break; \n"
"   }\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.w = raw.x; break;\n"
"       case 1u: result.w = raw.y; break;\n"
"       case 2u: result.w = raw.z; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"       case 4u: result.w = 0u; break;\n"
"       case 5u: result.w = 1u; break; \n"
"   }\n"
"   return result;\n"
"}\n";

/* this is currently used in rgba8.
   Driver maps rgba8 to bgra8. We use this swizzle function
   to get the correct data to write. */
static gctSTRING gcLibImageStoreSwizzle =
"highp vec4 _viv_image_store_swizzle(highp uvec4 img_desc, highp vec4 raw)\n"
"{\n"
"   vec4 result = raw;\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.x = raw.w; break;\n"
"       case 1u: result.y = raw.w; break;\n"
"       case 2u: result.z = raw.w; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.x = raw.z; break;\n"
"       case 1u: result.y = raw.z; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.w = raw.z; break;\n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.x = raw.y; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.z = raw.y; break;\n"
"       case 3u: result.w = raw.y; break;\n"
"   }\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.y = raw.x; break;\n"
"       case 2u: result.z = raw.x; break;\n"
"       case 3u: result.w = raw.x; break;\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_store_swizzle_int(highp uvec4 img_desc, highp ivec4 raw)\n"
"{\n"
"   ivec4 result = raw;\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.x = raw.w; break;\n"
"       case 1u: result.y = raw.w; break;\n"
"       case 2u: result.z = raw.w; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.x = raw.z; break;\n"
"       case 1u: result.y = raw.z; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.w = raw.z; break;\n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.x = raw.y; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.z = raw.y; break;\n"
"       case 3u: result.w = raw.y; break;\n"
"   }\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.y = raw.x; break;\n"
"       case 2u: result.z = raw.x; break;\n"
"       case 3u: result.w = raw.x; break;\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp uvec4 _viv_image_store_swizzle_uint(highp uvec4 img_desc, highp uvec4 raw)\n"
"{\n"
"   uvec4 result = raw;\n"
"   uint swizzleA  = _viv_bitfieldExtract_uint_const(img_desc.w, 28, 3);\n"
"   switch(swizzleA) {\n"
"       case 0u: result.x = raw.w; break;\n"
"       case 1u: result.y = raw.w; break;\n"
"       case 2u: result.z = raw.w; break;\n"
"       case 3u: result.w = raw.w; break;\n"
"   }\n"
"   uint swizzleB  = _viv_bitfieldExtract_uint_const(img_desc.w, 24, 3);\n"
"   switch(swizzleB) {\n"
"       case 0u: result.x = raw.z; break;\n"
"       case 1u: result.y = raw.z; break;\n"
"       case 2u: result.z = raw.z; break;\n"
"       case 3u: result.w = raw.z; break;\n"
"   }\n"
"   uint swizzleG  = _viv_bitfieldExtract_uint_const(img_desc.w, 20, 3);\n"
"   switch(swizzleG) {\n"
"       case 0u: result.x = raw.y; break;\n"
"       case 1u: result.y = raw.y; break;\n"
"       case 2u: result.z = raw.y; break;\n"
"       case 3u: result.w = raw.y; break;\n"
"   }\n"
"   uint swizzleR  = _viv_bitfieldExtract_uint_const(img_desc.w, 16, 3);\n"
"   switch(swizzleR) {\n"
"       case 0u: result.x = raw.x; break;\n"
"       case 1u: result.y = raw.x; break;\n"
"       case 2u: result.z = raw.x; break;\n"
"       case 3u: result.w = raw.x; break;\n"
"   }\n"
"   return result;\n"
"}\n";

/****************************imageLoad for a 2D image****************************/
static gctSTRING gcLibImageLoad_2D_float =
"highp vec4 _viv_image_load_2D_float(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:FLOAT16>, address, 0);\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_float_rgba8 =
"highp vec4 _viv_image_load_2D_float_rgba8(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 raw = _viv_image_load_2D_uint_rgba8ui(img_desc, p);\n"
"   return vec4(min(raw, 255u)) / 255.0;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_float_rgba8_snorm =
"highp vec4 _viv_image_load_2D_float_rgba8_snorm(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 raw = _viv_image_load_2D_int_rgba8i(img_desc, p);\n"
"   return vec4(clamp(raw, -127, 127)) / 127.0;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_float_rgba32f =
"highp vec4 _viv_image_load_2D_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp vec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:FLOAT>, address, 0);\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp vec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:FLOAT>, address, 0);\n"
"       result.zw = _viv_image_swizzle(img_desc_1, raw).xy;\n"
"   }\n"
"   return result;\n"
"}\n";

/* don't use raw = vec4(0.0, 0.0, 0.0, 1.0),
   recompilation has issue with const vector*/
static gctSTRING gcLibImageLoad_2D_float_r32f =
"highp vec4 _viv_image_load_2D_float_r32f(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       highp float temp;\n"
"       _viv_asm(LOAD, temp!<f:FLOAT>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0.0;\n"
"       raw.z = 0.0;\n"
"       raw.q = 1.0;\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_int =
"highp ivec4 _viv_image_load_2D_int(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT16>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_int_rgba8i =
"highp ivec4 _viv_image_load_2D_int_rgba8i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_int_rgba32i =
"highp ivec4 _viv_image_load_2D_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result.zw = _viv_image_swizzle_int(img_desc_1, raw).xy;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_int_r32i =
"highp ivec4 _viv_image_load_2D_int_r32i(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       highp int temp;\n"
"       _viv_asm(LOAD, temp!<f:INT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0;\n"
"       raw.z = 0;\n"
"       raw.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_uint =
"highp uvec4 _viv_image_load_2D_uint(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT16>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_uint_rgba8ui =
"highp uvec4 _viv_image_load_2D_uint_rgba8ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_uint_rgba32ui =
"highp uvec4 _viv_image_load_2D_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result.zw = _viv_image_swizzle_uint(img_desc_1, raw).xy;\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_uint_r32ui =
"highp uvec4 _viv_image_load_2D_uint_r32ui(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       highp uint temp;\n"
"       _viv_asm(LOAD, temp!<f:UINT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0u;\n"
"       raw.z = 0u;\n"
"       raw.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

/****************************imageLoad for a 3D/cube/2DArray image****************************/
static gctSTRING gcLibImageLoad_3Dcommon =
"highp uvec4 _viv_image_load_3Dcommon_uint_rgba8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3Dcommon_int_rgba8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3Dcommon_float(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    vec4 result = vec4(0.0);\n"
"    uint is = _viv_image_size(img_desc).w;\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"    uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"    uint inBorder = addrRet.x;\n"
"    uint address = addrRet.y;\n"
"    if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"    else {\n"
"        highp vec4 raw;\n"
"        _viv_asm(LOAD, raw!<f:FLOAT16>, address, 0);\n"
"        result = _viv_image_swizzle(img_desc, raw);\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3Dcommon_float_rgba8(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec4 raw = _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, p);\n"
"   result = vec4(raw) / 255.0;\n"
"   if (raw.x == 255u)\n"
"       result.x = 1.0;\n"
"   if (raw.y == 255u)\n"
"       result.y = 1.0;\n"
"   if (raw.z == 255u)\n"
"       result.z = 1.0;\n"
"   if (raw.w == 255u)\n"
"       result.w = 1.0;\n"
"   return result;\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3Dcommon_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec4 raw = _viv_image_load_3Dcommon_int_rgba8i(img_desc, p);\n"
"   result = vec4(raw) / 127.0;\n"
"   if (abs(raw.x) == 127)\n"
"       result.x = sign(result.x);\n"
"   if (abs(raw.y) == 127)\n"
"       result.y = sign(result.y);\n"
"   if (abs(raw.z) == 127)\n"
"       result.z = sign(result.z);\n"
"   if (abs(raw.w) == 127)\n"
"       result.w = sign(result.w);\n"
"   return result;\n"
"}\n"
"highp vec4 _viv_image_load_3Dcommon_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    vec4 result = vec4(0.0);\n"
"    uint is = _viv_image_size(img_desc).w;\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"    uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"    uint inBorder = addrRet.x;\n"
"    uint address = addrRet.y;\n"
"    if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"    else {\n"
"        highp vec4 raw;\n"
"        _viv_asm(LOAD, raw!<f:FLOAT>, address, 0);\n"
"        result = _viv_image_swizzle(img_desc, raw);\n"
"    }\n"
"    is = _viv_image_size(img_desc_1).w;\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is) ;\n"
"    addrRet = _viv_image_computeImgAddr(img_desc_1, p1, true);\n"
"    inBorder = addrRet.x;\n"
"    address = addrRet.y;\n"
"    if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"    else {\n"
"        highp vec4 raw;\n"
"        _viv_asm(LOAD, raw!<f:FLOAT>, address, 0);\n"
"        result.zw = _viv_image_swizzle(img_desc_1, raw).xy;\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3Dcommon_float_r32f(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       highp float temp;\n"
"       _viv_asm(LOAD, temp!<f:FLOAT>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0.0;\n"
"       raw.z = 0.0;\n"
"       raw.w = 1.0;\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3Dcommon_int(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT16>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3Dcommon_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   is = _viv_image_size(img_desc_1);\n"
"   p1 = p;\n"
"   p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"   addrRet = _viv_image_computeImgAddr(img_desc_1, p1, true);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result.zw = _viv_image_swizzle_int(img_desc_1, raw).xy;\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3Dcommon_int_r32i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       highp int temp;\n"
"       _viv_asm(LOAD, temp!<f:INT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0;\n"
"       raw.z = 0;\n"
"       raw.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"highp uvec4 _viv_image_load_3Dcommon_uint(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT16>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_3Dcommon_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   is = _viv_image_size(img_desc_1);\n"
"   p1 = p;\n"
"   p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"   addrRet = _viv_image_computeImgAddr(img_desc_1, p1, true);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result.zw = _viv_image_swizzle_uint(img_desc_1, raw).xy;\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_3Dcommon_uint_r32ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       highp uint temp;\n"
"       _viv_asm(LOAD, temp!<f:UINT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0u;\n"
"       raw.z = 0u;\n"
"       raw.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";


static gctSTRING gcLibImageLoad_3D =
"highp uvec4 _viv_image_load_3D_uint_rgba8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3D_int_rgba8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba8i(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3D_float(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3D_float_rgba8(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3D_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8_snorm(img_desc, p);\n"
"}\n"
"highp vec4 _viv_image_load_3D_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float_rgba32f(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_3D_float_r32f(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_r32f(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3D_int(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3D_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba32i(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_3D_int_r32i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_r32i(img_desc, p);\n"
"}\n"
"highp uvec4 _viv_image_load_3D_uint(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint(img_desc, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_3D_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_3D_uint_r32ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_r32ui(img_desc, p);\n"
"}\n";

/* cube */
static gctSTRING gcLibImageLoad_cube =
"highp uvec4 _viv_image_load_cube_uint_rgba8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_cube_int_rgba8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba8i(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_cube_float(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_cube_float_rgba8(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_cube_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8_snorm(img_desc, p);\n"
"}\n"
"highp vec4 _viv_image_load_cube_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float_rgba32f(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_cube_float_r32f(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_r32f(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_cube_int(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_cube_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba32i(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_cube_int_r32i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_r32i(img_desc, p);\n"
"}\n"
"highp uvec4 _viv_image_load_cube_uint(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint(img_desc, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_cube_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_cube_uint_r32ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_r32ui(img_desc, p);\n"
"}\n";

/* 2DArray */
static gctSTRING gcLibImageLoad_2DArray =
"highp uvec4 _viv_image_load_2DArray_uint_rgba8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_2DArray_int_rgba8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba8i(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_2DArray_float(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_2DArray_float_rgba8(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_2DArray_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8_snorm(img_desc, p);\n"
"}\n"
"highp vec4 _viv_image_load_2DArray_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float_rgba32f(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_2DArray_float_r32f(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_r32f(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_2DArray_int(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_2DArray_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba32i(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_2DArray_int_r32i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_r32i(img_desc, p);\n"
"}\n"
"highp uvec4 _viv_image_load_2DArray_uint(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint(img_desc, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_2DArray_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_2DArray_uint_r32ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_r32ui(img_desc, p);\n"
"}\n";

/* CubeArray */
static gctSTRING gcLibImageLoad_CubeArray =
"highp uvec4 _viv_image_load_CubeArray_uint_rgba8ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba8ui(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_CubeArray_int_rgba8i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba8i(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_CubeArray_float(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    return _viv_image_load_3Dcommon_float(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_CubeArray_float_rgba8(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8(img_desc, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_CubeArray_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba8_snorm(img_desc, p);\n"
"}\n"
"highp vec4 _viv_image_load_CubeArray_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_rgba32f(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp vec4 _viv_image_load_CubeArray_float_r32f(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_float_r32f(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_CubeArray_int(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int(img_desc, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_CubeArray_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_rgba32i(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp ivec4 _viv_image_load_CubeArray_int_r32i(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_int_r32i(img_desc, p);\n"
"}\n"
"highp uvec4 _viv_image_load_CubeArray_uint(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint(img_desc, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_CubeArray_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p);\n"
"}\n"
"\n"
"highp uvec4 _viv_image_load_CubeArray_uint_r32ui(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"   return _viv_image_load_3Dcommon_uint_r32ui(img_desc, p);\n"
"}\n";

/****************************imageLoad for a buffer image****************************/
static gctSTRING gcLibImageLoad_Buffer_float =
"highp vec4 _viv_image_load_buffer_float(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1.0 : 0.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:FLOAT16>, address, 0);\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_float_rgba8 =
"highp vec4 _viv_image_load_buffer_float_rgba8(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   uvec4 raw = _viv_image_load_buffer_uint_rgba8ui(img_desc, coord);\n"
"   result = vec4(raw) / 255.0;\n"
"   if (raw.x == 255u)\n"
"       result.x = 1.0;\n"
"   if (raw.y == 255u)\n"
"       result.y = 1.0;\n"
"   if (raw.z == 255u)\n"
"       result.z = 1.0;\n"
"   if (raw.w == 255u)\n"
"       result.w = 1.0;\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_float_rgba8_snorm =
"highp vec4 _viv_image_load_buffer_float_rgba8_snorm(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec4 raw = _viv_image_load_buffer_int_rgba8i(img_desc, coord);\n"
"   result = vec4(raw) / 127.0;\n"
"   if (abs(raw.x) == 127)\n"
"       result.x = sign(result.x);\n"
"   if (abs(raw.y) == 127)\n"
"       result.y = sign(result.y);\n"
"   if (abs(raw.z) == 127)\n"
"       result.z = sign(result.z);\n"
"   if (abs(raw.w) == 127)\n"
"       result.w = sign(result.w);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_float_rgba32f =
"highp vec4 _viv_image_load_buffer_float_rgba32f(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp vec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:FLOAT>, address, 0);\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_float_r32f =
"highp vec4 _viv_image_load_buffer_float_r32f(highp uvec4 img_desc, int coord)\n"
"{\n"
"   vec4 result = vec4(0.0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1.0; } \n"
"   else {\n"
"       highp vec4 raw;\n"
"       highp float temp;\n"
"       _viv_asm(LOAD, temp!<f:FLOAT>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0.0;\n"
"       raw.z = 0.0;\n"
"       raw.w = 1.0;\n"
"       result = _viv_image_swizzle(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_int =
"highp ivec4 _viv_image_load_buffer_int(highp uvec4 img_desc, int coord)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT16>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_int_rgba8i =
"highp ivec4 _viv_image_load_buffer_int_rgba8i(highp uvec4 img_desc, int coord)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1 : 0; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT8>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_int_rgba32i =
"highp ivec4 _viv_image_load_buffer_int_rgba32i(highp uvec4 img_desc, int coord)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp ivec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:INT32>, address, 0);\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_int_r32i =
"highp ivec4 _viv_image_load_buffer_int_r32i(highp uvec4 img_desc, int coord)\n"
"{\n"
"   ivec4 result = ivec4(0);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1; } \n"
"   else {\n"
"       highp ivec4 raw;\n"
"       highp int temp;\n"
"       _viv_asm(LOAD, temp!<f:INT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0;\n"
"       raw.z = 0;\n"
"       raw.w = 1;\n"
"       result = _viv_image_swizzle_int(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_uint =
"highp uvec4 _viv_image_load_buffer_uint(highp uvec4 img_desc, int coord)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT16>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_uint_rgba8ui =
"highp uvec4 _viv_image_load_buffer_uint_rgba8ui(highp uvec4 img_desc, int coord)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint inBorder = addrRet.x;\n"
"   uint address = addrRet.y;\n"
"   if (inBorder > 0u) { result.w = (inBorder == 2u) ? 1u : 0u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT8>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_uint_rgba32ui =
"highp uvec4 _viv_image_load_buffer_uint_rgba32ui(highp uvec4 img_desc, int coord)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x <= 0u) {\n"
"       highp uvec4 raw;\n"
"       _viv_asm(LOAD, raw!<f:UINT32>, address, 0);\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_uint_r32ui =
"highp uvec4 _viv_image_load_buffer_uint_r32ui(highp uvec4 img_desc, int coord)\n"
"{\n"
"   uvec4 result = uvec4(0u);\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x > 0u) { result.w = 1u; } \n"
"   else {\n"
"       highp uvec4 raw;\n"
"       highp uint temp;\n"
"       _viv_asm(LOAD, temp!<f:UINT32>, address, 0);\n"
"       raw.x = temp;\n"
"       raw.y = 0u;\n"
"       raw.z = 0u;\n"
"       raw.w = 1u;\n"
"       result = _viv_image_swizzle_uint(img_desc, raw);\n"
"   }\n"
"   return result;\n"
"}\n";

/* CubeArray */
/* gc7000 image instruction implmentation, in which HW support image instruction */
static gctSTRING gcLibImageLoad_2D_float_hati4 =
"highp vec4 _viv_image_load_2D_float(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"    highp vec4 result;\n"
"    _viv_asm(IMAGE_RD, result, img_desc, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_float_1_hati4 =
"highp vec4 _viv_image_load_2D_float_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    _viv_asm(IMAGE_RD, result1, img_desc, p);\n"
"    _viv_asm(IMAGE_RD, result2, img_desc_1, p);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_int_hati4 =
"highp ivec4 _viv_image_load_2D_int(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    _viv_asm(IMAGE_RD, result, img_desc, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_int_1_hati4 =
"highp ivec4 _viv_image_load_2D_int_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    _viv_asm(IMAGE_RD, result1, img_desc, p);\n"
"    _viv_asm(IMAGE_RD, result2, img_desc_1, p);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_uint_hati4 =
"highp uvec4 _viv_image_load_2D_uint(highp uvec4 img_desc, ivec2 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    _viv_asm(IMAGE_RD, result, img_desc, p);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2D_uint_1_hati4 =
"highp uvec4 _viv_image_load_2D_uint_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    _viv_asm(IMAGE_RD, result1, img_desc, p);\n"
"    _viv_asm(IMAGE_RD, result2, img_desc_1, p);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_3D_float_hati4 =
"highp vec4 _viv_image_load_3D_float(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_3D_float_1_hati4 =
"highp vec4 _viv_image_load_3D_float_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_3D_int_hati4 =
"highp ivec4 _viv_image_load_3D_int(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_3D_int_1_hati4 =
"highp ivec4 _viv_image_load_3D_int_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

/* we have to write in:
   p1.z = int(img_desc.x) + p.z * int(is.w) ;
   not
   p1.z = int(img_desc.x)+ p.z * is.w ;
   since we treat the img_desc as its image type, not
   uint. Thus, if the image is rgba16ui or rgba8ui,
   int(img_desc.x) will truncate the base address.
   */

static gctSTRING gcLibImageLoad_3D_uint_hati4 =
"highp uvec4 _viv_image_load_3D_uint(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_3D_uint_1_hati4 =
"highp uvec4 _viv_image_load_3D_uint_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_cube_float_hati4 =
"highp vec4 _viv_image_load_cube_float(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_cube_float_1_hati4 =
"highp vec4 _viv_image_load_cube_float_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_cube_int_hati4 =
"highp ivec4 _viv_image_load_cube_int(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_cube_int_1_hati4 =
"highp ivec4 _viv_image_load_cube_int_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_cube_uint_hati4 =
"highp uvec4 _viv_image_load_cube_uint(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_cube_uint_1_hati4 =
"highp uvec4 _viv_image_load_cube_uint_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_2DArray_float_hati4 =
"highp vec4 _viv_image_load_2DArray_float(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2DArray_float_1_hati4 =
"highp vec4 _viv_image_load_2DArray_float_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_2DArray_int_hati4 =
"highp ivec4 _viv_image_load_2DArray_int(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2DArray_int_1_hati4 =
"highp ivec4 _viv_image_load_2DArray_int_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_2DArray_uint_hati4 =
"highp uvec4 _viv_image_load_2DArray_uint(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_2DArray_uint_1_hati4 =
"highp uvec4 _viv_image_load_2DArray_uint_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_CubeArray_float_img_access =
"highp vec4 _viv_image_load_CubeArray_float(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_CubeArray_float_1_img_access =
"highp vec4 _viv_image_load_CubeArray_float_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp vec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_CubeArray_int_img_access =
"highp ivec4 _viv_image_load_CubeArray_int(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_CubeArray_int_1_img_access =
"highp ivec4 _viv_image_load_CubeArray_int_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp ivec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_CubeArray_uint_img_access =
"highp uvec4 _viv_image_load_CubeArray_uint(highp uvec4 img_desc, ivec3 p)\n"
"{\n"
"    highp uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    _viv_asm(IMAGE_RD_3D, result, img_desc, p1);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_CubeArray_uint_1_img_access =
"highp uvec4 _viv_image_load_CubeArray_uint_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p)\n"
"{\n"
"    highp uvec4 result1, result2;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result1, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"    _viv_asm(IMAGE_RD_3D, result2, img_desc_1, p1);\n"
"    result1.zw = result2.xy;\n"
"    return result1;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_float_img_access =
"highp vec4 _viv_image_load_buffer_float(highp uvec4 img_desc, int p)\n"
"{\n"
"    highp vec4 result;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_RD, result, img_desc, newCoord);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_int_img_access =
"highp ivec4 _viv_image_load_buffer_int(highp uvec4 img_desc, int p)\n"
"{\n"
"    highp ivec4 result;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_RD, result, img_desc, newCoord);\n"
"    return result;\n"
"}\n";

static gctSTRING gcLibImageLoad_Buffer_uint_img_access =
"highp uvec4 _viv_image_load_buffer_uint(highp uvec4 img_desc, int p)\n"
"{\n"
"    highp uvec4 result;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_RD, result, img_desc, newCoord);\n"
"    return result;\n"
"}\n";

/* imageStore gc3000/5000 implementation,
   where HW does not support image_wr */
/* format rgba32f */
static gctSTRING gcLibImageStore_2D_float_rgba32f =
"void _viv_image_store_2D_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, vec4 data)\n"
"{\n"
"   vec2 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.xy);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.zw);\n"
"   }\n"
"}\n";

/* format rgba16f */
static gctSTRING gcLibImageStore_2D_float =
"void _viv_image_store_2D_float(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT16>, address, data);\n"
"   }\n"
"}\n";

/* format r32f */
static gctSTRING gcLibImageStore_2D_float_r32f =
"void _viv_image_store_2D_float_r32f(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.x);\n"
"   }\n"
"}\n";

/* format rgba8
   since driver treats rgba8 as bgra8, we need _viv_image_store_swizzle to
   get the correct data to write */
static gctSTRING gcLibImageStore_2D_float_rgba8 =
"void _viv_image_store_2D_float_rgba8(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 data1 = uvec4(clamp(data, 0.0, 1.0) * 255.5);\n"
"       uvec4 data2 = _viv_image_store_swizzle_uint(img_desc, data1);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data2);\n"
"   }\n"
"}\n";

/* format rgba8_snorm */
static gctSTRING gcLibImageStore_2D_float_rgba8_snorm =
"void _viv_image_store_2D_float_rgba8_snorm(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec3 p1;\n"
"   p1.xy = p;\n"
"   p1.z = 0;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 data1 = ivec4(clamp(data, -1.0, 1.0) * 127.5);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data1);\n"
"   }\n"
"}\n";

/* format rgba32i */
static gctSTRING gcLibImageStore_2D_int_rgba32i =
"void _viv_image_store_2D_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, ivec4 data)\n"
"{\n"
"   ivec2 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.xy);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.zw);\n"
"   }\n"
"}\n";

/* format rgba16i */
static gctSTRING gcLibImageStore_2D_int =
"void _viv_image_store_2D_int(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT16>, address, data);\n"
"   }\n"
"}\n";

/* format rgba8i */
static gctSTRING gcLibImageStore_2D_int_rgba8i =
"void _viv_image_store_2D_int_rgba8i(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 val = _viv_image_store_swizzle_int(img_desc_u, data);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, val);\n"
"   }\n"
"}\n";

/* format r32i */
static gctSTRING gcLibImageStore_2D_int_r32i =
"void _viv_image_store_2D_int_r32i(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"   int result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.x);\n"
"   }\n"
"}\n";

/* format rgba32ui */
static gctSTRING gcLibImageStore_2D_uint_rgba32ui =
"void _viv_image_store_2D_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, uvec4 data)\n"
"{\n"
"   uvec2 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.xy);\n"
"   }\n"
"   addrRet = _viv_image_computeImgAddr2D(img_desc_1, p);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.zw);\n"
"   }\n"
"}\n";

/* format rgba16ui */
static gctSTRING gcLibImageStore_2D_uint =
"void _viv_image_store_2D_uint(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT16>, address, data);\n"
"   }\n"
"}\n";

/* format rgba8ui */
static gctSTRING gcLibImageStore_2D_uint_rgba8ui =
"void _viv_image_store_2D_uint_rgba8ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 val = _viv_image_store_swizzle_uint(img_desc, data);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, val);\n"
"   }\n"
"}\n";

/* format r32ui */
static gctSTRING gcLibImageStore_2D_uint_r32ui =
"void _viv_image_store_2D_uint_r32ui(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"   uint result;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.x);\n"
"   }\n"
"}\n";


/* 3D/cube/2DArray image store */
static gctSTRING gcLibImageStore_3Dcommon =
"void _viv_image_store_3Dcommon_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"   vec2 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.xy);\n"
"   }\n"
"   is = _viv_image_size(img_desc_1).w;\n"
"   p1 = p;\n"
"   p1.z = int(img_desc_1.x) + p.z * int(is) ;\n"
"   addrRet = _viv_image_computeImgAddr(img_desc_1, p1, true);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.zw);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_float(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT16>, address, data);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_float_r32f(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   float result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc_u, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.x);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_float_rgba8(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc_u, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 data1 = uvec4(clamp(data, 0.0, 1.0) * 255.5);\n"
"       uvec4 data2 = _viv_image_store_swizzle_uint(img_desc_u, data1);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data2);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 data1 = ivec4(clamp(data, -1.0, 1.0) * 127.5);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data1);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"   ivec2 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.xy);\n"
"   }\n"
"   is = _viv_image_size(img_desc_1).w;\n"
"   p1 = p;\n"
"   p1.z = int(img_desc_1.x) + p.z * int(is) ;\n"
"   addrRet = _viv_image_computeImgAddr(img_desc_1, p1, true);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.zw);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_int(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT16>, address, data);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_int_rgba8i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc_u, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 val = _viv_image_store_swizzle_int(img_desc_u, data);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, val);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_int_r32i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   int result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.x);\n"
"   }\n"
"}\n"
"void _viv_image_store_3Dcommon_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"   uvec2 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.xy);\n"
"   }\n"
"   is = _viv_image_size(img_desc_1).w;\n"
"   p1 = p;\n"
"   p1.z = int(img_desc_1.x) + p.z * int(is);\n"
"   addrRet = _viv_image_computeImgAddr(img_desc_1, p1, true);\n"
"   address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.zw);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_uint(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT16>, address, data);\n"
"   }\n"
"}\n"
"\n"
"void _viv_image_store_3Dcommon_uint_rgba8ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 val = _viv_image_store_swizzle_uint(img_desc, data);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, val);\n"
"   }\n"
"}\n"
"void _viv_image_store_3Dcommon_uint_r32ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   uint result;\n"
"   uint is = _viv_image_size(img_desc).w;\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is) ;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr(img_desc, p1, true);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.x);\n"
"   }\n"
"}\n";

static gctSTRING gcLibImageStore_3D =
"void _viv_image_store_3D_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba32f(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_3D_float(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_3D_float_r32f(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_r32f(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_3D_float_rgba8(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_3D_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8_snorm(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_3D_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba32i(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_3D_int(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_3D_int_rgba8i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba8i(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_3D_int_r32i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_r32i(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_3D_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_3D_uint(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_3D_uint_rgba8ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba8ui(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_3D_uint_r32ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_r32ui(img_desc, p, data);\n"
"}\n";

/* cube */
static gctSTRING gcLibImageStore_cube =
"void _viv_image_store_cube_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba32f(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_cube_float(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_cube_float_r32f(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_r32f(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_cube_float_rgba8(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_cube_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8_snorm(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_cube_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba32i(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_cube_int(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_cube_int_rgba8i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba8i(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_cube_int_r32i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_r32i(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_cube_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_cube_uint(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_cube_uint_rgba8ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba8ui(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_cube_uint_r32ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_r32ui(img_desc, p, data);\n"
"}\n";

/* 2DArray */
static gctSTRING gcLibImageStore_2DArray =
"void _viv_image_store_2DArray_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba32f(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_2DArray_float(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_2DArray_float_r32f(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_r32f(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_2DArray_float_rgba8(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_2DArray_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8_snorm(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_2DArray_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba32i(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_2DArray_int(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_2DArray_int_rgba8i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba8i(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_2DArray_int_r32i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_r32i(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_2DArray_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_2DArray_uint(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_2DArray_uint_rgba8ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba8ui(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_2DArray_uint_r32ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_r32ui(img_desc, p, data);\n"
"}\n";

static gctSTRING gcLibImageStore_CubeArray =
"void _viv_image_store_CubeArray_float_rgba32f(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba32f(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_CubeArray_float(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_CubeArray_float_r32f(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_r32f(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_CubeArray_float_rgba8(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_CubeArray_float_rgba8_snorm(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_float_rgba8_snorm(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_CubeArray_int_rgba32i(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba32i(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_CubeArray_int(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_CubeArray_int_rgba8i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_rgba8i(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_CubeArray_int_r32i(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_int_r32i(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_CubeArray_uint_rgba32ui(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba32ui(img_desc, img_desc_1, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_CubeArray_uint(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint(img_desc, p, data);\n"
"}\n"
"\n"
"void _viv_image_store_CubeArray_uint_rgba8ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_rgba8ui(img_desc, p, data);\n"
"}\n"
"void _viv_image_store_CubeArray_uint_r32ui(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"   _viv_image_store_3Dcommon_uint_r32ui(img_desc, p, data);\n"
"}\n";

static gctSTRING gcLibImageStore_Buffer_float_rgba32f =
"void _viv_image_store_buffer_float_rgba32f(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data);\n"
"   }\n"
"}\n";

/* format rgba16f */
static gctSTRING gcLibImageStore_Buffer_float =
"void _viv_image_store_buffer_float(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT16>, address, data);\n"
"   }\n"
"}\n";

/* format r32f */
static gctSTRING gcLibImageStore_Buffer_float_r32f =
"void _viv_image_store_buffer_float_r32f(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   float result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:FLOAT>, address, data.x);\n"
"   }\n"
"}\n";

/* format rgba8
   since driver treats rgba8 as bgra8, we need _viv_image_store_swizzle to
   get the correct data to write */
static gctSTRING gcLibImageStore_Buffer_float_rgba8 =
"void _viv_image_store_buffer_float_rgba8(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec4 img_desc_u = img_desc;\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc_u, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       uvec4 data1 = uvec4(clamp(data, 0.0, 1.0) * 255.5);\n"
"       uvec4 data2 = _viv_image_store_swizzle_uint(img_desc_u, data1);\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data2);\n"
"   }\n"
"}\n";

/* format rgba8_snorm */
static gctSTRING gcLibImageStore_Buffer_float_rgba8_snorm =
"void _viv_image_store_buffer_float_rgba8_snorm(highp uvec4 img_desc, int coord, vec4 data)\n"
"{\n"
"   vec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       ivec4 data1 = ivec4(clamp(data, -1.0, 1.0) * 127.5);\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data1);\n"
"   }\n"
"}\n";

/* format rgba32i */
static gctSTRING gcLibImageStore_Buffer_int_rgba32i =
"void _viv_image_store_buffer_int_rgba32i(highp uvec4 img_desc, int coord, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data);\n"
"   }\n"
"}\n";

/* format rgba16i */
static gctSTRING gcLibImageStore_Buffer_int =
"void _viv_image_store_buffer_int(highp uvec4 img_desc, int coord, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT16>, address, data);\n"
"   }\n"
"}\n";

/* format rgba8i */
static gctSTRING gcLibImageStore_Buffer_int_rgba8i =
"void _viv_image_store_buffer_int_rgba8i(highp uvec4 img_desc, int coord, ivec4 data)\n"
"{\n"
"   ivec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT8>, address, data);\n"
"   }\n"
"}\n";

/* format r32i */
static gctSTRING gcLibImageStore_Buffer_int_r32i =
"void _viv_image_store_buffer_int_r32i(highp uvec4 img_desc, int coord, ivec4 data)\n"
"{\n"
"   int result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:INT32>, address, data.x);\n"
"   }\n"
"}\n";

/* format rgba32ui */
static gctSTRING gcLibImageStore_Buffer_uint_rgba32ui =
"void _viv_image_store_buffer_uint_rgba32ui(highp uvec4 img_desc, int coord, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data);\n"
"   }\n"
"}\n";

/* format rgba16ui */
static gctSTRING gcLibImageStore_Buffer_uint =
"void _viv_image_store_buffer_uint(highp uvec4 img_desc, int coord, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT16>, address, data);\n"
"   }\n"
"}\n";

/* format rgba8ui */
static gctSTRING gcLibImageStore_Buffer_uint_rgba8ui =
"void _viv_image_store_buffer_uint_rgba8ui(highp uvec4 img_desc, int coord, uvec4 data)\n"
"{\n"
"   uvec4 result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT8>, address, data);\n"
"   }\n"
"}\n";

/* format r32ui */
static gctSTRING gcLibImageStore_Buffer_uint_r32ui =
"void _viv_image_store_buffer_uint_r32ui(highp uvec4 img_desc, int coord, uvec4 data)\n"
"{\n"
"   uint result;\n"
"   ivec2 p = ivec2(coord%MAX_TEXTURE_BUFFER_SIZE, coord/MAX_TEXTURE_BUFFER_SIZE);\n"
"   uvec2 addrRet = _viv_image_computeImgAddr2D(img_desc, p);\n"
"   uint address = addrRet.y;\n"
"   if (addrRet.x == 0u) {\n"
"       _viv_asm(STORE1, result!<f:UINT32>, address, data.x);\n"
"   }\n"
"}\n";

/* halti4 */
static gctSTRING gcLibImageStore_2D_float_hati4 =
"void _viv_image_store_2D_float(highp uvec4 img_desc, ivec2 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"}\n";

static gctSTRING gcLibImageStore_2D_float_1_hati4 =
"void _viv_image_store_2D_float_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, vec4 data)\n"
"{\n"
"    vec2 result = data.xy;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR, result, img_desc_1, p);\n"
"}\n";

static gctSTRING gcLibImageStore_2D_int_hati4 =
"void _viv_image_store_2D_int(highp uvec4 img_desc, ivec2 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"}\n";

static gctSTRING gcLibImageStore_2D_int_1_hati4 =
"void _viv_image_store_2D_int_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR, result, img_desc_1, p);\n"
"}\n";

static gctSTRING gcLibImageStore_2D_uint_hati4 =
"void _viv_image_store_2D_uint(highp uvec4 img_desc, ivec2 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"}\n";

static gctSTRING gcLibImageStore_2D_uint_1_hati4 =
"void _viv_image_store_2D_uint_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec2 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR, result, img_desc, p);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR, result, img_desc_1, p);\n"
"}\n";

static gctSTRING gcLibImageStore_3D_float_hati4 =
"void _viv_image_store_3D_float(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_3D_float_1_hati4 =
"void _viv_image_store_3D_float_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"    vec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_3D_int_hati4 =
"void _viv_image_store_3D_int(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_3D_int_1_hati4 =
"void _viv_image_store_3D_int_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_3D_uint_hati4 =
"void _viv_image_store_3D_uint(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_3D_uint_1_hati4 =
"void _viv_image_store_3D_uint_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_cube_float_hati4 =
"void _viv_image_store_cube_float(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_cube_float_1_hati4 =
"void _viv_image_store_cube_float_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"    vec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_cube_int_hati4 =
"void _viv_image_store_cube_int(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_cube_int_1_hati4 =
"void _viv_image_store_cube_int_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_cube_uint_hati4 =
"void _viv_image_store_cube_uint(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_cube_uint_1_hati4 =
"void _viv_image_store_cube_uint_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_2DArray_float_hati4 =
"void _viv_image_store_2DArray_float(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_2DArray_float_1_hati4 =
"void _viv_image_store_2DArray_float_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"    vec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_2DArray_int_hati4 =
"void _viv_image_store_2DArray_int(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_2DArray_int_1_hati4 =
"void _viv_image_store_2DArray_int_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_2DArray_uint_hati4 =
"void _viv_image_store_2DArray_uint(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_2DArray_uint_1_hati4 =
"void _viv_image_store_2DArray_uint_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_CubeArray_float_img_access =
"void _viv_image_store_CubeArray_float(highp uvec4 img_desc, ivec3 p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_CubeArray_float_1_img_access =
"void _viv_image_store_CubeArray_float_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, vec4 data)\n"
"{\n"
"    vec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_CubeArray_int_img_access =
"void _viv_image_store_CubeArray_int(highp uvec4 img_desc, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_CubeArray_int_1_img_access =
"void _viv_image_store_CubeArray_int_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, ivec4 data)\n"
"{\n"
"    ivec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w) ;\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_CubeArray_uint_img_access =
"void _viv_image_store_CubeArray_uint(highp uvec4 img_desc, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"    result = data;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_CubeArray_uint_1_img_access =
"void _viv_image_store_CubeArray_uint_1(highp uvec4 img_desc, highp uvec4 img_desc_1, ivec3 p, uvec4 data)\n"
"{\n"
"    uvec2 result;\n"
"    uvec4 is = _viv_image_size(img_desc);\n"
"    ivec3 p1 = p;\n"
"    p1.z = int(img_desc.x) + p.z * int(is.w);\n"
"    result = data.xy;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc, p1);\n"
"    is = _viv_image_size(img_desc_1);\n"
"    p1 = p;\n"
"    p1.z = int(img_desc_1.x) + p.z * int(is.w);\n"
"    result = data.zw;\n"
"    _viv_asm(IMAGE_WR_3D, result, img_desc_1, p1);\n"
"}\n";

static gctSTRING gcLibImageStore_Buffer_float_img_access =
"void _viv_image_store_buffer_float(highp uvec4 img_desc, int p, vec4 data)\n"
"{\n"
"    vec4 result;\n"
"    result = data;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_WR, result, img_desc, newCoord);\n"
"}\n";

static gctSTRING gcLibImageStore_Buffer_int_img_access =
"void _viv_image_store_buffer_int(highp uvec4 img_desc, int p, ivec4 data)\n"
"{\n"
"    ivec4 result;\n"
"    result = data;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_WR, result, img_desc, newCoord);\n"
"}\n";

static gctSTRING gcLibImageStore_Buffer_uint_img_access =
"void _viv_image_store_buffer_uint(highp uvec4 img_desc, int p, uvec4 data)\n"
"{\n"
"    uvec4 result;\n"
"    result = data;\n"
"    ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"    _viv_asm(IMAGE_WR, result, img_desc, newCoord);\n"
"}\n";

/* image atomic functions */
static gctSTRING gcLibImageAtomicAdd_2D_int =
"int _viv_image_atomic_add_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_2D_uint =
"uint _viv_image_atomic_add_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_3D_int =
"int _viv_image_atomic_add_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_3D_uint =
"uint _viv_image_atomic_add_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_CUBE_int =
"int _viv_image_atomic_add_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_CUBE_uint =
"uint _viv_image_atomic_add_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_2DARRAY_int =
"int _viv_image_atomic_add_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_2DARRAY_uint =
"uint _viv_image_atomic_add_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_buffer_int =
"int _viv_image_atomic_add_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_buffer_uint =
"uint _viv_image_atomic_add_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_2D_int =
"int _viv_image_atomic_min_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_2D_uint =
"uint _viv_image_atomic_min_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_3D_int =
"int _viv_image_atomic_min_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_3D_uint =
"uint _viv_image_atomic_min_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_CUBE_int =
"int _viv_image_atomic_min_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_CUBE_uint =
"uint _viv_image_atomic_min_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_2DARRAY_int =
"int _viv_image_atomic_min_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_2DARRAY_uint =
"uint _viv_image_atomic_min_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_buffer_int =
"int _viv_image_atomic_min_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_buffer_uint =
"uint _viv_image_atomic_min_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_2D_int =
"int _viv_image_atomic_max_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_2D_uint =
"uint _viv_image_atomic_max_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_3D_int =
"int _viv_image_atomic_max_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_3D_uint =
"uint _viv_image_atomic_max_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_CUBE_int =
"int _viv_image_atomic_max_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_CUBE_uint =
"uint _viv_image_atomic_max_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_2DARRAY_int =
"int _viv_image_atomic_max_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_2DARRAY_uint =
"uint _viv_image_atomic_max_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_buffer_int =
"int _viv_image_atomic_max_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_buffer_uint =
"uint _viv_image_atomic_max_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_2D_int =
"int _viv_image_atomic_and_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_2D_uint =
"uint _viv_image_atomic_and_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_3D_int =
"int _viv_image_atomic_and_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_3D_uint =
"uint _viv_image_atomic_and_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_CUBE_int =
"int _viv_image_atomic_and_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_CUBE_uint =
"uint _viv_image_atomic_and_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_2DARRAY_int =
"int _viv_image_atomic_and_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_2DARRAY_uint =
"uint _viv_image_atomic_and_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_buffer_int =
"int _viv_image_atomic_and_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_buffer_uint =
"uint _viv_image_atomic_and_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_2D_int =
"int _viv_image_atomic_or_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_2D_uint =
"uint _viv_image_atomic_or_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_3D_int =
"int _viv_image_atomic_or_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_3D_uint =
"uint _viv_image_atomic_or_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_CUBE_int =
"int _viv_image_atomic_or_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_CUBE_uint =
"uint _viv_image_atomic_or_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_2DARRAY_int =
"int _viv_image_atomic_or_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_2DARRAY_uint =
"uint _viv_image_atomic_or_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_buffer_int =
"int _viv_image_atomic_or_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_buffer_uint =
"uint _viv_image_atomic_or_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_2D_int =
"int _viv_image_atomic_xor_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_2D_uint =
"uint _viv_image_atomic_xor_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_3D_int =
"int _viv_image_atomic_xor_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_3D_uint =
"uint _viv_image_atomic_xor_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_CUBE_int =
"int _viv_image_atomic_xor_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_CUBE_uint =
"uint _viv_image_atomic_xor_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_2DARRAY_int =
"int _viv_image_atomic_xor_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_2DARRAY_uint =
"uint _viv_image_atomic_xor_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_buffer_int =
"int _viv_image_atomic_xor_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_buffer_uint =
"uint _viv_image_atomic_xor_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2D_int =
"int _viv_image_atomic_xchg_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2D_uint =
"uint _viv_image_atomic_xchg_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2D_float =
"float _viv_image_atomic_xchg_2D_float(highp uvec4 img_desc, ivec2 p, float data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_3D_int =
"int _viv_image_atomic_xchg_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_3D_uint =
"uint _viv_image_atomic_xchg_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_3D_float =
"float _viv_image_atomic_xchg_3D_float(highp uvec4 img_desc, ivec3 p, float data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_CUBE_int =
"int _viv_image_atomic_xchg_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_CUBE_uint =
"uint _viv_image_atomic_xchg_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_CUBE_float =
"float _viv_image_atomic_xchg_CUBE_float(highp uvec4 img_desc, ivec3 p, float data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2DARRAY_int =
"int _viv_image_atomic_xchg_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2DARRAY_uint =
"uint _viv_image_atomic_xchg_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2DARRAY_float =
"float _viv_image_atomic_xchg_2DARRAY_float(highp uvec4 img_desc, ivec3 p, float data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_buffer_int =
"int _viv_image_atomic_xchg_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_buffer_uint =
"uint _viv_image_atomic_xchg_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_buffer_float =
"float _viv_image_atomic_xchg_buffer_float(highp uvec4 img_desc, int p, float data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_2D_int =
"int _viv_image_atomic_cmpxchg_2D_int(highp uvec4 img_desc, ivec2 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), p).y;\n"
"   ivec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_2D_uint =
"uint _viv_image_atomic_cmpxchg_2D_uint(highp uvec4 img_desc, ivec2 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, p).y;\n"
"   uvec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_3D_int =
"int _viv_image_atomic_cmpxchg_3D_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   ivec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_3D_uint =
"uint _viv_image_atomic_cmpxchg_3D_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   uvec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_CUBE_int =
"int _viv_image_atomic_cmpxchg_CUBE_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   ivec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_CUBE_uint =
"uint _viv_image_atomic_cmpxchg_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   uvec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_2DARRAY_int =
"int _viv_image_atomic_cmpxchg_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(uvec4(img_desc), p1, true).y;\n"
"   ivec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_2DARRAY_uint =
"uint _viv_image_atomic_cmpxchg_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   address = _viv_image_computeImgAddr(img_desc, p1, true).y;\n"
"   uvec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_buffer_int =
"int _viv_image_atomic_cmpxchg_buffer_int(highp uvec4 img_desc, int p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(uvec4(img_desc), ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   ivec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_buffer_uint =
"uint _viv_image_atomic_cmpxchg_buffer_uint(highp uvec4 img_desc, int p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   address = _viv_image_computeImgAddr2D(img_desc, ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE)).y;\n"
"   uvec2 temp;\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_2D_int_hati4 =
"int _viv_image_atomic_add_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_2D_uint_hati4 =
"uint _viv_image_atomic_add_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_3D_int_hati4 =
"int _viv_image_atomic_add_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_3D_uint_hati4 =
"uint _viv_image_atomic_add_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_CUBE_int_hati4 =
"int _viv_image_atomic_add_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_CUBE_uint_hati4 =
"uint _viv_image_atomic_add_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_2DARRAY_int_hati4 =
"int _viv_image_atomic_add_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_add_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_buffer_int_img_access =
"int _viv_image_atomic_add_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAdd_buffer_uint_img_access =
"uint _viv_image_atomic_add_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMADD, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_2D_int_hati4 =
"int _viv_image_atomic_min_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_2D_uint_hati4 =
"uint _viv_image_atomic_min_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_3D_int_hati4 =
"int _viv_image_atomic_min_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_3D_uint_hati4 =
"uint _viv_image_atomic_min_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_CUBE_int_hati4 =
"int _viv_image_atomic_min_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_CUBE_uint_hati4 =
"uint _viv_image_atomic_min_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_2DARRAY_int_hati4 =
"int _viv_image_atomic_min_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_min_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_buffer_int_img_access =
"int _viv_image_atomic_min_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMin_buffer_uint_img_access =
"uint _viv_image_atomic_min_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMMIN, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_2D_int_hati4 =
"int _viv_image_atomic_max_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_2D_uint_hati4 =
"uint _viv_image_atomic_max_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_3D_int_hati4 =
"int _viv_image_atomic_max_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_3D_uint_hati4 =
"uint _viv_image_atomic_max_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_CUBE_int_hati4 =
"int _viv_image_atomic_max_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_CUBE_uint_hati4 =
"uint _viv_image_atomic_max_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_2DARRAY_int_hati4 =
"int _viv_image_atomic_max_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_max_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_buffer_int_img_access =
"int _viv_image_atomic_max_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicMax_buffer_uint_img_access =
"uint _viv_image_atomic_max_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMMAX, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_2D_int_hati4 =
"int _viv_image_atomic_and_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_2D_uint_hati4 =
"uint _viv_image_atomic_and_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_3D_int_hati4 =
"int _viv_image_atomic_and_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_3D_uint_hati4 =
"uint _viv_image_atomic_and_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_CUBE_int_hati4 =
"int _viv_image_atomic_and_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_CUBE_uint_hati4 =
"uint _viv_image_atomic_and_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_2DARRAY_int_hati4 =
"int _viv_image_atomic_and_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_and_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_buffer_int_img_access =
"int _viv_image_atomic_and_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicAnd_buffer_uint_img_access =
"uint _viv_image_atomic_and_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMAND, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_2D_int_hati4 =
"int _viv_image_atomic_or_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_2D_uint_hati4 =
"uint _viv_image_atomic_or_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_3D_int_hati4 =
"int _viv_image_atomic_or_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_3D_uint_hati4 =
"uint _viv_image_atomic_or_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_CUBE_int_hati4 =
"int _viv_image_atomic_or_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_CUBE_uint_hati4 =
"uint _viv_image_atomic_or_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_2DARRAY_int_hati4 =
"int _viv_image_atomic_or_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_or_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_buffer_int_img_access =
"int _viv_image_atomic_or_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicOr_buffer_uint_img_access =
"uint _viv_image_atomic_or_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_2D_int_hati4 =
"int _viv_image_atomic_xor_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_2D_uint_hati4 =
"uint _viv_image_atomic_xor_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_3D_int_hati4 =
"int _viv_image_atomic_xor_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_3D_uint_hati4 =
"uint _viv_image_atomic_xor_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_CUBE_int_hati4 =
"int _viv_image_atomic_xor_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_CUBE_uint_hati4 =
"uint _viv_image_atomic_xor_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_2DARRAY_int_hati4 =
"int _viv_image_atomic_xor_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_xor_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_buffer_int_img_access =
"int _viv_image_atomic_xor_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXor_buffer_uint_img_access =
"uint _viv_image_atomic_xor_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMXOR, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2D_int_hati4 =
"int _viv_image_atomic_xchg_2D_int(highp uvec4 img_desc, ivec2 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2D_uint_hati4 =
"uint _viv_image_atomic_xchg_2D_uint(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2D_float_hati4 =
"float _viv_image_atomic_xchg_2D_float(highp uvec4 img_desc, ivec2 p, uint data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_3D_int_hati4 =
"int _viv_image_atomic_xchg_3D_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_3D_uint_hati4 =
"uint _viv_image_atomic_xchg_3D_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_3D_float_hati4 =
"float _viv_image_atomic_xchg_3D_float(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_CUBE_int_hati4 =
"int _viv_image_atomic_xchg_CUBE_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_CUBE_uint_hati4 =
"uint _viv_image_atomic_xchg_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_CUBE_float_hati4 =
"float _viv_image_atomic_xchg_CUBE_float(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2DARRAY_int_hati4 =
"int _viv_image_atomic_xchg_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_xchg_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_2DARRAY_float_hati4 =
"float _viv_image_atomic_xchg_2DARRAY_float(highp uvec4 img_desc, ivec3 p, uint data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_buffer_int_img_access =
"int _viv_image_atomic_xchg_buffer_int(highp uvec4 img_desc, int p, int data)\n"
"{\n"
"   int result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_buffer_uint_img_access =
"uint _viv_image_atomic_xchg_buffer_uint(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   uint result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicXchg_buffer_float_img_access =
"float _viv_image_atomic_xchg_buffer_float(highp uvec4 img_desc, int p, uint data)\n"
"{\n"
"   float result;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   _viv_asm(ATOMXCHG, result, address, data);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_2D_int_hati4 =
"int _viv_image_atomic_cmpxchg_2D_int(highp uvec4 img_desc, ivec2 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   ivec2 temp;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_2D_uint_hati4 =
"uint _viv_image_atomic_cmpxchg_2D_uint(highp uvec4 img_desc, ivec2 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uvec2 temp;\n"
"   uint address;\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, p);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_3D_int_hati4 =
"int _viv_image_atomic_cmpxchg_3D_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   ivec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_3D_uint_hati4 =
"uint _viv_image_atomic_cmpxchg_3D_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uvec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_CUBE_int_hati4 =
"int _viv_image_atomic_cmpxchg_CUBE_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   ivec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_CUBE_uint_hati4 =
"uint _viv_image_atomic_cmpxchg_CUBE_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uvec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_2DARRAY_int_hati4 =
"int _viv_image_atomic_cmpxchg_2DARRAY_int(highp uvec4 img_desc, ivec3 p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   ivec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_2DARRAY_uint_hati4 =
"uint _viv_image_atomic_cmpxchg_2DARRAY_uint(highp uvec4 img_desc, ivec3 p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uvec2 temp;\n"
"   uint address;\n"
"   uvec4 is = _viv_image_size(img_desc);\n"
"   ivec3 p1 = p;\n"
"   p1.z = int(img_desc.x) + p.z * int(is.w) ;\n"
"   _viv_asm(IMAGE_ADDR_3D, address, img_desc, p1);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_buffer_int_img_access =
"int _viv_image_atomic_cmpxchg_buffer_int(highp uvec4 img_desc, int p, int data0, int data1)\n"
"{\n"
"   int result;\n"
"   ivec2 temp;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

static gctSTRING gcLibImageAtomicCmpXchg_buffer_uint_img_access =
"uint _viv_image_atomic_cmpxchg_buffer_uint(highp uvec4 img_desc, int p, uint data0, uint data1)\n"
"{\n"
"   uint result;\n"
"   uvec2 temp;\n"
"   uint address;\n"
"   ivec2 newCoord = ivec2(p%MAX_TEXTURE_BUFFER_SIZE, p/MAX_TEXTURE_BUFFER_SIZE);\n"
"   _viv_asm(IMAGE_ADDR, address, img_desc, newCoord);\n"
"   temp.y = data0;"
"   temp.x = data1;"
"   _viv_asm(ATOMCMPXCHG, result, address, temp);\n"
"   return result;\n"
"}\n";

/******************** advanced blend equation implementation ********************/
/* gc3000/5000 blend equation implementation */
static gctSTRING gcLibBlendEquation_Multiply =
"vec4 _blend_equation_advanced_multiply(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_MULTIPLY) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Screen =
"vec4 _blend_equation_advanced_screen(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SCREEN) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = src.xyz + dst.xyz - src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Overlay =
"vec4 _blend_equation_advanced_overlay(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_OVERLAY) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            vec3 temp = (vec3(2) * dst.xyz) == vec3(dst.w) ? vec3(0.5) : dst.xyz/vec3(dst.w);\n"
"            dst.xyz = mix(temp, vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f1 = vec3(2.0) * src.xyz * dst.xyz;\n"
"            vec3 f2 = vec3(1.0) - vec3(2.0) * (vec3(1.0) - src.xyz) * (vec3(1.0) - dst.xyz);\n"
"            bvec3 sel = lessThanEqual(dst.xyz, vec3(0.5));\n"
"            vec3 f = mix(f2, f1, sel);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Darken =
"vec4 _blend_equation_advanced_darken(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DARKEN) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = min(src.xyz, dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Lighten =
"vec4 _blend_equation_advanced_lighten(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_LIGHTEN) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = max(src.xyz, dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Hardlight =
"vec4 _blend_equation_advanced_hardlight(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HARDLIGHT) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            vec3 temp = (vec3(2) * src.xyz) == vec3(src.w) ? vec3(0.5) : src.xyz/vec3(src.w);\n"
"            src.xyz = mix(temp, vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f1 = vec3(2.0) * src.xyz * dst.xyz;\n"
"            vec3 f2 = vec3(1.0) - vec3(2.0) * (vec3(1.0) - src.xyz) * (vec3(1.0) - dst.xyz);\n"
"            bvec3 sel = lessThanEqual(src.xyz, vec3(0.5));\n"
"            vec3 f = mix(f2, f1, sel);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Difference =
"vec4 _blend_equation_advanced_difference(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DIFFERENCE) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = abs(src.xyz - dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Exclusion =
"vec4 _blend_equation_advanced_exclusion(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_EXCLUSION) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = src.xyz + dst.xyz - vec3(2.0) * src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Colordodge =
"vec4 _blend_equation_advanced_colordodge(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            vec3 temp = src.xyz == vec3(src.w) ? vec3(1.0) : src.xyz/vec3(src.w);\n"
"            src.xyz = mix(temp, vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            temp = dst.xyz == vec3(dst.w) ? vec3(1.0) : dst.xyz/vec3(dst.w);\n"
"            dst.xyz = mix(temp, vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = vec3(1.0);\n"
"            sel1 = lessThanEqual(dst.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            bvec3 sel2 = lessThan(src.xyz, vec3(1.0));\n"
"            f = mix(f, min(vec3(1.0), dst.xyz/(vec3(1.0) - src.xyz)), sel2);\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Colorburn =
"vec4 _blend_equation_advanced_colorburn(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            vec3 temp = dst.xyz == vec3(dst.w) ? vec3(1.0) : dst.xyz/vec3(dst.w);\n"
"            dst.xyz = mix(temp, vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = vec3(0.0);\n"
"            sel1 = greaterThanEqual(dst.xyz, vec3(1.0));\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            bvec3 sel2 = greaterThan(src.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(1.0) - min(vec3(1.0), (vec3(1.0) - dst.xyz)/src.xyz), sel2);\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Softlight =
"vec4 _blend_equation_advanced_softlight(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            vec3 temp = (vec3(2) * src.xyz) == vec3(src.w) ? vec3(0.5) : src.xyz/vec3(src.w);\n"
"            src.xyz = mix(temp, vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            temp = (vec3(4) *dst.xyz) == vec3(dst.w) ? vec3(0.25) : dst.xyz/vec3(dst.w);\n"
"            dst.xyz = mix(temp, vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f1 = dst.xyz - (vec3(1.0) - vec3(2.0) * src.xyz)* dst.xyz * (vec3(1.0) - dst.xyz);\n"
"            vec3 f2 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0))* dst.xyz * ((vec3(16.0) * dst.xyz - vec3(12.0))* dst.xyz+vec3(3.0));\n"
"            vec3 f3 = dst.xyz + (vec3(2.0) * src.xyz-vec3(1.0)) *(sqrt(dst.xyz)-dst.xyz);\n"
"            vec3 f = f3;\n"
"            sel1 = lessThanEqual(src.xyz, vec3(0.5));\n"
"            f = mix(f, f1, sel1);\n"
"            bvec3 sel2 = lessThanEqual(dst.xyz, vec3(0.25));\n"
"            f = mix(f, f2, sel2);\n"
"            f = mix(f, f1, sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_HSL_HUE =
"vec4 _blend_equation_advanced_hsl_hue(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            float minbase = min(min(src.x, src.y), src.z);\n"
"            float maxbase = max(max(src.x, src.y), src.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(dst.x, dst.y), dst.z);\n"
"            float maxsat = max(max(dst.x, dst.y), dst.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (src.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
/* TO-DO: fix the const vec. For now, should not written in
             float lbase = dot(sret.xyz, vec(0.30, 0.59, 0.11)); */
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_HSL_SATURATION =
"vec4 _blend_equation_advanced_hsl_saturation(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            float minbase = min(min(dst.x, dst.y), dst.z);\n"
"            float maxbase = max(max(dst.x, dst.y), dst.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(src.x, src.y), src.z);\n"
"            float maxsat = max(max(src.x, src.y), src.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (dst.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_HSL_COLOR =
"vec4 _blend_equation_advanced_hsl_color(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float lbase = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;\n"
"            float llum = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = src.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_HSL_LUMINOSITY =
"vec4 _blend_equation_advanced_hsl_luminosity(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY) {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float lbase = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float llum = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = dst.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_ALL =
"vec4 _blend_equation_advanced_all(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    float width,\n"
"    float height,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"            vec2 cord = gl_FragCoord.xy / vec2(width, height);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            vec3 temp = src.xyz == vec3(src.w) ? vec3(1.0) : src.xyz/vec3(src.w);\n"
"            src.xyz = mix(temp, vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            temp = dst.xyz == vec3(dst.w) ? vec3(1.0) : dst.xyz/vec3(dst.w);\n"
"            dst.xyz = mix(temp, vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            bvec3 sel2;\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_MULTIPLY) {\n"
"            vec3 f = src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SCREEN) {\n"
"            vec3 f = src.xyz + dst.xyz - src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_OVERLAY) {\n"
"            vec3 f1 = vec3(2.0) * src.xyz * dst.xyz;\n"
"            vec3 f2 = vec3(1.0) - vec3(2.0) * (vec3(1.0) - src.xyz) * (vec3(1.0) - dst.xyz);\n"
"            bvec3 sel = lessThanEqual(dst.xyz, vec3(0.5));\n"
"            vec3 f = mix(f2, f1, sel);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DARKEN) {\n"
"            vec3 f = min(src.xyz, dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_LIGHTEN) {\n"
"            vec3 f = max(src.xyz, dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HARDLIGHT) {\n"
"            vec3 f1 = vec3(2.0) * src.xyz * dst.xyz;\n"
"            vec3 f2 = vec3(1.0) - vec3(2.0) * (vec3(1.0) - src.xyz) * (vec3(1.0) - dst.xyz);\n"
"            bvec3 sel = lessThanEqual(src.xyz, vec3(0.5));\n"
"            vec3 f = mix(f2, f1, sel);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_DIFFERENCE) {\n"
"            vec3 f = abs(src.xyz - dst.xyz);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_EXCLUSION) {\n"
"            vec3 f = src.xyz + dst.xyz - vec3(2.0) * src.xyz * dst.xyz;\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE) {\n"
"            vec3 f = vec3(1.0); \n"
"            sel1 = lessThanEqual(dst.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            sel2 = lessThan(src.xyz, vec3(1.0));\n"
"            f = mix(f, min(vec3(1.0), dst.xyz/(vec3(1.0) - src.xyz)), sel2);\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN) {\n"
"            vec3 f = vec3(0.0);\n"
"            sel1 = greaterThanEqual(dst.xyz, vec3(1.0));\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            sel2 = greaterThan(src.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(1.0) - min(vec3(1.0), (vec3(1.0) - dst.xyz)/src.xyz), sel2);\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT) {\n"
"            vec3 f1 = dst.xyz - (vec3(1.0) - vec3(2.0) * src.xyz)* dst.xyz * (vec3(1.0) - dst.xyz);\n"
"            vec3 f2 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0))* dst.xyz * ((vec3(16.0) * dst.xyz - vec3(12.0))* dst.xyz+vec3(3.0));\n"
"            vec3 f3 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0)) *(sqrt(dst.xyz)-dst.xyz);\n"
"            vec3 f = f3;\n"
"            sel1 = lessThanEqual(src.xyz, vec3(0.5));\n"
"            f = mix(f, f1, sel1);\n"
"            sel2 = lessThanEqual(dst.xyz, vec3(0.25));\n"
"            f = mix(f, f2, sel2);\n"
"            f = mix(f, f1, sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE) {\n"
"            float minbase = min(min(src.x, src.y), src.z);\n"
"            float maxbase = max(max(src.x, src.y), src.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(dst.x, dst.y), dst.z);\n"
"            float maxsat = max(max(dst.x, dst.y), dst.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (src.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION) {\n"
"            float minbase = min(min(dst.x, dst.y), dst.z);\n"
"            float maxbase = max(max(dst.x, dst.y), dst.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(src.x, src.y), src.z);\n"
"            float maxsat = max(max(src.x, src.y), src.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (dst.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR) {\n"
"            float lbase = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;\n"
"            float llum = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = src.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY) {\n"
"            float lbase = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float llum = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = dst.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

/* gc7000 blend equation implementation */
static gctSTRING gcLibBlendEquation_Colordodge_hati4 =
"vec4 _blend_equation_advanced_colordodge(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE) {\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = vec3(1.0);\n"
"            sel1 = lessThanEqual(dst.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            bvec3 sel2 = lessThan(src.xyz, vec3(1.0));\n"
"            f = mix(f, min(vec3(1.0), dst.xyz/(vec3(1.0) - src.xyz)), sel2);\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Colorburn_hati4 =
"vec4 _blend_equation_advanced_colorburn(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN) {\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f = vec3(0.0);\n"
"            sel1 = greaterThanEqual(dst.xyz, vec3(1.0));\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            bvec3 sel2 = greaterThan(src.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(1.0) - min(vec3(1.0), (vec3(1.0) - dst.xyz)/src.xyz), sel2);\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_Softlight_hati4 =
"vec4 _blend_equation_advanced_softlight(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT) {\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f1 = dst.xyz - (vec3(1.0) - vec3(2.0) * src.xyz)* dst.xyz * (vec3(1.0) - dst.xyz);\n"
"            vec3 f2 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0))* dst.xyz * ((vec3(16.0) * dst.xyz - vec3(12.0))* dst.xyz+vec3(3.0));\n"
"            vec3 f3 = dst.xyz + (vec3(2.0) * src.xyz-vec3(1.0)) *(sqrt(dst.xyz)-dst.xyz);\n"
"            vec3 f = f3;\n"
"            sel1 = lessThanEqual(src.xyz, vec3(0.5));\n"
"            f = mix(f, f1, sel1);\n"
"            bvec3 sel2 = lessThanEqual(dst.xyz, vec3(0.25));\n"
"            f = mix(f, f2, sel2);\n"
"            f = mix(f, f1, sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_HSL_HUE_hati4 =
"vec4 _blend_equation_advanced_hsl_hue(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE) {\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            float minbase = min(min(src.x, src.y), src.z);\n"
"            float maxbase = max(max(src.x, src.y), src.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(dst.x, dst.y), dst.z);\n"
"            float maxsat = max(max(dst.x, dst.y), dst.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (src.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
/* TO-DO: fix the const vec. For now, should not written in
             float lbase = dot(sret.xyz, vec(0.30, 0.59, 0.11)); */
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_HSL_SATURATION_hati4 =
"vec4 _blend_equation_advanced_hsl_saturation(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION) {\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            float minbase = min(min(dst.x, dst.y), dst.z);\n"
"            float maxbase = max(max(dst.x, dst.y), dst.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(src.x, src.y), src.z);\n"
"            float maxsat = max(max(src.x, src.y), src.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (dst.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_HSL_COLOR_hati4 =
"vec4 _blend_equation_advanced_hsl_color(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR) {\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float lbase = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;\n"
"            float llum = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = src.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";


static gctSTRING gcLibBlendEquation_HSL_LUMINOSITY_hati4 =
"vec4 _blend_equation_advanced_hsl_luminosity(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY) {\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
/* specify the lod=0, src2=0x1001 used in textld_u instructions,
   0x1 and 0x1 */
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float lbase = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float llum = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = dst.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"        }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLibBlendEquation_ALL_hati4 =
"vec4 _blend_equation_advanced_all(\n"
"    vec4   src,\n"
"    sampler2D sampler,\n"
"    ivec2 blend_enable_mode\n"
"    )\n"
"{\n"
"    vec4 dst;\n"
"    vec4 result = src;\n"
"    if (blend_enable_mode.x == 1)\n"
"    {\n"
"            bvec3 sel1 = bvec3(src.w == 0.0);\n"
"            src.xyz = mix(src.xyz/vec3(src.w), vec3(0.0), sel1);\n"
"            vec2 cord = floor(gl_FragCoord.xy);\n"
"            _viv_asm(TEXU_LOD, dst, 0, 0x1001);\n"
"            _viv_asm(TEXLD, dst, sampler, cord);\n"
"            sel1 = bvec3(dst.w == 0.0);\n"
"            dst.xyz = mix(dst.xyz/vec3(dst.w), vec3(0.0), sel1);\n"
"            float p0 = src.w * dst.w;\n"
"            float p1 = src.w * (1.0 - dst.w);\n"
"            float p2 = dst.w * (1.0 - src.w);\n"
"            vec3 f;\n"
"            bvec3 sel2;\n"
"        if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORDODGE) {\n"
"            f = vec3(1.0); \n"
"            sel1 = lessThanEqual(dst.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            sel2 = lessThan(src.xyz, vec3(1.0));\n"
"            f = mix(f, min(vec3(1.0), dst.xyz/(vec3(1.0) - src.xyz)), sel2);\n"
"            f = mix(f, vec3(0.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_COLORBURN) {\n"
"            f = vec3(0.0);\n"
"            sel1 = greaterThanEqual(dst.xyz, vec3(1.0));\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            sel2 = greaterThan(src.xyz, vec3(0.0));\n"
"            f = mix(f, vec3(1.0) - min(vec3(1.0), (vec3(1.0) - dst.xyz)/src.xyz), sel2);\n"
"            f = mix(f, vec3(1.0), sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_SOFTLIGHT) {\n"
"            vec3 f1 = dst.xyz - (vec3(1.0) - vec3(2.0) * src.xyz)* dst.xyz * (vec3(1.0) - dst.xyz);\n"
"            vec3 f2 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0))* dst.xyz * ((vec3(16.0) * dst.xyz - vec3(12.0))* dst.xyz+vec3(3.0));\n"
"            vec3 f3 = dst.xyz + (vec3(2.0) * src.xyz - vec3(1.0)) *(sqrt(dst.xyz)-dst.xyz);\n"
"            f = f3;\n"
"            sel1 = lessThanEqual(src.xyz, vec3(0.5));\n"
"            f = mix(f, f1, sel1);\n"
"            sel2 = lessThanEqual(dst.xyz, vec3(0.25));\n"
"            f = mix(f, f2, sel2);\n"
"            f = mix(f, f1, sel1);\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_HUE) {\n"
"            float minbase = min(min(src.x, src.y), src.z);\n"
"            float maxbase = max(max(src.x, src.y), src.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(dst.x, dst.y), dst.z);\n"
"            float maxsat = max(max(dst.x, dst.y), dst.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (src.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_SATURATION) {\n"
"            float minbase = min(min(dst.x, dst.y), dst.z);\n"
"            float maxbase = max(max(dst.x, dst.y), dst.z);\n"
"            float sbase = maxbase - minbase;\n"
"            float minsat = min(min(src.x, src.y), src.z);\n"
"            float maxsat = max(max(src.x, src.y), src.z);\n"
"            float ssat = maxsat - minsat;\n"
"            vec3 sret;\n"
"            if (sbase > 0.0)\n"
"            { sret = (dst.xyz - vec3(minbase))* vec3(ssat) / vec3(sbase); }\n"
"            else \n"
"            { sret = vec3(0.0); } \n"
"            float lbase = sret.x * 0.30 + sret.y * 0.59 + sret.z * 0.11;\n"
"            float llum = dst.x * 0.30 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = sret.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_COLOR) {\n"
"            float lbase = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;\n"
"            float llum = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = src.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       } else if (blend_enable_mode.y == gcvLAYOUT_QUALIFIER_BLEND_SUPPORT_HSL_LUMINOSITY) {\n"
"            float lbase = dst.x * 0.3 + dst.y * 0.59 + dst.z * 0.11;\n"
"            float llum = src.x * 0.3 + src.y * 0.59 + src.z * 0.11;;\n"
"            float ldiff = llum - lbase;\n"
"            vec3 f = dst.xyz + vec3(ldiff);\n"
"            float minv3 = min(min(f.x, f.y), f.z);\n"
"            float maxv3 = max(max(f.x, f.y), f.z);\n"
"            if (minv3 < 0.0)\n"
"            { f = llum + ((f - llum)*llum) / (llum != minv3 ? (llum - minv3) : 1.0); }\n"
"            else if (maxv3 > 1.0)\n"
"            { f = llum + ((f - llum)*(1.0 - llum)) / (maxv3 != llum ? (maxv3 - llum) : 1.0); }\n"
"            else \n"
"            { f = f; }\n"
"            result.xyz = f * vec3(p0) + src.xyz * vec3(p1) + dst.xyz * vec3(p2);\n"
"            result.w = p0 + p1 + p2;\n"
"       }\n"
"    }\n"
"    return result;\n"
"}\n"
"\n";

static gctSTRING gcLib_3instMixFunc =
NL
NL "float _viv_mix_float(float x, float y, float a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec2 _viv_mix_vec2(vec2 x, vec2 y, float a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec3 _viv_mix_vec3(vec3 x, vec3 y, float a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec4 _viv_mix_vec4(vec4 x, vec4 y, float a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec2 _viv_mix_vec2_vec2(vec2 x, vec2 y, vec2 a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec3 _viv_mix_vec3_vec3(vec3 x, vec3 y, vec3 a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL
NL "vec4 _viv_mix_vec4_vec4(vec4 x, vec4 y, vec4 a)"
NL "{"
NL "    return x * (1.0 - a) + y * a;"
NL "}"
NL ;

static gctSTRING gcLib_2instMixFunc =
NL
NL "float _viv_mix_float(float x, float y, float a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec2 _viv_mix_vec2(vec2 x, vec2 y, float a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec3 _viv_mix_vec3(vec3 x, vec3 y, float a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec4 _viv_mix_vec4(vec4 x, vec4 y, float a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec2 _viv_mix_vec2_vec2(vec2 x, vec2 y, vec2 a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec3 _viv_mix_vec3_vec3(vec3 x, vec3 y, vec3 a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL
NL "vec4 _viv_mix_vec4_vec4(vec4 x, vec4 y, vec4 a)"
NL "{"
NL "    return (y - x) * a + x;"
NL "}"
NL ;

static gctSTRING gcLibCommon_Func =
NL "float _viv_round(float x)"
NL "{"
NL "    /* sign(x) * floor((abs(x) + 0.5)) */"
NL "    float sgn = sign(x);"
NL "    float tmp0, tmp1, tmp2;"
NL "    _viv_asm(ABS, tmp0, x);"
NL "    _viv_asm(ADD!<rnd:RTZ>, tmp1, tmp0, 0.5);"
NL "    _viv_asm(FLOOR, tmp2, tmp1);"
NL "    return sgn * tmp2;"
NL "}"
NL
NL "vec2 _viv_round_vec2(vec2 x)"
NL "{"
NL "    /* sign(x) * floor((abs(x) + 0.5)) */"
NL "    vec2 sgn = sign(x);"
NL "    vec2 tmp0, tmp1, tmp2;"
NL "    _viv_asm(ABS, tmp0, x);"
NL "    _viv_asm(ADD!<rnd:RTZ>, tmp1, tmp0, 0.5);"
NL "    _viv_asm(FLOOR, tmp2, tmp1);"
NL "    return sgn * tmp2;"
NL "}"
NL
NL "vec3 _viv_round_vec3(vec3 x)"
NL "{"
NL "    /* sign(x) * floor((abs(x) + 0.5)) */"
NL "    vec3 sgn = sign(x);"
NL "    vec3 tmp0, tmp1, tmp2;"
NL "    _viv_asm(ABS, tmp0, x);"
NL "    _viv_asm(ADD!<rnd:RTZ>, tmp1, tmp0, 0.5);"
NL "    _viv_asm(FLOOR, tmp2, tmp1);"
NL "    return sgn * tmp2;"
NL "}"
NL
NL "vec4 _viv_round_vec4(vec4 x)"
NL "{"
NL "    /* sign(x) * floor((abs(x) + 0.5)) */"
NL "    vec4 sgn = sign(x);"
NL "    vec4 tmp0, tmp1, tmp2;"
NL "    _viv_asm(ABS, tmp0, x);"
NL "    _viv_asm(ADD!<rnd:RTZ>, tmp1, tmp0, 0.5);"
NL "    _viv_asm(FLOOR, tmp2, tmp1);"
NL "    return sgn * tmp2;"
NL "}"
NL
NL "float _viv_roundEven(float x)"
NL "{"
NL "    const float epsilon = 0.0000001;"
NL "    float fraction;"
NL "    float integerPart;"
NL "    highp float absVal = abs(x);"
NL "    fraction = _viv_modf_1(absVal, integerPart);"
NL "    if (fraction == 0.5)"
NL "    {"
NL "        /* half way */;"
NL "        float sgn = sign(x);"
NL "        if (mod(integerPart, 2.0) < epsilon)"
NL "        {"
NL "            return sgn*integerPart;"
NL "        }"
NL "        else {"
NL "            return sgn*(integerPart + 1.0);"
NL "        }"
NL "    }"
NL "    else {"
NL "        return _viv_round(x);"
NL "    }"
NL "}"
NL
NL "vec2 _viv_roundEven_vec2(vec2 x)"
NL "{"
NL "    vec2 tmp0;"
NL "    tmp0.x = _viv_roundEven(x.x);"
NL "    tmp0.y = _viv_roundEven(x.y);"
NL "    return tmp0;"
NL "}"
NL
NL "vec3 _viv_roundEven_vec3(vec3 x)"
NL "{"
NL "    vec3 tmp0;"
NL "    tmp0.x = _viv_roundEven(x.x);"
NL "    tmp0.y = _viv_roundEven(x.y);"
NL "    tmp0.z = _viv_roundEven(x.z);"
NL "    return tmp0;"
NL "}"
NL
NL "vec4 _viv_roundEven_vec4(vec4 x)"
NL "{"
NL "    vec4 tmp0;"
NL "    tmp0.x = _viv_roundEven(x.x);"
NL "    tmp0.y = _viv_roundEven(x.y);"
NL "    tmp0.z = _viv_roundEven(x.z);"
NL "    tmp0.w = _viv_roundEven(x.w);"
NL "    return tmp0;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateCommon =
NL "#define INTERPOLATE_AT_CENTROID                            0"
NL "#define INTERPOLATE_AT_SAMPLE                              1"
NL "#define INTERPOLATE_AT_CENTER                              2"
NL "bool _viv_calculate_sample_mask(uint sampleMaskIn, vec4 sampleLocation[4], out vec4 newLocation)"
NL "{"
NL "    newLocation = vec4(0.0);"
NL "    ivec4 mask = ivec4(0);"
NL "    int count = 0;"
NL "    if ((sampleMaskIn & 0x1u) != 0u) mask.x = 1;"
NL "    if ((sampleMaskIn & 0x2u) != 0u) mask.y = 1;"
NL "    if ((sampleMaskIn & 0x4u) != 0u) mask.z = 1;"
NL "    if ((sampleMaskIn & 0x8u) != 0u) mask.w = 1;"
NL "    if (mask.x + mask.y + mask.z + mask.w >= 3)"
NL "        return false;"
NL "    for (int i = 0; i < 4; i++)"
NL "    {"
NL "        if (mask[i] == 1)"
NL "        {"
NL "            newLocation += sampleLocation[i];"
NL "            count++;"
NL "        }"
NL "    }"
NL "    if (count == 0)"
NL "        return false;"
NL "    newLocation = newLocation / float(count);"
NL "    return true;"
NL "}"
NL
NL "vec4 _viv_GetVaryingValueAtCenter(vec4 interpolant, int interpolateType, vec4 position,"
NL "                                  bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    vec4 newInterpolant = interpolant;"
NL "    vec4 newInterpolant1 = newInterpolant * position.w;"
NL "    vec4 dsx_v = dFdx(newInterpolant1);"
NL "    vec4 dsy_v = dFdy(newInterpolant1);"
NL "    if (!multiSampleBuffer) return newInterpolant;"
NL "    if (underSampleShading || interpolateType == INTERPOLATE_AT_SAMPLE)"
NL "    {"
NL "        vec4 newSampleLocation = sampleLocation[sampleId];"
NL "        newInterpolant1 += dsx_v * (0.5 - newSampleLocation.x) + dsy_v * (0.5 - newSampleLocation.y);"
NL "        newInterpolant = newInterpolant1 / position.w;"
NL "    }"
NL "    return newInterpolant;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtCentroid_float =
NL "float _viv_interpolateAtCentroid_float(float interpolant,"
NL "                                       int interpolateType, vec4 position,"
NL "                                       bool multiSampleBuffer, bool underSampleShading, int sampleId, int sampleMaskIn, vec4 sampleLocation[4])"
NL "{"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).x;"
NL "    uint maskin = uint(sampleMaskIn);"
NL "    vec4 newSampleLocation = vec4(0.0);"
NL "    float newInterpolant = interpolant;"
NL "    float newInterpolant1 = newInterpolant * position.w;"
NL "    float dsx_v = dFdx(newInterpolant1);"
NL "    float dsy_v = dFdy(newInterpolant1);"
NL "    if (_viv_calculate_sample_mask(maskin, sampleLocation, newSampleLocation))"
NL "    {"
NL "        newInterpolant1 += dsx_v * (newSampleLocation.x - 0.5) + dsy_v * (newSampleLocation.y - 0.5);"
NL "        newInterpolant = newInterpolant1 / position.w;"
NL "    }"
NL "    return newInterpolant;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtCentroid_vec2 =
NL "vec2 _viv_interpolateAtCentroid_vec2(vec2 interpolant,"
NL "                                     int interpolateType, vec4 position,"
NL "                                     bool multiSampleBuffer, bool underSampleShading, int sampleId, int sampleMaskIn, vec4 sampleLocation[4])"
NL "{"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    uint maskin = uint(sampleMaskIn);"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xy;"
NL "    vec4 newSampleLocation = vec4(0.0);"
NL "    vec2 newInterpolant = interpolant;"
NL "    vec2 newInterpolant1 = newInterpolant * position.w;"
NL "    vec2 dsx_v = dFdx(newInterpolant1);"
NL "    vec2 dsy_v = dFdy(newInterpolant1);"
NL "    if (_viv_calculate_sample_mask(maskin, sampleLocation, newSampleLocation))"
NL "    {"
NL "        newInterpolant1 += dsx_v * (newSampleLocation.x - 0.5) + dsy_v * (newSampleLocation.y - 0.5);"
NL "        newInterpolant = newInterpolant1 / position.w;"
NL "    }"
NL "    return newInterpolant;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtCentroid_vec3 =
NL "vec3 _viv_interpolateAtCentroid_vec3(vec3 interpolant,"
NL "                                     int interpolateType, vec4 position,"
NL "                                     bool multiSampleBuffer, bool underSampleShading, int sampleId, int sampleMaskIn, vec4 sampleLocation[4])"
NL "{"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xyz;"
NL "    uint maskin = uint(sampleMaskIn);"
NL "    vec4 newSampleLocation = vec4(0.0);"
NL "    vec3 newInterpolant = interpolant;"
NL "    vec3 newInterpolant1 = newInterpolant * position.w;"
NL "    vec3 dsx_v = dFdx(newInterpolant1);"
NL "    vec3 dsy_v = dFdy(newInterpolant1);"
NL "    if (_viv_calculate_sample_mask(maskin, sampleLocation, newSampleLocation))"
NL "    {"
NL "        newInterpolant1 += dsx_v * (newSampleLocation.x - 0.5) + dsy_v * (newSampleLocation.y - 0.5);"
NL "        newInterpolant = newInterpolant1 / position.w;"
NL "    }"
NL "    return newInterpolant;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtCentroid_vec4 =
NL "vec4 _viv_interpolateAtCentroid_vec4(vec4 interpolant,"
NL "                                     int interpolateType, vec4 position,"
NL "                                     bool multiSampleBuffer, bool underSampleShading, int sampleId, int sampleMaskIn, vec4 sampleLocation[4])"
NL "{"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(interpolant, interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation);"
NL "    uint maskin = uint(sampleMaskIn);"
NL "    vec4 newSampleLocation = vec4(0.0);"
NL "    vec4 newInterpolant = interpolant;"
NL "    vec4 newInterpolant1 = newInterpolant * position.w;"
NL "    vec4 dsx_v = dFdx(newInterpolant1);"
NL "    vec4 dsy_v = dFdy(newInterpolant1);"
NL "    if (_viv_calculate_sample_mask(maskin, sampleLocation, newSampleLocation))"
NL "    {"
NL "        newInterpolant1 += dsx_v * (newSampleLocation.x - 0.5) + dsy_v * (newSampleLocation.y - 0.5);"
NL "        newInterpolant = newInterpolant1 / position.w;"
NL "    }"
NL "    return newInterpolant;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtSample_float =
NL "float _viv_interpolateAtSample_float(float interpolant, int sampleIndex,"
NL "                                     int interpolateType,"
NL "                                     vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    if (sampleIndex > 3) return interpolant;"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).x;"
NL "    vec4 newSampleLocation = sampleLocation[sampleIndex];"
NL "    float newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * (newSampleLocation.x - 0.5) + dFdy(newInterpolant) * (newSampleLocation.y - 0.5);"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtSample_vec2 =
NL "vec2 _viv_interpolateAtSample_vec2(vec2 interpolant, int sampleIndex,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    if (sampleIndex > 3) return interpolant;"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xy;"
NL "    vec4 newSampleLocation = sampleLocation[sampleIndex];"
NL "    vec2 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * (newSampleLocation.x - 0.5) + dFdy(newInterpolant) * (newSampleLocation.y - 0.5);"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtSample_vec3 =
NL "vec3 _viv_interpolateAtSample_vec3(vec3 interpolant, int sampleIndex,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"

NL "    if (sampleIndex > 3) return interpolant;"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xyz;"
NL "    vec4 newSampleLocation = sampleLocation[sampleIndex];"
NL "    vec3 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * (newSampleLocation.x - 0.5) + dFdy(newInterpolant) * (newSampleLocation.y - 0.5);"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtSample_vec4 =
NL "vec4 _viv_interpolateAtSample_vec4(vec4 interpolant, int sampleIndex,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    if (sampleIndex > 3) return interpolant;"
NL "    if (!multiSampleBuffer) return interpolant;"
NL "    interpolant = _viv_GetVaryingValueAtCenter(interpolant, interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation);"
NL "    vec4 newSampleLocation = sampleLocation[sampleIndex];"
NL "    vec4 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * (newSampleLocation.x - 0.5) + dFdy(newInterpolant) * (newSampleLocation.y - 0.5);"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtOffset_float =
NL "float _viv_interpolateAtOffset_float(float interpolant, vec2 offset,"
NL "                                     int interpolateType,"
NL "                                     vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).x;"
NL "    float newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * offset.x + dFdy(newInterpolant) * offset.y;"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtOffset_vec2 =
NL "vec2 _viv_interpolateAtOffset_vec2(vec2 interpolant, vec2 offset,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xy;"
NL "    vec2 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * offset.x + dFdy(newInterpolant) * offset.y;"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtOffset_vec3 =
NL "vec3 _viv_interpolateAtOffset_vec3(vec3 interpolant, vec2 offset,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    interpolant = _viv_GetVaryingValueAtCenter(vec4(interpolant, 0.0), interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation).xyz;"
NL "    vec3 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * offset.x + dFdy(newInterpolant) * offset.y;"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

static gctSTRING gcLibInterpolateAtOffset_vec4 =
NL "vec4 _viv_interpolateAtOffset_vec4(vec4 interpolant,vec2 offset,"
NL "                                   int interpolateType,"
NL "                                   vec4 position, bool multiSampleBuffer, bool underSampleShading, int sampleId, vec4 sampleLocation[4])"
NL "{"
NL "    interpolant = _viv_GetVaryingValueAtCenter(interpolant, interpolateType, position, multiSampleBuffer, underSampleShading, sampleId, sampleLocation);"
NL "    vec4 newInterpolant = interpolant * position.w;"
NL "    newInterpolant += dFdx(newInterpolant) * offset.x + dFdy(newInterpolant) * offset.y;"
NL "    return newInterpolant / position.w;"
NL "}"
NL ;

#undef NL
#endif /* __gc_vsc_gl_builtin_lib_h_ */

