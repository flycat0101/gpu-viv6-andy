/****************************************************************************
*
*    Copyright (c) 2005 - 2019 by Vivante Corp.  All rights reserved.
*
*    The material in this file is confidential and contains trade secrets
*    of Vivante Corporation. This is proprietary information owned by
*    Vivante Corporation. No part of this work may be disclosed,
*    reproduced, copied, transmitted, or used in any way for any purpose,
*    without the express written permission of Vivante Corporation.
*
*****************************************************************************/


#include "gc_vk_precomp.h"


VkResult __vk_FenceStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkFence *fce = (__vkFence *)obj;

    return VK_SUCCESS;
}

VkResult __vk_SemaphoreStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkSemaphore *sph = (__vkSemaphore *)obj;

    return VK_SUCCESS;
}

VkResult __vk_EventStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkEvent *evt = (__vkEvent *)obj;

    return VK_SUCCESS;
}

VkResult __vk_QueryPoolStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkQueryPool *qyp = (__vkQueryPool *)obj;

    return VK_SUCCESS;
}

VkResult __vk_BufferStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkBuffer *bfr = (__vkBuffer *)obj;

    return VK_SUCCESS;
}

VkResult __vk_BufferViewStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkBufferView *bfv = (__vkBufferView *)obj;

    return VK_SUCCESS;
}

VkResult __vk_ImageStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkImage *img = (__vkImage *)obj;

    return VK_SUCCESS;
}

VkResult __vk_ImageViewStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkImageView *imv = (__vkImageView *)obj;

    return VK_SUCCESS;
}

VkResult __vk_AttachmentViewStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkAttachmentView *atv = (__vkAttachmentView *)obj;

    return VK_SUCCESS;
}

VkResult __vk_PipelineCacheStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkPipelineCache *pch = (__vkPipelineCache *)obj;

    return VK_SUCCESS;
}

VkResult __vk_PipelinesStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkPipeline *pip = (__vkPipeline *)obj;

    return VK_SUCCESS;
}

VkResult __vk_PipelineLayoutStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkPipelineLayout *plt = (__vkPipelineLayout *)obj;

    return VK_SUCCESS;
}

VkResult __vk_SamplerStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkSampler *spl = (__vkSampler *)obj;

    return VK_SUCCESS;
}

VkResult __vk_DescriptorSetStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
    return VK_SUCCESS;
}

VkResult __vk_DescriptorSetLayoutStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkDescriptorSetLayout *dsl = (__vkDescriptorSetLayout *)obj;

    return VK_SUCCESS;
}

VkResult __vk_DescriptorPoolStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkDescriptorPool *dsp = (__vkDescriptorPool *)obj;

    return VK_SUCCESS;
}

VkResult __vk_ShaderModuleStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkShaderModule *shm = (__vkShaderModule *)obj;

    return VK_SUCCESS;
}

VkResult __vk_DynamicViewportStateStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkDynamicViewportState *dvs = (__vkDynamicViewportState *)obj;

    return VK_SUCCESS;
}

VkResult __vk_DynamicRasterStateStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkDynamicRasterState *drs = (__vkDynamicRasterState *)obj;

    return VK_SUCCESS;
}

VkResult __vk_DynamicColorBlendStateStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkDynamicColorBlendState *cbs = (__vkDynamicColorBlendState *)obj;

    return VK_SUCCESS;
}

VkResult __vk_DynamicDepthStencilStateStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkDynamicDepthStencilState *dss = (__vkDynamicDepthStencilState *)obj;

    return VK_SUCCESS;
}

VkResult __vk_FrameBufferStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkFramebuffer *fbs = (__vkFramebuffer *)obj;

    return VK_SUCCESS;
}

VkResult __vk_RenderPassStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkRenderPass *rdp = (__vkRenderPass *)obj;

    return VK_SUCCESS;
}

VkResult __vk_CommandPoolStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
    return VK_SUCCESS;
}

VkResult __vk_CommandBufferStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{

    return VK_SUCCESS;
}

VkResult __vk_DeviceMemoryStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkDeviceMemory *dvm = (__vkDeviceMemory *)obj;

    return VK_SUCCESS;
}

VkResult __vk_SwapchainKHRStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkSwapchainKHR *swap = (__vkSwapchainKHR *)obj;

    return VK_SUCCESS;
}

VkResult __vk_SurfaceKHRStatFunc(__vkDevContext *devCtx, __vkObject *obj, int32_t flag)
{
//    __vkSurfaceKHR *swap = (__vkSurfaceKHR *)obj;

    return VK_SUCCESS;
}

/* __vkObjectStatFuncTable[] must have the same order as __vkObjectIndex */

PFN_ObjectStatFunc __vkObjectStatFuncTable[] = {
    __vk_FenceStatFunc, /* __VK_OBJECT_FENCE */
    __vk_SemaphoreStatFunc, /* __VK_OBJECT_SEMAPHORE */
    __vk_EventStatFunc, /* __VK_OBJECT_EVENT */
    __vk_QueryPoolStatFunc, /* __VK_OBJECT_QUERY_POOL */
    __vk_BufferStatFunc, /* __VK_OBJECT_BUFFER */
    __vk_BufferViewStatFunc, /* __VK_OBJECT_BUFFER_VIEW */
    __vk_ImageStatFunc, /* __VK_OBJECT_IMAGE */
    __vk_ImageViewStatFunc, /* __VK_OBJECT_IMAGE_VIEW */
    __vk_ShaderModuleStatFunc, /* __VK_OBJECT_SHADER_MODULE */
    __vk_PipelineCacheStatFunc, /* __VK_OBJECT_PIPELINE_CACHE */
    __vk_PipelinesStatFunc, /* __VK_OBJECT_PIPELINES */
    __vk_PipelineLayoutStatFunc, /* __VK_OBJECT_PIPELINE_LAYOUT */
    __vk_SamplerStatFunc, /* __VK_OBJECT_SAMPLER */
    __vk_DescriptorSetStatFunc, /* __VK_OBJECT_DESCRIPTORSET */
    __vk_DescriptorSetLayoutStatFunc, /* __VK_OBJECT_DESCRIPTORSET_LAYOUT */
    __vk_DescriptorPoolStatFunc, /* __VK_OBJECT_DESCRIPTOR_POOL */
    __vk_FrameBufferStatFunc, /* __VK_OBJECT_FRAMEBUFFER */
    __vk_RenderPassStatFunc, /* __VK_OBJECT_RENDER_PASS */
    __vk_CommandPoolStatFunc, /* __VK_OBJECT_COMMAND_POOL */
    __vk_CommandBufferStatFunc, /* __VK_OBJECT_COMMAND_BUFFER */
    __vk_DeviceMemoryStatFunc, /* __VK_OBJECT_DEVICE_MEMORY */
    __vk_SwapchainKHRStatFunc, /* __VK_OBJECT_SWAPCHAIN_KHR */
    __vk_SurfaceKHRStatFunc, /* __VK_OBJECT_SURFACE_KHR */
};

char *__vkObjectNames[] = {
    "VK_OBJECT_FENCE", /* __VK_OBJECT_FENCE */
    "VK_OBJECT_SEMAPHORE", /* __VK_OBJECT_SEMAPHORE */
    "VK_OBJECT_EVENT", /* __VK_OBJECT_EVENT */
    "VK_OBJECT_QUERY_POOL", /* __VK_OBJECT_QUERY_POOL */
    "VK_OBJECT_BUFFER", /* __VK_OBJECT_BUFFER */
    "VK_OBJECT_BUFFER_VIEW", /* __VK_OBJECT_BUFFER_VIEW */
    "VK_OBJECT_IMAGE", /* __VK_OBJECT_IMAGE */
    "VK_OBJECT_IMAGE_VIEW", /* __VK_OBJECT_IMAGE_VIEW */
    "VK_OBJECT_SHADER_MODULE", /* __VK_OBJECT_SHADER_MODULE */
    "VK_OBJECT_PIPELINE_CACHE", /* __VK_OBJECT_PIPELINE_CACHE */
    "VK_OBJECT_PIPELINES", /* __VK_OBJECT_PIPELINES */
    "VK_OBJECT_PIPELINE_LAYOUT", /* __VK_OBJECT_PIPELINE_LAYOUT */
    "VK_OBJECT_SAMPLER", /* __VK_OBJECT_SAMPLER */
    "VK_OBJECT_DESCRIPTORSET", /* __VK_OBJECT_DESCRIPTORSET */
    "VK_OBJECT_DESCRIPTORSET_LAYOUT", /* __VK_OBJECT_DESCRIPTORSET_LAYOUT */
    "VK_OBJECT_DESCRIPTOR_POOL", /* __VK_OBJECT_DESCRIPTOR_POOL */
    "VK_OBJECT_FRAMEBUFFER", /* __VK_OBJECT_FRAMEBUFFER */
    "VK_OBJECT_RENDER_PASS", /* __VK_OBJECT_RENDER_PASS */
    "VK_OBJECT_COMMAND_POOL", /* __VK_OBJECT_COMMAND_POOL */
    "VK_OBJECT_COMMAND_BUFFER", /* __VK_OBJECT_COMMAND_BUFFER */
    "VK_OBJECT_DEVICE_MEMORY", /* __VK_OBJECT_DEVICE_MEMORY */
    "VK_OBJECT_SWAPCHAIN_KHR"               /* __VK_OBJECT_SWAPCHAIN_KHR */
    "VK_OBJECT_SURFACE_KHR"                 /* __VK_OBJECT_SURFACE_KHR */
};

VkResult __vk_CreateObject(
    __vkDevContext *devCtx,
    __vkObjectIndex index,
    uint32_t size,
    __vkObject **pObject
    )
{
    __vkObject *obj;

    __VK_SET_ALLOCATIONCB(&devCtx->memCb);

    /* Allocate memory for a VK object */
    obj = (__vkObject *)__VK_ALLOC(size, 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
    if (!obj)
    {
        return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
    __VK_MEMZERO(obj, size);

    set_loader_magic_value(obj);

    obj->sType = __VK_OBJECT_INDEX_TO_TYPE(index);
    obj->pDevContext = devCtx;

#if __VK_RESOURCE_INFO
    gcoOS_AtomIncrement(gcvNULL, devCtx->atom_id, &obj->id);
#endif

    /* Return the pointer to object */
    *pObject = obj;

    return VK_SUCCESS;
}

VkResult __vk_DestroyObject(
    __vkDevContext *devCtx,
    __vkObjectIndex index,
    __vkObject *obj
    )
{
    __VK_SET_ALLOCATIONCB(&devCtx->memCb);

    /* Free the object */
    if (obj)
    {
        __VK_FREE(obj);
    }

    return VK_SUCCESS;
}

VkResult __vk_InitObjectLists(
    VkDevice device
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    uint32_t i;

    /* Initialize devCtx->vkObject[i] */
    for (i = 0; i < __VK_DEV_OBJECT_COUNT; i++)
    {
        devCtx->vkObject[i].objectStatFunc = __vkObjectStatFuncTable[i];

        gcoOS_CreateMutex(gcvNULL, &devCtx->vkObject[i].objMutex);
    }

    return VK_SUCCESS;
}

VkResult __vk_FiniObjectLists(
    __vkDevContext *devCtx
    )
{
    __vkObjectList *list;
    __vkObject *obj;
    uint32_t i;

    __VK_SET_ALLOCATIONCB(&devCtx->memCb);

    /* Final check on devCtx->vkObject[i] lists */
    for (i = 0; i < __VK_DEV_OBJECT_COUNT; i++)
    {
        list = &devCtx->vkObject[i];

        /* Lock down the linked list */
        gcoOS_AcquireMutex(gcvNULL, list->objMutex, gcvINFINITE);

        obj = list->objList;
        while (obj)
        {
            __VK_DEBUG_PRINT(0, "%s Leak :: %p,", __vkObjectNames[i], obj);
            (*list->objectStatFunc)(devCtx, obj, -1);
            list->objList = obj->pNext;
            __VK_FREE(obj);
            obj = list->objList;
        }

        /* Release the linked list */
        gcoOS_ReleaseMutex(gcvNULL, list->objMutex);
    }

    return VK_SUCCESS;
}

VkResult __vk_InsertObject(
    __vkDevContext *devCtx,
    __vkObjectIndex index,
    __vkObject *obj
    )
{
    __vkObjectList *list = &devCtx->vkObject[index];

    /* Lock down the linked list */
    gcoOS_AcquireMutex(gcvNULL, list->objMutex, gcvINFINITE);

    /* Insert obj to the beginning of the linked list */
    if (obj)
    {
        (*list->objectStatFunc)(devCtx, obj, 1);

        obj->pNext = list->objList;
        list->objList = obj;
    }

    /* Release the linked list */
    gcoOS_ReleaseMutex(gcvNULL, list->objMutex);

    return VK_SUCCESS;
}

VkResult __vk_RemoveObject(
    __vkDevContext *devCtx,
    __vkObjectIndex index,
    __vkObject *obj
    )
{
    __vkObjectList *list = &devCtx->vkObject[index];
    __vkObject *tmpobj, *preobj;

    if (list->objList == gcvNULL)
        return VK_SUCCESS;

    /* Lock down the linked list */
    gcoOS_AcquireMutex(gcvNULL, list->objMutex, gcvINFINITE);

    /* Remove obj from the linked list */
    preobj = tmpobj = list->objList;
    while (tmpobj != obj && tmpobj->pNext)
    {
        preobj = tmpobj;
        tmpobj = tmpobj->pNext;
    }
    if (tmpobj == obj)
    {
        (*list->objectStatFunc)(devCtx, obj, -1);

        if (obj == list->objList)
        {
            list->objList = tmpobj->pNext;
        }
        else
        {
            preobj->pNext = tmpobj->pNext;
        }
    }

    /* Release the linked list */
    gcoOS_ReleaseMutex(gcvNULL, list->objMutex);

    return VK_SUCCESS;
}



