/****************************************************************************
*
*    Copyright (c) 2005 - 2016 by Vivante Corp.  All rights reserved.
*
*    The material in this file is confidential and contains trade secrets
*    of Vivante Corporation. This is proprietary information owned by
*    Vivante Corporation. No part of this work may be disclosed,
*    reproduced, copied, transmitted, or used in any way for any purpose,
*    without the express written permission of Vivante Corporation.
*
*****************************************************************************/


#include "gc_vk_precomp.h"

/* TS may have issue that in different command buffer, use same surface, we need a way to work out.
   Disalbe for now
*/
static VkBool32 g_dbgNoTS = VK_TRUE;

__vkFormatInfo g_vkFormatInfoTable[] =
{
    /*      VK_FORMAT_UNDEFINED                 */
    {__VK_FMT_CATEGORY_MAX, VK_FALSE, { 1, 1}, 0, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*      VK_FORMAT_R4G4_UNORM_PACK8          */
    {__VK_FMT_CATEGORY_MAX, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*      VK_FORMAT_R4G4B4A4_UNORM_PACK16     */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, __VK_FORMAT_A4R4G4B4_UNFORM_PACK16,
    {0, 0, 0}},
    /*      VK_FORMAT_B4G4R4A4_UNORM_PACK16     */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, __VK_FORMAT_A4R4G4B4_UNFORM_PACK16,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*     VK_FORMAT_R5G6B5_UNORM_PACK16       */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R5G6B5_UNORM_PACK16,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     0}},
     /*     VK_FORMAT_B5G6R5_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R5G6B5_UNORM_PACK16,
    {0, 0, 0}},
    /*      VK_FORMAT_R5G5B5A1_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*     VK_FORMAT_B5G5R5A1_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    {0, 0, 0}},
    /*     VK_FORMAT_A1R5G5B5_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     0}},
     /*     VK_FORMAT_R8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_R8_UNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_R8_SNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_UNDEFINED,
    {0, 0, __VK_FORMAT_VERTEX_FEATURES}},
    /*     VK_FORMAT_R8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_UNDEFINED,
    {0, 0, __VK_FORMAT_VERTEX_FEATURES}},
    /*     VK_FORMAT_R8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_R8_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_R8_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8_SRGB, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_R8_SRGB,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R8G8_UNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R8G8_SNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0, 0, __VK_FORMAT_VERTEX_FEATURES}},
    /*     VK_FORMAT_R8G8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0, 0, __VK_FORMAT_VERTEX_FEATURES}},
    /*     VK_FORMAT_R8G8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R8G8_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES   | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES   | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R8G8_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES   | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES   | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8_SRGB, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R8G8_SRGB,
    {0, 0, 0}},
    /*      VK_FORMAT_R8G8B8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_SRGB, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_SRGB, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_R8G8B8A8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_UNORM,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8B8A8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R8G8B8A8_SNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8B8A8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_R8G8B8A8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*     VK_FORMAT_R8G8B8A8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R8G8B8A8_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8B8A8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R8G8B8A8_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8B8A8_SRGB, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_SRGB,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     0}},
    /*    VK_FORMAT_B8G8R8A8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_UNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_B8G8R8A8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_SNORM,
    {0, 0, 0}},
    /*    VK_FORMAT_B8G8R8A8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_B8G8R8A8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_B8G8R8A8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R8G8B8A8_UINT,
    {0, 0, 0}},
    /*    VK_FORMAT_B8G8R8A8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R8G8B8A8_SINT,
    {0, 0,0}},
    /*    VK_FORMAT_B8G8R8A8_SRGB, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_SRGB,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     0}},
     /*    VK_FORMAT_A8B8G8R8_UNORM_PACK32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_UNORM,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A8B8G8R8_SNORM_PACK32, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A8B8G8R8_SNORM_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A8B8G8R8_USCALED_PACK32, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A8B8G8R8_SSCALED_PACK32, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A8B8G8R8_UINT_PACK32, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A8B8G8R8_UINT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A8B8G8R8_SINT_PACK32, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A8B8G8R8_SINT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A8B8G8R8_SRGB_PACK32, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_SRGB,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     0}},
     /*    VK_FORMAT_A2R10G10B10_UNORM_PACK32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A2B10G10R10_UNORM_PACK32,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    VK_FORMAT_A2R10G10B10_SNORM_PACK32, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2R10G10B10_USCALED_PACK32, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2R10G10B10_SSCALED_PACK32, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2R10G10B10_UINT_PACK32, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2R10G10B10_SINT_PACK32, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2B10G10R10_UNORM_PACK32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A2B10G10R10_UNORM_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A2B10G10R10_SNORM_PACK32, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2B10G10R10_USCALED_PACK32, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2B10G10R10_SSCALED_PACK32, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2B10G10R10_UINT_PACK32, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A2B10G10R10_UINT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A2B10G10R10_SINT_PACK32, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A2B10G10R10_SINT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES,
     __VK_FORMAT_VERTEX_FEATURES}},

     /*   VK_FORMAT_R16_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
     /*   VK_FORMAT_R16_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
     /*   VK_FORMAT_R16_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R16_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R16_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R16_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*   VK_FORMAT_R16_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R16_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*   VK_FORMAT_R16_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R16_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    VK_FORMAT_R16G16_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
    /*    VK_FORMAT_R16G16_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R16G16_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R16G16_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R16G16_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    VK_FORMAT_R16G16B16_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*    VK_FORMAT_R16G16B16A16_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16B16A16_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16B16A16_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16A16_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16A16_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R16G16B16A16_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16B16A16_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R16G16B16A16_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16B16A16_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R16G16B16A16_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},

    /*     VK_FORMAT_R32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R32_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R32_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R32_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R32G32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R32G32_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R32G32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R32G32_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R32G32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R32G32_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},

     /*   VK_FORMAT_R32G32B32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 96, 1, VK_FORMAT_UNDEFINED,
    {0, 0,
    __VK_FORMAT_VERTEX_FEATURES}},
     /*   VK_FORMAT_R32G32B32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 96, 1, VK_FORMAT_UNDEFINED,
    {0, 0,
    __VK_FORMAT_VERTEX_FEATURES}},
    /*   VK_FORMAT_R32G32B32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 96, 1, VK_FORMAT_UNDEFINED,
    {0, 0,
    __VK_FORMAT_VERTEX_FEATURES}},
    /*   VK_FORMAT_R32G32B32A32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 128, 1, __VK_FORMAT_R32G32B32A32_UINT_2_R32G32_UINT,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*   VK_FORMAT_R32G32B32A32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 128, 1, __VK_FORMAT_R32G32B32A32_SINT_2_R32G32_SINT,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*   VK_FORMAT_R32G32B32A32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 128, 1, __VK_FORMAT_R32G32B32A32_SFLOAT_2_R32G32_SFLOAT,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},

    /*   VK_FORMAT_R64_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},

    /*   VK_FORMAT_R64G64B64_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 192, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64B64_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 192, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64B64_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 192, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},

    /*   VK_FORMAT_R64G64B64A64_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 256, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64B64A64_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 256, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64B64A64_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 256, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},

    /*   VK_FORMAT_B10G11R11_UFLOAT_PACK32, */
    {__VK_FMT_CATEGORY_UFLOAT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B10G11R11_UFLOAT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES}},
     /*   VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, */
    {__VK_FMT_CATEGORY_UFLOAT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},

    /*   VK_FORMAT_D16_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_D16_UNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_DEPTH_FEATURES,
     0}},
     /*   VK_FORMAT_X8_D24_UNORM_PACK32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, __VK_FORMAT_D24_UNORM_X8_PACKED32,
    {0,
     __VK_FORMAT_DEPTH_FEATURES,
     0}},
     /*   VK_FORMAT_D32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_D32_SFLOAT,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES,
     0}},
     /*   VK_FORMAT_S8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_S8_UINT,
    {0,
     __VK_FORMAT_DEPTH_FEATURES,
     0}},
     /*   VK_FORMAT_D16_UNORM_S8_UINT, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_D24_UNORM_S8_UINT, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, __VK_FORMAT_D24_UNORM_S8_UINT_PACKED32,
    {0,
     __VK_FORMAT_DEPTH_FEATURES,
     0}},
     /*   VK_FORMAT_D32_SFLOAT_S8_UINT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},

    /*   VK_FORMAT_BC1_RGB_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC1_RGB_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC1_RGBA_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC1_RGBA_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC2_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC2_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC3_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC3_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC4_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC4_SNORM_BLOCK, */
    {__VK_FMT_CATEGORY_SNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC5_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC5_SNORM_BLOCK, */
    {__VK_FMT_CATEGORY_SNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC6H_UFLOAT_BLOCK, */
    {__VK_FMT_CATEGORY_UFLOAT, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC6H_SFLOAT_BLOCK, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC7_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC7_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},

     /*   VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
    /*   VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_EAC_R11_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_EAC_R11_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_EAC_R11_SNORM_BLOCK, */
    {__VK_FMT_CATEGORY_SNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_EAC_R11_SNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_EAC_R11G11_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_EAC_R11G11_SNORM_BLOCK, */
    {__VK_FMT_CATEGORY_SNORM, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},

    /*   VK_FORMAT_ASTC_4x4_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_4x4_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_5x4_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 5, 4}, 128, 1, VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_5x4_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 5, 4}, 128, 1, VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_5x5_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 5, 5}, 128, 1, VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_5x5_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 5, 5}, 128, 1, VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_6x5_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 6, 5}, 128, 1, VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_6x5_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 6, 5}, 128, 1, VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_6x6_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 6, 6}, 128, 1, VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
    /*   VK_FORMAT_ASTC_6x6_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 6, 6}, 128, 1, VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x5_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 8, 5}, 128, 1, VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x5_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 8, 5}, 128, 1, VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x6_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 8, 6}, 128, 1, VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x6_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 8, 6}, 128, 1, VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x8_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 8, 8}, 128, 1, VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x8_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 8, 8}, 128, 1, VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x5_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {10, 5}, 128, 1, VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x5_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {10, 5}, 128, 1, VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x6_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {10, 6}, 128, 1, VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x6_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {10, 6}, 128, 1, VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x8_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {10, 8}, 128, 1, VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
      /*   VK_FORMAT_ASTC_10x8_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {10, 8}, 128, 1, VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
    /*   VK_FORMAT_ASTC_10x10_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {10, 10}, 128, 1, VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x10_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {10, 10}, 128, 1, VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_12x10_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {12, 10}, 128, 1, VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_12x10_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {12, 10}, 128, 1, VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_12x12_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {12, 12}, 128, 1, VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
    /*   VK_FORMAT_ASTC_12x12_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {12, 12}, 128, 1, VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},

    /* internal resident formats
    */

    /*  __VK_FORMAT_R32G32B32A32_SFLOAT_2_RG32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 128, 2, __VK_FORMAT_R32G32B32A32_SFLOAT_2_R32G32_SFLOAT,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
    __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*  __VK_FORMAT_R32G32B32A32_SINT_2_RG32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 128, 2, __VK_FORMAT_R32G32B32A32_SINT_2_R32G32_SINT,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
    __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*  __VK_FORMAT_R32G32B32A32_UINT_2_RG32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 128, 2, __VK_FORMAT_R32G32B32A32_UINT_2_R32G32_UINT,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
    __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*  __VK_FORMAT_A4R4G4B4_UNFORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, __VK_FORMAT_A4R4G4B4_UNFORM_PACK16,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
    0}},
    /*  __VK_FORMAT_R8_1_X8R8G8B8, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, __VK_FORMAT_R8_1_X8R8G8B8,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     0}},
    /*  __VK_FORMAT_D24_UNORM_S8_UINT_PACKED32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, __VK_FORMAT_D24_UNORM_S8_UINT_PACKED32,
    {0,
    __VK_FORMAT_DEPTH_FEATURES,
    0}},
    /*  __VK_FORMAT_D24_UNORM_X8_PACKED32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, __VK_FORMAT_D24_UNORM_X8_PACKED32,
    {0,
    __VK_FORMAT_DEPTH_FEATURES,
    0}},
};

#if __VK_NEW_DEVICE_QUEUE
static VkResult __vki_CreateSurfNode(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node,
    uint32_t bytes,
    uint32_t alignment,
    gceSURF_TYPE surfType,
    uint32_t flag,
    gcePOOL pool
    )
{
    VkResult result = VK_SUCCESS;
    gcsHAL_INTERFACE iface;
    uint32_t i;

    __VK_MEMZERO(node, sizeof(gcsSURF_NODE));

    iface.command   = gcvHAL_ALLOCATE_LINEAR_VIDEO_MEMORY;
    iface.u.AllocateLinearVideoMemory.bytes = bytes;
    iface.u.AllocateLinearVideoMemory.alignment = alignment;
    iface.u.AllocateLinearVideoMemory.flag = flag;
    iface.u.AllocateLinearVideoMemory.pool = pool;
    iface.u.AllocateLinearVideoMemory.type = surfType;

    __VK_ONERROR(__vk_DeviceControl(&iface, 0));

    node->u.normal.node = iface.u.AllocateLinearVideoMemory.node;
    node->pool          = iface.u.AllocateLinearVideoMemory.pool;
    node->size          = iface.u.AllocateLinearVideoMemory.bytes;

    node->physical2     = ~0U;
    node->physical3     = ~0U;

    for (i = 0; i < gcvHARDWARE_NUM_TYPES; i++)
    {
        node->hardwareAddresses[i] = ~0U;
    }

    return VK_SUCCESS;

OnError:

    return result;
}

VkResult __vki_DestroySurfNode(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node
    )
{
    gcsHAL_INTERFACE iface;
    VkResult result = VK_SUCCESS;

    /* Release the allocated video memory asynchronously. */
    iface.command = gcvHAL_RELEASE_VIDEO_MEMORY;
    iface.u.ReleaseVideoMemory.node = node->u.normal.node;

    /* Call kernel HAL. */
    __VK_ONERROR(__vk_DeviceControl(&iface, 0));

    /* Reset the node. */
    node->pool  = gcvPOOL_UNKNOWN;
    node->valid = gcvFALSE;

    return VK_SUCCESS;

OnError:
    return result;
}

VkResult __vki_LockSurfNode(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node,
    gctUINT32 * devAddr,
    gctPOINTER * hostAddr
    )
{
    gceHARDWARE_TYPE type = gcvHARDWARE_3D;
    gceENGINE engine = gcvENGINE_RENDER;
    VkResult result = VK_SUCCESS;

    if (node->lockCounts[type][engine] == 0)
    {
        gcsHAL_INTERFACE iface;
        gctUINT32 handle = node->u.normal.node;
        gctBOOL cacheable = node->u.normal.cacheable;

        if (node->pool == gcvPOOL_USER)
        {
            gctUINT32 physical;

            gcmSAFECASTPHYSADDRT(physical, node->u.wrapped.physical);

            if (physical != gcvINVALID_ADDRESS)
            {
                __VK_ASSERT(devCtx->database->REG_MC20);
                gcoOS_CPUPhysicalToGPUPhysical(physical, &physical);
            }

            /*
            ** Although we want to treat user memory in the same way as video memory,
            ** user memory still has some distinguishing feature to allow some optimization.
            */
            if (handle == 0)
            {
                /*
                ** Some software access only surface has no kernel video node.
                ** Since 'physical' is only for one hardware, it can't be used by other hardware type.
                ** TODO: Remove usage of gcoSURF_WrapSurface to avoid this path.
                */
                gcmASSERT(node->logical != gcvNULL);
                node->hardwareAddresses[type] = physical + (gctUINT32)node->bufferOffset;
            }
            else if ((physical >= devCtx->chipInfo->flatMappingStart)
                  && (physical < devCtx->chipInfo->flatMappingEnd))
            {
                /*
                ** If physical address is in flat mapping range of current hardware,
                ** use physical address as hardware address instead of lock in kernel.
                */
                node->hardwareAddresses[type] = physical + (gctUINT32) node->bufferOffset;

                handle = 0;

                /* TODO: Use reference count of each type as valid flag. */
                node->valid = gcvTRUE;
            }

            node->u.wrapped.lockedInKernel[type] = handle ? gcvTRUE : gcvFALSE;
            cacheable = gcvFALSE;
        }

        if (handle)
        {
            /* Fill in the kernel call structure. */
            iface.engine = engine;
            iface.command = gcvHAL_LOCK_VIDEO_MEMORY;
            iface.u.LockVideoMemory.node = handle;
            iface.u.LockVideoMemory.cacheable = cacheable;
            __VK_ONERROR(__vk_DeviceControl(&iface, 0));

            /* Validate the node. */
            node->valid = gcvTRUE;

            /* VIV: This flag is needed by bg2ct specific patch, if it is not set
            ** all cache function is skipped. */
            if (node->pool != gcvPOOL_USER)
            {
                node->lockedInKernel = gcvTRUE;
            }

            /* Store hardware address. */
            node->hardwareAddresses[type] = iface.u.LockVideoMemory.address + (gctUINT32)node->bufferOffset;
            /* Store logical address. */
            node->logical = gcmUINT64_TO_PTR(iface.u.LockVideoMemory.memory + node->bufferOffset);
        }
    }

    /* Increment the lock count per hardware type. */
    node->lockCounts[type][engine]++;

    /* Set the result. */
    if (devAddr != gcvNULL)
    {
        *devAddr = node->hardwareAddresses[type];
    }

    if (hostAddr != gcvNULL)
    {
        *hostAddr = node->logical;
    }

OnError:
    return result;
}


VkResult __vki_UnlockSurfNode(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node
    )
{
    gceENGINE engine = gcvENGINE_RENDER;
    gceSURF_TYPE surfType = gcvSURF_TYPE_UNKNOWN;
    gceHARDWARE_TYPE type = gcvHARDWARE_3D;
    VkResult result = VK_SUCCESS;

    gcsHAL_INTERFACE iface;

    /* Verify whether the node is valid. */
    if (node->lockCounts[type][engine] <= 0)
    {
        __VK_PRINT("__vki_UnlockSurfNode: node=0x%x; unlock called on an unlocked surface.", node);
    }
    /* Locked more then once? */
    else
    {
        node->lockCounts[type][engine]--;

        if (node->lockCounts[type][engine] == 0)
        {
            gctUINT32 handle = node->u.normal.node;

            if ((node->pool == gcvPOOL_USER)
             && (node->u.wrapped.lockedInKernel[type] == gcvFALSE)
            )
            {
                handle = 0;
            }

            if (handle)
            {
#if gcdDUMP
                uint32_t gpuVirtual = node->hardwareAddresses[type];
                gcmDUMP(gcvNULL, "#[unlock 0x%08x]", gpuVirtual);
#endif

                /* Unlock the video memory node. */
                iface.engine = engine;
                iface.command = gcvHAL_UNLOCK_VIDEO_MEMORY;
                iface.u.UnlockVideoMemory.node = handle;
                iface.u.UnlockVideoMemory.type = surfType & ~gcvSURF_NO_VIDMEM;
                /* Call the kernel. */
                __VK_ONERROR(__vk_DeviceControl(&iface, 0));

                iface.command = gcvHAL_BOTTOM_HALF_UNLOCK_VIDEO_MEMORY;
                iface.u.BottomHalfUnlockVideoMemory.node = handle;
                iface.u.BottomHalfUnlockVideoMemory.type = surfType & ~gcvSURF_NO_VIDMEM;
                /* Call the kernel. */
                __VK_ONERROR(__vk_DeviceControl(&iface, 0));
            }
        }
    }

    return VK_SUCCESS;

OnError:

    return result;
}


#endif

static VkResult __vki_ImportVideoNode(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node,
    uint32_t name,
    gcePOOL pool,
    size_t size
    )
{
    VkResult result = VK_SUCCESS;
    gcsHAL_INTERFACE iface;
    uint32_t i;

    __VK_MEMZERO(node, sizeof(gcsSURF_NODE));

    iface.command = gcvHAL_IMPORT_VIDEO_MEMORY;
    iface.u.ImportVideoMemory.name = name;

    __VK_ONERROR(__vk_DeviceControl(&iface, 0));

    node->u.normal.node = iface.u.ImportVideoMemory.handle;
    node->pool          = pool;
    node->size          = size;

    node->physical2     = ~0U;
    node->physical3     = ~0U;

    for (i = 0; i < gcvHARDWARE_NUM_TYPES; i++)
    {
        node->hardwareAddresses[i] = ~0U;
    }

    return VK_SUCCESS;

OnError:
    return result;
}

static VkResult __vki_ImportUserMemory(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node,
    unsigned long physical,
    void * virt,
    size_t size
    )
{
    VkResult result = VK_SUCCESS;
    gcsHAL_INTERFACE iface;
    uint32_t i;

    __VK_MEMZERO(node, sizeof(gcsSURF_NODE));

    iface.command = gcvHAL_WRAP_USER_MEMORY;
    iface.u.WrapUserMemory.desc.physical = physical;
    iface.u.WrapUserMemory.desc.logical  = (uintptr_t) virt;
    iface.u.WrapUserMemory.desc.handle   = 0;
    iface.u.WrapUserMemory.desc.size     = (gctUINT32)size;
    iface.u.WrapUserMemory.desc.flag     = gcvALLOC_FLAG_USERMEMORY;
    iface.u.WrapUserMemory.node          = 0;

    __VK_ONERROR(__vk_DeviceControl(&iface, 0));

    node->u.normal.node = iface.u.WrapUserMemory.node;
    node->pool          = gcvPOOL_VIRTUAL;
    node->size          = size;

    node->physical2     = ~0U;
    node->physical3     = ~0U;

    for (i = 0; i < gcvHARDWARE_NUM_TYPES; i++)
    {
        node->hardwareAddresses[i] = ~0U;
    }

    return VK_SUCCESS;

OnError:
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_AllocateMemory(
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory
    )
{
    VkResult result = VK_SUCCESS;
    gceSTATUS status = gcvSTATUS_OK;
    __vkDeviceMemory *dvm = gcvNULL;
    __vkDevContext *devCtx = (__vkDevContext*)device;

    do {
        /* Set the allocator to the parent allocator or API defined allocator if valid */
        __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

        result = __vk_CreateObject(devCtx, __VK_OBJECT_DEVICE_MEMORY, sizeof(__vkDeviceMemory), (__vkObject**)&dvm);
        if (result != VK_SUCCESS)
        {
            break;
        }

        dvm->devCtx = devCtx;
        dvm->mapped = VK_FALSE;
        dvm->memCb = __VK_ALLOCATIONCB;
        /* Vulkan need guarantee maximum alignment (256) for all usage. */
        dvm->align  = 256;
        dvm->size   = (gctSIZE_T)pAllocateInfo->allocationSize;
        gcoOS_MemCopy(&dvm->allocInfo, pAllocateInfo, gcmSIZEOF(VkMemoryAllocateInfo));

#if __VK_NEW_DEVICE_QUEUE
        __VK_ERR_BREAK(__vki_CreateSurfNode(devCtx, &dvm->node, (uint32_t)dvm->size, dvm->align, gcvSURF_TYPE_UNKNOWN,
                                            gcvALLOC_FLAG_NONE, gcvPOOL_DEFAULT));

        __VK_ERR_BREAK(__vki_LockSurfNode(devCtx, &dvm->node, &dvm->devAddr, &dvm->hostAddr));

#else
        gcmERR_BREAK(gcsSURF_NODE_Construct(&dvm->node, dvm->size, dvm->align, gcvSURF_TYPE_UNKNOWN,
                                            gcvALLOC_FLAG_NONE, gcvPOOL_DEFAULT));

        gcmERR_BREAK(gcsSURF_NODE_Lock(&dvm->node, &dvm->devAddr, &dvm->hostAddr));
#endif
#if gcdDUMP
        __VK_MEMZERO(dvm->hostAddr, dvm->size);

        gcmDUMP(gcvNULL, "#[info: initialize device memory=%d", dvm->obj.id);
        gcmDUMP_BUFFER(gcvNULL,
                       "memory",
                       dvm->devAddr,
                       dvm->hostAddr,
                       0,
                       dvm->size);
#endif
        /* Return the object pointer as a 64-bit handle */
        *pMemory = (VkDeviceMemory)(uintptr_t)dvm;
    } while (VK_FALSE);

    if (gcmIS_ERROR(status) && dvm)
    {
#if __VK_NEW_DEVICE_QUEUE
        if (dvm->hostAddr)
        {
            __VK_VERIFY_OK(__vki_UnlockSurfNode(devCtx, &dvm->node));
        }

        if (dvm->node.pool != gcvPOOL_UNKNOWN)
        {
            __VK_VERIFY_OK(__vki_DestroySurfNode(devCtx, &dvm->node));
        }
#else
        if (dvm->hostAddr)
        {
            gcmVERIFY_OK(gcsSURF_NODE_Unlock(&dvm->node));
        }

        if (dvm->node.pool != gcvPOOL_UNKNOWN)
        {
            gcmVERIFY_OK(gcsSURF_NODE_Destroy(&dvm->node));
        }
#endif
        __vk_DestroyObject(devCtx, __VK_OBJECT_DEVICE_MEMORY, (__vkObject *)dvm);
    }

    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_ImportMemory(
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const __VkMemoryImportInfo* pImportInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory
    )
{
    VkResult result = VK_SUCCESS;
    __vkDeviceMemory *dvm = gcvNULL;
    __vkDevContext *devCtx = (__vkDevContext*)device;

    do
    {
        /* Set the allocator to the parent allocator or API defined allocator if valid */
        __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

        result = __vk_CreateObject(devCtx, __VK_OBJECT_DEVICE_MEMORY, sizeof(__vkDeviceMemory), (__vkObject**)&dvm);
        if (result != VK_SUCCESS)
        {
            break;
        }

        dvm->devCtx = devCtx;
        dvm->mapped = VK_FALSE;
        dvm->memCb  = __VK_ALLOCATIONCB;
        /* Vulkan need guarantee maximum alignment (256) for all usage. */
        dvm->align  = 256;
        dvm->size   = (size_t) pAllocateInfo->allocationSize;
        dvm->ts     = NULL;

        gcoOS_MemCopy(&dvm->allocInfo, pAllocateInfo, gcmSIZEOF(VkMemoryAllocateInfo));

        switch (pImportInfo->type)
        {
        case __VK_MEMORY_IMPORT_TYPE_USER_MEMORY:
            result = __vki_ImportUserMemory(devCtx, &dvm->node, pImportInfo->u.usermemory.physical,
                pImportInfo->u.usermemory.virtAddress, (size_t)pAllocateInfo->allocationSize);
            break;

        case __VK_MEMORY_IMPORT_TYPE_VIDEO_NODE:
            result = __vki_ImportVideoNode(devCtx, &dvm->node, pImportInfo->u.videoMemNode.nodeName,
                pImportInfo->u.videoMemNode.nodePool, (size_t)pAllocateInfo->allocationSize);
            break;

        case __VK_MEMORY_IMPORT_TYPE_LINUX_DMA_BUF:
            /* Not supported yet. */
            __VK_ASSERT(0);
            break;
        default:
            __VK_ASSERT(0);
            break;
        }

        if (result != VK_SUCCESS)
            break;

#if __VK_NEW_DEVICE_QUEUE
        __VK_ERR_BREAK(__vki_LockSurfNode(devCtx, &dvm->node, &dvm->devAddr, &dvm->hostAddr));

#else
        if (gcmIS_ERROR(gcsSURF_NODE_Lock(&dvm->node, &dvm->devAddr, &dvm->hostAddr)))
        {
            break;
        }
#endif

#if gcdDUMP
        __VK_MEMZERO(dvm->hostAddr, dvm->size);

        gcmDUMP(gcvNULL, "#[info: initialize device memory=%d", dvm->obj.id);
        gcmDUMP_BUFFER(gcvNULL,
                       "memory",
                       dvm->devAddr,
                       dvm->hostAddr,
                       0,
                       dvm->size);
#endif
        /* Return the object pointer as a 64-bit handle */
        *pMemory = (VkDeviceMemory)(uintptr_t)dvm;

        return VK_SUCCESS;
    } while (VK_FALSE);

    /* Error rollback. */
    if (dvm)
    {
#if __VK_NEW_DEVICE_QUEUE
        if (dvm->hostAddr)
        {
            __VK_VERIFY_OK(__vki_UnlockSurfNode(devCtx, &dvm->node));
        }

        if (dvm->node.pool != gcvPOOL_UNKNOWN)
        {
            __VK_VERIFY_OK(__vki_DestroySurfNode(devCtx, &dvm->node));
        }
#else
        if (dvm->hostAddr)
        {
            gcmVERIFY_OK(gcsSURF_NODE_Unlock(&dvm->node));
        }

        if (dvm->node.pool != gcvPOOL_UNKNOWN)
        {
            gcmVERIFY_OK(gcsSURF_NODE_Destroy(&dvm->node));
        }
#endif
        __vk_DestroyObject(devCtx, __VK_OBJECT_DEVICE_MEMORY, (__vkObject *)dvm);
    }

    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_FreeMemory(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator
    )
{
    if (memory != VK_NULL_HANDLE)
    {
        __vkDevContext *devCtx = (__vkDevContext*)device;
        __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory*, memory);

        /* Set the allocator to the parent allocator or API defined allocator if valid */
        __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

#if __VK_NEW_DEVICE_QUEUE
        __VK_VERIFY_OK(__vki_UnlockSurfNode(devCtx, &dvm->node));
        __VK_VERIFY_OK(__vki_DestroySurfNode(devCtx, &dvm->node));
        /* Free TS related information. */
        if (dvm->ts)
        {
            uint32_t i = 0;
            gcmVERIFY_OK(__vki_UnlockSurfNode(devCtx, &dvm->ts->tsNode));
            gcmVERIFY_OK(__vki_DestroySurfNode(devCtx, &dvm->ts->tsNode));
            for (i = 0; i < dvm->ts->mipLevels; i++)
            {
                __VK_FREE(dvm->ts->tileStatusDisable[i]);
                __VK_FREE(dvm->ts->fcValue[i]);
                __VK_FREE(dvm->ts->fcValueUpper[i]);
            }
            __VK_FREE(dvm->ts->tileStatusDisable);
            __VK_FREE(dvm->ts->fcValue);
            __VK_FREE(dvm->ts->fcValueUpper);
            __VK_FREE(dvm->ts);
        }
#else
        gcmVERIFY_OK(gcsSURF_NODE_Unlock(&dvm->node));
        gcmVERIFY_OK(gcsSURF_NODE_Destroy(&dvm->node));

        /* Free TS related information. */
        if (dvm->ts)
        {
            uint32_t i = 0;
            gcmVERIFY_OK(gcsSURF_NODE_Unlock(&dvm->ts->tsNode));
            gcmVERIFY_OK(gcsSURF_NODE_Destroy(&dvm->ts->tsNode));
            for (i = 0; i < dvm->ts->mipLevels; i++)
            {
                __VK_FREE(dvm->ts->tileStatusDisable[i]);
                __VK_FREE(dvm->ts->fcValue[i]);
                __VK_FREE(dvm->ts->fcValueUpper[i]);
            }
            __VK_FREE(dvm->ts->tileStatusDisable);
            __VK_FREE(dvm->ts->fcValue);
            __VK_FREE(dvm->ts->fcValueUpper);
            __VK_FREE(dvm->ts);
        }
#endif
        __vk_DestroyObject(devCtx, __VK_OBJECT_DEVICE_MEMORY, (__vkObject *)dvm);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_MapMemory(
    VkDevice device,
    VkDeviceMemory mem,
    VkDeviceSize offset,
    VkDeviceSize size,
    VkMemoryMapFlags flags,
    void** ppData
    )
{
    __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory *, mem);

    *ppData = gcmUINT64_TO_PTR(gcmPTR_TO_UINT64(dvm->hostAddr) + offset);
    dvm->mappedSize = size;
    dvm->mappedOffset = offset;
    dvm->mapped = VK_TRUE;

    return VK_SUCCESS;
}

VKAPI_ATTR void VKAPI_CALL __vk_UnmapMemory(
    VkDevice device,
    VkDeviceMemory mem
    )
{
    __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory *, mem);

#if gcdDUMP
    gcmDUMP(gcvNULL, "#[info: update device memory=%d", dvm->obj.id);
    gcmDUMP_BUFFER(gcvNULL,
                   "memory",
                   dvm->devAddr,
                   dvm->hostAddr,
                   (gctUINT)dvm->mappedOffset,
                   (gctUINT)dvm->mappedSize);
#endif

    dvm->mappedOffset = 0;
    dvm->mappedSize = 0;
    dvm->mapped = VK_FALSE;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_FlushMappedMemoryRanges(
    VkDevice device,
    uint32_t memRangeCount,
    const VkMappedMemoryRange* pMemRanges
    )
{
    /* TODO */
    return VK_SUCCESS;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_InvalidateMappedMemoryRanges(
    VkDevice device,
    uint32_t memRangeCount,
    const VkMappedMemoryRange* pMemRanges
    )
{
    /* TODO */
    return VK_SUCCESS;
}

VKAPI_ATTR void VKAPI_CALL __vk_GetDeviceMemoryCommitment(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize* pCommittedMemoryInBytes
    )
{
    /* We didn't report memory type support VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
    ** so always return error.
    */
}

VkResult __vki_AllocateTileStatus(
    __vkDevContext *devCtx,
    __vkImage *img

    )
{
    VkBool32 is2BitPerTile = devCtx->database->REG_TileStatus2Bits;
    __vkTileStatus *tsResource = img->memory->ts;
    VkResult result = VK_SUCCESS;
    uint32_t i = 0;
    uint32_t j = 0;
    uint32_t totalBytes = 0;
    int32_t compressedFormat = -1;

    __VK_SET_ALLOCATIONCB(&img->memCb);

    do
    {
        if (g_dbgNoTS) return VK_SUCCESS;

        if (img->createInfo.usage &
            (VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT))
        {
            if (tsResource)
            {
                return VK_SUCCESS;
            }

            if (img->formatInfo.partCount > 1)
            {
                return VK_SUCCESS;
            }

            if ((img->formatInfo.bitsPerBlock / img->formatInfo.partCount) > 32)
            {
                return VK_SUCCESS;
            }

            if (!devCtx->database->REG_BltEngine)
            {
                return VK_SUCCESS;
            }

            tsResource = (__vkTileStatus*)__VK_ALLOC(sizeof(__vkTileStatus), 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);

            __VK_MEMZERO(tsResource, sizeof(__vkTileStatus));

            /* Allocate ts information. */
            tsResource->tileStatusDisable = (VkBool32**)__VK_ALLOC(img->createInfo.mipLevels * sizeof(VkBool32*),
                8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
            __VK_ONERROR(tsResource->tileStatusDisable ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);

            for (i = 0; i < img->createInfo.mipLevels; i++)
            {
                *(tsResource->tileStatusDisable + i) = (VkBool32*)__VK_ALLOC(img->createInfo.arrayLayers * sizeof(VkBool32),
                    8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
                __VK_ONERROR(*(tsResource->tileStatusDisable + i) ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);
                __VK_MEMZERO(*(tsResource->tileStatusDisable + i), img->createInfo.arrayLayers * sizeof(VkBool32));
            }

            tsResource->fcValue = (uint32_t**)__VK_ALLOC(img->createInfo.mipLevels * sizeof(uint32_t*),
                8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
            __VK_ONERROR(tsResource->fcValue ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);

            for (i = 0; i < img->createInfo.mipLevels; i++)
            {
                *(tsResource->fcValue + i) = (uint32_t*)__VK_ALLOC(img->createInfo.arrayLayers * sizeof(uint32_t),
                    8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
                __VK_ONERROR(*(tsResource->fcValue + i) ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);
                __VK_MEMZERO(*(tsResource->fcValue + i), img->createInfo.arrayLayers * sizeof(uint32_t));
            }

            tsResource->fcValueUpper = (uint32_t**)__VK_ALLOC(img->createInfo.mipLevels * sizeof(uint32_t*),
                8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
            __VK_ONERROR(tsResource->fcValueUpper ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);

            for (i = 0; i < img->createInfo.mipLevels; i++)
            {
                *(tsResource->fcValueUpper + i) = (uint32_t*)__VK_ALLOC(img->createInfo.arrayLayers * sizeof(uint32_t),
                    8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
                __VK_ONERROR(*(tsResource->fcValueUpper + i) ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);
                __VK_MEMZERO(*(tsResource->fcValueUpper + i), img->createInfo.arrayLayers * sizeof(uint32_t));
            }

            tsResource->mipLevels = img->createInfo.mipLevels;

            for (i = 0; i < img->createInfo.mipLevels; i++)
            {
                for (j = 0; j < img->createInfo.arrayLayers; j++)
                {
                    /* Set tile status disabled at the beginning to be consistent with POOL value */
                    tsResource->tileStatusDisable[i][j] = VK_FALSE;

                    /* Set default fill color. */
                    switch (img->formatInfo.residentImgFormat)
                    {
                    case VK_FORMAT_D16_UNORM:
                        tsResource->fcValue[i][j] = tsResource->fcValueUpper[i][j] = 0xFFFFFFFF;
                        break;
                    case __VK_FORMAT_D24_UNORM_X8_PACKED32:
                    case __VK_FORMAT_D24_UNORM_S8_UINT_PACKED32:
                        tsResource->fcValue[i][j] = tsResource->fcValueUpper[i][j] = 0xFFFFFF00;
                        break;
                    default:
                        tsResource->fcValue[i][j] = tsResource->fcValueUpper[i][j] = 0x00000000;
                        break;
                    }
                }
            }

            /* Query tileStatus size. */
            if (devCtx->database->CACHE128B256BPERLINE)
            {
                /*Todo: 128B cache mode.*/
            }
            else
            {
                totalBytes = (uint32_t)(is2BitPerTile ? (img->memory->node.size >> 8) : (img->memory->node.size >> 7));
                if (img->sampleInfo.product > 1)
                {
                    __VK_ASSERT(is2BitPerTile);
                    totalBytes >>= 2;
                }
            }

            tsResource->tileStatusFiller = is2BitPerTile ? 0x55555555 : 0x11111111;
            tsResource->tileStatusInvalidFiller = 0;

            /* Tile status supported? */
            if (totalBytes == 0)
            {
                return VK_SUCCESS;
            }

#if __VK_NEW_DEVICE_QUEUE
            __VK_ERR_BREAK(__vki_CreateSurfNode(devCtx, &tsResource->tsNode, totalBytes, 1, gcvSURF_TYPE_UNKNOWN,
                gcvALLOC_FLAG_NONE, gcvPOOL_DEFAULT));

            __VK_ERR_BREAK(__vki_LockSurfNode(devCtx, &tsResource->tsNode, &tsResource->devAddr, &tsResource->hostAddr));

#else
            /* Allocate the tile status buffer. */
            __VK_ERR_BREAK(gcsSURF_NODE_Construct(&tsResource->tsNode, totalBytes, 1, gcvSURF_TILE_STATUS,
                gcvALLOC_FLAG_NONE, gcvPOOL_DEFAULT));

            __VK_ERR_BREAK(gcsSURF_NODE_Lock(&tsResource->tsNode, VK_NULL_HANDLE, VK_NULL_HANDLE));
#endif
            /* Fill the tile status memory with the invalid filler.
               APP may give memory with context, we set TS to be invalid, and make it enable
            */
            __VK_MEMSET(tsResource->tsNode.logical,
                    (uint8_t)tsResource->tileStatusInvalidFiller,
                    tsResource->tsNode.size);

            /* Get surface compression setting.*/
            if (devCtx->database->REG_ZCompression)
            {
                /* Determine color compression format. */
                switch (img->formatInfo.residentImgFormat)
                {
                case __VK_FORMAT_A4R4G4B4_UNFORM_PACK16:
                    if (!devCtx->database->CACHE128B256BPERLINE)
                    {
                        compressedFormat = 0x0;
                    }
                    break;
                case VK_FORMAT_A1R5G5B5_UNORM_PACK16:
                    compressedFormat = 0x1;
                    break;
                case VK_FORMAT_R5G6B5_UNORM_PACK16:
                    compressedFormat = 0x2;
                    break;
                case VK_FORMAT_R8G8B8A8_UINT:
                case VK_FORMAT_R8G8B8A8_SINT:
                case VK_FORMAT_R8G8B8A8_UNORM:
                    compressedFormat = 0x3;
                    break;
                case VK_FORMAT_D16_UNORM:
                    if (devCtx->database->REG_V2Compression ||
                        devCtx->database->CACHE128B256BPERLINE ||
                        (devCtx->database->REG_DecompressZ16))
                    {
                        compressedFormat = 0x8;
                    }
                    break;
                case __VK_FORMAT_D24_UNORM_X8_PACKED32:
                    compressedFormat = 0x6;
                    break;
                case __VK_FORMAT_D24_UNORM_S8_UINT_PACKED32:
                    compressedFormat = 0x5;
                    break;
                case VK_FORMAT_S8_UINT:
                    if (devCtx->database->REG_S8MSAACompression && (img->sampleInfo.product > 1))
                    {
                        compressedFormat = 0x9;
                    }
                    break;
                default:
                    break;
                }

                if (img->createInfo.usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)
                {
                    if ((img->formatInfo.residentImgFormat == VK_FORMAT_S8_UINT) &&
                        (!devCtx->database->REG_S8MSAACompression ||
                        (img->sampleInfo.product <= 1))
                        )
                    {
                        tsResource->compressed = VK_FALSE;
                    }
                    else if ((img->formatInfo.residentImgFormat == VK_FORMAT_D16_UNORM) &&
                        (devCtx->database->REG_V2Compression) &&
                        (tsResource->fcValue[0][0] != 0xFFFFFFFF)
                        )
                    {
                        tsResource->compressed = VK_FALSE;
                    }
                    else
                    {
                        tsResource->compressed = devCtx->database->REG_ZCompression;
                    }
                }
                else
                {
                    tsResource->compressed = ((compressedFormat != -1) &&
                        ((img->sampleInfo.product > 1) || devCtx->database->CACHE128B256BPERLINE));
                }

                if ((img->sampleInfo.product > 1) &&
                    devCtx->database->REG_V2Compression &&
                    !devCtx->database->REG_MSAACoherencyCheck
                    )
                {
                    tsResource->compressed = VK_FALSE;
                }
            }

            tsResource->compressedFormat = compressedFormat;
        }
    }while(VK_FALSE);

    img->memory->ts = tsResource;

OnError:
    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_BindBufferMemory(
    VkDevice device,
    VkBuffer buffer,
    VkDeviceMemory mem,
    VkDeviceSize memOffset
    )
{
    __vkBuffer *buf = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkBuffer *, buffer);
    __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory *, mem);

    buf->memory = dvm;
    buf->memOffset = memOffset;

    return VK_SUCCESS;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_BindImageMemory(
    VkDevice device,
    VkImage image,
    VkDeviceMemory mem,
    VkDeviceSize memOffset
    )
{
    VkResult result = VK_SUCCESS;
    __vkDevContext *devCtx = (__vkDevContext *)device;
    __vkImage *img = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage *, image);
    __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory *, mem);

    img->memory = dvm;
    img->memOffset = memOffset;

    /* Allocate tileStatus for image. */
    __VK_ONERROR(__vki_AllocateTileStatus(devCtx, img));

OnError:
    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_GetBufferMemoryRequirements(
    VkDevice device,
    VkBuffer buffer,
    VkMemoryRequirements* pMemoryRequirements
    )
{
    __vkBuffer *buf = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkBuffer *, buffer);

    *pMemoryRequirements = buf->memReq;
}

VKAPI_ATTR void VKAPI_CALL __vk_GetImageMemoryRequirements(
    VkDevice device,
    VkImage image,
    VkMemoryRequirements* pMemoryRequirements
    )
{
    __vkImage *img = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage *, image);

    *pMemoryRequirements = img->memReq;
}

void __vkGetAlign(
    IN  __vkDevContext *devCtx,
    IN  __vkFormatInfo *formatInfo,
    IN  VkImageTiling tiling,
    OUT gctUINT_PTR pAlignX,
    OUT gctUINT_PTR pAlignY,
    OUT gctUINT32  *pAlignH,
    OUT gceTILING  *pHalTiling
    )
{
    gceTILING halTiling = gcvINVALIDTILED;
    gctUINT32 alignX, alignY, alignH;
    gctUINT32 resolveAlignX, resolveAlignY;

#if __VK_NEW_DEVICE_QUEUE
    resolveAlignX = (devCtx->database->REG_BltEngine) ? 1 : 16;
    resolveAlignY = (devCtx->database->REG_BltEngine) ? 1 : 4;
#else
    resolveAlignX = devCtx->hardware->resolveAlignmentX;
    resolveAlignY = devCtx->hardware->resolveAlignmentY;
#endif

    if ((formatInfo->residentImgFormat >= VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK &&
         formatInfo->residentImgFormat <= VK_FORMAT_ASTC_12x12_SRGB_BLOCK))
    {
        alignX = formatInfo->blockSize.width;
        alignY = formatInfo->blockSize.height;
        halTiling = gcvTILED;
        alignH = (alignX == 16)
               ? 0x1
               : 0x0;
    }
    else if (tiling == VK_IMAGE_TILING_LINEAR)
    {
        /* Fit resolve alignment. */
        alignX = resolveAlignX;
        alignY = resolveAlignY;
        halTiling = gcvLINEAR;
        alignH = 0x1;
    }
    else
    {
        alignX = 64;
        alignY = 64;
        halTiling = gcvSUPERTILED;
        alignH = 0x2;
    }

    if (pAlignX)
    {
        *pAlignX = alignX;
    }

    if (pAlignY)
    {
        *pAlignY = alignY;
    }

    if (pAlignH)
    {
        *pAlignH = alignH;
    }

    if (pHalTiling)
    {
        *pHalTiling = halTiling;
    }
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_CreateBuffer(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer
    )
{
    VkResult result = VK_SUCCESS;

    do {
        __vkDevContext *devCtx = (__vkDevContext *)device;
        __vkBuffer *buf;
        VkDeviceSize align = 0;

        /* Set the allocator to the parent allocator or API defined allocator if valid */
        __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

        result = __vk_CreateObject(devCtx, __VK_OBJECT_BUFFER, sizeof(__vkBuffer), (__vkObject**)&buf);
        if (result != VK_SUCCESS)
        {
            break;
        }

        gcoOS_MemCopy(&buf->createInfo, pCreateInfo, gcmSIZEOF(VkBufferCreateInfo));

        if (pCreateInfo->usage & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT)
        {
            align = gcmMAX(align, 8);
        }
        if (pCreateInfo->usage & VK_BUFFER_USAGE_INDEX_BUFFER_BIT)
        {
            /* Index buffer required 16 bytes alignment */
            align = gcmMAX(align, 16);
        }
        if (pCreateInfo->usage & ~(VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT))
        {
            /* Other buffer required 8 bytes alignment */
            align = gcmMAX(align, 8);
        }

        /* Initialize __vkBuffer specific data fields here */
        buf->devCtx = devCtx;
        buf->memCb = __VK_ALLOCATIONCB;
        buf->memReq.size = pCreateInfo->size;
        buf->memReq.alignment = align;
        buf->memReq.memoryTypeBits = 0x1;

        buf->memory = gcvNULL;
        buf->memOffset = 0;

        /* Return the object pointer as a 64-bit handle */
        *pBuffer = (VkBuffer)(uintptr_t)buf;
    }
    while (VK_FALSE);

    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_DestroyBuffer(
    VkDevice device,
    VkBuffer buffer,
    const VkAllocationCallbacks* pAllocator
    )
{
    if (buffer != VK_NULL_HANDLE)
    {
        __vkDevContext *devCtx = (__vkDevContext *)device;
        __vkBuffer *buf = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkBuffer *, buffer);

        __vk_DestroyObject(devCtx, __VK_OBJECT_BUFFER, (__vkObject*)buf);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_CreateBufferView(
    VkDevice device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBufferView* pView
    )
{
    VkResult result = VK_SUCCESS;
    __vkDevContext *devCtx = (__vkDevContext *)device;
    __vkBufferView *bfv = VK_NULL_HANDLE;
    /* Set the allocator to the parent allocator or API defined allocator if valid */
    __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

    do {
        __VK_ERR_BREAK(__vk_CreateObject(devCtx, __VK_OBJECT_BUFFER_VIEW, sizeof(__vkBufferView), (__vkObject**)&bfv));
        /* Initialize __vkBufferView specific data fields here */
        gcoOS_MemCopy(&bfv->createInfo, pCreateInfo, gcmSIZEOF(VkBufferViewCreateInfo));
        bfv->devCtx = devCtx;
        bfv->memCb = __VK_ALLOCATIONCB;
        bfv->formatInfo = g_vkFormatInfoTable[pCreateInfo->format];
        /* buffer view must keep original layout of create format */
        bfv->formatInfo.residentImgFormat = pCreateInfo->format;
        __VK_ASSERT(bfv->formatInfo.partCount == 1);
        /* Return the object pointer as a 64-bit handle */
        *pView = (VkBufferView)(uintptr_t)bfv;

        __VK_ERR_BREAK((*devCtx->chipFuncs->CreateBufferView)(device, (VkBufferView)(uintptr_t)bfv));
    }
    while (VK_FALSE);

    if ((VK_SUCCESS != result) && bfv)
    {
        if (bfv->chipPriv)
        {
            (*devCtx->chipFuncs->DestroyBufferView)(device, (VkBufferView)(uintptr_t)bfv);
        }
        __vk_DestroyObject(devCtx, __VK_OBJECT_BUFFER_VIEW, (__vkObject *)bfv);

    }

    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_DestroyBufferView(
    VkDevice device,
    VkBufferView bufferView,
    const VkAllocationCallbacks* pAllocator
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    __vkBufferView *bfv = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkBufferView *, bufferView);

    if (bfv->chipPriv)
    {
        (*devCtx->chipFuncs->DestroyBufferView)(device, (VkBufferView)(uintptr_t)bfv);
    }

    __vk_DestroyObject(devCtx, __VK_OBJECT_BUFFER_VIEW, (__vkObject *)bfv);
}

#if defined(ANDROID) && (ANDROID_SDK_VERSION >= 24)
#include <gc_gralloc_priv.h>

/* VK_ANDROID_native_buffer. */
static VkResult __BindAndroidNativeBufferMemory(
    VkDevice device,
    const VkNativeBufferANDROID* pNativeBuffer,
    const VkAllocationCallbacks* pAllocator,
    __vkImage* image
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    VkResult result = VK_SUCCESS;
    VkDeviceMemory memory = VK_NULL_HANDLE;
    VkMemoryAllocateInfo allocInfo;
    __VkMemoryImportInfo importInfo;
    gc_native_handle_t*  handle;

    /* Set the allocator to the parent allocator or API defined allocator if valid */
    handle = gc_native_handle_get(pNativeBuffer->handle);

    allocInfo = (VkMemoryAllocateInfo) {
        .sType              = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        .pNext              = NULL,
        .allocationSize     = handle->nodeSize,
        .memoryTypeIndex    = 0,
    };

    importInfo = (__VkMemoryImportInfo) {
        .type               = __VK_MEMORY_IMPORT_TYPE_VIDEO_NODE,
        .u.videoMemNode.nodeName           = handle->node,
        .u.videoMemNode.nodePool           = handle->nodePool,
    };

    __VK_ONERROR(__vk_ImportMemory(device, &allocInfo, &importInfo, pAllocator, &memory));

    image->memory    = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory*, memory);
    image->memOffset = 0;
    image->residentMemory = VK_TRUE;


OnError:
    return result;
}
#endif


VKAPI_ATTR VkResult VKAPI_CALL __vk_CreateImage(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    VkResult result = VK_SUCCESS;
    __vkImage *img = VK_NULL_HANDLE;

    /* Set the allocator to the parent allocator or API defined allocator if valid */
    __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

    do
    {
        gctUINT alignX, alignY;
        VkDeviceSize alignment;
        VkDeviceSize totalBytes = 0;
        uint32_t level;
        gctUINT width, height, depth;
        VkBool32 enableCC;
        __VK_ONERROR(__vk_CreateObject(devCtx, __VK_OBJECT_IMAGE, sizeof(__vkImage), (__vkObject**)&img));

        img->devCtx = devCtx;
        img->memCb = __VK_ALLOCATIONCB;
        gcoOS_MemCopy(&img->createInfo, pCreateInfo, gcmSIZEOF(VkImageCreateInfo));

        /* For linear with usage == VK_IMAGE_USAGE_TRANSFER_DST|SRC_BIT use native Vulkan format as resident format */
        if (((pCreateInfo->usage & (~(VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT))) == 0)
            && (pCreateInfo->tiling == VK_IMAGE_TILING_LINEAR))
        {
            img->formatInfo = g_vkFormatInfoTable[pCreateInfo->format];
            img->formatInfo.residentImgFormat = pCreateInfo->format;
            __VK_ASSERT(img->formatInfo.partCount == 1);
        }
        else
        {
            uint32_t residentFormat = g_vkFormatInfoTable[pCreateInfo->format].residentImgFormat;
            img->formatInfo = g_vkFormatInfoTable[residentFormat];
        }

        if (img->formatInfo.residentImgFormat == VK_FORMAT_UNDEFINED)
        {
            /* Shouldn't happen if app pays attention to format queries */
            __VK_ASSERT(0);
            __VK_ONERROR(VK_ERROR_FORMAT_NOT_SUPPORTED);
        }

        __vkGetAlign(devCtx, &img->formatInfo, pCreateInfo->tiling, &alignX, &alignY, &img->hAlignment, &img->halTiling);

        img->pImgLevels = (__vkImageLevel*)__VK_ALLOC(pCreateInfo->mipLevels * sizeof(__vkImageLevel), 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
        __VK_ONERROR(img->pImgLevels ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);
        __VK_MEMZERO(img->pImgLevels, pCreateInfo->mipLevels * sizeof(__vkImageLevel));
        if (pCreateInfo->samples & VK_SAMPLE_COUNT_4_BIT)
        {
            img->sampleInfo.x       = 2;
            img->sampleInfo.y       = 2;
            img->sampleInfo.product = 4;
        }
        else if (pCreateInfo->samples & VK_SAMPLE_COUNT_2_BIT)
        {
            img->sampleInfo.x       = 2;
            img->sampleInfo.y       = 1;
            img->sampleInfo.product = 2;
        }
        else
        {
            img->sampleInfo.x       = 1;
            img->sampleInfo.y       = 1;
            img->sampleInfo.product = 1;
        }

        enableCC = devCtx->database->CACHE128B256BPERLINE;

        if (!img->formatInfo.compressed && devCtx->database->CACHE128B256BPERLINE)
        {
            alignment = 256;
        }
        else if (!img->formatInfo.compressed && enableCC)
        {
            alignment = 256;
        }
        else if (img->sampleInfo.product > 1)
        {
            alignment = 256;
        }
        else
        {
            if (img->formatInfo.compressed && img->halTiling == gcvTILED)
            {
                /* compressed format is disable supertile */
                alignment =  img->formatInfo.bitsPerBlock / 8;
            }
            else
            {
                /* alignment should be 16(pixels) * byte per pixels for tiled surface*/
                alignment = (img->formatInfo.bitsPerBlock >= 64) ? (4 * 4 * img->formatInfo.bitsPerBlock/8) : 64;
            }
        }

        width  = pCreateInfo->extent.width;
        height = pCreateInfo->extent.height;
        depth  = pCreateInfo->extent.depth;

        for (level = 0; level < pCreateInfo->mipLevels; ++level)
        {
            __vkImageLevel *pLevel = &img->pImgLevels[level];

            pLevel->requestW = width;
            pLevel->requestH = height;
            pLevel->requestD = pCreateInfo->arrayLayers > 1 ? pCreateInfo->arrayLayers : depth;
            pLevel->allocedW = width  * img->sampleInfo.x;
            pLevel->allocedH = height * img->sampleInfo.y;
            pLevel->alignedW = gcmALIGN_NP2(width, alignX) * img->sampleInfo.x;
            pLevel->alignedH = gcmALIGN_NP2(height, alignY) * img->sampleInfo.y;
            pLevel->partCount = img->formatInfo.partCount;

            pLevel->stride    = (pLevel->alignedW / img->formatInfo.blockSize.width)  * img->formatInfo.bitsPerBlock / 8;
            pLevel->stride    = pLevel->stride / pLevel->partCount;
            pLevel->sliceSize = (pLevel->alignedH / img->formatInfo.blockSize.height) * pLevel->stride;
            pLevel->sliceSize = gcmALIGN(pLevel->sliceSize, alignment);
            pLevel->partSize  = pLevel->sliceSize * pLevel->requestD;
            pLevel->size      = pLevel->partSize * pLevel->partCount;

            pLevel->offset    = totalBytes;
            totalBytes       += pLevel->size;

            width  = gcmMAX((width >> 1), 1);
            height = gcmMAX((height >> 1), 1);
            depth  = gcmMAX((depth >> 1), 1);
        }

        img->memReq.size = totalBytes;
        img->memReq.alignment = alignment;
        img->memReq.memoryTypeBits = 0x1;

        img->memory = gcvNULL;
        img->memOffset = 0;

#if defined(ANDROID) && (ANDROID_SDK_VERSION >= 24)
        if (pCreateInfo->pNext != NULL)
        {
            /* VK_ANDROID_native_buffer. */
            VkNativeBufferANDROID *nativeBuffer = (VkNativeBufferANDROID *)pCreateInfo->pNext;

            if (nativeBuffer->sType == VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID)
            {
                __VK_ONERROR(__BindAndroidNativeBufferMemory(device, nativeBuffer, pAllocator, img));
            }
        }
#endif

        /* pImage the object pointer as a 64-bit handle */
        *pImage = (VkImage)(uintptr_t)img;
    }
    while (VK_FALSE);

OnError:
    if ((VK_SUCCESS != result) && img)
    {
        if (img->pImgLevels)
        {
            __VK_FREE(img->pImgLevels);
        }
        __vk_DestroyObject(devCtx, __VK_OBJECT_IMAGE, (__vkObject*)img);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_DestroyImage(
    VkDevice device,
    VkImage image,
    const VkAllocationCallbacks* pAllocator
    )
{
    __vkDevContext *devCtx = (__vkDevContext*)device;
    __vkImage *img = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage*, image);

    /* Set the allocator to the parent allocator or API defined allocator if valid */
    __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

    if (img->residentMemory)
    {
        __vk_FreeMemory(device, (VkDeviceMemory)(uintptr_t)img->memory, pAllocator);
    }

    __VK_FREE(img->pImgLevels);

    __vk_DestroyObject(devCtx, __VK_OBJECT_IMAGE, (__vkObject*)img);
}

VKAPI_ATTR void VKAPI_CALL __vk_GetImageSubresourceLayout(
    VkDevice device,
    VkImage image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout* pLayout
    )
{
    __vkImage *img = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage*, image);
    __vkImageLevel *pLevel = &img->pImgLevels[pSubresource->mipLevel];

    pLayout->offset = pLevel->offset + pLevel->sliceSize * pSubresource->arrayLayer;
    pLayout->size = pLevel->sliceSize;
    pLayout->rowPitch = pLevel->stride;
    pLayout->depthPitch = img->createInfo.imageType == VK_IMAGE_TYPE_3D ? pLevel->sliceSize : 0;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_CreateImageView(
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView* pView
    )
{
    VkResult result = VK_SUCCESS;
    __vkDevContext *devCtx = (__vkDevContext*)device;
    __vkImageView *imv = VK_NULL_HANDLE;
    uint32_t residentFormat = g_vkFormatInfoTable[pCreateInfo->format].residentImgFormat;
    /* Set the allocator to the parent allocator or API defined allocator if valid */
    __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

    do {
        __VK_ONERROR(__vk_CreateObject(devCtx, __VK_OBJECT_IMAGE_VIEW, sizeof(__vkImageView), (__vkObject**)&imv));

        imv->devCtx = devCtx;
        imv->memCb = __VK_ALLOCATIONCB;
        imv->formatInfo = &g_vkFormatInfoTable[residentFormat];

        gcoOS_MemCopy(&imv->createInfo, pCreateInfo, gcmSIZEOF(VkImageViewCreateInfo));

        __VK_ONERROR((*devCtx->chipFuncs->CreateImageView)(device, (VkImageView)(uintptr_t)imv));

        /* Return the object pointer as a 64-bit handle */
        *pView = (VkImageView)(uintptr_t)imv;
    }
    while (VK_FALSE);

OnError:

    if ((VK_SUCCESS != result) && imv)
    {
        if (imv->chipPriv)
        {
            (*devCtx->chipFuncs->DestroyImageView)(device, (VkImageView)(uintptr_t)imv);
        }
        __vk_DestroyObject(devCtx, __VK_OBJECT_IMAGE_VIEW, (__vkObject *)imv);
    }

    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_DestroyImageView(
    VkDevice device,
    VkImageView imageView,
    const VkAllocationCallbacks* pAllocator
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    __vkImageView *imv = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImageView *, imageView);

    (*devCtx->chipFuncs->DestroyImageView)(device, (VkImageView)(uintptr_t)imv);

    __vk_DestroyObject(devCtx, __VK_OBJECT_IMAGE_VIEW, (__vkObject *)imv);
}


VKAPI_ATTR VkResult VKAPI_CALL __vk_CreateSampler(
    VkDevice device,
    const VkSamplerCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler* pSampler
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    __vkSampler *spl;
    VkResult result;

    /* Set the allocator to the parent allocator or API defined allocator if valid */
    __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

    __VK_ONERROR(__vk_CreateObject(devCtx, __VK_OBJECT_SAMPLER, sizeof(__vkSampler), (__vkObject**)&spl));

    /* Initialize __vkSampler specific data fields here */
    __VK_MEMCOPY(&spl->createInfo, pCreateInfo, sizeof(VkSamplerCreateInfo));
    spl->memCb = __VK_ALLOCATIONCB;
    /* (TODO) we don't support it with state */
    if (spl->createInfo.unnormalizedCoordinates)
    {
        __VK_DEBUG_PRINT(__VK_DBG_LEVEL_ERROR, "unormalized texture coordinate, patch is not ready");
    }

    __VK_ONERROR((*devCtx->chipFuncs->CreateSampler)(device, (VkSampler)(uintptr_t)spl));

    /* Return the object pointer as a 64-bit handle */
    *pSampler = (VkSampler)(uintptr_t)spl;

    return VK_SUCCESS;

OnError:
    if (spl)
    {
        if (spl->chipPriv)
        {
            __VK_FREE(spl->chipPriv);
        }

        __vk_DestroyObject(devCtx, __VK_OBJECT_SAMPLER, (__vkObject *)spl);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_DestroySampler(
    VkDevice device,
    VkSampler sampler,
    const VkAllocationCallbacks* pAllocator
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    __vkSampler *spl = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkSampler *, sampler);

    /* Set the allocator to the parent allocator or API defined allocator if valid */
    __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

    __VK_FREE(spl->chipPriv);

    __vk_DestroyObject(devCtx, __VK_OBJECT_SAMPLER, (__vkObject *)spl);
}



