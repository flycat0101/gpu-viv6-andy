/****************************************************************************
*
*    Copyright (c) 2005 - 2019 by Vivante Corp.  All rights reserved.
*
*    The material in this file is confidential and contains trade secrets
*    of Vivante Corporation. This is proprietary information owned by
*    Vivante Corporation. No part of this work may be disclosed,
*    reproduced, copied, transmitted, or used in any way for any purpose,
*    without the express written permission of Vivante Corporation.
*
*****************************************************************************/


#include "gc_vk_precomp.h"

/* TS may have issue that in different command buffer, use same surface, we need a way to work out.
   Disalbe for now
*/
#if __VK_ENABLETS
static VkBool32 g_dbgNoTS = VK_FALSE;
#endif
__vkFormatInfo g_vkFormatInfoTable[] =
{
    /*      VK_FORMAT_UNDEFINED                 */
    {__VK_FMT_CATEGORY_MAX, VK_FALSE, { 1, 1}, 0, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*      VK_FORMAT_R4G4_UNORM_PACK8          */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*      VK_FORMAT_R4G4B4A4_UNORM_PACK16     */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, __VK_FORMAT_A4R4G4B4_UNORM_PACK16,
    {0, 0, 0}},
    /*      VK_FORMAT_B4G4R4A4_UNORM_PACK16     */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, __VK_FORMAT_A4R4G4B4_UNORM_PACK16,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*     VK_FORMAT_R5G6B5_UNORM_PACK16       */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R5G6B5_UNORM_PACK16,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     0}},
     /*     VK_FORMAT_B5G6R5_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R5G6B5_UNORM_PACK16,
    {0, 0, 0}},
    /*      VK_FORMAT_R5G5B5A1_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*     VK_FORMAT_B5G5R5A1_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    {0, 0, 0}},
    /*     VK_FORMAT_A1R5G5B5_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     0}},
     /*     VK_FORMAT_R8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_R8_UNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_R8_SNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_UNDEFINED,
    {0, 0, __VK_FORMAT_VERTEX_FEATURES}},
    /*     VK_FORMAT_R8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_UNDEFINED,
    {0, 0, __VK_FORMAT_VERTEX_FEATURES}},
    /*     VK_FORMAT_R8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_R8_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_R8_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8_SRGB, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_R8_SRGB,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R8G8_UNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R8G8_SNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0, 0, __VK_FORMAT_VERTEX_FEATURES}},
    /*     VK_FORMAT_R8G8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0, 0, __VK_FORMAT_VERTEX_FEATURES}},
    /*     VK_FORMAT_R8G8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R8G8_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES   | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES   | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R8G8_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES   | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES   | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8_SRGB, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R8G8_SRGB,
    {0, 0, 0}},
    /*      VK_FORMAT_R8G8B8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R8G8B8_SRGB, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_B8G8R8_SRGB, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 24, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_R8G8B8A8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_UNORM,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8B8A8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R8G8B8A8_SNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8B8A8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*     VK_FORMAT_R8G8B8A8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*     VK_FORMAT_R8G8B8A8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R8G8B8A8_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8B8A8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R8G8B8A8_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R8G8B8A8_SRGB, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_SRGB,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     0}},
    /*    VK_FORMAT_B8G8R8A8_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_UNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_B8G8R8A8_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_SNORM,
    {0, 0, 0}},
    /*    VK_FORMAT_B8G8R8A8_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_B8G8R8A8_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_B8G8R8A8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R8G8B8A8_UINT,
    {0, 0, 0}},
    /*    VK_FORMAT_B8G8R8A8_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R8G8B8A8_SINT,
    {0, 0,0}},
    /*    VK_FORMAT_B8G8R8A8_SRGB, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_SRGB,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     0}},
     /*    VK_FORMAT_A8B8G8R8_UNORM_PACK32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_UNORM,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A8B8G8R8_SNORM_PACK32, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A8B8G8R8_SNORM_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A8B8G8R8_USCALED_PACK32, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A8B8G8R8_SSCALED_PACK32, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A8B8G8R8_UINT_PACK32, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A8B8G8R8_UINT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A8B8G8R8_SINT_PACK32, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A8B8G8R8_SINT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A8B8G8R8_SRGB_PACK32, */
    {__VK_FMT_CATEGORY_SRGB, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B8G8R8A8_SRGB,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     0}},
     /*    VK_FORMAT_A2R10G10B10_UNORM_PACK32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2R10G10B10_SNORM_PACK32, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2R10G10B10_USCALED_PACK32, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2R10G10B10_SSCALED_PACK32, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2R10G10B10_UINT_PACK32, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2R10G10B10_SINT_PACK32, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2B10G10R10_UNORM_PACK32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A2B10G10R10_UNORM_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A2B10G10R10_SNORM_PACK32, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2B10G10R10_USCALED_PACK32, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2B10G10R10_SSCALED_PACK32, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_A2B10G10R10_UINT_PACK32, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A2B10G10R10_UINT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_A2B10G10R10_SINT_PACK32, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_A2B10G10R10_SINT_PACK32,
    {0, 0, 0}},

     /*   VK_FORMAT_R16_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
     /*   VK_FORMAT_R16_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
     /*   VK_FORMAT_R16_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R16_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R16_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R16_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*   VK_FORMAT_R16_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R16_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*   VK_FORMAT_R16_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_R16_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    VK_FORMAT_R16G16_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
    /*    VK_FORMAT_R16G16_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R16G16_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R16G16_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R16G16_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    VK_FORMAT_R16G16B16_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 48, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*    VK_FORMAT_R16G16B16A16_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16B16A16_SNORM, */
    {__VK_FMT_CATEGORY_SNORM, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0,
     0,
     __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16B16A16_USCALED, */
    {__VK_FMT_CATEGORY_USCALED, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16A16_SSCALED, */
    {__VK_FMT_CATEGORY_SSCALED, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*    VK_FORMAT_R16G16B16A16_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R16G16B16A16_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16B16A16_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R16G16B16A16_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R16G16B16A16_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R16G16B16A16_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},

    /*     VK_FORMAT_R32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R32_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*    VK_FORMAT_R32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R32_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_R32_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R32G32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R32G32_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R32G32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R32G32_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*     VK_FORMAT_R32G32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_R32G32_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},

     /*   VK_FORMAT_R32G32B32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 96, 1, VK_FORMAT_UNDEFINED,
    {0, 0,
    __VK_FORMAT_VERTEX_FEATURES}},
     /*   VK_FORMAT_R32G32B32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 96, 1, VK_FORMAT_UNDEFINED,
    {0, 0,
    __VK_FORMAT_VERTEX_FEATURES}},
    /*   VK_FORMAT_R32G32B32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 96, 1, VK_FORMAT_UNDEFINED,
    {0, 0,
    __VK_FORMAT_VERTEX_FEATURES}},
    /*   VK_FORMAT_R32G32B32A32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 128, 1, __VK_FORMAT_R32G32B32A32_UINT_2_R32G32_UINT,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*   VK_FORMAT_R32G32B32A32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 128, 1, __VK_FORMAT_R32G32B32A32_SINT_2_R32G32_SINT,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
     /*   VK_FORMAT_R32G32B32A32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 128, 1, __VK_FORMAT_R32G32B32A32_SFLOAT_2_R32G32_SFLOAT,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},

    /*   VK_FORMAT_R64_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},

    /*   VK_FORMAT_R64G64B64_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 192, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64B64_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 192, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64B64_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 192, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},

    /*   VK_FORMAT_R64G64B64A64_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 256, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64B64A64_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 256, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_R64G64B64A64_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 256, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},

    /*   VK_FORMAT_B10G11R11_UFLOAT_PACK32, */
    {__VK_FMT_CATEGORY_UFLOAT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_B10G11R11_UFLOAT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES}},
     /*   VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, */
    {__VK_FMT_CATEGORY_UFLOAT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},

    /*   VK_FORMAT_D16_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, VK_FORMAT_D16_UNORM,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_DEPTH_FEATURES,
     0}},
     /*   VK_FORMAT_X8_D24_UNORM_PACK32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, __VK_FORMAT_D24_UNORM_X8_PACKED32,
    {0,
     __VK_FORMAT_DEPTH_FEATURES,
     0}},
     /*   VK_FORMAT_D32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_D32_SFLOAT,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES,
     0}},
     /*   VK_FORMAT_S8_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 8, 1, VK_FORMAT_S8_UINT,
    {0,
     __VK_FORMAT_DEPTH_FEATURES,
     0}},
     /*   VK_FORMAT_D16_UNORM_S8_UINT, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
    /*   VK_FORMAT_D24_UNORM_S8_UINT, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, __VK_FORMAT_D24_UNORM_S8_UINT_PACKED32,
    {0,
     __VK_FORMAT_DEPTH_FEATURES,
     0}},
     /*   VK_FORMAT_D32_SFLOAT_S8_UINT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},

    /*   VK_FORMAT_BC1_RGB_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC1_RGB_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC1_RGBA_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC1_RGBA_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC2_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC2_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC3_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC3_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC4_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC4_SNORM_BLOCK, */
    {__VK_FMT_CATEGORY_SNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC5_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC5_SNORM_BLOCK, */
    {__VK_FMT_CATEGORY_SNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC6H_UFLOAT_BLOCK, */
    {__VK_FMT_CATEGORY_UFLOAT, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC6H_SFLOAT_BLOCK, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC7_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},
     /*   VK_FORMAT_BC7_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_UNDEFINED,
    {0, 0, 0}},

     /*   VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
    /*   VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_EAC_R11_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_EAC_R11_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_EAC_R11_SNORM_BLOCK, */
    {__VK_FMT_CATEGORY_SNORM, VK_TRUE, { 4, 4}, 64, 1, VK_FORMAT_EAC_R11_SNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_EAC_R11G11_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_EAC_R11G11_SNORM_BLOCK, */
    {__VK_FMT_CATEGORY_SNORM, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},

    /*   VK_FORMAT_ASTC_4x4_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_4x4_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 4, 4}, 128, 1, VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_5x4_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 5, 4}, 128, 1, VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_5x4_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 5, 4}, 128, 1, VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_5x5_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 5, 5}, 128, 1, VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_5x5_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 5, 5}, 128, 1, VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_6x5_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 6, 5}, 128, 1, VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_6x5_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 6, 5}, 128, 1, VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_6x6_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 6, 6}, 128, 1, VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
    /*   VK_FORMAT_ASTC_6x6_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 6, 6}, 128, 1, VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x5_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 8, 5}, 128, 1, VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x5_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 8, 5}, 128, 1, VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x6_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 8, 6}, 128, 1, VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x6_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 8, 6}, 128, 1, VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x8_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, { 8, 8}, 128, 1, VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_8x8_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, { 8, 8}, 128, 1, VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x5_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {10, 5}, 128, 1, VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x5_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {10, 5}, 128, 1, VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x6_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {10, 6}, 128, 1, VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x6_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {10, 6}, 128, 1, VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x8_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {10, 8}, 128, 1, VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
      /*   VK_FORMAT_ASTC_10x8_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {10, 8}, 128, 1, VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
    /*   VK_FORMAT_ASTC_10x10_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {10, 10}, 128, 1, VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_10x10_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {10, 10}, 128, 1, VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_12x10_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {12, 10}, 128, 1, VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_12x10_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {12, 10}, 128, 1, VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
     /*   VK_FORMAT_ASTC_12x12_UNORM_BLOCK, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {12, 12}, 128, 1, VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},
    /*   VK_FORMAT_ASTC_12x12_SRGB_BLOCK, */
    {__VK_FMT_CATEGORY_SRGB, VK_TRUE, {12, 12}, 128, 1, VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
     0}},

    /* internal resident formats
    */

    /*  __VK_FORMAT_R32G32B32A32_SFLOAT_2_RG32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 128, 2, __VK_FORMAT_R32G32B32A32_SFLOAT_2_R32G32_SFLOAT,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
    __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*  __VK_FORMAT_R32G32B32A32_SINT_2_RG32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 128, 2, __VK_FORMAT_R32G32B32A32_SINT_2_R32G32_SINT,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
    __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*  __VK_FORMAT_R32G32B32A32_UINT_2_RG32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 128, 2, __VK_FORMAT_R32G32B32A32_UINT_2_R32G32_UINT,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
    __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    __VK_FORMAT_R16G16B16A16_SFLOAT_2_R16G16_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 64, 2, __VK_FORMAT_R16G16B16A16_SFLOAT_2_R16G16_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    __VK_FORMAT_R16G16B16A16_SINT_2_R16G16_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 64, 2, __VK_FORMAT_R16G16B16A16_SINT_2_R16G16_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    __VK_FORMAT_R16G16B16A16_UINT_2_R16G16_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 64, 2, __VK_FORMAT_R16G16B16A16_UINT_2_R16G16_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    __VK_FORMAT_R32G32_SFLOAT_2_R32_SFLOAT, */
    {__VK_FMT_CATEGORY_SFLOAT, VK_FALSE, { 1, 1}, 64, 2, __VK_FORMAT_R32G32_SFLOAT_2_R32_SFLOAT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    __VK_FORMAT_R32G32_SINT_2_R32_SINT, */
    {__VK_FMT_CATEGORY_SINT, VK_FALSE, { 1, 1}, 64, 2, __VK_FORMAT_R32G32_SINT_2_R32_SINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*    __VK_FORMAT_R32G32_UINT_2_R32_UINT, */
    {__VK_FMT_CATEGORY_UINT, VK_FALSE, { 1, 1}, 64, 2, __VK_FORMAT_R32G32_UINT_2_R32_UINT,
    {__VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_IMAGE_FEATURES | __VK_FORMAT_COLOR_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     __VK_FORMAT_SAMPLE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_STORAGE_TEXEL_BUFFER_FEATURES | __VK_FORMAT_VERTEX_FEATURES}},
    /*  __VK_FORMAT_A4R4G4B4_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 16, 1, __VK_FORMAT_A4R4G4B4_UNORM_PACK16,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES,
    0}},
    /*  __VK_FORMAT_R8_1_X8R8G8B8, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, __VK_FORMAT_R8_1_X8R8G8B8,
    {0,
     __VK_FORMAT_SAMPLE_IMAGE_FILTERABLE_FEATURES | __VK_FORMAT_COLOR_BLEND_FEATURES | __VK_FORMAT_STORAGE_IMAGE_FEATURES,
     0}},
    /*  __VK_FORMAT_D24_UNORM_S8_UINT_PACKED32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, __VK_FORMAT_D24_UNORM_S8_UINT_PACKED32,
    {0,
    __VK_FORMAT_DEPTH_FEATURES,
    0}},
    /*  __VK_FORMAT_D24_UNORM_X8_PACKED32, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 1, 1}, 32, 1, __VK_FORMAT_D24_UNORM_X8_PACKED32,
    {0,
    __VK_FORMAT_DEPTH_FEATURES,
    0}},
    /*  __VK_FORMAT_G8B8G8R8_422_RGB_IDENTITY_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 2, 1}, 32, 1, __VK_FORMAT_G8B8G8R8_422_RGB_IDENTITY_UNORM,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FEATURES,
    0}},
    /*  __VK_FORMAT_B8G8R8G8_422_RGB_IDENTITY_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 2, 1}, 32, 1, __VK_FORMAT_B8G8R8G8_422_RGB_IDENTITY_UNORM,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FEATURES,
    0}},
    /*  __VK_FORMAT_G8B8G8R8_422_NARROW_RANGE_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 2, 1}, 32, 1, __VK_FORMAT_G8B8G8R8_422_NARROW_RANGE_UNORM,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FEATURES,
    0}},
    /*  __VK_FORMAT_B8G8R8G8_422_NARROW_RANGE_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, { 2, 1}, 32, 1, __VK_FORMAT_B8G8R8G8_422_NARROW_RANGE_UNORM,
    {0,
    __VK_FORMAT_SAMPLE_IMAGE_FEATURES,
    0}},
};

__vkFormatInfo g_vkFormatInfoTable1000156[] =
{
    /*   VK_FORMAT_G8B8G8R8_422_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {2, 1}, 32, 1, VK_FORMAT_G8B8G8R8_422_UNORM,
    {__VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
     __VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
     0}},
    /*   VK_FORMAT_B8G8R8G8_422_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {2, 1}, 32, 1, VK_FORMAT_B8G8R8G8_422_UNORM,
    {__VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
     __VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
     0}},
    /*   VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 24, 1, VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    {__VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
     __VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
     0}},
    /*   VK_FORMAT_G8_B8R8_2PLANE_420_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 16, 1, VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    {__VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
     __VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
     0}},
    /*   VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 24, 1, VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    {__VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
     __VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
     0}},
    /*   VK_FORMAT_G8_B8R8_2PLANE_422_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 16, 1, VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    {__VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
     __VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
     0}},
    /*   VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 24, 1, VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    {__VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
     __VK_FORMAT_YCBCR_CONVERSION_FEATURES | VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
     0}},
    /*   VK_FORMAT_R10X6_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 16, 1, VK_FORMAT_R10X6_UNORM_PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_R10X6G10X6_UNORM_2PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 32, 1, VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 64, 1, VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {2, 1}, 64, 1, VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {2, 1}, 64, 1, VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 48, 1, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 48, 1, VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 48, 1, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 48, 1, VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 48, 1, VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_R12X4_UNORM_PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 16, 1, VK_FORMAT_R12X4_UNORM_PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_R12X4G12X4_UNORM_2PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 32, 1, VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 64, 1, VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {2, 1}, 64, 1, VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {2, 1}, 64, 1, VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 48, 1, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 48, 1, VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 48, 1, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 48, 1, VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 48, 1, VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    {0, 0, 0}},
    /*   VK_FORMAT_G16B16G16R16_422_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {2, 1}, 64, 1, VK_FORMAT_G16B16G16R16_422_UNORM,
    {0, 0, 0}},
    /*   VK_FORMAT_B16G16R16G16_422_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_TRUE, {2, 1}, 64, 1, VK_FORMAT_B16G16R16G16_422_UNORM,
    {0, 0, 0}},
    /*   VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 64, 1, VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    {0, 0, 0}},
    /*   VK_FORMAT_G16_B16R16_2PLANE_420_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 64, 1, VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    {0, 0, 0}},
    /*   VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 64, 1, VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    {0, 0, 0}},
    /*   VK_FORMAT_G16_B16R16_2PLANE_422_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {2, 1}, 64, 1, VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    {0, 0, 0}},
    /*   VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 48, 1, VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    {0, 0, 0}},
    /*   VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG, */
    {__VK_FMT_CATEGORY_UNORM, VK_FALSE, {1, 1}, 48, 1, VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,
    {0, 0, 0}}
};

__vkFormatInfo * __vk_GetVkFormatInfo(
    VkFormat vkFormat
    )
{
    uint32_t formatIndex = vkFormat / 1000;

    if (formatIndex == 0)
    {
         return &g_vkFormatInfoTable[vkFormat];
    }
    else if (formatIndex == 1000156)
    {
         return &g_vkFormatInfoTable1000156[vkFormat - 1000156000];
    }
    else
    {
        return &g_vkFormatInfoTable[VK_FORMAT_UNDEFINED];
    }
}

__vkYCbCrFormatInfo __vk_GetYCbCrFormatInfo(
    VkFormat format
    )
{
    __vkYCbCrFormatInfo info = {0, 1, 1, 1, 8};

    info.bYUVFormat = format >= VK_FORMAT_G8B8G8R8_422_UNORM && format <= VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM;

    switch (format)
    {
    case VK_FORMAT_G8B8G8R8_422_UNORM:
        info.planeCount     = 1;
        info.uvHorzSample   = 2;
        info.uvVertSample   = 1;
        info.bitsPerChannel = 8;
        info.planeFormat[0] = VK_FORMAT_R8G8_UNORM;
        break;
    case VK_FORMAT_B8G8R8G8_422_UNORM:
        info.planeCount     = 1;
        info.uvHorzSample   = 2;
        info.uvVertSample   = 1;
        info.bitsPerChannel = 8;
        info.planeFormat[0] = VK_FORMAT_R8G8_UNORM;
        break;
    case VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:
        info.planeCount     = 3;
        info.uvHorzSample   = 2;
        info.uvVertSample   = 2;
        info.bitsPerChannel = 8;
        info.planeFormat[0] = VK_FORMAT_R8_UNORM;
        info.planeFormat[1] = VK_FORMAT_R8_UNORM;
        info.planeFormat[2] = VK_FORMAT_R8_UNORM;
        break;
    case VK_FORMAT_G8_B8R8_2PLANE_420_UNORM:
        info.planeCount     = 2;
        info.uvHorzSample   = 2;
        info.uvVertSample   = 2;
        info.bitsPerChannel = 8;
        info.planeFormat[0] = VK_FORMAT_R8_UNORM;
        info.planeFormat[1] = VK_FORMAT_R8G8_UNORM;
        break;
    case VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM:
        info.planeCount     = 3;
        info.uvHorzSample   = 2;
        info.uvVertSample   = 1;
        info.bitsPerChannel = 8;
        info.planeFormat[0] = VK_FORMAT_R8_UNORM;
        info.planeFormat[1] = VK_FORMAT_R8_UNORM;
        info.planeFormat[2] = VK_FORMAT_R8_UNORM;
        break;
    case VK_FORMAT_G8_B8R8_2PLANE_422_UNORM:
        info.planeCount     = 2;
        info.uvHorzSample   = 2;
        info.uvVertSample   = 1;
        info.bitsPerChannel = 8;
        info.planeFormat[0] = VK_FORMAT_R8_UNORM;
        info.planeFormat[1] = VK_FORMAT_R8G8_UNORM;
        break;
    case VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM:
        info.planeCount     = 3;
        info.uvHorzSample   = 1;
        info.uvVertSample   = 1;
        info.bitsPerChannel = 8;
        info.planeFormat[0] = VK_FORMAT_R8_UNORM;
        info.planeFormat[1] = VK_FORMAT_R8_UNORM;
        info.planeFormat[2] = VK_FORMAT_R8_UNORM;
        break;
    case VK_FORMAT_R10X6_UNORM_PACK16:
    case VK_FORMAT_R10X6G10X6_UNORM_2PACK16:
    case VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16:
    case VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:
    case VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:
    case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:
    case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:
    case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:
    case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:
    case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:
    case VK_FORMAT_R12X4_UNORM_PACK16:
    case VK_FORMAT_R12X4G12X4_UNORM_2PACK16:
    case VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16:
    case VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:
    case VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:
    case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
    case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:
    case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:
    case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:
    case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:
    case VK_FORMAT_G16B16G16R16_422_UNORM:
    case VK_FORMAT_B16G16R16G16_422_UNORM:
    case VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM:
    case VK_FORMAT_G16_B16R16_2PLANE_420_UNORM:
    case VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM:
    case VK_FORMAT_G16_B16R16_2PLANE_422_UNORM:
    case VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM:
    default:
        if (info.bYUVFormat)
        {
            __VK_ASSERT(0 && "not implement");
        }
        break;
    }

    return info;
}

int32_t __vk_GetPlaneIndex(
    VkImageAspectFlags flags
    )
{
    int32_t plane = -1;
    if (flags & VK_IMAGE_ASPECT_PLANE_0_BIT)
    {
        plane = 0;
    }
    else if (flags & VK_IMAGE_ASPECT_PLANE_1_BIT)
    {
        plane = 1;
    }
    else if (flags & VK_IMAGE_ASPECT_PLANE_2_BIT)
    {
        plane = 2;
    }

    return plane;
}

__vkFormatInfo *__vk_GetPlaneFormatInfo(
    __vkImage *pImage,
    VkImageAspectFlags flags
    )
{
    int32_t plane = __vk_GetPlaneIndex(flags);

    if (pImage->ycbcrFormatInfo.bYUVFormat)
    {
        plane = plane < 0 ? 0 : plane;
        return __vk_GetVkFormatInfo(pImage->ycbcrFormatInfo.planeFormat[plane]);
    }
    else
    {
        return VK_NULL_HANDLE;
    }
}

VkDeviceSize __vk_GetPlaneOffset(
    __vkImage *pImage,
    VkImageAspectFlags flags,
    int32_t level
    )
{
    int32_t plane = __vk_GetPlaneIndex(flags);

    if (pImage->ycbcrFormatInfo.bYUVFormat && plane > -1)
    {
        return pImage->pImgLevels[level].planeOffset[plane];
    }
    else
    {
        return 0;
    }
}

static VkResult __vki_CreateSurfNode(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node,
    gctSIZE_T bytes,
    uint32_t alignment,
    gceSURF_TYPE surfType,
    uint32_t flag,
    gcePOOL pool
    )
{
    VkResult result = VK_SUCCESS;
    gcsHAL_INTERFACE iface;
    uint32_t i;

    __VK_MEMZERO(node, sizeof(gcsSURF_NODE));

    iface.command   = gcvHAL_ALLOCATE_LINEAR_VIDEO_MEMORY;
    iface.u.AllocateLinearVideoMemory.bytes = bytes;
    iface.u.AllocateLinearVideoMemory.alignment = alignment;
    iface.u.AllocateLinearVideoMemory.flag = flag;
    iface.u.AllocateLinearVideoMemory.pool = pool;
    iface.u.AllocateLinearVideoMemory.type = (gctUINT32)surfType & 0xFF;

    __VK_ONERROR(__vk_DeviceControl(&iface, 0));

    node->u.normal.node = iface.u.AllocateLinearVideoMemory.node;
    node->pool          = iface.u.AllocateLinearVideoMemory.pool;
    node->size          = (gctSIZE_T)iface.u.AllocateLinearVideoMemory.bytes;

    node->physical2     = ~0U;
    node->physical3     = ~0U;

    for (i = 0; i < gcvHARDWARE_NUM_TYPES; i++)
    {
        node->hardwareAddresses[i] = ~0U;
    }

    return VK_SUCCESS;

OnError:

    return result;
}

VkResult __vki_DestroySurfNode(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node
    )
{
    gcsHAL_INTERFACE iface;
    VkResult result = VK_SUCCESS;

    /* Release the allocated video memory asynchronously. */
    iface.command = gcvHAL_RELEASE_VIDEO_MEMORY;
    iface.u.ReleaseVideoMemory.node = node->u.normal.node;

    /* Call kernel HAL. */
    __VK_ONERROR(__vk_DeviceControl(&iface, 0));

    /* Reset the node. */
    node->pool  = gcvPOOL_UNKNOWN;
    node->valid = gcvFALSE;

    return VK_SUCCESS;

OnError:
    return result;
}

static VkBool32
__vki_IsResourceFlatMapped(
    __vkDevContext *devCtx,
    gctPHYS_ADDR_T physical
    )
{
    uint32_t i;

    for (i = 0; i < devCtx->chipInfo->flatMappingRangeCount; i++)
    {
        if ((physical >= devCtx->chipInfo->flatMappingRanges[i].start) &&
            (physical < devCtx->chipInfo->flatMappingRanges[i].end) &&
            (devCtx->chipInfo->flatMappingRanges[i].flag == gcvFLATMAP_DIRECT) &&
            (physical != ~0ULL))
        {
            return VK_TRUE;
        }
    }

    return VK_FALSE;
}


VkResult __vki_LockSurfNode(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node,
    gctUINT32 * devAddr,
    gctPOINTER * hostAddr
    )
{
    gceHARDWARE_TYPE type = gcvHARDWARE_3D;
    gceENGINE engine = gcvENGINE_RENDER;
    VkResult result = VK_SUCCESS;

    if (node->lockCounts[type][engine] == 0)
    {
        gcsHAL_INTERFACE iface;
        gctUINT32 handle = node->u.normal.node;
        gctBOOL cacheable = node->u.normal.cacheable;

        if (node->pool == gcvPOOL_USER)
        {
            gctPHYS_ADDR_T physical;

            physical = node->u.wrapped.physical;

            if (physical != gcvINVALID_PHYSICAL_ADDRESS)
            {
                gctUINT32 baseAddress;

                gcmVERIFY_OK(gcoHAL_GetBaseAddr(gcvNULL, &baseAddress));
                physical -= baseAddress;

                gcoOS_CPUPhysicalToGPUPhysical(physical, &physical);
            }

            /*
            ** Although we want to treat user memory in the same way as video memory,
            ** user memory still has some distinguishing feature to allow some optimization.
            */
            if (handle == 0)
            {
                /*
                ** Some software access only surface has no kernel video node.
                ** Since 'physical' is only for one hardware, it can't be used by other hardware type.
                */
                gcmASSERT(node->logical != gcvNULL);
                node->hardwareAddresses[type] = (gctUINT32)physical + (gctUINT32)node->bufferOffset;
            }
            else if (__vki_IsResourceFlatMapped(devCtx, physical))
            {
                /*
                ** If physical address is in flat mapping range of current hardware,
                ** use physical address as hardware address instead of lock in kernel.
                */
                node->hardwareAddresses[type] = (gctUINT32)physical + (gctUINT32) node->bufferOffset;

                handle = 0;

                node->valid = gcvTRUE;
            }

            node->u.wrapped.lockedInKernel[type] = handle ? gcvTRUE : gcvFALSE;
            cacheable = gcvFALSE;
        }

        if (handle)
        {
            /* Fill in the kernel call structure. */
            iface.engine = engine;
            iface.command = gcvHAL_LOCK_VIDEO_MEMORY;
            iface.u.LockVideoMemory.node = handle;
            iface.u.LockVideoMemory.cacheable = cacheable;
            __VK_ONERROR(__vk_DeviceControl(&iface, 0));

            /* Validate the node. */
            node->valid = gcvTRUE;

            if (node->pool != gcvPOOL_USER)
            {
                node->lockedInKernel = gcvTRUE;
            }

            /* Store hardware address. */
            node->hardwareAddresses[type] = iface.u.LockVideoMemory.address + (gctUINT32)node->bufferOffset;
            /* Store logical address. */
            node->logical = gcmUINT64_TO_PTR(iface.u.LockVideoMemory.memory + node->bufferOffset);
        }
    }

    /* Increment the lock count per hardware type. */
    node->lockCounts[type][engine]++;

    /* Set the result. */
    if (devAddr != gcvNULL)
    {
        *devAddr = node->hardwareAddresses[type];
    }

    if (hostAddr != gcvNULL)
    {
        *hostAddr = node->logical;
    }

OnError:
    return result;
}


VkResult __vki_UnlockSurfNode(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node
    )
{
    gceENGINE engine = gcvENGINE_RENDER;
    gceSURF_TYPE surfType = gcvSURF_TYPE_UNKNOWN;
    gceHARDWARE_TYPE type = gcvHARDWARE_3D;
    VkResult result = VK_SUCCESS;

    gcsHAL_INTERFACE iface;

    /* Verify whether the node is valid. */
    if (node->lockCounts[type][engine] <= 0)
    {
        __VK_PRINT("__vki_UnlockSurfNode: node=%p unlock called on an unlocked surface.", node);
    }
    /* Locked more then once? */
    else
    {
        node->lockCounts[type][engine]--;

        if (node->lockCounts[type][engine] == 0)
        {
            gctUINT32 handle = node->u.normal.node;

            if ((node->pool == gcvPOOL_USER)
             && (node->u.wrapped.lockedInKernel[type] == gcvFALSE)
            )
            {
                handle = 0;
            }

            if (handle)
            {
#if gcdDUMP
                uint32_t gpuVirtual = node->hardwareAddresses[type];
                gcmDUMP(gcvNULL, "#[unlock 0x%08x]", gpuVirtual);
#endif

                /* Unlock the video memory node. */
                iface.engine = engine;
                iface.command = gcvHAL_UNLOCK_VIDEO_MEMORY;
                iface.u.UnlockVideoMemory.node = handle;
                iface.u.UnlockVideoMemory.type = (gctUINT32)surfType & 0xFF;
                /* Call the kernel. */
                __VK_ONERROR(__vk_DeviceControl(&iface, 0));

                iface.command = gcvHAL_BOTTOM_HALF_UNLOCK_VIDEO_MEMORY;
                iface.u.BottomHalfUnlockVideoMemory.node = handle;
                iface.u.BottomHalfUnlockVideoMemory.type = (gctUINT32)surfType & 0xFF;
                /* Call the kernel. */
                __VK_ONERROR(__vk_DeviceControl(&iface, 0));
            }
        }
    }

    return VK_SUCCESS;

OnError:

    return result;
}

static VkResult __vki_ImportDmabuf(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node,
    int32_t fd
    )
{
    VkResult result = VK_SUCCESS;
    gcsHAL_INTERFACE iface;
    uint32_t i;

    __VK_MEMZERO(node, sizeof(gcsSURF_NODE));

    iface.command = gcvHAL_WRAP_USER_MEMORY;
    iface.u.WrapUserMemory.desc.flag   = gcvALLOC_FLAG_DMABUF;
    iface.u.WrapUserMemory.desc.handle = fd;
    iface.u.WrapUserMemory.desc.dmabuf = 0;

    __VK_ONERROR(__vk_DeviceControl(&iface, 0));

    node->pool          = gcvPOOL_VIRTUAL;
    node->size          = (gctSIZE_T)iface.u.WrapUserMemory.bytes;
    node->u.normal.node = iface.u.WrapUserMemory.node;

    node->physical2     = ~0U;
    node->physical3     = ~0U;

    for (i = 0; i < gcvHARDWARE_NUM_TYPES; i++)
    {
        node->hardwareAddresses[i] = ~0U;
    }

    return VK_SUCCESS;

OnError:
    return result;
}

static VkResult __vki_ImportVideoNode(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node,
    uint32_t name,
    gcePOOL pool,
    size_t size
    )
{
    VkResult result = VK_SUCCESS;
    gcsHAL_INTERFACE iface;
    uint32_t i;

    __VK_MEMZERO(node, sizeof(gcsSURF_NODE));

    iface.command = gcvHAL_IMPORT_VIDEO_MEMORY;
    iface.u.ImportVideoMemory.name = name;

    __VK_ONERROR(__vk_DeviceControl(&iface, 0));

    node->u.normal.node = iface.u.ImportVideoMemory.handle;
    node->pool          = pool;
    node->size          = size;

    node->physical2     = ~0U;
    node->physical3     = ~0U;

    for (i = 0; i < gcvHARDWARE_NUM_TYPES; i++)
    {
        node->hardwareAddresses[i] = ~0U;
    }

    return VK_SUCCESS;

OnError:
    return result;
}

static VkResult __vki_ImportUserMemory(
    __vkDevContext *devCtx,
    gcsSURF_NODE_PTR node,
    unsigned long physical,
    void * virt,
    size_t size
    )
{
    VkResult result = VK_SUCCESS;
    gcsHAL_INTERFACE iface;
    uint32_t i;

    __VK_MEMZERO(node, sizeof(gcsSURF_NODE));

    iface.command = gcvHAL_WRAP_USER_MEMORY;
    iface.u.WrapUserMemory.desc.physical = physical;
    iface.u.WrapUserMemory.desc.logical  = (uintptr_t) virt;
    iface.u.WrapUserMemory.desc.handle   = 0;
    iface.u.WrapUserMemory.desc.size     = (gctUINT32)size;
    iface.u.WrapUserMemory.desc.flag     = gcvALLOC_FLAG_USERMEMORY;
    iface.u.WrapUserMemory.node          = 0;

    __VK_ONERROR(__vk_DeviceControl(&iface, 0));

    node->u.normal.node = iface.u.WrapUserMemory.node;
    node->pool          = gcvPOOL_USER;
    node->size          = size;

    node->physical2     = ~0U;
    node->physical3     = ~0U;

    for (i = 0; i < gcvHARDWARE_NUM_TYPES; i++)
    {
        node->hardwareAddresses[i] = ~0U;
    }

    return VK_SUCCESS;

OnError:
    return result;
}

#if defined(ANDROID)
#if (ANDROID_SDK_VERSION >= 24)

#ifdef DRM_GRALLOC

#include <gralloc_handle.h>

/* VK_ANDROID_native_buffer. */
static VkResult __BindAndroidNativeBufferMemory(
    VkDevice device,
    const VkNativeBufferANDROID* pNativeBuffer,
    const VkAllocationCallbacks* pAllocator,
    __vkImage* image
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    VkResult result = VK_SUCCESS;
    VkDeviceMemory memory = VK_NULL_HANDLE;
    VkMemoryAllocateInfo allocInfo;
    __VkMemoryImportInfo importInfo;
    native_handle_t * handle = (native_handle_t*)pNativeBuffer->handle;
    int err, fd;

    err = gralloc_handle_validate(handle);
    if (err)
    {
        /* Invalid handle. */
        ALOGE("%s(%d): invalid buffer=%p", __func__, __LINE__, pNativeBuffer);
        return VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR;
    }

    /* Set the allocator to the parent allocator or API defined allocator if valid */
    fd = (handle && handle->numFds) ? (int)handle->data[0] : -1;
    if (fd < 0)
    {
        ALOGE("%s(%d): invalid fd=%d", __func__, __LINE__, fd);
        return VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR;
    }

    allocInfo = (VkMemoryAllocateInfo) {
        .sType              = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        .pNext              = NULL,
        .allocationSize     = 0,
        .memoryTypeIndex    = 0,
    };

    importInfo = (__VkMemoryImportInfo) {
        .type              = __VK_MEMORY_IMPORT_TYPE_LINUX_DMA_BUF,
        .u.dmaBuf.dmaBufFd = fd,
    };

    __VK_ONERROR(__vk_ImportMemory(device, &allocInfo, &importInfo, pAllocator, &memory));

    image->memory    = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory*, memory);
    image->memOffset = 0;
    image->residentMemory = VK_TRUE;

OnError:
    return result;
}

#else

#include <gc_gralloc_priv.h>

/* VK_ANDROID_native_buffer. */
static VkResult __BindAndroidNativeBufferMemory(
    VkDevice device,
    const VkNativeBufferANDROID* pNativeBuffer,
    const VkAllocationCallbacks* pAllocator,
    __vkImage* image
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    VkResult result = VK_SUCCESS;
    VkDeviceMemory memory = VK_NULL_HANDLE;
    VkMemoryAllocateInfo allocInfo;
    __VkMemoryImportInfo importInfo;
    gc_native_handle_t*  handle;

    /* Set the allocator to the parent allocator or API defined allocator if valid */
    handle = gc_native_handle_get(pNativeBuffer->handle);

    allocInfo = (VkMemoryAllocateInfo) {
        .sType              = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        .pNext              = NULL,
        .allocationSize     = handle->nodeSize,
        .memoryTypeIndex    = 0,
    };

    importInfo = (__VkMemoryImportInfo) {
        .type               = __VK_MEMORY_IMPORT_TYPE_VIDEO_NODE,
        .u.videoMemNode.nodeName           = handle->node,
        .u.videoMemNode.nodePool           = handle->nodePool,
    };

    __VK_ONERROR(__vk_ImportMemory(device, &allocInfo, &importInfo, pAllocator, &memory));

    image->memory    = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory*, memory);
    image->memOffset = 0;
    image->residentMemory = VK_TRUE;


OnError:
    return result;
}
#endif
#endif /* ANDROID_SDK_VERSION >= 24 */


#if ANDROID_SDK_VERSION >= 26

#include <vndk/hardware_buffer.h>

extern VkResult __VK_constructAHardwareBuffer(
    uint32_t Width,
    uint32_t Height,
    uint32_t Layers,
    VkFormat vkFormat,
    VkImageCreateFlags vkImgCreateFlags,
    VkImageUsageFlags  vkUsage,
    struct AHardwareBuffer **ahw
    );

extern VkResult __VK_releaseAHardwareBuffer(struct AHardwareBuffer *ahw);
extern VkResult __VK_acquireAHardwareBuffer(struct AHardwareBuffer *ahw);

static VkResult __ImportMemoryFromAHardware(
    VkDevice device,
    struct AHardwareBuffer* buffer,
    VkDeviceMemory *memory
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    VkResult result = VK_SUCCESS;
    VkMemoryAllocateInfo allocInfo;
    __VkMemoryImportInfo importInfo;

    ALOGV("%s(%d): AHardwareBuffer =%p", __func__, __LINE__, buffer);
#ifdef DRM_GRALLOC
    native_handle_t    *handle = (native_handle_t*)AHardwareBuffer_getNativeHandle(buffer);
#else
    gc_native_handle_t *handle = gc_native_handle_get((buffer_handle_t)AHardwareBuffer_getNativeHandle(buffer) );
#endif
    __VK_ASSERT(handle);

#ifdef DRM_GRALLOC
    {
        int err, fd;

        err = gralloc_handle_validate(handle);
        if (err)
        {
            /* Invalid handle. */
            ALOGE("%s(%d): invalid AHardwareBuffer =%p", __func__, __LINE__, buffer);
            return VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR;
        }

        /* Set the allocator to the parent allocator or API defined allocator if valid */
        fd = (handle && handle->numFds) ? (int)handle->data[0] : -1;
        if (fd < 0)
        {
            ALOGE("%s(%d): invalid fd=%d", __func__, __LINE__, fd);
            return VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR;
        }

        allocInfo = (VkMemoryAllocateInfo) {
            .sType              = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            .pNext              = NULL,
            .allocationSize     = 0,
            .memoryTypeIndex    = 0,
        };

        importInfo = (__VkMemoryImportInfo) {
            .type              = __VK_MEMORY_IMPORT_TYPE_LINUX_DMA_BUF,
            .u.dmaBuf.dmaBufFd = fd,
        };
    }
#else
    {
        allocInfo = (VkMemoryAllocateInfo) {
            .sType              = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            .pNext              = NULL,
            .allocationSize     = handle->nodeSize,
            .memoryTypeIndex    = 0,
        };

        importInfo = (__VkMemoryImportInfo) {
            .type               = __VK_MEMORY_IMPORT_TYPE_VIDEO_NODE,
            .u.videoMemNode.nodeName           = handle->node,
            .u.videoMemNode.nodePool           = handle->nodePool,
        };
    }
#endif

    __VK_ONERROR(__vk_ImportMemory(device, &allocInfo, &importInfo, VK_NULL_HANDLE, memory));

OnError:
    return result;
}
#endif /* ANDROID_SDK_VERSION >= 26 */

#endif /* defined(ANDROID) */

VKAPI_ATTR VkResult VKAPI_CALL __vk_AllocateMemory(
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory
    )
{
    VkResult result = VK_SUCCESS;
    __vkDeviceMemory *dvm = gcvNULL;
    __vkDevContext *devCtx = (__vkDevContext*)device;
    gctSIZE_T size = 0u;
    VkBaseInStructure *pBaseIn = (VkBaseInStructure *)pAllocateInfo->pNext;
    VkBool32  bExternalMemory = VK_FALSE;
    VkExportMemoryAllocateInfo    *exportInfo = VK_NULL_HANDLE;
    VkMemoryDedicatedAllocateInfo *dedicatedInfo = VK_NULL_HANDLE;

#if (ANDROID_SDK_VERSION >= 26)
    VkImportAndroidHardwareBufferInfoANDROID  *ahwImported  = VK_NULL_HANDLE;
#endif

    while (pBaseIn)
    {
        if (pBaseIn->sType == VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO)
        {
            exportInfo = (VkExportMemoryAllocateInfo *)pBaseIn;
        }
#if (ANDROID_SDK_VERSION >= 26)
        else if (pBaseIn->sType == VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID)
        {
            ahwImported = (VkImportAndroidHardwareBufferInfoANDROID *)pBaseIn;
        }
#endif
        else if (pBaseIn->sType == VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO)
        {
            dedicatedInfo = (VkMemoryDedicatedAllocateInfo *)pBaseIn;
        }
        pBaseIn = (VkBaseInStructure *)pBaseIn->pNext;
    }

#if (ANDROID_SDK_VERSION >= 26)
    do {
        if (ahwImported)
        {
            bExternalMemory = VK_TRUE;
            __VK_ASSERT(ahwImported->buffer);
            __VK_ERR_BREAK(__ImportMemoryFromAHardware(device, ahwImported->buffer, pMemory));
            dvm = (__vkDeviceMemory *)*pMemory;

            __VK_acquireAHardwareBuffer(ahwImported->buffer);
            dvm->ahwBuffer    = ahwImported->buffer;
        }

        if (exportInfo && (exportInfo->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID) != 0)
        {
            uint32_t width = 0, height = 1, layers = 1;
            VkFormat            imgFormat = VK_FORMAT_UNDEFINED;
            VkImageCreateFlags  imgFlags = 0;
            VkImageUsageFlags   imgUsage = 0;
            struct AHardwareBuffer *aBuffer;

            bExternalMemory = VK_TRUE;
            if (dedicatedInfo && dedicatedInfo->image)
            {
                __vkImage *img = (__vkImage*)dedicatedInfo->image;
                width  = img->createInfo.extent.width;
                height = img->createInfo.extent.height;
                layers = img->createInfo.arrayLayers;

                imgFormat = img->createInfo.format;
                imgFlags  = img->createInfo.flags;
                imgUsage  = img->createInfo.usage;
            }
            else if (dedicatedInfo && dedicatedInfo->buffer)
            {
                __vkBuffer *buffer = (__vkBuffer*)dedicatedInfo->buffer;
                width  = buffer->createInfo.size;
                height = 1;
                layers = 1;
            }
            else
            {
                width  = pAllocateInfo->allocationSize;
                height = 1;
                layers = 1;
            }

            __VK_ERR_BREAK(__VK_constructAHardwareBuffer(width, height, layers, imgFormat, imgFlags, imgUsage, &aBuffer));
            __VK_ERR_BREAK(__ImportMemoryFromAHardware(device, aBuffer, pMemory));

            dvm = (__vkDeviceMemory* )*pMemory;
            dvm->ahwBuffer    = aBuffer;
        }

        if (dvm)
        {
            gcoOS_MemCopy(&dvm->allocInfo, pAllocateInfo, gcmSIZEOF(VkMemoryAllocateInfo));
#if gcdDUMP
            __VK_MEMZERO(dvm->hostAddr, dvm->size);

            gcmDUMP(gcvNULL, "#[info: initialize device memory(android hardware buffer)=%d]", dvm->obj.id);
            gcmDUMP_BUFFER(gcvNULL,
                            gcvDUMP_BUFFER_MEMORY,
                            dvm->devAddr,
                            dvm->hostAddr,
                            0,
                            dvm->size);
#endif
        }
    } while (gcvFALSE);
#else
    dedicatedInfo = dedicatedInfo;
    exportInfo    = exportInfo;
#endif

    if (!bExternalMemory)
    {
        do {
            /* Set the allocator to the parent allocator or API defined allocator if valid */
            __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

            result = __vk_CreateObject(devCtx, __VK_OBJECT_DEVICE_MEMORY, sizeof(__vkDeviceMemory), (__vkObject**)&dvm);
            if (result != VK_SUCCESS)
            {
                break;
            }

            dvm->devCtx = devCtx;
            dvm->mapped = VK_FALSE;
            dvm->memCb = __VK_ALLOCATIONCB;
            /* Vulkan need guarantee maximum alignment (256) for all usage. */
            dvm->align  = 256;
            dvm->size   = (gctSIZE_T)pAllocateInfo->allocationSize;
            size        = dvm->size;

            if (devCtx->enabledFeatures.robustBufferAccess &&
                !devCtx->database->ROBUSTNESS)
            {
                size = __VK_ALIGN(size, 4096);
            }

            gcoOS_MemCopy(&dvm->allocInfo, pAllocateInfo, gcmSIZEOF(VkMemoryAllocateInfo));

            __VK_ERR_BREAK(__vki_CreateSurfNode(devCtx, &dvm->node, size, dvm->align, gcvSURF_TYPE_UNKNOWN,
                                                gcvALLOC_FLAG_NONE, gcvPOOL_DEFAULT));

            __VK_ERR_BREAK(__vki_LockSurfNode(devCtx, &dvm->node, &dvm->devAddr, &dvm->hostAddr));

            if ((devCtx->enabledFeatures.robustBufferAccess &&
                !devCtx->database->ROBUSTNESS) ||
                (devCtx->enabledFeatures.robustBufferAccess &&
                devCtx->database->ROBUSTNESS &&
                !devCtx->database->SH_ROBUSTNESS_FIX) )
            {
                __VK_MEMZERO(dvm->hostAddr, size);
            }

#if gcdDUMP
            __VK_MEMZERO(dvm->hostAddr, dvm->size);

            gcmDUMP(gcvNULL, "#[info: initialize device memory=%d]", dvm->obj.id);
            gcmDUMP_BUFFER(gcvNULL,
                           gcvDUMP_BUFFER_MEMORY,
                           dvm->devAddr,
                           dvm->hostAddr,
                           0,
                           dvm->size);
#endif
            /* Return the object pointer as a 64-bit handle */
            *pMemory = (VkDeviceMemory)(uintptr_t)dvm;
        } while (VK_FALSE);

        if (!__VK_IS_SUCCESS(result) && dvm)
        {
#if (ANDROID_SDK_VERSION >= 26)
            if (dvm->ahwBuffer)
            {
                __VK_releaseAHardwareBuffer(dvm->ahwBuffer);
                dvm->ahwBuffer = VK_NULL_HANDLE;
            }
#endif
            if (dvm->hostAddr)
            {
                __VK_VERIFY_OK(__vki_UnlockSurfNode(devCtx, &dvm->node));
            }

            if (dvm->node.pool != gcvPOOL_UNKNOWN)
            {
                __VK_VERIFY_OK(__vki_DestroySurfNode(devCtx, &dvm->node));
            }
            __vk_DestroyObject(devCtx, __VK_OBJECT_DEVICE_MEMORY, (__vkObject *)dvm);
            *pMemory = VK_NULL_HANDLE;
        }
    }

    return result;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_ImportMemory(
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const __VkMemoryImportInfo* pImportInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory
    )
{
    VkResult result = VK_SUCCESS;
    __vkDeviceMemory *dvm = gcvNULL;
    __vkDevContext *devCtx = (__vkDevContext*)device;

    do
    {
        /* Set the allocator to the parent allocator or API defined allocator if valid */
        __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

        result = __vk_CreateObject(devCtx, __VK_OBJECT_DEVICE_MEMORY, sizeof(__vkDeviceMemory), (__vkObject**)&dvm);
        if (result != VK_SUCCESS)
        {
            break;
        }

        dvm->devCtx = devCtx;
        dvm->mapped = VK_FALSE;
        dvm->memCb  = __VK_ALLOCATIONCB;
        /* Vulkan need guarantee maximum alignment (256) for all usage. */
        dvm->align  = 256;
        dvm->size   = (size_t) pAllocateInfo->allocationSize;
#if __VK_ENABLETS
        dvm->ts     = NULL;
#endif
        gcoOS_MemCopy(&dvm->allocInfo, pAllocateInfo, gcmSIZEOF(VkMemoryAllocateInfo));

        switch (pImportInfo->type)
        {
        case __VK_MEMORY_IMPORT_TYPE_USER_MEMORY:
            result = __vki_ImportUserMemory(devCtx, &dvm->node, pImportInfo->u.usermemory.physical,
                pImportInfo->u.usermemory.virtAddress, (size_t)pAllocateInfo->allocationSize);
            break;

        case __VK_MEMORY_IMPORT_TYPE_VIDEO_NODE:
            result = __vki_ImportVideoNode(devCtx, &dvm->node, pImportInfo->u.videoMemNode.nodeName,
                pImportInfo->u.videoMemNode.nodePool, (size_t)pAllocateInfo->allocationSize);
            break;

        case __VK_MEMORY_IMPORT_TYPE_LINUX_DMA_BUF:
            result = __vki_ImportDmabuf(devCtx, &dvm->node, pImportInfo->u.dmaBuf.dmaBufFd);

            /* Since dmabuf didn't know it's size in user mode, need to update user size after kernel retrive it */
            if (__VK_IS_SUCCESS(result))
            {
                dvm->size = (gctSIZE_T)dvm->node.size;
                dvm->allocInfo.allocationSize = (VkDeviceSize)dvm->node.size;
            }
            break;

        default:
            __VK_ASSERT(0);
            break;
        }

        if (result != VK_SUCCESS)
            break;

        __VK_ERR_BREAK(__vki_LockSurfNode(devCtx, &dvm->node, &dvm->devAddr, &dvm->hostAddr));

#if gcdDUMP
        __VK_MEMZERO(dvm->hostAddr, dvm->size);

        gcmDUMP(gcvNULL, "#[info: initialize device memory=%d]", dvm->obj.id);
        gcmDUMP_BUFFER(gcvNULL,
                       gcvDUMP_BUFFER_MEMORY,
                       dvm->devAddr,
                       dvm->hostAddr,
                       0,
                       dvm->size);
#endif
        /* Return the object pointer as a 64-bit handle */
        *pMemory = (VkDeviceMemory)(uintptr_t)dvm;

        return VK_SUCCESS;
    } while (VK_FALSE);

    /* Error rollback. */
    if (dvm)
    {
        if (dvm->hostAddr)
        {
            __VK_VERIFY_OK(__vki_UnlockSurfNode(devCtx, &dvm->node));
        }

        if (dvm->node.pool != gcvPOOL_UNKNOWN)
        {
            __VK_VERIFY_OK(__vki_DestroySurfNode(devCtx, &dvm->node));
        }
        __vk_DestroyObject(devCtx, __VK_OBJECT_DEVICE_MEMORY, (__vkObject *)dvm);
    }

    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_FreeMemory(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator
    )
{
    if (memory != VK_NULL_HANDLE)
    {
        __vkDevContext *devCtx = (__vkDevContext*)device;
        __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory*, memory);
#if __VK_ENABLETS
        /* Set the allocator to the parent allocator or API defined allocator if valid */
        __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);
#endif

#if (ANDROID_SDK_VERSION >= 26)
        if (dvm->ahwBuffer)
        {
            __VK_releaseAHardwareBuffer(dvm->ahwBuffer);
            dvm->ahwBuffer = VK_NULL_HANDLE;
        }
#endif

        __VK_VERIFY_OK(__vki_UnlockSurfNode(devCtx, &dvm->node));
        __VK_VERIFY_OK(__vki_DestroySurfNode(devCtx, &dvm->node));
#if __VK_ENABLETS
        /* Free TS related information. */
        if (dvm->ts)
        {
            uint32_t i = 0;
            __VK_VERIFY_OK(__vki_UnlockSurfNode(devCtx, &dvm->ts->tsNode));
            __VK_VERIFY_OK(__vki_DestroySurfNode(devCtx, &dvm->ts->tsNode));
            for (i = 0; i < dvm->ts->mipLevels; i++)
            {
                __VK_FREE(dvm->ts->tileStatusDisable[i]);
                __VK_FREE(dvm->ts->fcValue[i]);
                __VK_FREE(dvm->ts->fcValueUpper[i]);
            }
            __VK_FREE(dvm->ts->tileStatusDisable);
            __VK_FREE(dvm->ts->fcValue);
            __VK_FREE(dvm->ts->fcValueUpper);
            __VK_FREE(dvm->ts);
        }
#endif

        __vk_DestroyObject(devCtx, __VK_OBJECT_DEVICE_MEMORY, (__vkObject *)dvm);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_MapMemory(
    VkDevice device,
    VkDeviceMemory mem,
    VkDeviceSize offset,
    VkDeviceSize size,
    VkMemoryMapFlags flags,
    void** ppData
    )
{
    __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory *, mem);

    *ppData = gcmUINT64_TO_PTR(gcmPTR_TO_UINT64(dvm->hostAddr) + offset);
    dvm->mappedSize = (size == VK_WHOLE_SIZE) ? (dvm->size - offset): size;
    dvm->mappedOffset = offset;
    dvm->mapped = VK_TRUE;

    gcmDUMP(gcvNULL, "#[info: update[ Map ] memory=%d]", dvm->obj.id);
    gcmDUMP_BUFFER(gcvNULL,
                    gcvDUMP_BUFFER_VERIFY,
                    dvm->devAddr,
                    dvm->hostAddr,
                    (gctSIZE_T)dvm->mappedOffset,
                    (gctSIZE_T)dvm->mappedSize);

    return VK_SUCCESS;
}

VKAPI_ATTR void VKAPI_CALL __vk_UnmapMemory(
    VkDevice device,
    VkDeviceMemory mem
    )
{
    __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory *, mem);

    gcmDUMP(gcvNULL, "#[info: update[ Unmap ] device memory=%d]", dvm->obj.id);
    gcmDUMP_BUFFER(gcvNULL,
                   gcvDUMP_BUFFER_MEMORY,
                   dvm->devAddr,
                   dvm->hostAddr,
                   (gctSIZE_T)dvm->mappedOffset,
                   (gctSIZE_T)dvm->mappedSize);

    dvm->mappedOffset = 0;
    dvm->mappedSize = 0;
    dvm->mapped = VK_FALSE;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_FlushMappedMemoryRanges(
    VkDevice device,
    uint32_t memRangeCount,
    const VkMappedMemoryRange* pMemRanges
    )
{
#if gcdDUMP
    __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory *, pMemRanges->memory);

    gcmDUMP(gcvNULL, "#[info: flush mapped memory=%d]", dvm->obj.id);
    gcmDUMP_BUFFER(gcvNULL,
                    gcvDUMP_BUFFER_MEMORY,
                    dvm->devAddr,
                    dvm->hostAddr,
                    (gctSIZE_T)pMemRanges->offset,
                    pMemRanges->size == VK_WHOLE_SIZE ? (gctSIZE_T)(dvm->size - pMemRanges->offset - dvm->mappedOffset) : (gctSIZE_T)pMemRanges->size);
#endif
    return VK_SUCCESS;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_InvalidateMappedMemoryRanges(
    VkDevice device,
    uint32_t memRangeCount,
    const VkMappedMemoryRange* pMemRanges
    )
{
#if gcdDUMP
    __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory *, pMemRanges->memory);

    gcmDUMP(gcvNULL, "#[info: invalidate mapped memory=%d]", dvm->obj.id);
    gcmDUMP_BUFFER(gcvNULL,
                    gcvDUMP_BUFFER_VERIFY,
                    dvm->devAddr,
                    dvm->hostAddr,
                    (gctSIZE_T)pMemRanges->offset,
                    pMemRanges->size == VK_WHOLE_SIZE ? (gctSIZE_T)(dvm->size - pMemRanges->offset - dvm->mappedOffset) : (gctSIZE_T)pMemRanges->size);
#endif
    return VK_SUCCESS;
}

VKAPI_ATTR void VKAPI_CALL __vk_GetDeviceMemoryCommitment(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize* pCommittedMemoryInBytes
    )
{
    /* We didn't report memory type support VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
    ** so always return error.
    */
}
#if __VK_ENABLETS
VkResult __vki_AllocateTileStatus(
    __vkDevContext *devCtx,
    __vkImage *img

    )
{
    VkBool32 is2BitPerTile = devCtx->database->REG_TileStatus2Bits;
    __vkTileStatus *tsResource = img->memory->ts;
    VkResult result = VK_SUCCESS;
    uint32_t i = 0;
    uint32_t j = 0;
    gctSIZE_T totalBytes = 0;
    int32_t compressedFormat = -1;
    gctUINT32 resolveAlignX, resolveAlignY;
    gctUINT32 alignment;

    __VK_SET_ALLOCATIONCB(&img->memCb);

    do
    {
        if (g_dbgNoTS || !devCtx->database->TS_FC_VULKAN_SUPPORT)
        {
            return VK_SUCCESS;
        }

        if (img->createInfo.usage &
            (VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT))
        {
            if (tsResource)
            {
                return VK_SUCCESS;
            }

            if (img->formatInfo.partCount > 1)
            {
                return VK_SUCCESS;
            }

            if ((img->formatInfo.bitsPerBlock / img->formatInfo.partCount) > 32)
            {
                return VK_SUCCESS;
            }

            if (!devCtx->database->REG_BltEngine)
            {
                return VK_SUCCESS;
            }

            tsResource = (__vkTileStatus*)__VK_ALLOC(sizeof(__vkTileStatus), 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);

            __VK_MEMZERO(tsResource, sizeof(__vkTileStatus));

            /* Allocate ts information. */
            tsResource->tileStatusDisable = (VkBool32**)__VK_ALLOC(img->createInfo.mipLevels * sizeof(VkBool32*),
                8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
            __VK_ONERROR(tsResource->tileStatusDisable ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);

            for (i = 0; i < img->createInfo.mipLevels; i++)
            {
                *(tsResource->tileStatusDisable + i) = (VkBool32*)__VK_ALLOC(img->createInfo.arrayLayers * sizeof(VkBool32),
                    8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
                __VK_ONERROR(*(tsResource->tileStatusDisable + i) ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);
                __VK_MEMZERO(*(tsResource->tileStatusDisable + i), img->createInfo.arrayLayers * sizeof(VkBool32));
            }

            tsResource->fcValue = (uint32_t**)__VK_ALLOC(img->createInfo.mipLevels * sizeof(uint32_t*),
                8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
            __VK_ONERROR(tsResource->fcValue ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);

            for (i = 0; i < img->createInfo.mipLevels; i++)
            {
                *(tsResource->fcValue + i) = (uint32_t*)__VK_ALLOC(img->createInfo.arrayLayers * sizeof(uint32_t),
                    8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
                __VK_ONERROR(*(tsResource->fcValue + i) ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);
                __VK_MEMZERO(*(tsResource->fcValue + i), img->createInfo.arrayLayers * sizeof(uint32_t));
            }

            tsResource->fcValueUpper = (uint32_t**)__VK_ALLOC(img->createInfo.mipLevels * sizeof(uint32_t*),
                8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
            __VK_ONERROR(tsResource->fcValueUpper ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);

            for (i = 0; i < img->createInfo.mipLevels; i++)
            {
                *(tsResource->fcValueUpper + i) = (uint32_t*)__VK_ALLOC(img->createInfo.arrayLayers * sizeof(uint32_t),
                    8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
                __VK_ONERROR(*(tsResource->fcValueUpper + i) ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);
                __VK_MEMZERO(*(tsResource->fcValueUpper + i), img->createInfo.arrayLayers * sizeof(uint32_t));
            }

            tsResource->mipLevels = img->createInfo.mipLevels;

            for (i = 0; i < img->createInfo.mipLevels; i++)
            {
                for (j = 0; j < img->createInfo.arrayLayers; j++)
                {
                    /* Set tile status disabled at the beginning to be consistent with POOL value */
                    tsResource->tileStatusDisable[i][j] = VK_FALSE;

                    /* Set default fill color. */
                    switch (img->formatInfo.residentImgFormat)
                    {
                    case VK_FORMAT_D16_UNORM:
                        tsResource->fcValue[i][j] = tsResource->fcValueUpper[i][j] = 0xFFFFFFFF;
                        break;
                    case __VK_FORMAT_D24_UNORM_X8_PACKED32:
                    case __VK_FORMAT_D24_UNORM_S8_UINT_PACKED32:
                        tsResource->fcValue[i][j] = tsResource->fcValueUpper[i][j] = 0xFFFFFF00;
                        break;
                    default:
                        tsResource->fcValue[i][j] = tsResource->fcValueUpper[i][j] = 0x00000000;
                        break;
                    }
                }
            }

            resolveAlignX = (devCtx->database->REG_BltEngine) ? 1 : 16;
            resolveAlignY = (devCtx->database->REG_BltEngine) ? 1 : 4;

            alignment = resolveAlignX * resolveAlignY * 4;

            if (devCtx->database->CACHE128B256BPERLINE)
            {
                totalBytes = (img->sampleInfo.product == 4) ?
                            (img->memory->node.size >> 9) : (img->memory->node.size >> 8);

                tsResource->tileStatusFiller = 0xFFFFFFFF;
            }
            else
            {
                totalBytes = (is2BitPerTile ? (img->memory->node.size >> 8) : (img->memory->node.size >> 7));
                if (img->sampleInfo.product > 1)
                {
                    __VK_ASSERT(is2BitPerTile);
                    totalBytes >>= 2;
                }
                tsResource->tileStatusFiller = is2BitPerTile ? 0x55555555 : 0x11111111;
            }

            totalBytes += 64;
            totalBytes = gcmALIGN(totalBytes, alignment);

            tsResource->tileStatusInvalidFiller = 0;

            /* Tile status supported? */
            if (totalBytes == 0)
            {
                break;
            }

            __VK_ERR_BREAK(__vki_CreateSurfNode(devCtx, &tsResource->tsNode, totalBytes, 1, gcvSURF_TYPE_UNKNOWN,
                gcvALLOC_FLAG_NONE, gcvPOOL_DEFAULT));

            __VK_ERR_BREAK(__vki_LockSurfNode(devCtx, &tsResource->tsNode, &tsResource->devAddr, &tsResource->hostAddr));

            /* Fill the tile status memory with the invalid filler.
               APP may give memory with context, we set TS to be invalid, and make it enable
            */
            __VK_MEMSET(tsResource->tsNode.logical,
                    (uint8_t)tsResource->tileStatusInvalidFiller,
                    tsResource->tsNode.size);

            /* Get surface compression setting.*/
            if (devCtx->database->REG_ZCompression)
            {
                /* Determine color compression format. */
                switch (img->formatInfo.residentImgFormat)
                {
                case __VK_FORMAT_A4R4G4B4_UNORM_PACK16:
                    if (!devCtx->msaa_64bpp)
                    {
                        compressedFormat = 0x0;
                    }
                    break;
                case VK_FORMAT_A1R5G5B5_UNORM_PACK16:
                    compressedFormat = 0x1;
                    break;
                case VK_FORMAT_R5G6B5_UNORM_PACK16:
                    compressedFormat = 0x2;
                    break;
                case VK_FORMAT_R8G8B8A8_UINT:
                case VK_FORMAT_R8G8B8A8_SINT:
                case VK_FORMAT_R8G8B8A8_UNORM:
                    compressedFormat = 0x3;
                    break;
                case VK_FORMAT_D16_UNORM:
                    if (devCtx->database->REG_V2Compression ||
                        devCtx->database->CACHE128B256BPERLINE ||
                        (devCtx->database->REG_DecompressZ16))
                    {
                        compressedFormat = 0x8;
                    }
                    break;
                case __VK_FORMAT_D24_UNORM_X8_PACKED32:
                    compressedFormat = 0x6;
                    break;
                case __VK_FORMAT_D24_UNORM_S8_UINT_PACKED32:
                    compressedFormat = 0x5;
                    break;
                case VK_FORMAT_S8_UINT:
                    if (devCtx->database->REG_S8MSAACompression && (img->sampleInfo.product > 1))
                    {
                        compressedFormat = 0x9;
                    }
                    break;
                default:
                    break;
                }

                if (img->createInfo.usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)
                {
                    if ((img->formatInfo.residentImgFormat == VK_FORMAT_S8_UINT) &&
                        (!devCtx->database->REG_S8MSAACompression ||
                        (img->sampleInfo.product <= 1))
                        )
                    {
                        tsResource->compressed = VK_FALSE;
                    }
                    else if ((img->formatInfo.residentImgFormat == VK_FORMAT_D16_UNORM) &&
                        (devCtx->database->REG_V2Compression) &&
                        (tsResource->fcValue[0][0] != 0xFFFFFFFF)
                        )
                    {
                        tsResource->compressed = VK_FALSE;
                    }
                    else
                    {
                        tsResource->compressed = devCtx->database->REG_ZCompression;
                    }
                }
                else
                {
                    tsResource->compressed = ((compressedFormat != -1) &&
                        ((img->sampleInfo.product > 1) || devCtx->database->CACHE128B256BPERLINE));
                }

                if ((img->sampleInfo.product > 1) &&
                    devCtx->database->REG_V2Compression &&
                    !devCtx->database->REG_MSAACoherencyCheck
                    )
                {
                    tsResource->compressed = VK_FALSE;
                }
            }

            tsResource->compressedFormat = compressedFormat;
        }
    } while(VK_FALSE);

    img->memory->ts = tsResource;

OnError:
    if (!__VK_IS_SUCCESS(result) && tsResource)
    {
        __VK_FREE(tsResource);
    }
    return result;
}
#endif

VKAPI_ATTR VkResult VKAPI_CALL __vk_BindBufferMemory(
    VkDevice device,
    VkBuffer buffer,
    VkDeviceMemory mem,
    VkDeviceSize memOffset
    )
{
    __vkBuffer *buf = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkBuffer *, buffer);
    __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory *, mem);

    buf->memory = dvm;
    buf->memOffset = memOffset;

    return VK_SUCCESS;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_BindImageMemory(
    VkDevice device,
    VkImage image,
    VkDeviceMemory mem,
    VkDeviceSize memOffset
    )
{
    VkResult result = VK_SUCCESS;
#if __VK_ENABLETS
    __vkDevContext *devCtx = (__vkDevContext *)device;
#endif
    __vkImage *img = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage *, image);
    __vkDeviceMemory *dvm = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkDeviceMemory *, mem);

    img->memory = dvm;
    img->memOffset = memOffset;
#if __VK_ENABLETS
    /* Allocate tileStatus for image. */
    __VK_ONERROR(__vki_AllocateTileStatus(devCtx, img));
#endif
#if __VK_ENABLETS
OnError:
    return result;
#else
    return result;
#endif
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_BindBufferMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos
    )
{
    uint32_t i = 0;
    for (i = 0; i < bindInfoCount; i++)
    {
        __vk_BindBufferMemory(device, pBindInfos[i].buffer, pBindInfos[i].memory, pBindInfos[i].memoryOffset);
    }
    return VK_SUCCESS;
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_BindImageMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos
    )
{
    uint32_t i = 0;
    for (i = 0; i < bindInfoCount; i++)
    {
        __vk_BindImageMemory(device, pBindInfos[i].image, pBindInfos[i].memory, pBindInfos[i].memoryOffset);
    }
    return VK_SUCCESS;
}

VKAPI_ATTR void VKAPI_CALL __vk_GetBufferMemoryRequirements(
    VkDevice device,
    VkBuffer buffer,
    VkMemoryRequirements* pMemoryRequirements
    )
{
    __vkBuffer *buf = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkBuffer *, buffer);

    *pMemoryRequirements = buf->memReq;
}

VKAPI_ATTR void VKAPI_CALL __vk_GetImageMemoryRequirements(
    VkDevice device,
    VkImage image,
    VkMemoryRequirements* pMemoryRequirements
    )
{
    __vkImage *img = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage *, image);

    *pMemoryRequirements = img->memReq;
}

VKAPI_ATTR void VKAPI_CALL __vk_GetImageMemoryRequirements2(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements
    )
{
    __vkImage *img = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage *, pInfo->image);
    VkImageCreateInfo imgCreateInfo = img->createInfo;
    VkExternalMemoryImageCreateInfo *externalCreateInfo = __VK_NON_DISPATCHABLE_HANDLE_CAST(VkExternalMemoryImageCreateInfo *, imgCreateInfo.pNext);
    VkMemoryDedicatedRequirements *memoryDer = __VK_NON_DISPATCHABLE_HANDLE_CAST(VkMemoryDedicatedRequirements *, pMemoryRequirements->pNext);

    pMemoryRequirements->memoryRequirements = img->memReq;
    pMemoryRequirements->sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;

    if (memoryDer)
    {
        memoryDer->requiresDedicatedAllocation = VK_FALSE;
        memoryDer->prefersDedicatedAllocation = VK_FALSE;
        if (externalCreateInfo && externalCreateInfo->handleTypes)
        {
            switch (externalCreateInfo->handleTypes)
            {
                case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
                case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
                case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
                case VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID:
                    memoryDer->requiresDedicatedAllocation = VK_TRUE;
                    memoryDer->prefersDedicatedAllocation = VK_TRUE;
                    break;
                default:
                    break;
            }
        }
        else
        {
            if (imgCreateInfo.flags & VK_IMAGE_CREATE_SPARSE_BINDING_BIT)
            {
                memoryDer->prefersDedicatedAllocation = VK_FALSE;
            }
        }
    }
    else
    {
        pMemoryRequirements->pNext = VK_NULL_HANDLE;
    }
}

VKAPI_ATTR void VKAPI_CALL __vk_GetBufferMemoryRequirements2(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements
    )
{
    __vkBuffer *buf = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkBuffer *, pInfo->buffer);
    VkBufferCreateInfo bufCreateInfo = buf->createInfo;
    VkExternalMemoryBufferCreateInfo *externalCreateInfo = __VK_NON_DISPATCHABLE_HANDLE_CAST(VkExternalMemoryBufferCreateInfo *, bufCreateInfo.pNext);
    VkMemoryDedicatedRequirements *memoryDer = __VK_NON_DISPATCHABLE_HANDLE_CAST(VkMemoryDedicatedRequirements *, pMemoryRequirements->pNext);

    pMemoryRequirements->memoryRequirements = buf->memReq;
    pMemoryRequirements->sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;

    if (memoryDer)
    {
        memoryDer->requiresDedicatedAllocation = VK_FALSE;
        memoryDer->prefersDedicatedAllocation = VK_FALSE;
        if (externalCreateInfo && externalCreateInfo->handleTypes)
        {
            switch (externalCreateInfo->handleTypes)
            {
                case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
                case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
                case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
                    memoryDer->requiresDedicatedAllocation = VK_TRUE;
                    memoryDer->prefersDedicatedAllocation = VK_TRUE;
                    break;
                default:
                    break;
            }
        }
        else
        {
            if (bufCreateInfo.flags & VK_BUFFER_CREATE_SPARSE_BINDING_BIT)
            {
                memoryDer->prefersDedicatedAllocation = VK_FALSE;
            }
        }
    }
    else
    {
        pMemoryRequirements->pNext = VK_NULL_HANDLE;
    }
}

void __vkGetAlign(
    IN  __vkDevContext *devCtx,
    IN  __vkFormatInfo *formatInfo,
    IN  VkImageTiling tiling,
    OUT gctUINT_PTR pAlignX,
    OUT gctUINT_PTR pAlignY,
    OUT gctUINT32  *pAlignH,
    OUT gceTILING  *pHalTiling
    )
{
    gceTILING halTiling = gcvINVALIDTILED;
    gctUINT32 alignX, alignY, alignH;
    gctUINT32 resolveAlignX, resolveAlignY;

    resolveAlignX = (devCtx->database->REG_BltEngine) ? 1 : 16;
    resolveAlignY = (devCtx->database->REG_BltEngine) ? 1 : 4;

    if ((formatInfo->residentImgFormat >= VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK &&
         formatInfo->residentImgFormat <= VK_FORMAT_ASTC_12x12_SRGB_BLOCK))
    {
        alignX = formatInfo->blockSize.width;
        alignY = formatInfo->blockSize.height;
        halTiling = gcvTILED;
        alignH = (alignX == 16)
               ? 0x1
               : 0x0;
    }
    else if (tiling == VK_IMAGE_TILING_LINEAR)
    {
        /* Fit resolve alignment. */
        alignX = resolveAlignX;
        alignY = resolveAlignY;
        halTiling = gcvLINEAR;
        alignH = 0x1;
    }
    else
    {
        alignX = 64;
        alignY = 64;
        halTiling = gcvSUPERTILED;
        alignH = 0x2;
    }

    if (pAlignX)
    {
        *pAlignX = alignX;
    }

    if (pAlignY)
    {
        *pAlignY = alignY;
    }

    if (pAlignH)
    {
        *pAlignH = alignH;
    }

    if (pHalTiling)
    {
        *pHalTiling = halTiling;
    }
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_CreateBuffer(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer
    )
{
    VkResult result = VK_SUCCESS;

    do {
        __vkDevContext *devCtx = (__vkDevContext *)device;
        __vkBuffer *buf;
        VkDeviceSize align = 0;

        /* Set the allocator to the parent allocator or API defined allocator if valid */
        __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

        result = __vk_CreateObject(devCtx, __VK_OBJECT_BUFFER, sizeof(__vkBuffer), (__vkObject**)&buf);
        if (result != VK_SUCCESS)
        {
            break;
        }

        gcoOS_MemCopy(&buf->createInfo, pCreateInfo, gcmSIZEOF(VkBufferCreateInfo));

        if (pCreateInfo->usage & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT)
        {
            align = gcmMAX(align, 8);
        }
        if (pCreateInfo->usage & VK_BUFFER_USAGE_INDEX_BUFFER_BIT)
        {
            /* Index buffer required 16 bytes alignment */
            align = gcmMAX(align, 16);
        }
        if (pCreateInfo->usage & (VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT))
        {
            align = devCtx->pPhyDevice->phyDevProp.limits.minTexelBufferOffsetAlignment;
        }
        if (pCreateInfo->usage & VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT)
        {
            align = devCtx->pPhyDevice->phyDevProp.limits.minUniformBufferOffsetAlignment;
        }
        if (pCreateInfo->usage & VK_BUFFER_USAGE_STORAGE_BUFFER_BIT)
        {
            align = devCtx->pPhyDevice->phyDevProp.limits.minStorageBufferOffsetAlignment;
        }
        if (pCreateInfo->usage &
            ~(VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT
            | VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
            | VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT))
        {
            /* Other buffer required 8 bytes alignment */
            align = gcmMAX(align, 8);
        }

        /* Initialize __vkBuffer specific data fields here */
        buf->devCtx = devCtx;
        buf->memCb = __VK_ALLOCATIONCB;
        if (devCtx->enabledFeatures.robustBufferAccess &&
            devCtx->database->ROBUSTNESS &&
            !devCtx->database->SH_ROBUSTNESS_FIX)
        {
            buf->memReq.size = __VK_ALIGN(pCreateInfo->size, 16);
        }
        else
        {
            buf->memReq.size = (gctSIZE_T)pCreateInfo->size;
        }
        buf->memReq.alignment = align;
        buf->memReq.memoryTypeBits = 0x3;

        buf->memory = gcvNULL;
        buf->memOffset = 0;

        /* Return the object pointer as a 64-bit handle */
        *pBuffer = (VkBuffer)(uintptr_t)buf;
    }
    while (VK_FALSE);

    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_DestroyBuffer(
    VkDevice device,
    VkBuffer buffer,
    const VkAllocationCallbacks* pAllocator
    )
{
    if (buffer != VK_NULL_HANDLE)
    {
        __vkDevContext *devCtx = (__vkDevContext *)device;
        __vkBuffer *buf = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkBuffer *, buffer);

        if (buf->splitMemory)
            __vk_FreeMemory(device, (VkDeviceMemory)(uintptr_t)buf->splitMemory, gcvNULL);

        __vk_DestroyObject(devCtx, __VK_OBJECT_BUFFER, (__vkObject*)buf);
    }
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_CreateBufferView(
    VkDevice device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBufferView* pView
    )
{
    VkResult result = VK_SUCCESS;
    __vkDevContext *devCtx = (__vkDevContext *)device;
    __vkBufferView *bfv = VK_NULL_HANDLE;
    /* Set the allocator to the parent allocator or API defined allocator if valid */
    __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

    do {
        __VK_ERR_BREAK(__vk_CreateObject(devCtx, __VK_OBJECT_BUFFER_VIEW, sizeof(__vkBufferView), (__vkObject**)&bfv));
        /* Initialize __vkBufferView specific data fields here */
        gcoOS_MemCopy(&bfv->createInfo, pCreateInfo, gcmSIZEOF(VkBufferViewCreateInfo));
        bfv->devCtx = devCtx;
        bfv->memCb = __VK_ALLOCATIONCB;
        bfv->formatInfo = *__vk_GetVkFormatInfo(pCreateInfo->format);
        /* buffer view must keep original layout of create format */
        bfv->formatInfo.residentImgFormat = pCreateInfo->format;
        __VK_ASSERT(bfv->formatInfo.partCount == 1);
        /* Return the object pointer as a 64-bit handle */
        *pView = (VkBufferView)(uintptr_t)bfv;

        __VK_ERR_BREAK((*devCtx->chipFuncs->CreateBufferView)(device, (VkBufferView)(uintptr_t)bfv));
    }
    while (VK_FALSE);

    if ((VK_SUCCESS != result) && bfv)
    {
        if (bfv->chipPriv)
        {
            (*devCtx->chipFuncs->DestroyBufferView)(device, (VkBufferView)(uintptr_t)bfv);
        }
        __vk_DestroyObject(devCtx, __VK_OBJECT_BUFFER_VIEW, (__vkObject *)bfv);

    }

    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_DestroyBufferView(
    VkDevice device,
    VkBufferView bufferView,
    const VkAllocationCallbacks* pAllocator
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    if (bufferView)
    {
        __vkBufferView *bfv = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkBufferView *, bufferView);

        if (bfv->chipPriv)
        {
            (*devCtx->chipFuncs->DestroyBufferView)(device, (VkBufferView)(uintptr_t)bfv);
        }

        __vk_DestroyObject(devCtx, __VK_OBJECT_BUFFER_VIEW, (__vkObject *)bfv);
    }
}

VkResult __vkCreateShadowImage(
    VkDevice device,
    __vkImage *image
    )
{
    VkResult result = VK_SUCCESS;
    __vkImage *img = image;
    __vkImage *shadowImage;
    VkImageCreateInfo imgCreateInfo;
    VkMemoryRequirements imgMemReq;
    VkDeviceMemory shadowMemory;

    VkMemoryAllocateInfo memAllocInfo = {
        VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        gcvNULL,
        0,
        0
    };

    __VK_MEMCOPY(&imgCreateInfo, &img->createInfo, sizeof(VkImageCreateInfo));
    imgCreateInfo.flags &= ~VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT;

    __vk_CreateImage(device, &imgCreateInfo, VK_NULL_HANDLE, &img->shadowImage);

    __vk_GetImageMemoryRequirements(device, img->shadowImage, &imgMemReq);

    memAllocInfo.allocationSize = imgMemReq.size;
    __VK_ONERROR(__vk_AllocateMemory(device, &memAllocInfo, gcvNULL, &shadowMemory));
    __VK_ONERROR(__vk_BindImageMemory(device, img->shadowImage, shadowMemory, 0));

    shadowImage = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage *, img->shadowImage);
    shadowImage->residentMemory = VK_TRUE;

OnError:
    __VK_ASSERT(result == VK_SUCCESS);
    return result;
}
VKAPI_ATTR VkResult VKAPI_CALL __vk_CreateImage(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    VkResult result = VK_SUCCESS;
    __vkImage *img = VK_NULL_HANDLE;
    VkExternalMemoryImageCreateInfo *externalCreateInfo = VK_NULL_HANDLE;
    VkBaseInStructure *pBaseIn = (VkBaseInStructure *)pCreateInfo->pNext;

    /* Set the allocator to the parent allocator or API defined allocator if valid */
    __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

    while (pBaseIn)
    {
        if (pBaseIn->sType == VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO)
        {
            externalCreateInfo = (VkExternalMemoryImageCreateInfo *)pBaseIn;
        }
        pBaseIn = (VkBaseInStructure *)pBaseIn->pNext;
    }

    do
    {
        gctUINT alignX, alignY;
        VkDeviceSize alignment;
        VkDeviceSize totalBytes = 0;
        uint32_t level;
        gctUINT width, height, depth;
        VkBool32 enableCC;
        uint32_t residentFormat;
        VkBool32 isCompatiableBppImage = VK_FALSE;
        VkExtent2D compressedBlockSize = {1, 1};
        __VK_ONERROR(__vk_CreateObject(devCtx, __VK_OBJECT_IMAGE, sizeof(__vkImage), (__vkObject**)&img));

        img->devCtx = devCtx;
        img->memCb = __VK_ALLOCATIONCB;
        gcoOS_MemCopy(&img->createInfo, pCreateInfo, gcmSIZEOF(VkImageCreateInfo));

        img->ycbcrFormatInfo = __vk_GetYCbCrFormatInfo(img->createInfo.format);

        /* For linear with usage == VK_IMAGE_USAGE_TRANSFER_DST|SRC_BIT use native Vulkan format as resident format */
        if (((pCreateInfo->usage & (~(VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT))) == 0)
            && (pCreateInfo->tiling == VK_IMAGE_TILING_LINEAR))
        {
            img->formatInfo = *__vk_GetVkFormatInfo(pCreateInfo->format);
            img->formatInfo.residentImgFormat = pCreateInfo->format;
            __VK_ASSERT(img->formatInfo.partCount == 1);
        }
        else
        {
            residentFormat = __vk_GetVkFormatInfo(pCreateInfo->format)->residentImgFormat;
            img->formatInfo = *__vk_GetVkFormatInfo((VkFormat) residentFormat);
        }

#if ANDROID_SDK_VERSION >= 26
        if (externalCreateInfo &&
            externalCreateInfo->handleTypes == VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID &&
            img->createInfo.format == VK_FORMAT_R8G8B8_UNORM)
        {
            residentFormat = __vk_GetVkFormatInfo(VK_FORMAT_R8G8B8A8_UNORM)->residentImgFormat;
            img->formatInfo = *__vk_GetVkFormatInfo((VkFormat) residentFormat);
        }
#else
        externalCreateInfo = externalCreateInfo;
#endif

        if (img->formatInfo.residentImgFormat == VK_FORMAT_UNDEFINED)
        {
            /* Shouldn't happen if app pays attention to format queries */
            __VK_ASSERT(0);
            __VK_ONERROR(VK_ERROR_FORMAT_NOT_SUPPORTED);
        }
        else if (img->formatInfo.bitsPerBlock == 64 && (img->createInfo.samples & VK_SAMPLE_COUNT_4_BIT) &&
                 !devCtx->msaa_64bpp)
        {
            uint32_t fakedFormat = VK_FORMAT_UNDEFINED;
            switch (img->formatInfo.residentImgFormat)
            {
            case VK_FORMAT_R16G16B16A16_SFLOAT:
                fakedFormat = __VK_FORMAT_R16G16B16A16_SFLOAT_2_R16G16_SFLOAT;
                break;
            case VK_FORMAT_R16G16B16A16_SINT:
                fakedFormat = __VK_FORMAT_R16G16B16A16_SINT_2_R16G16_SINT;
                break;
            case VK_FORMAT_R16G16B16A16_UINT:
                fakedFormat = __VK_FORMAT_R16G16B16A16_UINT_2_R16G16_UINT;
                break;
            case VK_FORMAT_R32G32_SFLOAT:
                fakedFormat = __VK_FORMAT_R32G32_SFLOAT_2_R32_SFLOAT;
                break;
            case VK_FORMAT_R32G32_SINT:
                fakedFormat = __VK_FORMAT_R32G32_SINT_2_R32_SINT;
                break;
            case VK_FORMAT_R32G32_UINT:
                fakedFormat = __VK_FORMAT_R32G32_UINT_2_R32_UINT;
                break;
            default:
                __VK_ASSERT(!"invalid format!");
                break;
            }
            img->formatInfo = *__vk_GetVkFormatInfo((VkFormat) fakedFormat);
        }

        __vkGetAlign(devCtx, &img->formatInfo, pCreateInfo->tiling, &alignX, &alignY, &img->hAlignment, &img->halTiling);

        /*fix dEQP-VK.pipeline.render_to_image.core.1d_array.huge.width_layers.r8g8b8a8_unorm_d24_unorm_s8_uint out of memory,
          for this case, the image size is too large which is 256MB, using linear to createImage can avoid this issue*/
        if (devCtx->pPhyDevice->pInst->patchID == gcvPATCH_DEQP &&
            (pCreateInfo->extent.width == 4096 &&
             pCreateInfo->extent.height == 1 &&
             pCreateInfo->extent.depth == 1 &&
             pCreateInfo->arrayLayers == 256 &&
             pCreateInfo->tiling == VK_IMAGE_TILING_OPTIMAL))
        {
            __vkGetAlign(devCtx, &img->formatInfo, VK_IMAGE_TILING_LINEAR, &alignX, &alignY, &img->hAlignment, &img->halTiling);
        }

        img->pImgLevels = (__vkImageLevel*)__VK_ALLOC(pCreateInfo->mipLevels * sizeof(__vkImageLevel), 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
        __VK_ONERROR(img->pImgLevels ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY);
        __VK_MEMZERO(img->pImgLevels, pCreateInfo->mipLevels * sizeof(__vkImageLevel));
        if (pCreateInfo->samples & VK_SAMPLE_COUNT_4_BIT)
        {
            img->sampleInfo.x       = 2;
            img->sampleInfo.y       = 2;
            img->sampleInfo.product = 4;
        }
        else if (pCreateInfo->samples & VK_SAMPLE_COUNT_2_BIT)
        {
            img->sampleInfo.x       = 2;
            img->sampleInfo.y       = 1;
            img->sampleInfo.product = 2;
        }
        else
        {
            img->sampleInfo.x       = 1;
            img->sampleInfo.y       = 1;
            img->sampleInfo.product = 1;
        }

        enableCC = devCtx->database->CACHE128B256BPERLINE;

        if (!img->formatInfo.compressed && enableCC)
        {
            alignment = 256;
        }
        else if (img->sampleInfo.product > 1)
        {
            alignment = 256;
        }
        else if (img->formatInfo.compressed)
        {
            alignment = img->formatInfo.bitsPerBlock / 8;
        }
        else
        {
            /* alignment should be 16(pixels) * byte per pixels for tiled surface, and HW require minimum 64 bytes align*/
            alignment = (img->formatInfo.bitsPerBlock >= 64) ? (4 * 4 * img->formatInfo.bitsPerBlock / 8) : 64;
        }

        width  = pCreateInfo->extent.width;
        height = pCreateInfo->extent.height;
        depth  = pCreateInfo->extent.depth;

        /*for 128 bpp compatiable image, create with 2 layer format in driver*/
        if ((img->createInfo.flags & VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT) &&
            img->formatInfo.compressed && img->formatInfo.bitsPerBlock <= 128)
        {
            isCompatiableBppImage = VK_TRUE;
            compressedBlockSize = img->formatInfo.blockSize;

            if (img->formatInfo.bitsPerBlock == 128)
            {
                img->formatInfo = *__vk_GetVkFormatInfo((VkFormat) __VK_FORMAT_R32G32B32A32_SFLOAT_2_R32G32_SFLOAT);
                __vkGetAlign(devCtx, &img->formatInfo, pCreateInfo->tiling, &alignX, &alignY, &img->hAlignment, &img->halTiling);
            }
            else
            {
                img->formatInfo = *__vk_GetVkFormatInfo(VK_FORMAT_R16G16B16A16_UINT);
               __vkGetAlign(devCtx, &img->formatInfo, pCreateInfo->tiling, &alignX, &alignY, &img->hAlignment, &img->halTiling);

            }
        }

        for (level = 0; level < pCreateInfo->mipLevels; ++level)
        {
            __vkImageLevel *pLevel = &img->pImgLevels[level];

            if (isCompatiableBppImage)
            {
                uint32_t compatiableWidth, compatiableHeight;

                compatiableWidth = gcmALIGN_NP2(width, compressedBlockSize.width) / compressedBlockSize.width;
                compatiableHeight = gcmALIGN_NP2(height, compressedBlockSize.height) / compressedBlockSize.height;
                pLevel->requestW = compatiableWidth;
                pLevel->requestH = compatiableHeight;
                pLevel->requestD = pCreateInfo->arrayLayers > 1 ? pCreateInfo->arrayLayers : depth;
                pLevel->allocedW = compatiableWidth  * img->sampleInfo.x;
                pLevel->allocedH = compatiableHeight * img->sampleInfo.y;
                pLevel->alignedW = gcmALIGN_NP2(compatiableWidth, alignX) * img->sampleInfo.x;
                pLevel->alignedH = gcmALIGN_NP2(compatiableHeight, alignY) * img->sampleInfo.y;
            }
            else
            {
                pLevel->requestW = width;
                pLevel->requestH = height;
                pLevel->requestD = pCreateInfo->arrayLayers > 1 ? pCreateInfo->arrayLayers : depth;
                pLevel->allocedW = width  * img->sampleInfo.x;
                pLevel->allocedH = height * img->sampleInfo.y;
                pLevel->alignedW = gcmALIGN_NP2(width, alignX) * img->sampleInfo.x;
                pLevel->alignedH = gcmALIGN_NP2(height, alignY) * img->sampleInfo.y;
            }
            pLevel->partCount = img->formatInfo.partCount;

            pLevel->stride    = (pLevel->alignedW / img->formatInfo.blockSize.width)  * img->formatInfo.bitsPerBlock / 8;
            pLevel->stride    = pLevel->stride / pLevel->partCount;
            pLevel->sliceSize = (pLevel->alignedH / img->formatInfo.blockSize.height) * pLevel->stride;
            pLevel->sliceSize = gcmALIGN(pLevel->sliceSize, alignment);
            pLevel->partSize  = pLevel->sliceSize * pLevel->requestD;
            pLevel->size      = pLevel->partSize * pLevel->partCount;

            if (img->ycbcrFormatInfo.bYUVFormat)
            {
                int32_t plane = 0;
                VkDeviceSize planeOffset = 0;
                int32_t planeCount  = img->ycbcrFormatInfo.planeCount;
                int32_t w = width;
                int32_t h = height;


                __VK_ASSERT(pLevel->partCount == 1);
                __VK_ASSERT(img->ycbcrFormatInfo.bYUVFormat);

                w = gcmALIGN_NP2(w, img->formatInfo.blockSize.width);
                h = gcmALIGN_NP2(h, img->formatInfo.blockSize.height);

                pLevel->planeRequestW[0] = width;
                pLevel->planeRequestH[0] = height;

                pLevel->planeRequestW[1] = pLevel->planeRequestW[2] = w / img->ycbcrFormatInfo.uvHorzSample;
                pLevel->planeRequestH[1] = pLevel->planeRequestH[2] = h / img->ycbcrFormatInfo.uvVertSample;

                pLevel->planeAllocedW[0] = w;
                pLevel->planeAllocedH[0] = h;
                pLevel->planeAllocedW[1] = pLevel->planeAllocedW[2] = pLevel->planeRequestW[1];
                pLevel->planeAllocedH[1] = pLevel->planeAllocedH[2] = pLevel->planeRequestH[1];

                /* memory layout of level *******************
                  | plane | plane | plane | plane |  => plane
                  |     slice     |     slice     |  => layer
                  |              part             |  => part
                *********************************************/
                for (plane = 0; plane < planeCount; plane++)
                {
                    __vkFormatInfo planeInfo = *__vk_GetVkFormatInfo(img->ycbcrFormatInfo.planeFormat[plane]);

                    pLevel->planeAlignedW[plane]    = gcmALIGN_NP2(pLevel->planeAllocedW[plane], alignX);
                    pLevel->planeAlignedH[plane]    = gcmALIGN_NP2(pLevel->planeAllocedH[plane], alignY);

                    pLevel->planeOffset[plane]  = planeOffset;
                    pLevel->planeStride[plane]  = pLevel->planeAlignedW[plane] * planeInfo.bitsPerBlock / 8;
                    pLevel->planeStride[plane] /= pLevel->partCount;
                    pLevel->planeSize[plane]    = pLevel->planeStride[plane] * pLevel->planeAlignedH[plane];

                    planeOffset += pLevel->planeSize[plane];
                    planeOffset  = gcmALIGN(planeOffset, alignment);
                }

                pLevel->sliceSize = planeOffset;
                pLevel->partSize  = pLevel->sliceSize * pLevel->requestD;
                pLevel->size      = pLevel->partSize * pLevel->partCount;
            }
            else
            {
                pLevel->planeRequestW[0] = pLevel->requestW;
                pLevel->planeRequestH[0] = pLevel->requestH;
                pLevel->planeAllocedW[0] = pLevel->allocedW;
                pLevel->planeAllocedH[0] = pLevel->allocedH;
                pLevel->planeAlignedW[0] = pLevel->alignedW;
                pLevel->planeAlignedH[0] = pLevel->alignedH;

                pLevel->planeOffset[0]  = 0;
                pLevel->planeStride[0]  = pLevel->stride;
                pLevel->planeSize[0]    = pLevel->sliceSize;
            }

            pLevel->offset    = totalBytes;
            totalBytes       += pLevel->size;

            width  = gcmMAX((width >> 1), 1);
            height = gcmMAX((height >> 1), 1);
            depth  = gcmMAX((depth >> 1), 1);
        }

        img->memReq.size = totalBytes;
        img->memReq.alignment = alignment;
        img->memReq.memoryTypeBits = 0x3;

        img->memory = gcvNULL;
        img->memOffset = 0;
        img->shadowImage = VK_NULL_HANDLE;

        if (isCompatiableBppImage)
        {
            __vkCreateShadowImage(device, img);
        }

#if defined(ANDROID) && (ANDROID_SDK_VERSION >= 24)
        if (pCreateInfo->pNext != NULL)
        {
            /* VK_ANDROID_native_buffer. */
            VkNativeBufferANDROID *nativeBuffer = (VkNativeBufferANDROID *)pCreateInfo->pNext;

            if (nativeBuffer->sType == VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID)
            {
                __VK_ONERROR(__BindAndroidNativeBufferMemory(device, nativeBuffer, pAllocator, img));
            }
        }
#endif

        /* pImage the object pointer as a 64-bit handle */
        *pImage = (VkImage)(uintptr_t)img;
    }
    while (VK_FALSE);

OnError:
    if ((VK_SUCCESS != result) && img)
    {
        if (img->pImgLevels)
        {
            __VK_FREE(img->pImgLevels);
        }
        __vk_DestroyObject(devCtx, __VK_OBJECT_IMAGE, (__vkObject*)img);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_DestroyImage(
    VkDevice device,
    VkImage image,
    const VkAllocationCallbacks* pAllocator
    )
{
    __vkDevContext *devCtx = (__vkDevContext*)device;
    if (image)
    {
        __vkImage *img = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage*, image);

        /* Set the allocator to the parent allocator or API defined allocator if valid */
        __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);
        if (img->residentMemory)
        {
            __vk_FreeMemory(device, (VkDeviceMemory)(uintptr_t)img->memory, pAllocator);
        }

        if (img->shadowImage)
        {
            __vk_DestroyImage(device, img->shadowImage, &devCtx->memCb);
        }

        __VK_FREE(img->pImgLevels);

        __vk_DestroyObject(devCtx, __VK_OBJECT_IMAGE, (__vkObject*)img);
    }
}

VKAPI_ATTR void VKAPI_CALL __vk_GetImageSubresourceLayout(
    VkDevice device,
    VkImage image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout* pLayout
    )
{
    __vkImage *img = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage*, image);
    __vkImageLevel *pLevel = &img->pImgLevels[pSubresource->mipLevel];
    int32_t planeIdx = __vk_GetPlaneIndex(pSubresource->aspectMask);

    pLayout->offset = pLevel->offset + pLevel->sliceSize * pSubresource->arrayLayer;
    pLayout->size = pLevel->sliceSize;
    pLayout->rowPitch = pLevel->stride;
    pLayout->depthPitch = img->createInfo.imageType == VK_IMAGE_TYPE_3D ? pLevel->sliceSize : 0;

    if (planeIdx > -1)
    {
        pLayout->offset  += pLevel->planeOffset[planeIdx];
        pLayout->size     = pLevel->planeSize[planeIdx];
        pLayout->rowPitch = pLevel->planeStride[planeIdx];
    }
}

VKAPI_ATTR VkResult VKAPI_CALL __vk_CreateImageView(
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView* pView
    )
{
    VkResult result = VK_SUCCESS;
    __vkDevContext *devCtx = (__vkDevContext*)device;
    __vkImageView *imv = VK_NULL_HANDLE;
    __vkImage     *img = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImage*, pCreateInfo->image);
    uint32_t residentFormat = __vk_GetVkFormatInfo(pCreateInfo->format)->residentImgFormat;
    __vkSamplerYcbcrConversion *ycbcrConversion = VK_NULL_HANDLE;

    /* according to spec, when do YCbCr conversion and aspectMask is VK_IMAGE_ASPECT_COLOR_BIT,
        format of image view must be identical to image */
    VkBool32 ycbcrPlaneView = pCreateInfo->format != img->createInfo.format && img->ycbcrFormatInfo.bYUVFormat;

    VkBaseInStructure *baseIn = (VkBaseInStructure *)pCreateInfo->pNext;

    /* Set the allocator to the parent allocator or API defined allocator if valid */
    __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

    while (baseIn)
    {
        switch (baseIn->sType)
        {
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
            {
                VkSamplerYcbcrConversionInfo *conversionInfo = (VkSamplerYcbcrConversionInfo *)baseIn;
                ycbcrConversion = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkSamplerYcbcrConversion*, conversionInfo->conversion);

                __VK_ASSERT((ycbcrPlaneView && __vk_GetPlaneIndex(pCreateInfo->subresourceRange.aspectMask) > -1) ||
                             (!ycbcrPlaneView && __vk_GetPlaneIndex(pCreateInfo->subresourceRange.aspectMask) == -1) );
                /* disable this for all YCbCr format go recompile pass */
                if (!ycbcrPlaneView)
                {
                    if (ycbcrConversion->createInfo.ycbcrModel == VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY &&
                        (residentFormat == VK_FORMAT_G8B8G8R8_422_UNORM || residentFormat == VK_FORMAT_B8G8R8G8_422_UNORM))
                    {
                        residentFormat = residentFormat - VK_FORMAT_G8B8G8R8_422_UNORM + __VK_FORMAT_G8B8G8R8_422_RGB_IDENTITY_UNORM;
                    }
                    else if ((ycbcrConversion->createInfo.ycbcrModel == VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 ||
                         ycbcrConversion->createInfo.ycbcrModel == VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709) &&
                         ycbcrConversion->createInfo.ycbcrRange == VK_SAMPLER_YCBCR_RANGE_ITU_NARROW &&
                        (residentFormat == VK_FORMAT_G8B8G8R8_422_UNORM || residentFormat == VK_FORMAT_B8G8R8G8_422_UNORM))
                    {
                        residentFormat = residentFormat - VK_FORMAT_G8B8G8R8_422_UNORM + __VK_FORMAT_G8B8G8R8_422_NARROW_RANGE_UNORM;
                    }
                }
                baseIn = (VkBaseInStructure *)conversionInfo->pNext;
            }
            break;
        default:
            baseIn = (VkBaseInStructure *)baseIn->pNext;
            break;
        }
    }

    do {
        __VK_ONERROR(__vk_CreateObject(devCtx, __VK_OBJECT_IMAGE_VIEW, sizeof(__vkImageView), (__vkObject**)&imv));

        imv->devCtx = devCtx;
        imv->memCb = __VK_ALLOCATIONCB;
        imv->formatInfo = __vk_GetVkFormatInfo((VkFormat) residentFormat);
        imv->ycbcrConversion = ycbcrConversion;
        imv->ycbcrPlaneView  = ycbcrPlaneView;

        gcoOS_MemCopy(&imv->createInfo, pCreateInfo, gcmSIZEOF(VkImageViewCreateInfo));

        __VK_ONERROR((*devCtx->chipFuncs->CreateImageView)(device, (VkImageView)(uintptr_t)imv));

        /* Return the object pointer as a 64-bit handle */
        *pView = (VkImageView)(uintptr_t)imv;
    }
    while (VK_FALSE);

OnError:

    if ((VK_SUCCESS != result) && imv)
    {
        if (imv->chipPriv)
        {
            (*devCtx->chipFuncs->DestroyImageView)(device, (VkImageView)(uintptr_t)imv);
        }
        __vk_DestroyObject(devCtx, __VK_OBJECT_IMAGE_VIEW, (__vkObject *)imv);
    }

    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_DestroyImageView(
    VkDevice device,
    VkImageView imageView,
    const VkAllocationCallbacks* pAllocator
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;

    if (imageView)
    {
        __vkImageView *imv = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkImageView *, imageView);
        (*devCtx->chipFuncs->DestroyImageView)(device, (VkImageView)(uintptr_t)imv);
        __vk_DestroyObject(devCtx, __VK_OBJECT_IMAGE_VIEW, (__vkObject *)imv);
    }
}


VKAPI_ATTR VkResult VKAPI_CALL __vk_CreateSampler(
    VkDevice device,
    const VkSamplerCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler* pSampler
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    __vkSampler *spl;
    VkResult result;
    __vkSamplerYcbcrConversion *ycbcrConversion = VK_NULL_HANDLE;
    VkBaseInStructure *baseIn = (VkBaseInStructure *)pCreateInfo->pNext;

    /* Set the allocator to the parent allocator or API defined allocator if valid */
    __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

    while (baseIn)
    {
        switch (baseIn->sType)
        {
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
            {
                VkSamplerYcbcrConversionInfo *conversionInfo = (VkSamplerYcbcrConversionInfo *)baseIn;
                ycbcrConversion = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkSamplerYcbcrConversion*, conversionInfo->conversion);
            }
            break;
        default:
            {
                __VK_ASSERT(!"unknown pNext in createSampler createInfo ");
            }
            break;
        }
        baseIn = (VkBaseInStructure *)baseIn->pNext;
    }

    __VK_ONERROR(__vk_CreateObject(devCtx, __VK_OBJECT_SAMPLER, sizeof(__vkSampler), (__vkObject**)&spl));

    /* Initialize __vkSampler specific data fields here */
    __VK_MEMCOPY(&spl->createInfo, pCreateInfo, sizeof(VkSamplerCreateInfo));
    spl->memCb = __VK_ALLOCATIONCB;
    spl->ycbcrConversion = ycbcrConversion;

    __VK_ONERROR((*devCtx->chipFuncs->CreateSampler)(device, (VkSampler)(uintptr_t)spl));

    /* Return the object pointer as a 64-bit handle */
    *pSampler = (VkSampler)(uintptr_t)spl;

    return VK_SUCCESS;

OnError:
    if (spl)
    {
        if (spl->chipPriv)
        {
            __VK_FREE(spl->chipPriv);
        }

        __vk_DestroyObject(devCtx, __VK_OBJECT_SAMPLER, (__vkObject *)spl);
    }
    return result;
}

VKAPI_ATTR void VKAPI_CALL __vk_DestroySampler(
    VkDevice device,
    VkSampler sampler,
    const VkAllocationCallbacks* pAllocator
    )
{
    __vkDevContext *devCtx = (__vkDevContext *)device;
    if (sampler)
    {
        __vkSampler *spl = __VK_NON_DISPATCHABLE_HANDLE_CAST(__vkSampler *, sampler);

        /* Set the allocator to the parent allocator or API defined allocator if valid */
        __VK_SET_API_ALLOCATIONCB(&devCtx->memCb);

        __VK_FREE(spl->chipPriv);

        __vk_DestroyObject(devCtx, __VK_OBJECT_SAMPLER, (__vkObject *)spl);
    }
}



