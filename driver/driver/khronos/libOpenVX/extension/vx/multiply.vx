#include "cl_viv_vx_ext.h"

#define VXC_ROUND_POLICY_TO_ZERO 0x00012001
#define VXC_ROUND_POLICY_TO_NEAREST_EVEN 0x00012002
#define VXC_CONVERT_POLICY_WRAP 0x0000a000
#define VXC_CONVERT_POLICY_SATURATE 0x0000a001

__kernel void multiply
(
	__read_only image2d_t in_image,
	__read_only image2d_t in1_image,
	__read_only vxc_float shift,
	__read_only int overflow,
	__read_only int rounding,
	__write_only image2d_t out_image
)
{
	const int pX = get_global_id(0);
	const int pY = get_global_id(1);
	vxc_float scale = -log2(shift);
	vxc_uchar16 v0 = viv_intrinsic_vx_read_imageuc(in_image, (int2)(pX, pY));
	vxc_uchar16 v1 = viv_intrinsic_vx_read_imageuc(in1_image, (int2)(pX, pY));
	vxc_uchar16 v;

	if(rounding == VXC_ROUND_POLICY_TO_ZERO)
	{
		if(overflow == VXC_CONVERT_POLICY_WRAP)
		{
			v = viv_intrinsic_vxmc_MulShift_uc(v0, v1, scale, VXC_MODIFIER(0, 7, 0, VXC_RM_TowardZero, 0));
		}
		else if(overflow == VXC_CONVERT_POLICY_SATURATE)
		{
			v = viv_intrinsic_vxmc_MulShift_uc(v0, v1, scale, VXC_MODIFIER(0, 7, 0, VXC_RM_TowardZero, 1));
		}
	}
	else if(rounding == VXC_ROUND_POLICY_TO_NEAREST_EVEN)
	{
		if(overflow == VXC_CONVERT_POLICY_WRAP)
		{
			v = viv_intrinsic_vxmc_MulShift_uc(v0, v1, scale, VXC_MODIFIER(0, 7, 0, VXC_RM_ToNearestEven, 0));
		}
		else if(overflow == VXC_CONVERT_POLICY_SATURATE)
		{
			v = viv_intrinsic_vxmc_MulShift_uc(v0, v1, scale, VXC_MODIFIER(0, 7, 0, VXC_RM_ToNearestEven, 1));
		}
	}

	viv_intrinsic_vx_write_imageuc(out_image, (int2)(pX, pY), v);
}