/****************************************************************************
*
*    Copyright (c) 2005 - 2015 by Vivante Corp.  All rights reserved.
*
*    The material in this file is confidential and contains trade secrets
*    of Vivante Corporation. This is proprietary information owned by
*    Vivante Corporation. No part of this work may be disclosed,
*    reproduced, copied, transmitted, or used in any way for any purpose,
*    without the express written permission of Vivante Corporation.
*
*****************************************************************************/


/* Please do NOT edit this file. */

#include <stdlib.h>

#include "gc_gralloc.h"
#include "gc_gralloc_format_xlate.h"
#include "gc_gralloc_priv.h"

#include <gc_hal.h>
#include <gc_hal_base.h>

#ifndef LOGV
#   define LOGV(...) ALOGV(__VA_ARGS__)
#endif


/******************************************************************************/

static gceHARDWARE_TYPE defaultHwType;

static int has2DCore;
static int has3DCore;
static int hasVGCore;
static int has3D2DCore;

static pthread_once_t onceControl = PTHREAD_ONCE_INIT;

/* Find out online hardwares and default hardware type. */
static void
check_hardware_types(
    void
    )
{
    gcsHAL_INTERFACE iface;
    iface.command = gcvHAL_CHIP_INFO;

    defaultHwType = gcvHARDWARE_INVALID;

    gcmVERIFY_OK(
        gcoOS_DeviceControl(gcvNULL,
                            IOCTL_GCHAL_INTERFACE,
                            &iface, gcmSIZEOF(iface),
                            &iface, gcmSIZEOF(iface)));

    /* Determine hardware features. */
    for (gctINT i = 0; i < iface.u.ChipInfo.count; i++)
    {
        switch (iface.u.ChipInfo.types[i])
        {
        case gcvHARDWARE_3D2D:
            defaultHwType = gcvHARDWARE_3D2D;
            has3D2DCore   = 1;
            break;

        case gcvHARDWARE_3D:
            /* 3D by default when exist. */
            defaultHwType = gcvHARDWARE_3D;
            has3DCore     = 1;
            break;

        case gcvHARDWARE_VG:
            hasVGCore     = 1;
            if (defaultHwType == gcvHARDWARE_INVALID)
            {
                /* VG type if VG only. */
                defaultHwType = gcvHARDWARE_VG;
            }
            break;

        case gcvHARDWARE_2D:
            has2DCore     = 1;
            if ((defaultHwType == gcvHARDWARE_INVALID) ||
                (defaultHwType == gcvHARDWARE_VG))
            {
                /* 2D type if 2D only or 2D,VG. */
                defaultHwType = gcvHARDWARE_2D;
            }
            break;

        default:
            break;
        }
    }

    if (defaultHwType == gcvHARDWARE_INVALID)
    {
        LOGE("Failed to get hardware types");
    }
}

static int
usage_has_type(
    int Usage,
    int Type
    )
{
    return ((Usage & GRALLOC_USAGE_PRIVATE_MASK_VIV) == Type);
}

static void
switch_hardware_type(
    int Usage
    )
{
    pthread_once(&onceControl, check_hardware_types);

    if (usage_has_type(Usage, GRALLOC_USAGE_HW_VG_RENDER_VIV))
    {
        /* Set to vg type if requested. */
        gcoHAL_SetHardwareType(gcvNULL, gcvHARDWARE_VG);
    }
    else
    {
        /* Otherwise follow default hw type. */
        gcoHAL_SetHardwareType(gcvNULL, defaultHwType);
    }
}

/******************************************************************************/

int gc_gralloc_wrap(private_handle_t * hnd,
        int width, int height, int format, int stride,
        unsigned long phys, void * vaddr)
{
    gc_native_handle_t * handle = gcvNULL;
    gcoSURF surface = gcvNULL;
    gcsSURF_FORMAT_INFO_PTR info[2];
    gceSURF_FORMAT halFormat;
    gctUINT address[3];
    gctPOINTER memory[3];
    gceSTATUS status;
    gctSHBUF shBuf = gcvNULL;
    gceHARDWARE_TYPE hwType = gcvHARDWARE_3D;
    gceHARDWARE_TYPE allocHwType = gcvHARDWARE_3D;

    /* Parameter check. */
    if (private_handle_t::validate(hnd))
    {
        return -EINVAL;
    }

    /* Check address. */
    if (vaddr == NULL)
    {
        LOGE("Invalid virtual address");
        return -EINVAL;
    }

    /* Translate format. */
    halFormat = gc_gralloc_translate_format(format);

    if (halFormat == gcvSURF_UNKNOWN)
    {
        return -EINVAL;
    }

    /* Get hardware type. */
    gcoHAL_GetHardwareType(gcvNULL, &hwType);

    /* Query format info. */
    gcmONERROR(gcoSURF_QueryFormat(halFormat, info));

    /* Caluculate stride, Vivante stride is in bytes. */
    switch (halFormat)
    {
    case gcvSURF_YUY2:
    case gcvSURF_UYVY:
    case gcvSURF_YVYU:
    case gcvSURF_VYUY:
        stride *= 2;
        break;

    case gcvSURF_YV12:
    case gcvSURF_I420:
    case gcvSURF_NV12:
    case gcvSURF_NV21:
    case gcvSURF_NV16:
    case gcvSURF_NV61:
        break;

    default:
        stride *= info[0]->bitsPerPixel / 8;
        break;
    }

    /* Get gc private handle. */
    handle = gc_native_handle_get(hnd);
    memset(handle, 0, sizeof (gc_native_handle_t));

    /* Switch to default hardware type. */
    switch_hardware_type(0);

    /* Get hardware type for buffer allocation. */
    gcoHAL_GetHardwareType(gcvNULL, &allocHwType);

    /* Construct wrapper surface. */
    gcmONERROR(
        gcoSURF_Construct(gcvNULL,
                          width, height, 1,
                          gcvSURF_BITMAP,
                          halFormat,
                          gcvPOOL_USER,
                          &surface));

    /* Set buffer address. */
    gcmONERROR(gcoSURF_SetBuffer(
        surface, gcvSURF_BITMAP, halFormat, stride, vaddr, phys));

    /* Set window size. */
    gcmONERROR(gcoSURF_SetWindow(
        surface, 0, 0, width, height));

    /* Lock surface. */
    gcmONERROR(gcoSURF_Lock(surface, address, memory));

    /* Set Y inverted content flag. */
    gcmONERROR(
        gcoSURF_SetFlags(surface,
                         gcvSURF_FLAG_CONTENT_YINVERTED,
                         gcvTRUE));

    /* Alloc shared buffer. */
    gcmONERROR(gcoSURF_AllocShBuffer(surface, &shBuf));

    /* Lock for possible hardware types for performance. */
    if (has2DCore && allocHwType != gcvHARDWARE_2D)
    {
        /* Lock for 2D core. */
        gcoHAL_SetHardwareType(gcvNULL, gcvHARDWARE_2D);
        gcmONERROR(gcoSURF_Lock(surface, gcvNULL, gcvNULL));
    }

    if (has3DCore && allocHwType != gcvHARDWARE_3D)
    {
        /* Lock for 3D core side. */
        gcoHAL_SetHardwareType(gcvNULL, gcvHARDWARE_3D);
        gcmONERROR(gcoSURF_Lock(surface, gcvNULL, gcvNULL));
    }

    if (has3D2DCore && allocHwType != gcvHARDWARE_3D2D)
    {
        /* Lock for 3D/2D core. */
        gcoHAL_SetHardwareType(gcvNULL, gcvHARDWARE_3D2D);
        gcmONERROR(gcoSURF_Lock(surface, gcvNULL, gcvNULL));
    }

    /* Save handle info. */
    handle->surface   = intptr_t(surface);

    handle->width     = (int) width;
    handle->height    = (int) height;
    handle->format    = (int) format;
    handle->stride    = (int) stride;

    handle->halFormat = (int) halFormat;

    handle->shBuf     = (int) intptr_t(shBuf);

    LOGV("Wrap buffer=%p: phys=%lx(%x) vaddr=%p size=%dx%d format=%d",
         hnd, phys, address[0], vaddr, width, height, format);

    /* Restore hardware type. */
    gcoHAL_SetHardwareType(gcvNULL, hwType);

    return 0;

OnError:
    LOGE("failed to wrap handle=%p", hnd);

    if (surface != gcvNULL)
    {
        gcmVERIFY_OK(gcoSURF_Destroy(surface));
    }

    /* Restore hardware type. */
    gcoHAL_SetHardwareType(gcvNULL, hwType);

    return -EFAULT;
}

int gc_gralloc_register_wrap(private_handle_t * hnd,
        unsigned long phys, void * vaddr)
{
    gc_native_handle_t * handle = gcvNULL;
    gcoSURF surface = gcvNULL;
    gceSURF_FORMAT halFormat;
    gctUINT address[3];
    gctPOINTER memory[3];
    gceSTATUS status;
    gceHARDWARE_TYPE hwType = gcvHARDWARE_3D;
    gceHARDWARE_TYPE allocHwType = gcvHARDWARE_3D;

    /* Parameter check. */
    if (private_handle_t::validate(hnd))
    {
        return -EINVAL;
    }

    /* Check address. */
    if (vaddr == NULL)
    {
        LOGE("Invalid virtual address");
        return -EINVAL;
    }

    /* Get private handle. */
    handle = gc_native_handle_get(hnd);

    if (!handle->surface ||
        !handle->width || !handle->height  || !handle->format)
    {
        /* The handle is not wrapped in server side. */
        return -EINVAL;
    }

    /* Translate format. */
    halFormat = (gceSURF_FORMAT) handle->halFormat;

    if (halFormat == gcvSURF_UNKNOWN)
    {
        return -EINVAL;
    }

    /* Get hardware type. */
    gcoHAL_GetHardwareType(gcvNULL, &hwType);

    /* Switch to default hardware type. */
    switch_hardware_type(0);

    /* Get hardware type for buffer allocation. */
    gcoHAL_GetHardwareType(gcvNULL, &allocHwType);

    /* Construct wrapper surface. */
    gcmONERROR(
        gcoSURF_Construct(gcvNULL,
                          handle->width, handle->height, 1,
                          gcvSURF_BITMAP,
                          halFormat,
                          gcvPOOL_USER,
                          &surface));

    /* Set buffer address. */
    gcmONERROR(gcoSURF_SetBuffer(
        surface, gcvSURF_BITMAP, halFormat, handle->stride, vaddr, phys));

    /* Set window size. */
    gcmONERROR(gcoSURF_SetWindow(
        surface, 0, 0, handle->width, handle->height));

    /* Lock surface. */
    gcmONERROR(gcoSURF_Lock(surface, address, memory));

    /* Set Y inverted content flag. */
    gcmONERROR(
        gcoSURF_SetFlags(surface,
                         gcvSURF_FLAG_CONTENT_YINVERTED,
                         gcvTRUE));

    if (handle->shBuf != 0)
    {
        /* Bind shared buffer. */
        gcmVERIFY_OK(gcoSURF_BindShBuffer(surface, (gctSHBUF) intptr_t(handle->shBuf)));
    }

    /* Lock for possible hardware types for performance. */
    if (has2DCore && allocHwType != gcvHARDWARE_2D)
    {
        /* Lock for 2D core. */
        gcoHAL_SetHardwareType(gcvNULL, gcvHARDWARE_2D);
        gcmONERROR(gcoSURF_Lock(surface, gcvNULL, gcvNULL));
    }

    if (has3DCore && allocHwType != gcvHARDWARE_3D)
    {
        /* Lock for 3D core side. */
        gcoHAL_SetHardwareType(gcvNULL, gcvHARDWARE_3D);
        gcmONERROR(gcoSURF_Lock(surface, gcvNULL, gcvNULL));
    }

    if (has3D2DCore && allocHwType != gcvHARDWARE_3D2D)
    {
        /* Lock for 3D/2D core. */
        gcoHAL_SetHardwareType(gcvNULL, gcvHARDWARE_3D2D);
        gcmONERROR(gcoSURF_Lock(surface, gcvNULL, gcvNULL));
    }

    /* Save handle info. */
    handle->surface   = intptr_t(surface);

    LOGV("Register wrap buffer=%p: phys=%lx(%x) vaddr=%p size=%dx%d format=%d",
         hnd, phys, address[0], vaddr, handle->width, handle->height, handle->format);

    /* Restore hardware type. */
    gcoHAL_SetHardwareType(gcvNULL, hwType);

    return 0;

OnError:
    LOGE("failed to register wrap handle=%p", hnd);

    if (surface != gcvNULL)
    {
        gcmVERIFY_OK(gcoSURF_Destroy(surface));
        gcmVERIFY_OK(gcoHAL_Commit(gcvNULL, gcvFALSE));
    }

    /* Restore hardware type. */
    gcoHAL_SetHardwareType(gcvNULL, hwType);

    return -EFAULT;
}

int gc_gralloc_unwrap(private_handle_t * hnd)
{
    gc_native_handle_t * handle;
    gcoSURF surface;
    gceHARDWARE_TYPE hwType = gcvHARDWARE_3D;
    gceHARDWARE_TYPE allocHwType = gcvHARDWARE_3D;

    /* Parameter check. */
    if (private_handle_t::validate(hnd))
    {
        return -EINVAL;
    }

    /* Get gc private handle. */
    handle = gc_native_handle_get(hnd);

    LOGV("Un-wrap buffer=%p: size=%dx%d format=%d",
         hnd, handle->width, handle->height, handle->format);

    /* Cast surface. */
    surface = (gcoSURF) handle->surface;

    /* Get hardware type. */
    gcoHAL_GetHardwareType(gcvNULL, &hwType);

    /* Switch to default hardware. */
    switch_hardware_type(0);

    /* Get hardware type for buffer allocation. */
    gcoHAL_GetHardwareType(gcvNULL, &allocHwType);

    /* Unlock and destroy wrapper surface. */
    gcmVERIFY_OK(gcoSURF_Unlock(surface, gcvNULL));

    /* Unlock for other possible hardware types. */
    if (has2DCore && allocHwType != gcvHARDWARE_2D)
    {
        /* Unlock for 2D core. */
        gcoHAL_SetHardwareType(gcvNULL, gcvHARDWARE_2D);
        gcmVERIFY_OK(gcoSURF_Unlock(surface, gcvNULL));
    }

    if (has3DCore && allocHwType != gcvHARDWARE_3D)
    {
        /* Unlock for 3D core side. */
        gcoHAL_SetHardwareType(gcvNULL, gcvHARDWARE_3D);
        gcmVERIFY_OK(gcoSURF_Unlock(surface, gcvNULL));
    }

    if (has3D2DCore && allocHwType != gcvHARDWARE_3D2D)
    {
        /* Unlock for 3D/2D core. */
        gcoHAL_SetHardwareType(gcvNULL, gcvHARDWARE_3D2D);
        gcmVERIFY_OK(gcoSURF_Unlock(surface, gcvNULL));
    }

    gcmVERIFY_OK(gcoSURF_Destroy(surface));
    gcmVERIFY_OK(gcoHAL_Commit(gcvNULL, gcvTRUE));

    /* Clear vivante private data. */
    memset(handle, 0, sizeof (gc_native_handle_t));

    /* Restore hardware type. */
    gcoHAL_SetHardwareType(gcvNULL, hwType);

    return 0;
}

int gc_gralloc_notify_change(private_handle_t * hnd)
{
    gc_native_handle_t * handle;

    /* Parameter check. */
    if (private_handle_t::validate(hnd))
    {
        return -EINVAL;
    }

    /* Get gc private handle. */
    handle = gc_native_handle_get(hnd);

    LOGV("notify change: buffer=%p: size=%dx%d format=%d",
         hnd, handle->width, handle->height, handle->format);

    if (handle->surface == 0)
    {
        /* Invalid handle. */
        return -EINVAL;
    }

    /* Update time stamp. */
    gcmVERIFY_OK(gcoSURF_UpdateTimeStamp((gcoSURF) handle->surface));

    /* Push surface shared states. */
    gcmVERIFY_OK(gcoSURF_PushSharedInfo((gcoSURF) handle->surface));

    return 0;
}
